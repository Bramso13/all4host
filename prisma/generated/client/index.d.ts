
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ConciergerieManager
 * 
 */
export type ConciergerieManager = $Result.DefaultSelection<Prisma.$ConciergerieManagerPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Property
 * 
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model Reservation
 * 
 */
export type Reservation = $Result.DefaultSelection<Prisma.$ReservationPayload>
/**
 * Model Agent
 * 
 */
export type Agent = $Result.DefaultSelection<Prisma.$AgentPayload>
/**
 * Model MaintenanceSession
 * 
 */
export type MaintenanceSession = $Result.DefaultSelection<Prisma.$MaintenanceSessionPayload>
/**
 * Model Maintenance
 * 
 */
export type Maintenance = $Result.DefaultSelection<Prisma.$MaintenancePayload>
/**
 * Model CleaningSession
 * 
 */
export type CleaningSession = $Result.DefaultSelection<Prisma.$CleaningSessionPayload>
/**
 * Model Cleaning
 * 
 */
export type Cleaning = $Result.DefaultSelection<Prisma.$CleaningPayload>
/**
 * Model CleaningManager
 * 
 */
export type CleaningManager = $Result.DefaultSelection<Prisma.$CleaningManagerPayload>
/**
 * Model InterventionSite
 * 
 */
export type InterventionSite = $Result.DefaultSelection<Prisma.$InterventionSitePayload>
/**
 * Model SiteCleaningSession
 * 
 */
export type SiteCleaningSession = $Result.DefaultSelection<Prisma.$SiteCleaningSessionPayload>
/**
 * Model LaundryManager
 * 
 */
export type LaundryManager = $Result.DefaultSelection<Prisma.$LaundryManagerPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model PropertyPhoto
 * 
 */
export type PropertyPhoto = $Result.DefaultSelection<Prisma.$PropertyPhotoPayload>
/**
 * Model CleaningPhoto
 * 
 */
export type CleaningPhoto = $Result.DefaultSelection<Prisma.$CleaningPhotoPayload>
/**
 * Model MaintenancePhoto
 * 
 */
export type MaintenancePhoto = $Result.DefaultSelection<Prisma.$MaintenancePhotoPayload>
/**
 * Model SiteCleaningPhoto
 * 
 */
export type SiteCleaningPhoto = $Result.DefaultSelection<Prisma.$SiteCleaningPhotoPayload>
/**
 * Model TicketPhoto
 * 
 */
export type TicketPhoto = $Result.DefaultSelection<Prisma.$TicketPhotoPayload>
/**
 * Model CleaningChecklist
 * 
 */
export type CleaningChecklist = $Result.DefaultSelection<Prisma.$CleaningChecklistPayload>
/**
 * Model SiteCleaningChecklist
 * 
 */
export type SiteCleaningChecklist = $Result.DefaultSelection<Prisma.$SiteCleaningChecklistPayload>
/**
 * Model CleaningPlanning
 * 
 */
export type CleaningPlanning = $Result.DefaultSelection<Prisma.$CleaningPlanningPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model DeliveryNote
 * 
 */
export type DeliveryNote = $Result.DefaultSelection<Prisma.$DeliveryNotePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model ServiceUser
 * 
 */
export type ServiceUser = $Result.DefaultSelection<Prisma.$ServiceUserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  admin: 'admin',
  user: 'user',
  agent: 'agent'
};

export type Role = (typeof Role)[keyof typeof Role]


export const PropertyStatus: {
  available: 'available',
  occupied: 'occupied',
  maintenance: 'maintenance',
  reserved: 'reserved'
};

export type PropertyStatus = (typeof PropertyStatus)[keyof typeof PropertyStatus]


export const OrderStatus: {
  received: 'received',
  processing: 'processing',
  delivery: 'delivery',
  completed: 'completed',
  returned: 'returned'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const TicketStatus: {
  open: 'open',
  in_progress: 'in_progress',
  resolved: 'resolved',
  closed: 'closed'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]


export const InterventionStatus: {
  planned: 'planned',
  in_progress: 'in_progress',
  completed: 'completed',
  cancelled: 'cancelled'
};

export type InterventionStatus = (typeof InterventionStatus)[keyof typeof InterventionStatus]


export const ServiceType: {
  cleaning: 'cleaning',
  maintenance: 'maintenance',
  housekeeping: 'housekeeping',
  laundry: 'laundry'
};

export type ServiceType = (typeof ServiceType)[keyof typeof ServiceType]


export const AgentType: {
  cleaning: 'cleaning',
  laundry: 'laundry',
  maintenance: 'maintenance'
};

export type AgentType = (typeof AgentType)[keyof typeof AgentType]


export const ServiceUserStatus: {
  active: 'active',
  inactive: 'inactive'
};

export type ServiceUserStatus = (typeof ServiceUserStatus)[keyof typeof ServiceUserStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type PropertyStatus = $Enums.PropertyStatus

export const PropertyStatus: typeof $Enums.PropertyStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

export type InterventionStatus = $Enums.InterventionStatus

export const InterventionStatus: typeof $Enums.InterventionStatus

export type ServiceType = $Enums.ServiceType

export const ServiceType: typeof $Enums.ServiceType

export type AgentType = $Enums.AgentType

export const AgentType: typeof $Enums.AgentType

export type ServiceUserStatus = $Enums.ServiceUserStatus

export const ServiceUserStatus: typeof $Enums.ServiceUserStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conciergerieManager`: Exposes CRUD operations for the **ConciergerieManager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConciergerieManagers
    * const conciergerieManagers = await prisma.conciergerieManager.findMany()
    * ```
    */
  get conciergerieManager(): Prisma.ConciergerieManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **Reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservation.findMany()
    * ```
    */
  get reservation(): Prisma.ReservationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenanceSession`: Exposes CRUD operations for the **MaintenanceSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceSessions
    * const maintenanceSessions = await prisma.maintenanceSession.findMany()
    * ```
    */
  get maintenanceSession(): Prisma.MaintenanceSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenance`: Exposes CRUD operations for the **Maintenance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maintenances
    * const maintenances = await prisma.maintenance.findMany()
    * ```
    */
  get maintenance(): Prisma.MaintenanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cleaningSession`: Exposes CRUD operations for the **CleaningSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CleaningSessions
    * const cleaningSessions = await prisma.cleaningSession.findMany()
    * ```
    */
  get cleaningSession(): Prisma.CleaningSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cleaning`: Exposes CRUD operations for the **Cleaning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cleanings
    * const cleanings = await prisma.cleaning.findMany()
    * ```
    */
  get cleaning(): Prisma.CleaningDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cleaningManager`: Exposes CRUD operations for the **CleaningManager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CleaningManagers
    * const cleaningManagers = await prisma.cleaningManager.findMany()
    * ```
    */
  get cleaningManager(): Prisma.CleaningManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interventionSite`: Exposes CRUD operations for the **InterventionSite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterventionSites
    * const interventionSites = await prisma.interventionSite.findMany()
    * ```
    */
  get interventionSite(): Prisma.InterventionSiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.siteCleaningSession`: Exposes CRUD operations for the **SiteCleaningSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteCleaningSessions
    * const siteCleaningSessions = await prisma.siteCleaningSession.findMany()
    * ```
    */
  get siteCleaningSession(): Prisma.SiteCleaningSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.laundryManager`: Exposes CRUD operations for the **LaundryManager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaundryManagers
    * const laundryManagers = await prisma.laundryManager.findMany()
    * ```
    */
  get laundryManager(): Prisma.LaundryManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyPhoto`: Exposes CRUD operations for the **PropertyPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyPhotos
    * const propertyPhotos = await prisma.propertyPhoto.findMany()
    * ```
    */
  get propertyPhoto(): Prisma.PropertyPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cleaningPhoto`: Exposes CRUD operations for the **CleaningPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CleaningPhotos
    * const cleaningPhotos = await prisma.cleaningPhoto.findMany()
    * ```
    */
  get cleaningPhoto(): Prisma.CleaningPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenancePhoto`: Exposes CRUD operations for the **MaintenancePhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenancePhotos
    * const maintenancePhotos = await prisma.maintenancePhoto.findMany()
    * ```
    */
  get maintenancePhoto(): Prisma.MaintenancePhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.siteCleaningPhoto`: Exposes CRUD operations for the **SiteCleaningPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteCleaningPhotos
    * const siteCleaningPhotos = await prisma.siteCleaningPhoto.findMany()
    * ```
    */
  get siteCleaningPhoto(): Prisma.SiteCleaningPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketPhoto`: Exposes CRUD operations for the **TicketPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketPhotos
    * const ticketPhotos = await prisma.ticketPhoto.findMany()
    * ```
    */
  get ticketPhoto(): Prisma.TicketPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cleaningChecklist`: Exposes CRUD operations for the **CleaningChecklist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CleaningChecklists
    * const cleaningChecklists = await prisma.cleaningChecklist.findMany()
    * ```
    */
  get cleaningChecklist(): Prisma.CleaningChecklistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.siteCleaningChecklist`: Exposes CRUD operations for the **SiteCleaningChecklist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteCleaningChecklists
    * const siteCleaningChecklists = await prisma.siteCleaningChecklist.findMany()
    * ```
    */
  get siteCleaningChecklist(): Prisma.SiteCleaningChecklistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cleaningPlanning`: Exposes CRUD operations for the **CleaningPlanning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CleaningPlannings
    * const cleaningPlannings = await prisma.cleaningPlanning.findMany()
    * ```
    */
  get cleaningPlanning(): Prisma.CleaningPlanningDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryNote`: Exposes CRUD operations for the **DeliveryNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryNotes
    * const deliveryNotes = await prisma.deliveryNote.findMany()
    * ```
    */
  get deliveryNote(): Prisma.DeliveryNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceUser`: Exposes CRUD operations for the **ServiceUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceUsers
    * const serviceUsers = await prisma.serviceUser.findMany()
    * ```
    */
  get serviceUser(): Prisma.ServiceUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ConciergerieManager: 'ConciergerieManager',
    Task: 'Task',
    Property: 'Property',
    Reservation: 'Reservation',
    Agent: 'Agent',
    MaintenanceSession: 'MaintenanceSession',
    Maintenance: 'Maintenance',
    CleaningSession: 'CleaningSession',
    Cleaning: 'Cleaning',
    CleaningManager: 'CleaningManager',
    InterventionSite: 'InterventionSite',
    SiteCleaningSession: 'SiteCleaningSession',
    LaundryManager: 'LaundryManager',
    Product: 'Product',
    Order: 'Order',
    Ticket: 'Ticket',
    Payment: 'Payment',
    PropertyPhoto: 'PropertyPhoto',
    CleaningPhoto: 'CleaningPhoto',
    MaintenancePhoto: 'MaintenancePhoto',
    SiteCleaningPhoto: 'SiteCleaningPhoto',
    TicketPhoto: 'TicketPhoto',
    CleaningChecklist: 'CleaningChecklist',
    SiteCleaningChecklist: 'SiteCleaningChecklist',
    CleaningPlanning: 'CleaningPlanning',
    OrderItem: 'OrderItem',
    DeliveryNote: 'DeliveryNote',
    Notification: 'Notification',
    Service: 'Service',
    ServiceUser: 'ServiceUser',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "conciergerieManager" | "task" | "property" | "reservation" | "agent" | "maintenanceSession" | "maintenance" | "cleaningSession" | "cleaning" | "cleaningManager" | "interventionSite" | "siteCleaningSession" | "laundryManager" | "product" | "order" | "ticket" | "payment" | "propertyPhoto" | "cleaningPhoto" | "maintenancePhoto" | "siteCleaningPhoto" | "ticketPhoto" | "cleaningChecklist" | "siteCleaningChecklist" | "cleaningPlanning" | "orderItem" | "deliveryNote" | "notification" | "service" | "serviceUser" | "session" | "account" | "verification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ConciergerieManager: {
        payload: Prisma.$ConciergerieManagerPayload<ExtArgs>
        fields: Prisma.ConciergerieManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConciergerieManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConciergerieManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConciergerieManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConciergerieManagerPayload>
          }
          findFirst: {
            args: Prisma.ConciergerieManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConciergerieManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConciergerieManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConciergerieManagerPayload>
          }
          findMany: {
            args: Prisma.ConciergerieManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConciergerieManagerPayload>[]
          }
          create: {
            args: Prisma.ConciergerieManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConciergerieManagerPayload>
          }
          createMany: {
            args: Prisma.ConciergerieManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConciergerieManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConciergerieManagerPayload>[]
          }
          delete: {
            args: Prisma.ConciergerieManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConciergerieManagerPayload>
          }
          update: {
            args: Prisma.ConciergerieManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConciergerieManagerPayload>
          }
          deleteMany: {
            args: Prisma.ConciergerieManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConciergerieManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConciergerieManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConciergerieManagerPayload>[]
          }
          upsert: {
            args: Prisma.ConciergerieManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConciergerieManagerPayload>
          }
          aggregate: {
            args: Prisma.ConciergerieManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConciergerieManager>
          }
          groupBy: {
            args: Prisma.ConciergerieManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConciergerieManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConciergerieManagerCountArgs<ExtArgs>
            result: $Utils.Optional<ConciergerieManagerCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      Reservation: {
        payload: Prisma.$ReservationPayload<ExtArgs>
        fields: Prisma.ReservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findFirst: {
            args: Prisma.ReservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findMany: {
            args: Prisma.ReservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          create: {
            args: Prisma.ReservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          createMany: {
            args: Prisma.ReservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReservationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          delete: {
            args: Prisma.ReservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          update: {
            args: Prisma.ReservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          deleteMany: {
            args: Prisma.ReservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReservationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          upsert: {
            args: Prisma.ReservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          aggregate: {
            args: Prisma.ReservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservation>
          }
          groupBy: {
            args: Prisma.ReservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservationCountArgs<ExtArgs>
            result: $Utils.Optional<ReservationCountAggregateOutputType> | number
          }
        }
      }
      Agent: {
        payload: Prisma.$AgentPayload<ExtArgs>
        fields: Prisma.AgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceSession: {
        payload: Prisma.$MaintenanceSessionPayload<ExtArgs>
        fields: Prisma.MaintenanceSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>
          }
          findMany: {
            args: Prisma.MaintenanceSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>[]
          }
          create: {
            args: Prisma.MaintenanceSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>
          }
          createMany: {
            args: Prisma.MaintenanceSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>
          }
          update: {
            args: Prisma.MaintenanceSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintenanceSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>[]
          }
          upsert: {
            args: Prisma.MaintenanceSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceSession>
          }
          groupBy: {
            args: Prisma.MaintenanceSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceSessionCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceSessionCountAggregateOutputType> | number
          }
        }
      }
      Maintenance: {
        payload: Prisma.$MaintenancePayload<ExtArgs>
        fields: Prisma.MaintenanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          findFirst: {
            args: Prisma.MaintenanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          findMany: {
            args: Prisma.MaintenanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>[]
          }
          create: {
            args: Prisma.MaintenanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          createMany: {
            args: Prisma.MaintenanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>[]
          }
          delete: {
            args: Prisma.MaintenanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          update: {
            args: Prisma.MaintenanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintenanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>[]
          }
          upsert: {
            args: Prisma.MaintenanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          aggregate: {
            args: Prisma.MaintenanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenance>
          }
          groupBy: {
            args: Prisma.MaintenanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceCountAggregateOutputType> | number
          }
        }
      }
      CleaningSession: {
        payload: Prisma.$CleaningSessionPayload<ExtArgs>
        fields: Prisma.CleaningSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CleaningSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CleaningSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>
          }
          findFirst: {
            args: Prisma.CleaningSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CleaningSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>
          }
          findMany: {
            args: Prisma.CleaningSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>[]
          }
          create: {
            args: Prisma.CleaningSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>
          }
          createMany: {
            args: Prisma.CleaningSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CleaningSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>[]
          }
          delete: {
            args: Prisma.CleaningSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>
          }
          update: {
            args: Prisma.CleaningSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>
          }
          deleteMany: {
            args: Prisma.CleaningSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CleaningSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CleaningSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>[]
          }
          upsert: {
            args: Prisma.CleaningSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>
          }
          aggregate: {
            args: Prisma.CleaningSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCleaningSession>
          }
          groupBy: {
            args: Prisma.CleaningSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CleaningSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CleaningSessionCountArgs<ExtArgs>
            result: $Utils.Optional<CleaningSessionCountAggregateOutputType> | number
          }
        }
      }
      Cleaning: {
        payload: Prisma.$CleaningPayload<ExtArgs>
        fields: Prisma.CleaningFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CleaningFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CleaningFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPayload>
          }
          findFirst: {
            args: Prisma.CleaningFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CleaningFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPayload>
          }
          findMany: {
            args: Prisma.CleaningFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPayload>[]
          }
          create: {
            args: Prisma.CleaningCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPayload>
          }
          createMany: {
            args: Prisma.CleaningCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CleaningCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPayload>[]
          }
          delete: {
            args: Prisma.CleaningDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPayload>
          }
          update: {
            args: Prisma.CleaningUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPayload>
          }
          deleteMany: {
            args: Prisma.CleaningDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CleaningUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CleaningUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPayload>[]
          }
          upsert: {
            args: Prisma.CleaningUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPayload>
          }
          aggregate: {
            args: Prisma.CleaningAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCleaning>
          }
          groupBy: {
            args: Prisma.CleaningGroupByArgs<ExtArgs>
            result: $Utils.Optional<CleaningGroupByOutputType>[]
          }
          count: {
            args: Prisma.CleaningCountArgs<ExtArgs>
            result: $Utils.Optional<CleaningCountAggregateOutputType> | number
          }
        }
      }
      CleaningManager: {
        payload: Prisma.$CleaningManagerPayload<ExtArgs>
        fields: Prisma.CleaningManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CleaningManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CleaningManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningManagerPayload>
          }
          findFirst: {
            args: Prisma.CleaningManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CleaningManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningManagerPayload>
          }
          findMany: {
            args: Prisma.CleaningManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningManagerPayload>[]
          }
          create: {
            args: Prisma.CleaningManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningManagerPayload>
          }
          createMany: {
            args: Prisma.CleaningManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CleaningManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningManagerPayload>[]
          }
          delete: {
            args: Prisma.CleaningManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningManagerPayload>
          }
          update: {
            args: Prisma.CleaningManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningManagerPayload>
          }
          deleteMany: {
            args: Prisma.CleaningManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CleaningManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CleaningManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningManagerPayload>[]
          }
          upsert: {
            args: Prisma.CleaningManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningManagerPayload>
          }
          aggregate: {
            args: Prisma.CleaningManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCleaningManager>
          }
          groupBy: {
            args: Prisma.CleaningManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CleaningManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CleaningManagerCountArgs<ExtArgs>
            result: $Utils.Optional<CleaningManagerCountAggregateOutputType> | number
          }
        }
      }
      InterventionSite: {
        payload: Prisma.$InterventionSitePayload<ExtArgs>
        fields: Prisma.InterventionSiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterventionSiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionSitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterventionSiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionSitePayload>
          }
          findFirst: {
            args: Prisma.InterventionSiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionSitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterventionSiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionSitePayload>
          }
          findMany: {
            args: Prisma.InterventionSiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionSitePayload>[]
          }
          create: {
            args: Prisma.InterventionSiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionSitePayload>
          }
          createMany: {
            args: Prisma.InterventionSiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterventionSiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionSitePayload>[]
          }
          delete: {
            args: Prisma.InterventionSiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionSitePayload>
          }
          update: {
            args: Prisma.InterventionSiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionSitePayload>
          }
          deleteMany: {
            args: Prisma.InterventionSiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterventionSiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterventionSiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionSitePayload>[]
          }
          upsert: {
            args: Prisma.InterventionSiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionSitePayload>
          }
          aggregate: {
            args: Prisma.InterventionSiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterventionSite>
          }
          groupBy: {
            args: Prisma.InterventionSiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterventionSiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterventionSiteCountArgs<ExtArgs>
            result: $Utils.Optional<InterventionSiteCountAggregateOutputType> | number
          }
        }
      }
      SiteCleaningSession: {
        payload: Prisma.$SiteCleaningSessionPayload<ExtArgs>
        fields: Prisma.SiteCleaningSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteCleaningSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteCleaningSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningSessionPayload>
          }
          findFirst: {
            args: Prisma.SiteCleaningSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteCleaningSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningSessionPayload>
          }
          findMany: {
            args: Prisma.SiteCleaningSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningSessionPayload>[]
          }
          create: {
            args: Prisma.SiteCleaningSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningSessionPayload>
          }
          createMany: {
            args: Prisma.SiteCleaningSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteCleaningSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningSessionPayload>[]
          }
          delete: {
            args: Prisma.SiteCleaningSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningSessionPayload>
          }
          update: {
            args: Prisma.SiteCleaningSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningSessionPayload>
          }
          deleteMany: {
            args: Prisma.SiteCleaningSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteCleaningSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteCleaningSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningSessionPayload>[]
          }
          upsert: {
            args: Prisma.SiteCleaningSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningSessionPayload>
          }
          aggregate: {
            args: Prisma.SiteCleaningSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteCleaningSession>
          }
          groupBy: {
            args: Prisma.SiteCleaningSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteCleaningSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteCleaningSessionCountArgs<ExtArgs>
            result: $Utils.Optional<SiteCleaningSessionCountAggregateOutputType> | number
          }
        }
      }
      LaundryManager: {
        payload: Prisma.$LaundryManagerPayload<ExtArgs>
        fields: Prisma.LaundryManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LaundryManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LaundryManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryManagerPayload>
          }
          findFirst: {
            args: Prisma.LaundryManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LaundryManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryManagerPayload>
          }
          findMany: {
            args: Prisma.LaundryManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryManagerPayload>[]
          }
          create: {
            args: Prisma.LaundryManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryManagerPayload>
          }
          createMany: {
            args: Prisma.LaundryManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LaundryManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryManagerPayload>[]
          }
          delete: {
            args: Prisma.LaundryManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryManagerPayload>
          }
          update: {
            args: Prisma.LaundryManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryManagerPayload>
          }
          deleteMany: {
            args: Prisma.LaundryManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LaundryManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LaundryManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryManagerPayload>[]
          }
          upsert: {
            args: Prisma.LaundryManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryManagerPayload>
          }
          aggregate: {
            args: Prisma.LaundryManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLaundryManager>
          }
          groupBy: {
            args: Prisma.LaundryManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<LaundryManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.LaundryManagerCountArgs<ExtArgs>
            result: $Utils.Optional<LaundryManagerCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      PropertyPhoto: {
        payload: Prisma.$PropertyPhotoPayload<ExtArgs>
        fields: Prisma.PropertyPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>
          }
          findFirst: {
            args: Prisma.PropertyPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>
          }
          findMany: {
            args: Prisma.PropertyPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>[]
          }
          create: {
            args: Prisma.PropertyPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>
          }
          createMany: {
            args: Prisma.PropertyPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>[]
          }
          delete: {
            args: Prisma.PropertyPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>
          }
          update: {
            args: Prisma.PropertyPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>
          }
          deleteMany: {
            args: Prisma.PropertyPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyPhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>[]
          }
          upsert: {
            args: Prisma.PropertyPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>
          }
          aggregate: {
            args: Prisma.PropertyPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyPhoto>
          }
          groupBy: {
            args: Prisma.PropertyPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyPhotoCountAggregateOutputType> | number
          }
        }
      }
      CleaningPhoto: {
        payload: Prisma.$CleaningPhotoPayload<ExtArgs>
        fields: Prisma.CleaningPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CleaningPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CleaningPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>
          }
          findFirst: {
            args: Prisma.CleaningPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CleaningPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>
          }
          findMany: {
            args: Prisma.CleaningPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>[]
          }
          create: {
            args: Prisma.CleaningPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>
          }
          createMany: {
            args: Prisma.CleaningPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CleaningPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>[]
          }
          delete: {
            args: Prisma.CleaningPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>
          }
          update: {
            args: Prisma.CleaningPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>
          }
          deleteMany: {
            args: Prisma.CleaningPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CleaningPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CleaningPhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>[]
          }
          upsert: {
            args: Prisma.CleaningPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>
          }
          aggregate: {
            args: Prisma.CleaningPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCleaningPhoto>
          }
          groupBy: {
            args: Prisma.CleaningPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CleaningPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CleaningPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<CleaningPhotoCountAggregateOutputType> | number
          }
        }
      }
      MaintenancePhoto: {
        payload: Prisma.$MaintenancePhotoPayload<ExtArgs>
        fields: Prisma.MaintenancePhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenancePhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenancePhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>
          }
          findFirst: {
            args: Prisma.MaintenancePhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenancePhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>
          }
          findMany: {
            args: Prisma.MaintenancePhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>[]
          }
          create: {
            args: Prisma.MaintenancePhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>
          }
          createMany: {
            args: Prisma.MaintenancePhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenancePhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>[]
          }
          delete: {
            args: Prisma.MaintenancePhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>
          }
          update: {
            args: Prisma.MaintenancePhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>
          }
          deleteMany: {
            args: Prisma.MaintenancePhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenancePhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintenancePhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>[]
          }
          upsert: {
            args: Prisma.MaintenancePhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>
          }
          aggregate: {
            args: Prisma.MaintenancePhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenancePhoto>
          }
          groupBy: {
            args: Prisma.MaintenancePhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenancePhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenancePhotoCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenancePhotoCountAggregateOutputType> | number
          }
        }
      }
      SiteCleaningPhoto: {
        payload: Prisma.$SiteCleaningPhotoPayload<ExtArgs>
        fields: Prisma.SiteCleaningPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteCleaningPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteCleaningPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningPhotoPayload>
          }
          findFirst: {
            args: Prisma.SiteCleaningPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteCleaningPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningPhotoPayload>
          }
          findMany: {
            args: Prisma.SiteCleaningPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningPhotoPayload>[]
          }
          create: {
            args: Prisma.SiteCleaningPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningPhotoPayload>
          }
          createMany: {
            args: Prisma.SiteCleaningPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteCleaningPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningPhotoPayload>[]
          }
          delete: {
            args: Prisma.SiteCleaningPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningPhotoPayload>
          }
          update: {
            args: Prisma.SiteCleaningPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningPhotoPayload>
          }
          deleteMany: {
            args: Prisma.SiteCleaningPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteCleaningPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteCleaningPhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningPhotoPayload>[]
          }
          upsert: {
            args: Prisma.SiteCleaningPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningPhotoPayload>
          }
          aggregate: {
            args: Prisma.SiteCleaningPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteCleaningPhoto>
          }
          groupBy: {
            args: Prisma.SiteCleaningPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteCleaningPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteCleaningPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<SiteCleaningPhotoCountAggregateOutputType> | number
          }
        }
      }
      TicketPhoto: {
        payload: Prisma.$TicketPhotoPayload<ExtArgs>
        fields: Prisma.TicketPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>
          }
          findFirst: {
            args: Prisma.TicketPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>
          }
          findMany: {
            args: Prisma.TicketPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>[]
          }
          create: {
            args: Prisma.TicketPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>
          }
          createMany: {
            args: Prisma.TicketPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>[]
          }
          delete: {
            args: Prisma.TicketPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>
          }
          update: {
            args: Prisma.TicketPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>
          }
          deleteMany: {
            args: Prisma.TicketPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketPhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>[]
          }
          upsert: {
            args: Prisma.TicketPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>
          }
          aggregate: {
            args: Prisma.TicketPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketPhoto>
          }
          groupBy: {
            args: Prisma.TicketPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<TicketPhotoCountAggregateOutputType> | number
          }
        }
      }
      CleaningChecklist: {
        payload: Prisma.$CleaningChecklistPayload<ExtArgs>
        fields: Prisma.CleaningChecklistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CleaningChecklistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CleaningChecklistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>
          }
          findFirst: {
            args: Prisma.CleaningChecklistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CleaningChecklistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>
          }
          findMany: {
            args: Prisma.CleaningChecklistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>[]
          }
          create: {
            args: Prisma.CleaningChecklistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>
          }
          createMany: {
            args: Prisma.CleaningChecklistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CleaningChecklistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>[]
          }
          delete: {
            args: Prisma.CleaningChecklistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>
          }
          update: {
            args: Prisma.CleaningChecklistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>
          }
          deleteMany: {
            args: Prisma.CleaningChecklistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CleaningChecklistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CleaningChecklistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>[]
          }
          upsert: {
            args: Prisma.CleaningChecklistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>
          }
          aggregate: {
            args: Prisma.CleaningChecklistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCleaningChecklist>
          }
          groupBy: {
            args: Prisma.CleaningChecklistGroupByArgs<ExtArgs>
            result: $Utils.Optional<CleaningChecklistGroupByOutputType>[]
          }
          count: {
            args: Prisma.CleaningChecklistCountArgs<ExtArgs>
            result: $Utils.Optional<CleaningChecklistCountAggregateOutputType> | number
          }
        }
      }
      SiteCleaningChecklist: {
        payload: Prisma.$SiteCleaningChecklistPayload<ExtArgs>
        fields: Prisma.SiteCleaningChecklistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteCleaningChecklistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningChecklistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteCleaningChecklistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningChecklistPayload>
          }
          findFirst: {
            args: Prisma.SiteCleaningChecklistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningChecklistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteCleaningChecklistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningChecklistPayload>
          }
          findMany: {
            args: Prisma.SiteCleaningChecklistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningChecklistPayload>[]
          }
          create: {
            args: Prisma.SiteCleaningChecklistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningChecklistPayload>
          }
          createMany: {
            args: Prisma.SiteCleaningChecklistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteCleaningChecklistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningChecklistPayload>[]
          }
          delete: {
            args: Prisma.SiteCleaningChecklistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningChecklistPayload>
          }
          update: {
            args: Prisma.SiteCleaningChecklistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningChecklistPayload>
          }
          deleteMany: {
            args: Prisma.SiteCleaningChecklistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteCleaningChecklistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteCleaningChecklistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningChecklistPayload>[]
          }
          upsert: {
            args: Prisma.SiteCleaningChecklistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteCleaningChecklistPayload>
          }
          aggregate: {
            args: Prisma.SiteCleaningChecklistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteCleaningChecklist>
          }
          groupBy: {
            args: Prisma.SiteCleaningChecklistGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteCleaningChecklistGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteCleaningChecklistCountArgs<ExtArgs>
            result: $Utils.Optional<SiteCleaningChecklistCountAggregateOutputType> | number
          }
        }
      }
      CleaningPlanning: {
        payload: Prisma.$CleaningPlanningPayload<ExtArgs>
        fields: Prisma.CleaningPlanningFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CleaningPlanningFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPlanningPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CleaningPlanningFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPlanningPayload>
          }
          findFirst: {
            args: Prisma.CleaningPlanningFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPlanningPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CleaningPlanningFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPlanningPayload>
          }
          findMany: {
            args: Prisma.CleaningPlanningFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPlanningPayload>[]
          }
          create: {
            args: Prisma.CleaningPlanningCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPlanningPayload>
          }
          createMany: {
            args: Prisma.CleaningPlanningCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CleaningPlanningCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPlanningPayload>[]
          }
          delete: {
            args: Prisma.CleaningPlanningDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPlanningPayload>
          }
          update: {
            args: Prisma.CleaningPlanningUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPlanningPayload>
          }
          deleteMany: {
            args: Prisma.CleaningPlanningDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CleaningPlanningUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CleaningPlanningUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPlanningPayload>[]
          }
          upsert: {
            args: Prisma.CleaningPlanningUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPlanningPayload>
          }
          aggregate: {
            args: Prisma.CleaningPlanningAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCleaningPlanning>
          }
          groupBy: {
            args: Prisma.CleaningPlanningGroupByArgs<ExtArgs>
            result: $Utils.Optional<CleaningPlanningGroupByOutputType>[]
          }
          count: {
            args: Prisma.CleaningPlanningCountArgs<ExtArgs>
            result: $Utils.Optional<CleaningPlanningCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      DeliveryNote: {
        payload: Prisma.$DeliveryNotePayload<ExtArgs>
        fields: Prisma.DeliveryNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>
          }
          findFirst: {
            args: Prisma.DeliveryNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>
          }
          findMany: {
            args: Prisma.DeliveryNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>[]
          }
          create: {
            args: Prisma.DeliveryNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>
          }
          createMany: {
            args: Prisma.DeliveryNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>[]
          }
          delete: {
            args: Prisma.DeliveryNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>
          }
          update: {
            args: Prisma.DeliveryNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>
          }
          deleteMany: {
            args: Prisma.DeliveryNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>[]
          }
          upsert: {
            args: Prisma.DeliveryNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>
          }
          aggregate: {
            args: Prisma.DeliveryNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryNote>
          }
          groupBy: {
            args: Prisma.DeliveryNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryNoteCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryNoteCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceUser: {
        payload: Prisma.$ServiceUserPayload<ExtArgs>
        fields: Prisma.ServiceUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceUserPayload>
          }
          findFirst: {
            args: Prisma.ServiceUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceUserPayload>
          }
          findMany: {
            args: Prisma.ServiceUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceUserPayload>[]
          }
          create: {
            args: Prisma.ServiceUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceUserPayload>
          }
          createMany: {
            args: Prisma.ServiceUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceUserPayload>[]
          }
          delete: {
            args: Prisma.ServiceUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceUserPayload>
          }
          update: {
            args: Prisma.ServiceUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceUserPayload>
          }
          deleteMany: {
            args: Prisma.ServiceUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceUserPayload>[]
          }
          upsert: {
            args: Prisma.ServiceUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceUserPayload>
          }
          aggregate: {
            args: Prisma.ServiceUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceUser>
          }
          groupBy: {
            args: Prisma.ServiceUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceUserCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceUserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    conciergerieManager?: ConciergerieManagerOmit
    task?: TaskOmit
    property?: PropertyOmit
    reservation?: ReservationOmit
    agent?: AgentOmit
    maintenanceSession?: MaintenanceSessionOmit
    maintenance?: MaintenanceOmit
    cleaningSession?: CleaningSessionOmit
    cleaning?: CleaningOmit
    cleaningManager?: CleaningManagerOmit
    interventionSite?: InterventionSiteOmit
    siteCleaningSession?: SiteCleaningSessionOmit
    laundryManager?: LaundryManagerOmit
    product?: ProductOmit
    order?: OrderOmit
    ticket?: TicketOmit
    payment?: PaymentOmit
    propertyPhoto?: PropertyPhotoOmit
    cleaningPhoto?: CleaningPhotoOmit
    maintenancePhoto?: MaintenancePhotoOmit
    siteCleaningPhoto?: SiteCleaningPhotoOmit
    ticketPhoto?: TicketPhotoOmit
    cleaningChecklist?: CleaningChecklistOmit
    siteCleaningChecklist?: SiteCleaningChecklistOmit
    cleaningPlanning?: CleaningPlanningOmit
    orderItem?: OrderItemOmit
    deliveryNote?: DeliveryNoteOmit
    notification?: NotificationOmit
    service?: ServiceOmit
    serviceUser?: ServiceUserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    conciergerieManagers: number
    cleaningManagers: number
    laundryManagers: number
    notifications: number
    serviceUsers: number
    agent: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    conciergerieManagers?: boolean | UserCountOutputTypeCountConciergerieManagersArgs
    cleaningManagers?: boolean | UserCountOutputTypeCountCleaningManagersArgs
    laundryManagers?: boolean | UserCountOutputTypeCountLaundryManagersArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    serviceUsers?: boolean | UserCountOutputTypeCountServiceUsersArgs
    agent?: boolean | UserCountOutputTypeCountAgentArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConciergerieManagersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConciergerieManagerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCleaningManagersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningManagerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLaundryManagersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaundryManagerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServiceUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
  }


  /**
   * Count Type ConciergerieManagerCountOutputType
   */

  export type ConciergerieManagerCountOutputType = {
    properties: number
    agents: number
    tasks: number
  }

  export type ConciergerieManagerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | ConciergerieManagerCountOutputTypeCountPropertiesArgs
    agents?: boolean | ConciergerieManagerCountOutputTypeCountAgentsArgs
    tasks?: boolean | ConciergerieManagerCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * ConciergerieManagerCountOutputType without action
   */
  export type ConciergerieManagerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConciergerieManagerCountOutputType
     */
    select?: ConciergerieManagerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConciergerieManagerCountOutputType without action
   */
  export type ConciergerieManagerCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * ConciergerieManagerCountOutputType without action
   */
  export type ConciergerieManagerCountOutputTypeCountAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
  }

  /**
   * ConciergerieManagerCountOutputType without action
   */
  export type ConciergerieManagerCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type PropertyCountOutputType
   */

  export type PropertyCountOutputType = {
    cleaningSessions: number
    maintenanceSessions: number
    reservations: number
    payments: number
    tickets: number
    photos: number
  }

  export type PropertyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningSessions?: boolean | PropertyCountOutputTypeCountCleaningSessionsArgs
    maintenanceSessions?: boolean | PropertyCountOutputTypeCountMaintenanceSessionsArgs
    reservations?: boolean | PropertyCountOutputTypeCountReservationsArgs
    payments?: boolean | PropertyCountOutputTypeCountPaymentsArgs
    tickets?: boolean | PropertyCountOutputTypeCountTicketsArgs
    photos?: boolean | PropertyCountOutputTypeCountPhotosArgs
  }

  // Custom InputTypes
  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCountOutputType
     */
    select?: PropertyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountCleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningSessionWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountMaintenanceSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceSessionWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyPhotoWhereInput
  }


  /**
   * Count Type AgentCountOutputType
   */

  export type AgentCountOutputType = {
    maintenanceSessions: number
    cleaningSessions: number
    tasks: number
    tickets: number
    cleaningPlannings: number
    siteCleaningSessions: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenanceSessions?: boolean | AgentCountOutputTypeCountMaintenanceSessionsArgs
    cleaningSessions?: boolean | AgentCountOutputTypeCountCleaningSessionsArgs
    tasks?: boolean | AgentCountOutputTypeCountTasksArgs
    tickets?: boolean | AgentCountOutputTypeCountTicketsArgs
    cleaningPlannings?: boolean | AgentCountOutputTypeCountCleaningPlanningsArgs
    siteCleaningSessions?: boolean | AgentCountOutputTypeCountSiteCleaningSessionsArgs
  }

  // Custom InputTypes
  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountMaintenanceSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceSessionWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountCleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningSessionWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountCleaningPlanningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningPlanningWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountSiteCleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteCleaningSessionWhereInput
  }


  /**
   * Count Type MaintenanceSessionCountOutputType
   */

  export type MaintenanceSessionCountOutputType = {
    photos: number
  }

  export type MaintenanceSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | MaintenanceSessionCountOutputTypeCountPhotosArgs
  }

  // Custom InputTypes
  /**
   * MaintenanceSessionCountOutputType without action
   */
  export type MaintenanceSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSessionCountOutputType
     */
    select?: MaintenanceSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaintenanceSessionCountOutputType without action
   */
  export type MaintenanceSessionCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenancePhotoWhereInput
  }


  /**
   * Count Type MaintenanceCountOutputType
   */

  export type MaintenanceCountOutputType = {
    sessionMaintenances: number
  }

  export type MaintenanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessionMaintenances?: boolean | MaintenanceCountOutputTypeCountSessionMaintenancesArgs
  }

  // Custom InputTypes
  /**
   * MaintenanceCountOutputType without action
   */
  export type MaintenanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceCountOutputType
     */
    select?: MaintenanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaintenanceCountOutputType without action
   */
  export type MaintenanceCountOutputTypeCountSessionMaintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceSessionWhereInput
  }


  /**
   * Count Type CleaningSessionCountOutputType
   */

  export type CleaningSessionCountOutputType = {
    photos: number
    checklist: number
  }

  export type CleaningSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | CleaningSessionCountOutputTypeCountPhotosArgs
    checklist?: boolean | CleaningSessionCountOutputTypeCountChecklistArgs
  }

  // Custom InputTypes
  /**
   * CleaningSessionCountOutputType without action
   */
  export type CleaningSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSessionCountOutputType
     */
    select?: CleaningSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CleaningSessionCountOutputType without action
   */
  export type CleaningSessionCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningPhotoWhereInput
  }

  /**
   * CleaningSessionCountOutputType without action
   */
  export type CleaningSessionCountOutputTypeCountChecklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningChecklistWhereInput
  }


  /**
   * Count Type CleaningCountOutputType
   */

  export type CleaningCountOutputType = {
    cleaningSessions: number
  }

  export type CleaningCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningSessions?: boolean | CleaningCountOutputTypeCountCleaningSessionsArgs
  }

  // Custom InputTypes
  /**
   * CleaningCountOutputType without action
   */
  export type CleaningCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningCountOutputType
     */
    select?: CleaningCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CleaningCountOutputType without action
   */
  export type CleaningCountOutputTypeCountCleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningSessionWhereInput
  }


  /**
   * Count Type CleaningManagerCountOutputType
   */

  export type CleaningManagerCountOutputType = {
    interventionSites: number
    siteCleaningSessions: number
    cleaningAgents: number
    cleaningPlannings: number
  }

  export type CleaningManagerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interventionSites?: boolean | CleaningManagerCountOutputTypeCountInterventionSitesArgs
    siteCleaningSessions?: boolean | CleaningManagerCountOutputTypeCountSiteCleaningSessionsArgs
    cleaningAgents?: boolean | CleaningManagerCountOutputTypeCountCleaningAgentsArgs
    cleaningPlannings?: boolean | CleaningManagerCountOutputTypeCountCleaningPlanningsArgs
  }

  // Custom InputTypes
  /**
   * CleaningManagerCountOutputType without action
   */
  export type CleaningManagerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningManagerCountOutputType
     */
    select?: CleaningManagerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CleaningManagerCountOutputType without action
   */
  export type CleaningManagerCountOutputTypeCountInterventionSitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionSiteWhereInput
  }

  /**
   * CleaningManagerCountOutputType without action
   */
  export type CleaningManagerCountOutputTypeCountSiteCleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteCleaningSessionWhereInput
  }

  /**
   * CleaningManagerCountOutputType without action
   */
  export type CleaningManagerCountOutputTypeCountCleaningAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
  }

  /**
   * CleaningManagerCountOutputType without action
   */
  export type CleaningManagerCountOutputTypeCountCleaningPlanningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningPlanningWhereInput
  }


  /**
   * Count Type InterventionSiteCountOutputType
   */

  export type InterventionSiteCountOutputType = {
    siteCleaningSessions: number
    cleaningPlannings: number
  }

  export type InterventionSiteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    siteCleaningSessions?: boolean | InterventionSiteCountOutputTypeCountSiteCleaningSessionsArgs
    cleaningPlannings?: boolean | InterventionSiteCountOutputTypeCountCleaningPlanningsArgs
  }

  // Custom InputTypes
  /**
   * InterventionSiteCountOutputType without action
   */
  export type InterventionSiteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionSiteCountOutputType
     */
    select?: InterventionSiteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InterventionSiteCountOutputType without action
   */
  export type InterventionSiteCountOutputTypeCountSiteCleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteCleaningSessionWhereInput
  }

  /**
   * InterventionSiteCountOutputType without action
   */
  export type InterventionSiteCountOutputTypeCountCleaningPlanningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningPlanningWhereInput
  }


  /**
   * Count Type SiteCleaningSessionCountOutputType
   */

  export type SiteCleaningSessionCountOutputType = {
    photos: number
    checklist: number
  }

  export type SiteCleaningSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | SiteCleaningSessionCountOutputTypeCountPhotosArgs
    checklist?: boolean | SiteCleaningSessionCountOutputTypeCountChecklistArgs
  }

  // Custom InputTypes
  /**
   * SiteCleaningSessionCountOutputType without action
   */
  export type SiteCleaningSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningSessionCountOutputType
     */
    select?: SiteCleaningSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SiteCleaningSessionCountOutputType without action
   */
  export type SiteCleaningSessionCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteCleaningPhotoWhereInput
  }

  /**
   * SiteCleaningSessionCountOutputType without action
   */
  export type SiteCleaningSessionCountOutputTypeCountChecklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteCleaningChecklistWhereInput
  }


  /**
   * Count Type LaundryManagerCountOutputType
   */

  export type LaundryManagerCountOutputType = {
    products: number
    orders: number
    deliveryNotes: number
    siteCleaningSessions: number
  }

  export type LaundryManagerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | LaundryManagerCountOutputTypeCountProductsArgs
    orders?: boolean | LaundryManagerCountOutputTypeCountOrdersArgs
    deliveryNotes?: boolean | LaundryManagerCountOutputTypeCountDeliveryNotesArgs
    siteCleaningSessions?: boolean | LaundryManagerCountOutputTypeCountSiteCleaningSessionsArgs
  }

  // Custom InputTypes
  /**
   * LaundryManagerCountOutputType without action
   */
  export type LaundryManagerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryManagerCountOutputType
     */
    select?: LaundryManagerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LaundryManagerCountOutputType without action
   */
  export type LaundryManagerCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * LaundryManagerCountOutputType without action
   */
  export type LaundryManagerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * LaundryManagerCountOutputType without action
   */
  export type LaundryManagerCountOutputTypeCountDeliveryNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryNoteWhereInput
  }

  /**
   * LaundryManagerCountOutputType without action
   */
  export type LaundryManagerCountOutputTypeCountSiteCleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteCleaningSessionWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    orderItems: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    orderItems: number
    deliveryNotes: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | OrderCountOutputTypeCountOrderItemsArgs
    deliveryNotes?: boolean | OrderCountOutputTypeCountDeliveryNotesArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountDeliveryNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryNoteWhereInput
  }


  /**
   * Count Type TicketCountOutputType
   */

  export type TicketCountOutputType = {
    photos: number
  }

  export type TicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | TicketCountOutputTypeCountPhotosArgs
  }

  // Custom InputTypes
  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCountOutputType
     */
    select?: TicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketPhotoWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    users: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ServiceCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceUserWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    role: $Enums.Role | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    role: $Enums.Role | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    role: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    role?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    role?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    role?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    role: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    conciergerieManagers?: boolean | User$conciergerieManagersArgs<ExtArgs>
    cleaningManagers?: boolean | User$cleaningManagersArgs<ExtArgs>
    laundryManagers?: boolean | User$laundryManagersArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    serviceUsers?: boolean | User$serviceUsersArgs<ExtArgs>
    agent?: boolean | User$agentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    conciergerieManagers?: boolean | User$conciergerieManagersArgs<ExtArgs>
    cleaningManagers?: boolean | User$cleaningManagersArgs<ExtArgs>
    laundryManagers?: boolean | User$laundryManagersArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    serviceUsers?: boolean | User$serviceUsersArgs<ExtArgs>
    agent?: boolean | User$agentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      conciergerieManagers: Prisma.$ConciergerieManagerPayload<ExtArgs>[]
      cleaningManagers: Prisma.$CleaningManagerPayload<ExtArgs>[]
      laundryManagers: Prisma.$LaundryManagerPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      serviceUsers: Prisma.$ServiceUserPayload<ExtArgs>[]
      agent: Prisma.$AgentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: $Enums.Role
      name: string
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conciergerieManagers<T extends User$conciergerieManagersArgs<ExtArgs> = {}>(args?: Subset<T, User$conciergerieManagersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConciergerieManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cleaningManagers<T extends User$cleaningManagersArgs<ExtArgs> = {}>(args?: Subset<T, User$cleaningManagersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    laundryManagers<T extends User$laundryManagersArgs<ExtArgs> = {}>(args?: Subset<T, User$laundryManagersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceUsers<T extends User$serviceUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$serviceUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agent<T extends User$agentArgs<ExtArgs> = {}>(args?: Subset<T, User$agentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.conciergerieManagers
   */
  export type User$conciergerieManagersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConciergerieManager
     */
    select?: ConciergerieManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConciergerieManager
     */
    omit?: ConciergerieManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConciergerieManagerInclude<ExtArgs> | null
    where?: ConciergerieManagerWhereInput
    orderBy?: ConciergerieManagerOrderByWithRelationInput | ConciergerieManagerOrderByWithRelationInput[]
    cursor?: ConciergerieManagerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConciergerieManagerScalarFieldEnum | ConciergerieManagerScalarFieldEnum[]
  }

  /**
   * User.cleaningManagers
   */
  export type User$cleaningManagersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningManager
     */
    select?: CleaningManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningManager
     */
    omit?: CleaningManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningManagerInclude<ExtArgs> | null
    where?: CleaningManagerWhereInput
    orderBy?: CleaningManagerOrderByWithRelationInput | CleaningManagerOrderByWithRelationInput[]
    cursor?: CleaningManagerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningManagerScalarFieldEnum | CleaningManagerScalarFieldEnum[]
  }

  /**
   * User.laundryManagers
   */
  export type User$laundryManagersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryManager
     */
    select?: LaundryManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryManager
     */
    omit?: LaundryManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryManagerInclude<ExtArgs> | null
    where?: LaundryManagerWhereInput
    orderBy?: LaundryManagerOrderByWithRelationInput | LaundryManagerOrderByWithRelationInput[]
    cursor?: LaundryManagerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaundryManagerScalarFieldEnum | LaundryManagerScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.serviceUsers
   */
  export type User$serviceUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceUser
     */
    select?: ServiceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceUser
     */
    omit?: ServiceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceUserInclude<ExtArgs> | null
    where?: ServiceUserWhereInput
    orderBy?: ServiceUserOrderByWithRelationInput | ServiceUserOrderByWithRelationInput[]
    cursor?: ServiceUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceUserScalarFieldEnum | ServiceUserScalarFieldEnum[]
  }

  /**
   * User.agent
   */
  export type User$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    cursor?: AgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ConciergerieManager
   */

  export type AggregateConciergerieManager = {
    _count: ConciergerieManagerCountAggregateOutputType | null
    _min: ConciergerieManagerMinAggregateOutputType | null
    _max: ConciergerieManagerMaxAggregateOutputType | null
  }

  export type ConciergerieManagerMinAggregateOutputType = {
    id: string | null
    name: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConciergerieManagerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConciergerieManagerCountAggregateOutputType = {
    id: number
    name: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConciergerieManagerMinAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConciergerieManagerMaxAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConciergerieManagerCountAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConciergerieManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConciergerieManager to aggregate.
     */
    where?: ConciergerieManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConciergerieManagers to fetch.
     */
    orderBy?: ConciergerieManagerOrderByWithRelationInput | ConciergerieManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConciergerieManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConciergerieManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConciergerieManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConciergerieManagers
    **/
    _count?: true | ConciergerieManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConciergerieManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConciergerieManagerMaxAggregateInputType
  }

  export type GetConciergerieManagerAggregateType<T extends ConciergerieManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateConciergerieManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConciergerieManager[P]>
      : GetScalarType<T[P], AggregateConciergerieManager[P]>
  }




  export type ConciergerieManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConciergerieManagerWhereInput
    orderBy?: ConciergerieManagerOrderByWithAggregationInput | ConciergerieManagerOrderByWithAggregationInput[]
    by: ConciergerieManagerScalarFieldEnum[] | ConciergerieManagerScalarFieldEnum
    having?: ConciergerieManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConciergerieManagerCountAggregateInputType | true
    _min?: ConciergerieManagerMinAggregateInputType
    _max?: ConciergerieManagerMaxAggregateInputType
  }

  export type ConciergerieManagerGroupByOutputType = {
    id: string
    name: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ConciergerieManagerCountAggregateOutputType | null
    _min: ConciergerieManagerMinAggregateOutputType | null
    _max: ConciergerieManagerMaxAggregateOutputType | null
  }

  type GetConciergerieManagerGroupByPayload<T extends ConciergerieManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConciergerieManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConciergerieManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConciergerieManagerGroupByOutputType[P]>
            : GetScalarType<T[P], ConciergerieManagerGroupByOutputType[P]>
        }
      >
    >


  export type ConciergerieManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    properties?: boolean | ConciergerieManager$propertiesArgs<ExtArgs>
    agents?: boolean | ConciergerieManager$agentsArgs<ExtArgs>
    tasks?: boolean | ConciergerieManager$tasksArgs<ExtArgs>
    _count?: boolean | ConciergerieManagerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conciergerieManager"]>

  export type ConciergerieManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conciergerieManager"]>

  export type ConciergerieManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conciergerieManager"]>

  export type ConciergerieManagerSelectScalar = {
    id?: boolean
    name?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConciergerieManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["conciergerieManager"]>
  export type ConciergerieManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    properties?: boolean | ConciergerieManager$propertiesArgs<ExtArgs>
    agents?: boolean | ConciergerieManager$agentsArgs<ExtArgs>
    tasks?: boolean | ConciergerieManager$tasksArgs<ExtArgs>
    _count?: boolean | ConciergerieManagerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConciergerieManagerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConciergerieManagerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConciergerieManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConciergerieManager"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      properties: Prisma.$PropertyPayload<ExtArgs>[]
      agents: Prisma.$AgentPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conciergerieManager"]>
    composites: {}
  }

  type ConciergerieManagerGetPayload<S extends boolean | null | undefined | ConciergerieManagerDefaultArgs> = $Result.GetResult<Prisma.$ConciergerieManagerPayload, S>

  type ConciergerieManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConciergerieManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConciergerieManagerCountAggregateInputType | true
    }

  export interface ConciergerieManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConciergerieManager'], meta: { name: 'ConciergerieManager' } }
    /**
     * Find zero or one ConciergerieManager that matches the filter.
     * @param {ConciergerieManagerFindUniqueArgs} args - Arguments to find a ConciergerieManager
     * @example
     * // Get one ConciergerieManager
     * const conciergerieManager = await prisma.conciergerieManager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConciergerieManagerFindUniqueArgs>(args: SelectSubset<T, ConciergerieManagerFindUniqueArgs<ExtArgs>>): Prisma__ConciergerieManagerClient<$Result.GetResult<Prisma.$ConciergerieManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConciergerieManager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConciergerieManagerFindUniqueOrThrowArgs} args - Arguments to find a ConciergerieManager
     * @example
     * // Get one ConciergerieManager
     * const conciergerieManager = await prisma.conciergerieManager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConciergerieManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, ConciergerieManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConciergerieManagerClient<$Result.GetResult<Prisma.$ConciergerieManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConciergerieManager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConciergerieManagerFindFirstArgs} args - Arguments to find a ConciergerieManager
     * @example
     * // Get one ConciergerieManager
     * const conciergerieManager = await prisma.conciergerieManager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConciergerieManagerFindFirstArgs>(args?: SelectSubset<T, ConciergerieManagerFindFirstArgs<ExtArgs>>): Prisma__ConciergerieManagerClient<$Result.GetResult<Prisma.$ConciergerieManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConciergerieManager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConciergerieManagerFindFirstOrThrowArgs} args - Arguments to find a ConciergerieManager
     * @example
     * // Get one ConciergerieManager
     * const conciergerieManager = await prisma.conciergerieManager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConciergerieManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, ConciergerieManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConciergerieManagerClient<$Result.GetResult<Prisma.$ConciergerieManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConciergerieManagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConciergerieManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConciergerieManagers
     * const conciergerieManagers = await prisma.conciergerieManager.findMany()
     * 
     * // Get first 10 ConciergerieManagers
     * const conciergerieManagers = await prisma.conciergerieManager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conciergerieManagerWithIdOnly = await prisma.conciergerieManager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConciergerieManagerFindManyArgs>(args?: SelectSubset<T, ConciergerieManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConciergerieManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConciergerieManager.
     * @param {ConciergerieManagerCreateArgs} args - Arguments to create a ConciergerieManager.
     * @example
     * // Create one ConciergerieManager
     * const ConciergerieManager = await prisma.conciergerieManager.create({
     *   data: {
     *     // ... data to create a ConciergerieManager
     *   }
     * })
     * 
     */
    create<T extends ConciergerieManagerCreateArgs>(args: SelectSubset<T, ConciergerieManagerCreateArgs<ExtArgs>>): Prisma__ConciergerieManagerClient<$Result.GetResult<Prisma.$ConciergerieManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConciergerieManagers.
     * @param {ConciergerieManagerCreateManyArgs} args - Arguments to create many ConciergerieManagers.
     * @example
     * // Create many ConciergerieManagers
     * const conciergerieManager = await prisma.conciergerieManager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConciergerieManagerCreateManyArgs>(args?: SelectSubset<T, ConciergerieManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConciergerieManagers and returns the data saved in the database.
     * @param {ConciergerieManagerCreateManyAndReturnArgs} args - Arguments to create many ConciergerieManagers.
     * @example
     * // Create many ConciergerieManagers
     * const conciergerieManager = await prisma.conciergerieManager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConciergerieManagers and only return the `id`
     * const conciergerieManagerWithIdOnly = await prisma.conciergerieManager.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConciergerieManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, ConciergerieManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConciergerieManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConciergerieManager.
     * @param {ConciergerieManagerDeleteArgs} args - Arguments to delete one ConciergerieManager.
     * @example
     * // Delete one ConciergerieManager
     * const ConciergerieManager = await prisma.conciergerieManager.delete({
     *   where: {
     *     // ... filter to delete one ConciergerieManager
     *   }
     * })
     * 
     */
    delete<T extends ConciergerieManagerDeleteArgs>(args: SelectSubset<T, ConciergerieManagerDeleteArgs<ExtArgs>>): Prisma__ConciergerieManagerClient<$Result.GetResult<Prisma.$ConciergerieManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConciergerieManager.
     * @param {ConciergerieManagerUpdateArgs} args - Arguments to update one ConciergerieManager.
     * @example
     * // Update one ConciergerieManager
     * const conciergerieManager = await prisma.conciergerieManager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConciergerieManagerUpdateArgs>(args: SelectSubset<T, ConciergerieManagerUpdateArgs<ExtArgs>>): Prisma__ConciergerieManagerClient<$Result.GetResult<Prisma.$ConciergerieManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConciergerieManagers.
     * @param {ConciergerieManagerDeleteManyArgs} args - Arguments to filter ConciergerieManagers to delete.
     * @example
     * // Delete a few ConciergerieManagers
     * const { count } = await prisma.conciergerieManager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConciergerieManagerDeleteManyArgs>(args?: SelectSubset<T, ConciergerieManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConciergerieManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConciergerieManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConciergerieManagers
     * const conciergerieManager = await prisma.conciergerieManager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConciergerieManagerUpdateManyArgs>(args: SelectSubset<T, ConciergerieManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConciergerieManagers and returns the data updated in the database.
     * @param {ConciergerieManagerUpdateManyAndReturnArgs} args - Arguments to update many ConciergerieManagers.
     * @example
     * // Update many ConciergerieManagers
     * const conciergerieManager = await prisma.conciergerieManager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConciergerieManagers and only return the `id`
     * const conciergerieManagerWithIdOnly = await prisma.conciergerieManager.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConciergerieManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, ConciergerieManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConciergerieManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConciergerieManager.
     * @param {ConciergerieManagerUpsertArgs} args - Arguments to update or create a ConciergerieManager.
     * @example
     * // Update or create a ConciergerieManager
     * const conciergerieManager = await prisma.conciergerieManager.upsert({
     *   create: {
     *     // ... data to create a ConciergerieManager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConciergerieManager we want to update
     *   }
     * })
     */
    upsert<T extends ConciergerieManagerUpsertArgs>(args: SelectSubset<T, ConciergerieManagerUpsertArgs<ExtArgs>>): Prisma__ConciergerieManagerClient<$Result.GetResult<Prisma.$ConciergerieManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConciergerieManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConciergerieManagerCountArgs} args - Arguments to filter ConciergerieManagers to count.
     * @example
     * // Count the number of ConciergerieManagers
     * const count = await prisma.conciergerieManager.count({
     *   where: {
     *     // ... the filter for the ConciergerieManagers we want to count
     *   }
     * })
    **/
    count<T extends ConciergerieManagerCountArgs>(
      args?: Subset<T, ConciergerieManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConciergerieManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConciergerieManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConciergerieManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConciergerieManagerAggregateArgs>(args: Subset<T, ConciergerieManagerAggregateArgs>): Prisma.PrismaPromise<GetConciergerieManagerAggregateType<T>>

    /**
     * Group by ConciergerieManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConciergerieManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConciergerieManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConciergerieManagerGroupByArgs['orderBy'] }
        : { orderBy?: ConciergerieManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConciergerieManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConciergerieManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConciergerieManager model
   */
  readonly fields: ConciergerieManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConciergerieManager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConciergerieManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    properties<T extends ConciergerieManager$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, ConciergerieManager$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agents<T extends ConciergerieManager$agentsArgs<ExtArgs> = {}>(args?: Subset<T, ConciergerieManager$agentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends ConciergerieManager$tasksArgs<ExtArgs> = {}>(args?: Subset<T, ConciergerieManager$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConciergerieManager model
   */
  interface ConciergerieManagerFieldRefs {
    readonly id: FieldRef<"ConciergerieManager", 'String'>
    readonly name: FieldRef<"ConciergerieManager", 'String'>
    readonly userId: FieldRef<"ConciergerieManager", 'String'>
    readonly createdAt: FieldRef<"ConciergerieManager", 'DateTime'>
    readonly updatedAt: FieldRef<"ConciergerieManager", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConciergerieManager findUnique
   */
  export type ConciergerieManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConciergerieManager
     */
    select?: ConciergerieManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConciergerieManager
     */
    omit?: ConciergerieManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConciergerieManagerInclude<ExtArgs> | null
    /**
     * Filter, which ConciergerieManager to fetch.
     */
    where: ConciergerieManagerWhereUniqueInput
  }

  /**
   * ConciergerieManager findUniqueOrThrow
   */
  export type ConciergerieManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConciergerieManager
     */
    select?: ConciergerieManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConciergerieManager
     */
    omit?: ConciergerieManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConciergerieManagerInclude<ExtArgs> | null
    /**
     * Filter, which ConciergerieManager to fetch.
     */
    where: ConciergerieManagerWhereUniqueInput
  }

  /**
   * ConciergerieManager findFirst
   */
  export type ConciergerieManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConciergerieManager
     */
    select?: ConciergerieManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConciergerieManager
     */
    omit?: ConciergerieManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConciergerieManagerInclude<ExtArgs> | null
    /**
     * Filter, which ConciergerieManager to fetch.
     */
    where?: ConciergerieManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConciergerieManagers to fetch.
     */
    orderBy?: ConciergerieManagerOrderByWithRelationInput | ConciergerieManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConciergerieManagers.
     */
    cursor?: ConciergerieManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConciergerieManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConciergerieManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConciergerieManagers.
     */
    distinct?: ConciergerieManagerScalarFieldEnum | ConciergerieManagerScalarFieldEnum[]
  }

  /**
   * ConciergerieManager findFirstOrThrow
   */
  export type ConciergerieManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConciergerieManager
     */
    select?: ConciergerieManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConciergerieManager
     */
    omit?: ConciergerieManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConciergerieManagerInclude<ExtArgs> | null
    /**
     * Filter, which ConciergerieManager to fetch.
     */
    where?: ConciergerieManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConciergerieManagers to fetch.
     */
    orderBy?: ConciergerieManagerOrderByWithRelationInput | ConciergerieManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConciergerieManagers.
     */
    cursor?: ConciergerieManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConciergerieManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConciergerieManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConciergerieManagers.
     */
    distinct?: ConciergerieManagerScalarFieldEnum | ConciergerieManagerScalarFieldEnum[]
  }

  /**
   * ConciergerieManager findMany
   */
  export type ConciergerieManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConciergerieManager
     */
    select?: ConciergerieManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConciergerieManager
     */
    omit?: ConciergerieManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConciergerieManagerInclude<ExtArgs> | null
    /**
     * Filter, which ConciergerieManagers to fetch.
     */
    where?: ConciergerieManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConciergerieManagers to fetch.
     */
    orderBy?: ConciergerieManagerOrderByWithRelationInput | ConciergerieManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConciergerieManagers.
     */
    cursor?: ConciergerieManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConciergerieManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConciergerieManagers.
     */
    skip?: number
    distinct?: ConciergerieManagerScalarFieldEnum | ConciergerieManagerScalarFieldEnum[]
  }

  /**
   * ConciergerieManager create
   */
  export type ConciergerieManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConciergerieManager
     */
    select?: ConciergerieManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConciergerieManager
     */
    omit?: ConciergerieManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConciergerieManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a ConciergerieManager.
     */
    data: XOR<ConciergerieManagerCreateInput, ConciergerieManagerUncheckedCreateInput>
  }

  /**
   * ConciergerieManager createMany
   */
  export type ConciergerieManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConciergerieManagers.
     */
    data: ConciergerieManagerCreateManyInput | ConciergerieManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConciergerieManager createManyAndReturn
   */
  export type ConciergerieManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConciergerieManager
     */
    select?: ConciergerieManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConciergerieManager
     */
    omit?: ConciergerieManagerOmit<ExtArgs> | null
    /**
     * The data used to create many ConciergerieManagers.
     */
    data: ConciergerieManagerCreateManyInput | ConciergerieManagerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConciergerieManagerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConciergerieManager update
   */
  export type ConciergerieManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConciergerieManager
     */
    select?: ConciergerieManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConciergerieManager
     */
    omit?: ConciergerieManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConciergerieManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a ConciergerieManager.
     */
    data: XOR<ConciergerieManagerUpdateInput, ConciergerieManagerUncheckedUpdateInput>
    /**
     * Choose, which ConciergerieManager to update.
     */
    where: ConciergerieManagerWhereUniqueInput
  }

  /**
   * ConciergerieManager updateMany
   */
  export type ConciergerieManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConciergerieManagers.
     */
    data: XOR<ConciergerieManagerUpdateManyMutationInput, ConciergerieManagerUncheckedUpdateManyInput>
    /**
     * Filter which ConciergerieManagers to update
     */
    where?: ConciergerieManagerWhereInput
    /**
     * Limit how many ConciergerieManagers to update.
     */
    limit?: number
  }

  /**
   * ConciergerieManager updateManyAndReturn
   */
  export type ConciergerieManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConciergerieManager
     */
    select?: ConciergerieManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConciergerieManager
     */
    omit?: ConciergerieManagerOmit<ExtArgs> | null
    /**
     * The data used to update ConciergerieManagers.
     */
    data: XOR<ConciergerieManagerUpdateManyMutationInput, ConciergerieManagerUncheckedUpdateManyInput>
    /**
     * Filter which ConciergerieManagers to update
     */
    where?: ConciergerieManagerWhereInput
    /**
     * Limit how many ConciergerieManagers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConciergerieManagerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConciergerieManager upsert
   */
  export type ConciergerieManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConciergerieManager
     */
    select?: ConciergerieManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConciergerieManager
     */
    omit?: ConciergerieManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConciergerieManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the ConciergerieManager to update in case it exists.
     */
    where: ConciergerieManagerWhereUniqueInput
    /**
     * In case the ConciergerieManager found by the `where` argument doesn't exist, create a new ConciergerieManager with this data.
     */
    create: XOR<ConciergerieManagerCreateInput, ConciergerieManagerUncheckedCreateInput>
    /**
     * In case the ConciergerieManager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConciergerieManagerUpdateInput, ConciergerieManagerUncheckedUpdateInput>
  }

  /**
   * ConciergerieManager delete
   */
  export type ConciergerieManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConciergerieManager
     */
    select?: ConciergerieManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConciergerieManager
     */
    omit?: ConciergerieManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConciergerieManagerInclude<ExtArgs> | null
    /**
     * Filter which ConciergerieManager to delete.
     */
    where: ConciergerieManagerWhereUniqueInput
  }

  /**
   * ConciergerieManager deleteMany
   */
  export type ConciergerieManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConciergerieManagers to delete
     */
    where?: ConciergerieManagerWhereInput
    /**
     * Limit how many ConciergerieManagers to delete.
     */
    limit?: number
  }

  /**
   * ConciergerieManager.properties
   */
  export type ConciergerieManager$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * ConciergerieManager.agents
   */
  export type ConciergerieManager$agentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    cursor?: AgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * ConciergerieManager.tasks
   */
  export type ConciergerieManager$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * ConciergerieManager without action
   */
  export type ConciergerieManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConciergerieManager
     */
    select?: ConciergerieManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConciergerieManager
     */
    omit?: ConciergerieManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConciergerieManagerInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    conciergerieManagerId: string | null
    agentId: string | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    conciergerieManagerId: string | null
    agentId: string | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    conciergerieManagerId: number
    agentId: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    conciergerieManagerId?: true
    agentId?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    conciergerieManagerId?: true
    agentId?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    conciergerieManagerId?: true
    agentId?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    conciergerieManagerId: string | null
    agentId: string | null
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conciergerieManagerId?: boolean
    agentId?: boolean
    conciergerieManager?: boolean | Task$conciergerieManagerArgs<ExtArgs>
    agent?: boolean | Task$agentArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conciergerieManagerId?: boolean
    agentId?: boolean
    conciergerieManager?: boolean | Task$conciergerieManagerArgs<ExtArgs>
    agent?: boolean | Task$agentArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conciergerieManagerId?: boolean
    agentId?: boolean
    conciergerieManager?: boolean | Task$conciergerieManagerArgs<ExtArgs>
    agent?: boolean | Task$agentArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conciergerieManagerId?: boolean
    agentId?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt" | "conciergerieManagerId" | "agentId", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conciergerieManager?: boolean | Task$conciergerieManagerArgs<ExtArgs>
    agent?: boolean | Task$agentArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conciergerieManager?: boolean | Task$conciergerieManagerArgs<ExtArgs>
    agent?: boolean | Task$agentArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conciergerieManager?: boolean | Task$conciergerieManagerArgs<ExtArgs>
    agent?: boolean | Task$agentArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      conciergerieManager: Prisma.$ConciergerieManagerPayload<ExtArgs> | null
      agent: Prisma.$AgentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      createdAt: Date
      updatedAt: Date
      conciergerieManagerId: string | null
      agentId: string | null
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conciergerieManager<T extends Task$conciergerieManagerArgs<ExtArgs> = {}>(args?: Subset<T, Task$conciergerieManagerArgs<ExtArgs>>): Prisma__ConciergerieManagerClient<$Result.GetResult<Prisma.$ConciergerieManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agent<T extends Task$agentArgs<ExtArgs> = {}>(args?: Subset<T, Task$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly name: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly conciergerieManagerId: FieldRef<"Task", 'String'>
    readonly agentId: FieldRef<"Task", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.conciergerieManager
   */
  export type Task$conciergerieManagerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConciergerieManager
     */
    select?: ConciergerieManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConciergerieManager
     */
    omit?: ConciergerieManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConciergerieManagerInclude<ExtArgs> | null
    where?: ConciergerieManagerWhereInput
  }

  /**
   * Task.agent
   */
  export type Task$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyAvgAggregateOutputType = {
    surface: number | null
    numberOfRooms: number | null
    numberOfBathrooms: number | null
  }

  export type PropertySumAggregateOutputType = {
    surface: number | null
    numberOfRooms: number | null
    numberOfBathrooms: number | null
  }

  export type PropertyMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.PropertyStatus | null
    location: string | null
    surface: number | null
    numberOfRooms: number | null
    numberOfBathrooms: number | null
    createdAt: Date | null
    updatedAt: Date | null
    conciergerieManagerId: string | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.PropertyStatus | null
    location: string | null
    surface: number | null
    numberOfRooms: number | null
    numberOfBathrooms: number | null
    createdAt: Date | null
    updatedAt: Date | null
    conciergerieManagerId: string | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    location: number
    surface: number
    numberOfRooms: number
    numberOfBathrooms: number
    createdAt: number
    updatedAt: number
    conciergerieManagerId: number
    _all: number
  }


  export type PropertyAvgAggregateInputType = {
    surface?: true
    numberOfRooms?: true
    numberOfBathrooms?: true
  }

  export type PropertySumAggregateInputType = {
    surface?: true
    numberOfRooms?: true
    numberOfBathrooms?: true
  }

  export type PropertyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    location?: true
    surface?: true
    numberOfRooms?: true
    numberOfBathrooms?: true
    createdAt?: true
    updatedAt?: true
    conciergerieManagerId?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    location?: true
    surface?: true
    numberOfRooms?: true
    numberOfBathrooms?: true
    createdAt?: true
    updatedAt?: true
    conciergerieManagerId?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    location?: true
    surface?: true
    numberOfRooms?: true
    numberOfBathrooms?: true
    createdAt?: true
    updatedAt?: true
    conciergerieManagerId?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _avg?: PropertyAvgAggregateInputType
    _sum?: PropertySumAggregateInputType
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: string
    name: string
    description: string
    status: $Enums.PropertyStatus
    location: string | null
    surface: number | null
    numberOfRooms: number | null
    numberOfBathrooms: number | null
    createdAt: Date
    updatedAt: Date
    conciergerieManagerId: string
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    location?: boolean
    surface?: boolean
    numberOfRooms?: boolean
    numberOfBathrooms?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conciergerieManagerId?: boolean
    conciergerieManager?: boolean | ConciergerieManagerDefaultArgs<ExtArgs>
    cleaningSessions?: boolean | Property$cleaningSessionsArgs<ExtArgs>
    maintenanceSessions?: boolean | Property$maintenanceSessionsArgs<ExtArgs>
    reservations?: boolean | Property$reservationsArgs<ExtArgs>
    payments?: boolean | Property$paymentsArgs<ExtArgs>
    tickets?: boolean | Property$ticketsArgs<ExtArgs>
    photos?: boolean | Property$photosArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    location?: boolean
    surface?: boolean
    numberOfRooms?: boolean
    numberOfBathrooms?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conciergerieManagerId?: boolean
    conciergerieManager?: boolean | ConciergerieManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    location?: boolean
    surface?: boolean
    numberOfRooms?: boolean
    numberOfBathrooms?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conciergerieManagerId?: boolean
    conciergerieManager?: boolean | ConciergerieManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    location?: boolean
    surface?: boolean
    numberOfRooms?: boolean
    numberOfBathrooms?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conciergerieManagerId?: boolean
  }

  export type PropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "location" | "surface" | "numberOfRooms" | "numberOfBathrooms" | "createdAt" | "updatedAt" | "conciergerieManagerId", ExtArgs["result"]["property"]>
  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conciergerieManager?: boolean | ConciergerieManagerDefaultArgs<ExtArgs>
    cleaningSessions?: boolean | Property$cleaningSessionsArgs<ExtArgs>
    maintenanceSessions?: boolean | Property$maintenanceSessionsArgs<ExtArgs>
    reservations?: boolean | Property$reservationsArgs<ExtArgs>
    payments?: boolean | Property$paymentsArgs<ExtArgs>
    tickets?: boolean | Property$ticketsArgs<ExtArgs>
    photos?: boolean | Property$photosArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conciergerieManager?: boolean | ConciergerieManagerDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conciergerieManager?: boolean | ConciergerieManagerDefaultArgs<ExtArgs>
  }

  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      conciergerieManager: Prisma.$ConciergerieManagerPayload<ExtArgs>
      cleaningSessions: Prisma.$CleaningSessionPayload<ExtArgs>[]
      maintenanceSessions: Prisma.$MaintenanceSessionPayload<ExtArgs>[]
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      photos: Prisma.$PropertyPhotoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      status: $Enums.PropertyStatus
      location: string | null
      surface: number | null
      numberOfRooms: number | null
      numberOfBathrooms: number | null
      createdAt: Date
      updatedAt: Date
      conciergerieManagerId: string
    }, ExtArgs["result"]["property"]>
    composites: {}
  }

  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFindManyArgs>(args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
     */
    create<T extends PropertyCreateArgs>(args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCreateManyArgs>(args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {PropertyCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
     */
    delete<T extends PropertyDeleteArgs>(args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUpdateArgs>(args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDeleteManyArgs>(args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUpdateManyArgs>(args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties and returns the data updated in the database.
     * @param {PropertyUpdateManyAndReturnArgs} args - Arguments to update many Properties.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conciergerieManager<T extends ConciergerieManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConciergerieManagerDefaultArgs<ExtArgs>>): Prisma__ConciergerieManagerClient<$Result.GetResult<Prisma.$ConciergerieManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cleaningSessions<T extends Property$cleaningSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Property$cleaningSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maintenanceSessions<T extends Property$maintenanceSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Property$maintenanceSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reservations<T extends Property$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Property$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Property$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Property$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends Property$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Property$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos<T extends Property$photosArgs<ExtArgs> = {}>(args?: Subset<T, Property$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Property model
   */
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'String'>
    readonly name: FieldRef<"Property", 'String'>
    readonly description: FieldRef<"Property", 'String'>
    readonly status: FieldRef<"Property", 'PropertyStatus'>
    readonly location: FieldRef<"Property", 'String'>
    readonly surface: FieldRef<"Property", 'Float'>
    readonly numberOfRooms: FieldRef<"Property", 'Int'>
    readonly numberOfBathrooms: FieldRef<"Property", 'Int'>
    readonly createdAt: FieldRef<"Property", 'DateTime'>
    readonly updatedAt: FieldRef<"Property", 'DateTime'>
    readonly conciergerieManagerId: FieldRef<"Property", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Property createManyAndReturn
   */
  export type PropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
  }

  /**
   * Property updateManyAndReturn
   */
  export type PropertyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to delete.
     */
    limit?: number
  }

  /**
   * Property.cleaningSessions
   */
  export type Property$cleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    where?: CleaningSessionWhereInput
    orderBy?: CleaningSessionOrderByWithRelationInput | CleaningSessionOrderByWithRelationInput[]
    cursor?: CleaningSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningSessionScalarFieldEnum | CleaningSessionScalarFieldEnum[]
  }

  /**
   * Property.maintenanceSessions
   */
  export type Property$maintenanceSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    where?: MaintenanceSessionWhereInput
    orderBy?: MaintenanceSessionOrderByWithRelationInput | MaintenanceSessionOrderByWithRelationInput[]
    cursor?: MaintenanceSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceSessionScalarFieldEnum | MaintenanceSessionScalarFieldEnum[]
  }

  /**
   * Property.reservations
   */
  export type Property$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Property.payments
   */
  export type Property$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Property.tickets
   */
  export type Property$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Property.photos
   */
  export type Property$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    where?: PropertyPhotoWhereInput
    orderBy?: PropertyPhotoOrderByWithRelationInput | PropertyPhotoOrderByWithRelationInput[]
    cursor?: PropertyPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyPhotoScalarFieldEnum | PropertyPhotoScalarFieldEnum[]
  }

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
  }


  /**
   * Model Reservation
   */

  export type AggregateReservation = {
    _count: ReservationCountAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  export type ReservationMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    startDate: Date | null
    endDate: Date | null
    client: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReservationMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    startDate: Date | null
    endDate: Date | null
    client: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReservationCountAggregateOutputType = {
    id: number
    propertyId: number
    startDate: number
    endDate: number
    client: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReservationMinAggregateInputType = {
    id?: true
    propertyId?: true
    startDate?: true
    endDate?: true
    client?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReservationMaxAggregateInputType = {
    id?: true
    propertyId?: true
    startDate?: true
    endDate?: true
    client?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReservationCountAggregateInputType = {
    id?: true
    propertyId?: true
    startDate?: true
    endDate?: true
    client?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservation to aggregate.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservations
    **/
    _count?: true | ReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationMaxAggregateInputType
  }

  export type GetReservationAggregateType<T extends ReservationAggregateArgs> = {
        [P in keyof T & keyof AggregateReservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservation[P]>
      : GetScalarType<T[P], AggregateReservation[P]>
  }




  export type ReservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithAggregationInput | ReservationOrderByWithAggregationInput[]
    by: ReservationScalarFieldEnum[] | ReservationScalarFieldEnum
    having?: ReservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationCountAggregateInputType | true
    _min?: ReservationMinAggregateInputType
    _max?: ReservationMaxAggregateInputType
  }

  export type ReservationGroupByOutputType = {
    id: string
    propertyId: string
    startDate: Date
    endDate: Date
    client: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReservationCountAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  type GetReservationGroupByPayload<T extends ReservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationGroupByOutputType[P]>
        }
      >
    >


  export type ReservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    startDate?: boolean
    endDate?: boolean
    client?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    startDate?: boolean
    endDate?: boolean
    client?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    startDate?: boolean
    endDate?: boolean
    client?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectScalar = {
    id?: boolean
    propertyId?: boolean
    startDate?: boolean
    endDate?: boolean
    client?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReservationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "startDate" | "endDate" | "client" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["reservation"]>
  export type ReservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type ReservationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type ReservationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $ReservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reservation"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      startDate: Date
      endDate: Date
      client: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reservation"]>
    composites: {}
  }

  type ReservationGetPayload<S extends boolean | null | undefined | ReservationDefaultArgs> = $Result.GetResult<Prisma.$ReservationPayload, S>

  type ReservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReservationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReservationCountAggregateInputType | true
    }

  export interface ReservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reservation'], meta: { name: 'Reservation' } }
    /**
     * Find zero or one Reservation that matches the filter.
     * @param {ReservationFindUniqueArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservationFindUniqueArgs>(args: SelectSubset<T, ReservationFindUniqueArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reservation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReservationFindUniqueOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservationFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservationFindFirstArgs>(args?: SelectSubset<T, ReservationFindFirstArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservationFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservation.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationWithIdOnly = await prisma.reservation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReservationFindManyArgs>(args?: SelectSubset<T, ReservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reservation.
     * @param {ReservationCreateArgs} args - Arguments to create a Reservation.
     * @example
     * // Create one Reservation
     * const Reservation = await prisma.reservation.create({
     *   data: {
     *     // ... data to create a Reservation
     *   }
     * })
     * 
     */
    create<T extends ReservationCreateArgs>(args: SelectSubset<T, ReservationCreateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reservations.
     * @param {ReservationCreateManyArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservationCreateManyArgs>(args?: SelectSubset<T, ReservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reservations and returns the data saved in the database.
     * @param {ReservationCreateManyAndReturnArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReservationCreateManyAndReturnArgs>(args?: SelectSubset<T, ReservationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reservation.
     * @param {ReservationDeleteArgs} args - Arguments to delete one Reservation.
     * @example
     * // Delete one Reservation
     * const Reservation = await prisma.reservation.delete({
     *   where: {
     *     // ... filter to delete one Reservation
     *   }
     * })
     * 
     */
    delete<T extends ReservationDeleteArgs>(args: SelectSubset<T, ReservationDeleteArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reservation.
     * @param {ReservationUpdateArgs} args - Arguments to update one Reservation.
     * @example
     * // Update one Reservation
     * const reservation = await prisma.reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservationUpdateArgs>(args: SelectSubset<T, ReservationUpdateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reservations.
     * @param {ReservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservationDeleteManyArgs>(args?: SelectSubset<T, ReservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservationUpdateManyArgs>(args: SelectSubset<T, ReservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations and returns the data updated in the database.
     * @param {ReservationUpdateManyAndReturnArgs} args - Arguments to update many Reservations.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReservationUpdateManyAndReturnArgs>(args: SelectSubset<T, ReservationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reservation.
     * @param {ReservationUpsertArgs} args - Arguments to update or create a Reservation.
     * @example
     * // Update or create a Reservation
     * const reservation = await prisma.reservation.upsert({
     *   create: {
     *     // ... data to create a Reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservation we want to update
     *   }
     * })
     */
    upsert<T extends ReservationUpsertArgs>(args: SelectSubset<T, ReservationUpsertArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservation.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends ReservationCountArgs>(
      args?: Subset<T, ReservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationAggregateArgs>(args: Subset<T, ReservationAggregateArgs>): Prisma.PrismaPromise<GetReservationAggregateType<T>>

    /**
     * Group by Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationGroupByArgs['orderBy'] }
        : { orderBy?: ReservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reservation model
   */
  readonly fields: ReservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reservation model
   */
  interface ReservationFieldRefs {
    readonly id: FieldRef<"Reservation", 'String'>
    readonly propertyId: FieldRef<"Reservation", 'String'>
    readonly startDate: FieldRef<"Reservation", 'DateTime'>
    readonly endDate: FieldRef<"Reservation", 'DateTime'>
    readonly client: FieldRef<"Reservation", 'String'>
    readonly notes: FieldRef<"Reservation", 'String'>
    readonly createdAt: FieldRef<"Reservation", 'DateTime'>
    readonly updatedAt: FieldRef<"Reservation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reservation findUnique
   */
  export type ReservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findUniqueOrThrow
   */
  export type ReservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findFirst
   */
  export type ReservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findFirstOrThrow
   */
  export type ReservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findMany
   */
  export type ReservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservations to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation create
   */
  export type ReservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to create a Reservation.
     */
    data: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
  }

  /**
   * Reservation createMany
   */
  export type ReservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reservation createManyAndReturn
   */
  export type ReservationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation update
   */
  export type ReservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to update a Reservation.
     */
    data: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
    /**
     * Choose, which Reservation to update.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation updateMany
   */
  export type ReservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to update.
     */
    limit?: number
  }

  /**
   * Reservation updateManyAndReturn
   */
  export type ReservationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation upsert
   */
  export type ReservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The filter to search for the Reservation to update in case it exists.
     */
    where: ReservationWhereUniqueInput
    /**
     * In case the Reservation found by the `where` argument doesn't exist, create a new Reservation with this data.
     */
    create: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
    /**
     * In case the Reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
  }

  /**
   * Reservation delete
   */
  export type ReservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter which Reservation to delete.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation deleteMany
   */
  export type ReservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservations to delete
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to delete.
     */
    limit?: number
  }

  /**
   * Reservation without action
   */
  export type ReservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
  }


  /**
   * Model Agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    type: $Enums.AgentType | null
    conciergerieManagerId: string | null
    userId: string | null
    cleaningManagerId: string | null
  }

  export type AgentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    type: $Enums.AgentType | null
    conciergerieManagerId: string | null
    userId: string | null
    cleaningManagerId: string | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    type: number
    conciergerieManagerId: number
    userId: number
    cleaningManagerId: number
    _all: number
  }


  export type AgentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    conciergerieManagerId?: true
    userId?: true
    cleaningManagerId?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    conciergerieManagerId?: true
    userId?: true
    cleaningManagerId?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    conciergerieManagerId?: true
    userId?: true
    cleaningManagerId?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithAggregationInput | AgentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    id: string
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    type: $Enums.AgentType
    conciergerieManagerId: string
    userId: string
    cleaningManagerId: string | null
    _count: AgentCountAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    conciergerieManagerId?: boolean
    userId?: boolean
    cleaningManagerId?: boolean
    maintenanceSessions?: boolean | Agent$maintenanceSessionsArgs<ExtArgs>
    cleaningSessions?: boolean | Agent$cleaningSessionsArgs<ExtArgs>
    conciergerieManager?: boolean | ConciergerieManagerDefaultArgs<ExtArgs>
    tasks?: boolean | Agent$tasksArgs<ExtArgs>
    tickets?: boolean | Agent$ticketsArgs<ExtArgs>
    cleaningPlannings?: boolean | Agent$cleaningPlanningsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    siteCleaningSessions?: boolean | Agent$siteCleaningSessionsArgs<ExtArgs>
    cleaningManager?: boolean | Agent$cleaningManagerArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    conciergerieManagerId?: boolean
    userId?: boolean
    cleaningManagerId?: boolean
    conciergerieManager?: boolean | ConciergerieManagerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    cleaningManager?: boolean | Agent$cleaningManagerArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    conciergerieManagerId?: boolean
    userId?: boolean
    cleaningManagerId?: boolean
    conciergerieManager?: boolean | ConciergerieManagerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    cleaningManager?: boolean | Agent$cleaningManagerArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    conciergerieManagerId?: boolean
    userId?: boolean
    cleaningManagerId?: boolean
  }

  export type AgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt" | "type" | "conciergerieManagerId" | "userId" | "cleaningManagerId", ExtArgs["result"]["agent"]>
  export type AgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenanceSessions?: boolean | Agent$maintenanceSessionsArgs<ExtArgs>
    cleaningSessions?: boolean | Agent$cleaningSessionsArgs<ExtArgs>
    conciergerieManager?: boolean | ConciergerieManagerDefaultArgs<ExtArgs>
    tasks?: boolean | Agent$tasksArgs<ExtArgs>
    tickets?: boolean | Agent$ticketsArgs<ExtArgs>
    cleaningPlannings?: boolean | Agent$cleaningPlanningsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    siteCleaningSessions?: boolean | Agent$siteCleaningSessionsArgs<ExtArgs>
    cleaningManager?: boolean | Agent$cleaningManagerArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conciergerieManager?: boolean | ConciergerieManagerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    cleaningManager?: boolean | Agent$cleaningManagerArgs<ExtArgs>
  }
  export type AgentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conciergerieManager?: boolean | ConciergerieManagerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    cleaningManager?: boolean | Agent$cleaningManagerArgs<ExtArgs>
  }

  export type $AgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agent"
    objects: {
      maintenanceSessions: Prisma.$MaintenanceSessionPayload<ExtArgs>[]
      cleaningSessions: Prisma.$CleaningSessionPayload<ExtArgs>[]
      conciergerieManager: Prisma.$ConciergerieManagerPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      cleaningPlannings: Prisma.$CleaningPlanningPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      siteCleaningSessions: Prisma.$SiteCleaningSessionPayload<ExtArgs>[]
      cleaningManager: Prisma.$CleaningManagerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      createdAt: Date
      updatedAt: Date
      type: $Enums.AgentType
      conciergerieManagerId: string
      userId: string
      cleaningManagerId: string | null
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type AgentGetPayload<S extends boolean | null | undefined | AgentDefaultArgs> = $Result.GetResult<Prisma.$AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFindUniqueArgs>(args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFindFirstArgs>(args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFindManyArgs>(args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends AgentCreateArgs>(args: SelectSubset<T, AgentCreateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agents.
     * @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentCreateManyArgs>(args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agents and returns the data saved in the database.
     * @param {AgentCreateManyAndReturnArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends AgentDeleteArgs>(args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentUpdateArgs>(args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDeleteManyArgs>(args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentUpdateManyArgs>(args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents and returns the data updated in the database.
     * @param {AgentUpdateManyAndReturnArgs} args - Arguments to update many Agents.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends AgentUpsertArgs>(args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agent model
   */
  readonly fields: AgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    maintenanceSessions<T extends Agent$maintenanceSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$maintenanceSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cleaningSessions<T extends Agent$cleaningSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$cleaningSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conciergerieManager<T extends ConciergerieManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConciergerieManagerDefaultArgs<ExtArgs>>): Prisma__ConciergerieManagerClient<$Result.GetResult<Prisma.$ConciergerieManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Agent$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Agent$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends Agent$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cleaningPlannings<T extends Agent$cleaningPlanningsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$cleaningPlanningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningPlanningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    siteCleaningSessions<T extends Agent$siteCleaningSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$siteCleaningSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteCleaningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cleaningManager<T extends Agent$cleaningManagerArgs<ExtArgs> = {}>(args?: Subset<T, Agent$cleaningManagerArgs<ExtArgs>>): Prisma__CleaningManagerClient<$Result.GetResult<Prisma.$CleaningManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agent model
   */
  interface AgentFieldRefs {
    readonly id: FieldRef<"Agent", 'String'>
    readonly name: FieldRef<"Agent", 'String'>
    readonly description: FieldRef<"Agent", 'String'>
    readonly createdAt: FieldRef<"Agent", 'DateTime'>
    readonly updatedAt: FieldRef<"Agent", 'DateTime'>
    readonly type: FieldRef<"Agent", 'AgentType'>
    readonly conciergerieManagerId: FieldRef<"Agent", 'String'>
    readonly userId: FieldRef<"Agent", 'String'>
    readonly cleaningManagerId: FieldRef<"Agent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Agent findUnique
   */
  export type AgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findFirst
   */
  export type AgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }

  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent createManyAndReturn
   */
  export type AgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
  }

  /**
   * Agent updateManyAndReturn
   */
  export type AgentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }

  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to delete.
     */
    limit?: number
  }

  /**
   * Agent.maintenanceSessions
   */
  export type Agent$maintenanceSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    where?: MaintenanceSessionWhereInput
    orderBy?: MaintenanceSessionOrderByWithRelationInput | MaintenanceSessionOrderByWithRelationInput[]
    cursor?: MaintenanceSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceSessionScalarFieldEnum | MaintenanceSessionScalarFieldEnum[]
  }

  /**
   * Agent.cleaningSessions
   */
  export type Agent$cleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    where?: CleaningSessionWhereInput
    orderBy?: CleaningSessionOrderByWithRelationInput | CleaningSessionOrderByWithRelationInput[]
    cursor?: CleaningSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningSessionScalarFieldEnum | CleaningSessionScalarFieldEnum[]
  }

  /**
   * Agent.tasks
   */
  export type Agent$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Agent.tickets
   */
  export type Agent$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Agent.cleaningPlannings
   */
  export type Agent$cleaningPlanningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPlanning
     */
    select?: CleaningPlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPlanning
     */
    omit?: CleaningPlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPlanningInclude<ExtArgs> | null
    where?: CleaningPlanningWhereInput
    orderBy?: CleaningPlanningOrderByWithRelationInput | CleaningPlanningOrderByWithRelationInput[]
    cursor?: CleaningPlanningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningPlanningScalarFieldEnum | CleaningPlanningScalarFieldEnum[]
  }

  /**
   * Agent.siteCleaningSessions
   */
  export type Agent$siteCleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningSession
     */
    select?: SiteCleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningSession
     */
    omit?: SiteCleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningSessionInclude<ExtArgs> | null
    where?: SiteCleaningSessionWhereInput
    orderBy?: SiteCleaningSessionOrderByWithRelationInput | SiteCleaningSessionOrderByWithRelationInput[]
    cursor?: SiteCleaningSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteCleaningSessionScalarFieldEnum | SiteCleaningSessionScalarFieldEnum[]
  }

  /**
   * Agent.cleaningManager
   */
  export type Agent$cleaningManagerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningManager
     */
    select?: CleaningManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningManager
     */
    omit?: CleaningManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningManagerInclude<ExtArgs> | null
    where?: CleaningManagerWhereInput
  }

  /**
   * Agent without action
   */
  export type AgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceSession
   */

  export type AggregateMaintenanceSession = {
    _count: MaintenanceSessionCountAggregateOutputType | null
    _min: MaintenanceSessionMinAggregateOutputType | null
    _max: MaintenanceSessionMaxAggregateOutputType | null
  }

  export type MaintenanceSessionMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    maintenanceId: string | null
    agentId: string | null
    startDate: Date | null
    endDate: Date | null
    notes: string | null
  }

  export type MaintenanceSessionMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    maintenanceId: string | null
    agentId: string | null
    startDate: Date | null
    endDate: Date | null
    notes: string | null
  }

  export type MaintenanceSessionCountAggregateOutputType = {
    id: number
    propertyId: number
    createdAt: number
    updatedAt: number
    maintenanceId: number
    agentId: number
    startDate: number
    endDate: number
    notes: number
    _all: number
  }


  export type MaintenanceSessionMinAggregateInputType = {
    id?: true
    propertyId?: true
    createdAt?: true
    updatedAt?: true
    maintenanceId?: true
    agentId?: true
    startDate?: true
    endDate?: true
    notes?: true
  }

  export type MaintenanceSessionMaxAggregateInputType = {
    id?: true
    propertyId?: true
    createdAt?: true
    updatedAt?: true
    maintenanceId?: true
    agentId?: true
    startDate?: true
    endDate?: true
    notes?: true
  }

  export type MaintenanceSessionCountAggregateInputType = {
    id?: true
    propertyId?: true
    createdAt?: true
    updatedAt?: true
    maintenanceId?: true
    agentId?: true
    startDate?: true
    endDate?: true
    notes?: true
    _all?: true
  }

  export type MaintenanceSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceSession to aggregate.
     */
    where?: MaintenanceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceSessions to fetch.
     */
    orderBy?: MaintenanceSessionOrderByWithRelationInput | MaintenanceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceSessions
    **/
    _count?: true | MaintenanceSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceSessionMaxAggregateInputType
  }

  export type GetMaintenanceSessionAggregateType<T extends MaintenanceSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceSession[P]>
      : GetScalarType<T[P], AggregateMaintenanceSession[P]>
  }




  export type MaintenanceSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceSessionWhereInput
    orderBy?: MaintenanceSessionOrderByWithAggregationInput | MaintenanceSessionOrderByWithAggregationInput[]
    by: MaintenanceSessionScalarFieldEnum[] | MaintenanceSessionScalarFieldEnum
    having?: MaintenanceSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceSessionCountAggregateInputType | true
    _min?: MaintenanceSessionMinAggregateInputType
    _max?: MaintenanceSessionMaxAggregateInputType
  }

  export type MaintenanceSessionGroupByOutputType = {
    id: string
    propertyId: string
    createdAt: Date
    updatedAt: Date
    maintenanceId: string
    agentId: string
    startDate: Date | null
    endDate: Date | null
    notes: string | null
    _count: MaintenanceSessionCountAggregateOutputType | null
    _min: MaintenanceSessionMinAggregateOutputType | null
    _max: MaintenanceSessionMaxAggregateOutputType | null
  }

  type GetMaintenanceSessionGroupByPayload<T extends MaintenanceSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceSessionGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceSessionGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    maintenanceId?: boolean
    agentId?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    maintenance?: boolean | MaintenanceDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    photos?: boolean | MaintenanceSession$photosArgs<ExtArgs>
    _count?: boolean | MaintenanceSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceSession"]>

  export type MaintenanceSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    maintenanceId?: boolean
    agentId?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    maintenance?: boolean | MaintenanceDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceSession"]>

  export type MaintenanceSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    maintenanceId?: boolean
    agentId?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    maintenance?: boolean | MaintenanceDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceSession"]>

  export type MaintenanceSessionSelectScalar = {
    id?: boolean
    propertyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    maintenanceId?: boolean
    agentId?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
  }

  export type MaintenanceSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "createdAt" | "updatedAt" | "maintenanceId" | "agentId" | "startDate" | "endDate" | "notes", ExtArgs["result"]["maintenanceSession"]>
  export type MaintenanceSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    maintenance?: boolean | MaintenanceDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    photos?: boolean | MaintenanceSession$photosArgs<ExtArgs>
    _count?: boolean | MaintenanceSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaintenanceSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    maintenance?: boolean | MaintenanceDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type MaintenanceSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    maintenance?: boolean | MaintenanceDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $MaintenanceSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceSession"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      maintenance: Prisma.$MaintenancePayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs>
      photos: Prisma.$MaintenancePhotoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      createdAt: Date
      updatedAt: Date
      maintenanceId: string
      agentId: string
      startDate: Date | null
      endDate: Date | null
      notes: string | null
    }, ExtArgs["result"]["maintenanceSession"]>
    composites: {}
  }

  type MaintenanceSessionGetPayload<S extends boolean | null | undefined | MaintenanceSessionDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceSessionPayload, S>

  type MaintenanceSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenanceSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenanceSessionCountAggregateInputType | true
    }

  export interface MaintenanceSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceSession'], meta: { name: 'MaintenanceSession' } }
    /**
     * Find zero or one MaintenanceSession that matches the filter.
     * @param {MaintenanceSessionFindUniqueArgs} args - Arguments to find a MaintenanceSession
     * @example
     * // Get one MaintenanceSession
     * const maintenanceSession = await prisma.maintenanceSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceSessionFindUniqueArgs>(args: SelectSubset<T, MaintenanceSessionFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaintenanceSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenanceSessionFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceSession
     * @example
     * // Get one MaintenanceSession
     * const maintenanceSession = await prisma.maintenanceSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSessionFindFirstArgs} args - Arguments to find a MaintenanceSession
     * @example
     * // Get one MaintenanceSession
     * const maintenanceSession = await prisma.maintenanceSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceSessionFindFirstArgs>(args?: SelectSubset<T, MaintenanceSessionFindFirstArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSessionFindFirstOrThrowArgs} args - Arguments to find a MaintenanceSession
     * @example
     * // Get one MaintenanceSession
     * const maintenanceSession = await prisma.maintenanceSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaintenanceSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceSessions
     * const maintenanceSessions = await prisma.maintenanceSession.findMany()
     * 
     * // Get first 10 MaintenanceSessions
     * const maintenanceSessions = await prisma.maintenanceSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceSessionWithIdOnly = await prisma.maintenanceSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceSessionFindManyArgs>(args?: SelectSubset<T, MaintenanceSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaintenanceSession.
     * @param {MaintenanceSessionCreateArgs} args - Arguments to create a MaintenanceSession.
     * @example
     * // Create one MaintenanceSession
     * const MaintenanceSession = await prisma.maintenanceSession.create({
     *   data: {
     *     // ... data to create a MaintenanceSession
     *   }
     * })
     * 
     */
    create<T extends MaintenanceSessionCreateArgs>(args: SelectSubset<T, MaintenanceSessionCreateArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaintenanceSessions.
     * @param {MaintenanceSessionCreateManyArgs} args - Arguments to create many MaintenanceSessions.
     * @example
     * // Create many MaintenanceSessions
     * const maintenanceSession = await prisma.maintenanceSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceSessionCreateManyArgs>(args?: SelectSubset<T, MaintenanceSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceSessions and returns the data saved in the database.
     * @param {MaintenanceSessionCreateManyAndReturnArgs} args - Arguments to create many MaintenanceSessions.
     * @example
     * // Create many MaintenanceSessions
     * const maintenanceSession = await prisma.maintenanceSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceSessions and only return the `id`
     * const maintenanceSessionWithIdOnly = await prisma.maintenanceSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaintenanceSession.
     * @param {MaintenanceSessionDeleteArgs} args - Arguments to delete one MaintenanceSession.
     * @example
     * // Delete one MaintenanceSession
     * const MaintenanceSession = await prisma.maintenanceSession.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceSession
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceSessionDeleteArgs>(args: SelectSubset<T, MaintenanceSessionDeleteArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaintenanceSession.
     * @param {MaintenanceSessionUpdateArgs} args - Arguments to update one MaintenanceSession.
     * @example
     * // Update one MaintenanceSession
     * const maintenanceSession = await prisma.maintenanceSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceSessionUpdateArgs>(args: SelectSubset<T, MaintenanceSessionUpdateArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaintenanceSessions.
     * @param {MaintenanceSessionDeleteManyArgs} args - Arguments to filter MaintenanceSessions to delete.
     * @example
     * // Delete a few MaintenanceSessions
     * const { count } = await prisma.maintenanceSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceSessionDeleteManyArgs>(args?: SelectSubset<T, MaintenanceSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceSessions
     * const maintenanceSession = await prisma.maintenanceSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceSessionUpdateManyArgs>(args: SelectSubset<T, MaintenanceSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceSessions and returns the data updated in the database.
     * @param {MaintenanceSessionUpdateManyAndReturnArgs} args - Arguments to update many MaintenanceSessions.
     * @example
     * // Update many MaintenanceSessions
     * const maintenanceSession = await prisma.maintenanceSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaintenanceSessions and only return the `id`
     * const maintenanceSessionWithIdOnly = await prisma.maintenanceSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintenanceSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintenanceSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaintenanceSession.
     * @param {MaintenanceSessionUpsertArgs} args - Arguments to update or create a MaintenanceSession.
     * @example
     * // Update or create a MaintenanceSession
     * const maintenanceSession = await prisma.maintenanceSession.upsert({
     *   create: {
     *     // ... data to create a MaintenanceSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceSession we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceSessionUpsertArgs>(args: SelectSubset<T, MaintenanceSessionUpsertArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaintenanceSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSessionCountArgs} args - Arguments to filter MaintenanceSessions to count.
     * @example
     * // Count the number of MaintenanceSessions
     * const count = await prisma.maintenanceSession.count({
     *   where: {
     *     // ... the filter for the MaintenanceSessions we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceSessionCountArgs>(
      args?: Subset<T, MaintenanceSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceSessionAggregateArgs>(args: Subset<T, MaintenanceSessionAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceSessionAggregateType<T>>

    /**
     * Group by MaintenanceSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceSessionGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceSession model
   */
  readonly fields: MaintenanceSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    maintenance<T extends MaintenanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceDefaultArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photos<T extends MaintenanceSession$photosArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceSession$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceSession model
   */
  interface MaintenanceSessionFieldRefs {
    readonly id: FieldRef<"MaintenanceSession", 'String'>
    readonly propertyId: FieldRef<"MaintenanceSession", 'String'>
    readonly createdAt: FieldRef<"MaintenanceSession", 'DateTime'>
    readonly updatedAt: FieldRef<"MaintenanceSession", 'DateTime'>
    readonly maintenanceId: FieldRef<"MaintenanceSession", 'String'>
    readonly agentId: FieldRef<"MaintenanceSession", 'String'>
    readonly startDate: FieldRef<"MaintenanceSession", 'DateTime'>
    readonly endDate: FieldRef<"MaintenanceSession", 'DateTime'>
    readonly notes: FieldRef<"MaintenanceSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceSession findUnique
   */
  export type MaintenanceSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceSession to fetch.
     */
    where: MaintenanceSessionWhereUniqueInput
  }

  /**
   * MaintenanceSession findUniqueOrThrow
   */
  export type MaintenanceSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceSession to fetch.
     */
    where: MaintenanceSessionWhereUniqueInput
  }

  /**
   * MaintenanceSession findFirst
   */
  export type MaintenanceSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceSession to fetch.
     */
    where?: MaintenanceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceSessions to fetch.
     */
    orderBy?: MaintenanceSessionOrderByWithRelationInput | MaintenanceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceSessions.
     */
    cursor?: MaintenanceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceSessions.
     */
    distinct?: MaintenanceSessionScalarFieldEnum | MaintenanceSessionScalarFieldEnum[]
  }

  /**
   * MaintenanceSession findFirstOrThrow
   */
  export type MaintenanceSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceSession to fetch.
     */
    where?: MaintenanceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceSessions to fetch.
     */
    orderBy?: MaintenanceSessionOrderByWithRelationInput | MaintenanceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceSessions.
     */
    cursor?: MaintenanceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceSessions.
     */
    distinct?: MaintenanceSessionScalarFieldEnum | MaintenanceSessionScalarFieldEnum[]
  }

  /**
   * MaintenanceSession findMany
   */
  export type MaintenanceSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceSessions to fetch.
     */
    where?: MaintenanceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceSessions to fetch.
     */
    orderBy?: MaintenanceSessionOrderByWithRelationInput | MaintenanceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceSessions.
     */
    cursor?: MaintenanceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceSessions.
     */
    skip?: number
    distinct?: MaintenanceSessionScalarFieldEnum | MaintenanceSessionScalarFieldEnum[]
  }

  /**
   * MaintenanceSession create
   */
  export type MaintenanceSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceSession.
     */
    data: XOR<MaintenanceSessionCreateInput, MaintenanceSessionUncheckedCreateInput>
  }

  /**
   * MaintenanceSession createMany
   */
  export type MaintenanceSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceSessions.
     */
    data: MaintenanceSessionCreateManyInput | MaintenanceSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaintenanceSession createManyAndReturn
   */
  export type MaintenanceSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * The data used to create many MaintenanceSessions.
     */
    data: MaintenanceSessionCreateManyInput | MaintenanceSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceSession update
   */
  export type MaintenanceSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceSession.
     */
    data: XOR<MaintenanceSessionUpdateInput, MaintenanceSessionUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceSession to update.
     */
    where: MaintenanceSessionWhereUniqueInput
  }

  /**
   * MaintenanceSession updateMany
   */
  export type MaintenanceSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceSessions.
     */
    data: XOR<MaintenanceSessionUpdateManyMutationInput, MaintenanceSessionUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceSessions to update
     */
    where?: MaintenanceSessionWhereInput
    /**
     * Limit how many MaintenanceSessions to update.
     */
    limit?: number
  }

  /**
   * MaintenanceSession updateManyAndReturn
   */
  export type MaintenanceSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * The data used to update MaintenanceSessions.
     */
    data: XOR<MaintenanceSessionUpdateManyMutationInput, MaintenanceSessionUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceSessions to update
     */
    where?: MaintenanceSessionWhereInput
    /**
     * Limit how many MaintenanceSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceSession upsert
   */
  export type MaintenanceSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceSession to update in case it exists.
     */
    where: MaintenanceSessionWhereUniqueInput
    /**
     * In case the MaintenanceSession found by the `where` argument doesn't exist, create a new MaintenanceSession with this data.
     */
    create: XOR<MaintenanceSessionCreateInput, MaintenanceSessionUncheckedCreateInput>
    /**
     * In case the MaintenanceSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceSessionUpdateInput, MaintenanceSessionUncheckedUpdateInput>
  }

  /**
   * MaintenanceSession delete
   */
  export type MaintenanceSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * Filter which MaintenanceSession to delete.
     */
    where: MaintenanceSessionWhereUniqueInput
  }

  /**
   * MaintenanceSession deleteMany
   */
  export type MaintenanceSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceSessions to delete
     */
    where?: MaintenanceSessionWhereInput
    /**
     * Limit how many MaintenanceSessions to delete.
     */
    limit?: number
  }

  /**
   * MaintenanceSession.photos
   */
  export type MaintenanceSession$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    where?: MaintenancePhotoWhereInput
    orderBy?: MaintenancePhotoOrderByWithRelationInput | MaintenancePhotoOrderByWithRelationInput[]
    cursor?: MaintenancePhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenancePhotoScalarFieldEnum | MaintenancePhotoScalarFieldEnum[]
  }

  /**
   * MaintenanceSession without action
   */
  export type MaintenanceSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
  }


  /**
   * Model Maintenance
   */

  export type AggregateMaintenance = {
    _count: MaintenanceCountAggregateOutputType | null
    _min: MaintenanceMinAggregateOutputType | null
    _max: MaintenanceMaxAggregateOutputType | null
  }

  export type MaintenanceMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaintenanceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaintenanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maintenance to aggregate.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Maintenances
    **/
    _count?: true | MaintenanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceMaxAggregateInputType
  }

  export type GetMaintenanceAggregateType<T extends MaintenanceAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenance[P]>
      : GetScalarType<T[P], AggregateMaintenance[P]>
  }




  export type MaintenanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceWhereInput
    orderBy?: MaintenanceOrderByWithAggregationInput | MaintenanceOrderByWithAggregationInput[]
    by: MaintenanceScalarFieldEnum[] | MaintenanceScalarFieldEnum
    having?: MaintenanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceCountAggregateInputType | true
    _min?: MaintenanceMinAggregateInputType
    _max?: MaintenanceMaxAggregateInputType
  }

  export type MaintenanceGroupByOutputType = {
    id: string
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: MaintenanceCountAggregateOutputType | null
    _min: MaintenanceMinAggregateOutputType | null
    _max: MaintenanceMaxAggregateOutputType | null
  }

  type GetMaintenanceGroupByPayload<T extends MaintenanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessionMaintenances?: boolean | Maintenance$sessionMaintenancesArgs<ExtArgs>
    _count?: boolean | MaintenanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance"]>

  export type MaintenanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["maintenance"]>

  export type MaintenanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["maintenance"]>

  export type MaintenanceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaintenanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["maintenance"]>
  export type MaintenanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessionMaintenances?: boolean | Maintenance$sessionMaintenancesArgs<ExtArgs>
    _count?: boolean | MaintenanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaintenanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MaintenanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MaintenancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Maintenance"
    objects: {
      sessionMaintenances: Prisma.$MaintenanceSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["maintenance"]>
    composites: {}
  }

  type MaintenanceGetPayload<S extends boolean | null | undefined | MaintenanceDefaultArgs> = $Result.GetResult<Prisma.$MaintenancePayload, S>

  type MaintenanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenanceCountAggregateInputType | true
    }

  export interface MaintenanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Maintenance'], meta: { name: 'Maintenance' } }
    /**
     * Find zero or one Maintenance that matches the filter.
     * @param {MaintenanceFindUniqueArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceFindUniqueArgs>(args: SelectSubset<T, MaintenanceFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Maintenance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenanceFindUniqueOrThrowArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintenance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindFirstArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceFindFirstArgs>(args?: SelectSubset<T, MaintenanceFindFirstArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintenance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindFirstOrThrowArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Maintenances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maintenances
     * const maintenances = await prisma.maintenance.findMany()
     * 
     * // Get first 10 Maintenances
     * const maintenances = await prisma.maintenance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceWithIdOnly = await prisma.maintenance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceFindManyArgs>(args?: SelectSubset<T, MaintenanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Maintenance.
     * @param {MaintenanceCreateArgs} args - Arguments to create a Maintenance.
     * @example
     * // Create one Maintenance
     * const Maintenance = await prisma.maintenance.create({
     *   data: {
     *     // ... data to create a Maintenance
     *   }
     * })
     * 
     */
    create<T extends MaintenanceCreateArgs>(args: SelectSubset<T, MaintenanceCreateArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Maintenances.
     * @param {MaintenanceCreateManyArgs} args - Arguments to create many Maintenances.
     * @example
     * // Create many Maintenances
     * const maintenance = await prisma.maintenance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceCreateManyArgs>(args?: SelectSubset<T, MaintenanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Maintenances and returns the data saved in the database.
     * @param {MaintenanceCreateManyAndReturnArgs} args - Arguments to create many Maintenances.
     * @example
     * // Create many Maintenances
     * const maintenance = await prisma.maintenance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Maintenances and only return the `id`
     * const maintenanceWithIdOnly = await prisma.maintenance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Maintenance.
     * @param {MaintenanceDeleteArgs} args - Arguments to delete one Maintenance.
     * @example
     * // Delete one Maintenance
     * const Maintenance = await prisma.maintenance.delete({
     *   where: {
     *     // ... filter to delete one Maintenance
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceDeleteArgs>(args: SelectSubset<T, MaintenanceDeleteArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Maintenance.
     * @param {MaintenanceUpdateArgs} args - Arguments to update one Maintenance.
     * @example
     * // Update one Maintenance
     * const maintenance = await prisma.maintenance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceUpdateArgs>(args: SelectSubset<T, MaintenanceUpdateArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Maintenances.
     * @param {MaintenanceDeleteManyArgs} args - Arguments to filter Maintenances to delete.
     * @example
     * // Delete a few Maintenances
     * const { count } = await prisma.maintenance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceDeleteManyArgs>(args?: SelectSubset<T, MaintenanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maintenances
     * const maintenance = await prisma.maintenance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceUpdateManyArgs>(args: SelectSubset<T, MaintenanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintenances and returns the data updated in the database.
     * @param {MaintenanceUpdateManyAndReturnArgs} args - Arguments to update many Maintenances.
     * @example
     * // Update many Maintenances
     * const maintenance = await prisma.maintenance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Maintenances and only return the `id`
     * const maintenanceWithIdOnly = await prisma.maintenance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintenanceUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintenanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Maintenance.
     * @param {MaintenanceUpsertArgs} args - Arguments to update or create a Maintenance.
     * @example
     * // Update or create a Maintenance
     * const maintenance = await prisma.maintenance.upsert({
     *   create: {
     *     // ... data to create a Maintenance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Maintenance we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceUpsertArgs>(args: SelectSubset<T, MaintenanceUpsertArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Maintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceCountArgs} args - Arguments to filter Maintenances to count.
     * @example
     * // Count the number of Maintenances
     * const count = await prisma.maintenance.count({
     *   where: {
     *     // ... the filter for the Maintenances we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceCountArgs>(
      args?: Subset<T, MaintenanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Maintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceAggregateArgs>(args: Subset<T, MaintenanceAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceAggregateType<T>>

    /**
     * Group by Maintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Maintenance model
   */
  readonly fields: MaintenanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Maintenance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessionMaintenances<T extends Maintenance$sessionMaintenancesArgs<ExtArgs> = {}>(args?: Subset<T, Maintenance$sessionMaintenancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Maintenance model
   */
  interface MaintenanceFieldRefs {
    readonly id: FieldRef<"Maintenance", 'String'>
    readonly name: FieldRef<"Maintenance", 'String'>
    readonly description: FieldRef<"Maintenance", 'String'>
    readonly createdAt: FieldRef<"Maintenance", 'DateTime'>
    readonly updatedAt: FieldRef<"Maintenance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Maintenance findUnique
   */
  export type MaintenanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance findUniqueOrThrow
   */
  export type MaintenanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance findFirst
   */
  export type MaintenanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maintenances.
     */
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance findFirstOrThrow
   */
  export type MaintenanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maintenances.
     */
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance findMany
   */
  export type MaintenanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenances to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance create
   */
  export type MaintenanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Maintenance.
     */
    data: XOR<MaintenanceCreateInput, MaintenanceUncheckedCreateInput>
  }

  /**
   * Maintenance createMany
   */
  export type MaintenanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Maintenances.
     */
    data: MaintenanceCreateManyInput | MaintenanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Maintenance createManyAndReturn
   */
  export type MaintenanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * The data used to create many Maintenances.
     */
    data: MaintenanceCreateManyInput | MaintenanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Maintenance update
   */
  export type MaintenanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Maintenance.
     */
    data: XOR<MaintenanceUpdateInput, MaintenanceUncheckedUpdateInput>
    /**
     * Choose, which Maintenance to update.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance updateMany
   */
  export type MaintenanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Maintenances.
     */
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which Maintenances to update
     */
    where?: MaintenanceWhereInput
    /**
     * Limit how many Maintenances to update.
     */
    limit?: number
  }

  /**
   * Maintenance updateManyAndReturn
   */
  export type MaintenanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * The data used to update Maintenances.
     */
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which Maintenances to update
     */
    where?: MaintenanceWhereInput
    /**
     * Limit how many Maintenances to update.
     */
    limit?: number
  }

  /**
   * Maintenance upsert
   */
  export type MaintenanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Maintenance to update in case it exists.
     */
    where: MaintenanceWhereUniqueInput
    /**
     * In case the Maintenance found by the `where` argument doesn't exist, create a new Maintenance with this data.
     */
    create: XOR<MaintenanceCreateInput, MaintenanceUncheckedCreateInput>
    /**
     * In case the Maintenance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceUpdateInput, MaintenanceUncheckedUpdateInput>
  }

  /**
   * Maintenance delete
   */
  export type MaintenanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter which Maintenance to delete.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance deleteMany
   */
  export type MaintenanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maintenances to delete
     */
    where?: MaintenanceWhereInput
    /**
     * Limit how many Maintenances to delete.
     */
    limit?: number
  }

  /**
   * Maintenance.sessionMaintenances
   */
  export type Maintenance$sessionMaintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    where?: MaintenanceSessionWhereInput
    orderBy?: MaintenanceSessionOrderByWithRelationInput | MaintenanceSessionOrderByWithRelationInput[]
    cursor?: MaintenanceSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceSessionScalarFieldEnum | MaintenanceSessionScalarFieldEnum[]
  }

  /**
   * Maintenance without action
   */
  export type MaintenanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
  }


  /**
   * Model CleaningSession
   */

  export type AggregateCleaningSession = {
    _count: CleaningSessionCountAggregateOutputType | null
    _avg: CleaningSessionAvgAggregateOutputType | null
    _sum: CleaningSessionSumAggregateOutputType | null
    _min: CleaningSessionMinAggregateOutputType | null
    _max: CleaningSessionMaxAggregateOutputType | null
  }

  export type CleaningSessionAvgAggregateOutputType = {
    duration: number | null
  }

  export type CleaningSessionSumAggregateOutputType = {
    duration: number | null
  }

  export type CleaningSessionMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    cleaningId: string | null
    agentId: string | null
    startDate: Date | null
    endDate: Date | null
    duration: number | null
    notes: string | null
  }

  export type CleaningSessionMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    cleaningId: string | null
    agentId: string | null
    startDate: Date | null
    endDate: Date | null
    duration: number | null
    notes: string | null
  }

  export type CleaningSessionCountAggregateOutputType = {
    id: number
    propertyId: number
    createdAt: number
    updatedAt: number
    cleaningId: number
    agentId: number
    startDate: number
    endDate: number
    duration: number
    notes: number
    _all: number
  }


  export type CleaningSessionAvgAggregateInputType = {
    duration?: true
  }

  export type CleaningSessionSumAggregateInputType = {
    duration?: true
  }

  export type CleaningSessionMinAggregateInputType = {
    id?: true
    propertyId?: true
    createdAt?: true
    updatedAt?: true
    cleaningId?: true
    agentId?: true
    startDate?: true
    endDate?: true
    duration?: true
    notes?: true
  }

  export type CleaningSessionMaxAggregateInputType = {
    id?: true
    propertyId?: true
    createdAt?: true
    updatedAt?: true
    cleaningId?: true
    agentId?: true
    startDate?: true
    endDate?: true
    duration?: true
    notes?: true
  }

  export type CleaningSessionCountAggregateInputType = {
    id?: true
    propertyId?: true
    createdAt?: true
    updatedAt?: true
    cleaningId?: true
    agentId?: true
    startDate?: true
    endDate?: true
    duration?: true
    notes?: true
    _all?: true
  }

  export type CleaningSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningSession to aggregate.
     */
    where?: CleaningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSessions to fetch.
     */
    orderBy?: CleaningSessionOrderByWithRelationInput | CleaningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CleaningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CleaningSessions
    **/
    _count?: true | CleaningSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CleaningSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CleaningSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CleaningSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CleaningSessionMaxAggregateInputType
  }

  export type GetCleaningSessionAggregateType<T extends CleaningSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateCleaningSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCleaningSession[P]>
      : GetScalarType<T[P], AggregateCleaningSession[P]>
  }




  export type CleaningSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningSessionWhereInput
    orderBy?: CleaningSessionOrderByWithAggregationInput | CleaningSessionOrderByWithAggregationInput[]
    by: CleaningSessionScalarFieldEnum[] | CleaningSessionScalarFieldEnum
    having?: CleaningSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CleaningSessionCountAggregateInputType | true
    _avg?: CleaningSessionAvgAggregateInputType
    _sum?: CleaningSessionSumAggregateInputType
    _min?: CleaningSessionMinAggregateInputType
    _max?: CleaningSessionMaxAggregateInputType
  }

  export type CleaningSessionGroupByOutputType = {
    id: string
    propertyId: string
    createdAt: Date
    updatedAt: Date
    cleaningId: string
    agentId: string
    startDate: Date | null
    endDate: Date | null
    duration: number | null
    notes: string | null
    _count: CleaningSessionCountAggregateOutputType | null
    _avg: CleaningSessionAvgAggregateOutputType | null
    _sum: CleaningSessionSumAggregateOutputType | null
    _min: CleaningSessionMinAggregateOutputType | null
    _max: CleaningSessionMaxAggregateOutputType | null
  }

  type GetCleaningSessionGroupByPayload<T extends CleaningSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CleaningSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CleaningSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CleaningSessionGroupByOutputType[P]>
            : GetScalarType<T[P], CleaningSessionGroupByOutputType[P]>
        }
      >
    >


  export type CleaningSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cleaningId?: boolean
    agentId?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    notes?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    cleaning?: boolean | CleaningDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    photos?: boolean | CleaningSession$photosArgs<ExtArgs>
    checklist?: boolean | CleaningSession$checklistArgs<ExtArgs>
    _count?: boolean | CleaningSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningSession"]>

  export type CleaningSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cleaningId?: boolean
    agentId?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    notes?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    cleaning?: boolean | CleaningDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningSession"]>

  export type CleaningSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cleaningId?: boolean
    agentId?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    notes?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    cleaning?: boolean | CleaningDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningSession"]>

  export type CleaningSessionSelectScalar = {
    id?: boolean
    propertyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cleaningId?: boolean
    agentId?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    notes?: boolean
  }

  export type CleaningSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "createdAt" | "updatedAt" | "cleaningId" | "agentId" | "startDate" | "endDate" | "duration" | "notes", ExtArgs["result"]["cleaningSession"]>
  export type CleaningSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    cleaning?: boolean | CleaningDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    photos?: boolean | CleaningSession$photosArgs<ExtArgs>
    checklist?: boolean | CleaningSession$checklistArgs<ExtArgs>
    _count?: boolean | CleaningSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CleaningSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    cleaning?: boolean | CleaningDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type CleaningSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    cleaning?: boolean | CleaningDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $CleaningSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CleaningSession"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      cleaning: Prisma.$CleaningPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs>
      photos: Prisma.$CleaningPhotoPayload<ExtArgs>[]
      checklist: Prisma.$CleaningChecklistPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      createdAt: Date
      updatedAt: Date
      cleaningId: string
      agentId: string
      startDate: Date | null
      endDate: Date | null
      duration: number | null
      notes: string | null
    }, ExtArgs["result"]["cleaningSession"]>
    composites: {}
  }

  type CleaningSessionGetPayload<S extends boolean | null | undefined | CleaningSessionDefaultArgs> = $Result.GetResult<Prisma.$CleaningSessionPayload, S>

  type CleaningSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CleaningSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CleaningSessionCountAggregateInputType | true
    }

  export interface CleaningSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CleaningSession'], meta: { name: 'CleaningSession' } }
    /**
     * Find zero or one CleaningSession that matches the filter.
     * @param {CleaningSessionFindUniqueArgs} args - Arguments to find a CleaningSession
     * @example
     * // Get one CleaningSession
     * const cleaningSession = await prisma.cleaningSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CleaningSessionFindUniqueArgs>(args: SelectSubset<T, CleaningSessionFindUniqueArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CleaningSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CleaningSessionFindUniqueOrThrowArgs} args - Arguments to find a CleaningSession
     * @example
     * // Get one CleaningSession
     * const cleaningSession = await prisma.cleaningSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CleaningSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, CleaningSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSessionFindFirstArgs} args - Arguments to find a CleaningSession
     * @example
     * // Get one CleaningSession
     * const cleaningSession = await prisma.cleaningSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CleaningSessionFindFirstArgs>(args?: SelectSubset<T, CleaningSessionFindFirstArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSessionFindFirstOrThrowArgs} args - Arguments to find a CleaningSession
     * @example
     * // Get one CleaningSession
     * const cleaningSession = await prisma.cleaningSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CleaningSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, CleaningSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CleaningSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CleaningSessions
     * const cleaningSessions = await prisma.cleaningSession.findMany()
     * 
     * // Get first 10 CleaningSessions
     * const cleaningSessions = await prisma.cleaningSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cleaningSessionWithIdOnly = await prisma.cleaningSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CleaningSessionFindManyArgs>(args?: SelectSubset<T, CleaningSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CleaningSession.
     * @param {CleaningSessionCreateArgs} args - Arguments to create a CleaningSession.
     * @example
     * // Create one CleaningSession
     * const CleaningSession = await prisma.cleaningSession.create({
     *   data: {
     *     // ... data to create a CleaningSession
     *   }
     * })
     * 
     */
    create<T extends CleaningSessionCreateArgs>(args: SelectSubset<T, CleaningSessionCreateArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CleaningSessions.
     * @param {CleaningSessionCreateManyArgs} args - Arguments to create many CleaningSessions.
     * @example
     * // Create many CleaningSessions
     * const cleaningSession = await prisma.cleaningSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CleaningSessionCreateManyArgs>(args?: SelectSubset<T, CleaningSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CleaningSessions and returns the data saved in the database.
     * @param {CleaningSessionCreateManyAndReturnArgs} args - Arguments to create many CleaningSessions.
     * @example
     * // Create many CleaningSessions
     * const cleaningSession = await prisma.cleaningSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CleaningSessions and only return the `id`
     * const cleaningSessionWithIdOnly = await prisma.cleaningSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CleaningSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, CleaningSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CleaningSession.
     * @param {CleaningSessionDeleteArgs} args - Arguments to delete one CleaningSession.
     * @example
     * // Delete one CleaningSession
     * const CleaningSession = await prisma.cleaningSession.delete({
     *   where: {
     *     // ... filter to delete one CleaningSession
     *   }
     * })
     * 
     */
    delete<T extends CleaningSessionDeleteArgs>(args: SelectSubset<T, CleaningSessionDeleteArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CleaningSession.
     * @param {CleaningSessionUpdateArgs} args - Arguments to update one CleaningSession.
     * @example
     * // Update one CleaningSession
     * const cleaningSession = await prisma.cleaningSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CleaningSessionUpdateArgs>(args: SelectSubset<T, CleaningSessionUpdateArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CleaningSessions.
     * @param {CleaningSessionDeleteManyArgs} args - Arguments to filter CleaningSessions to delete.
     * @example
     * // Delete a few CleaningSessions
     * const { count } = await prisma.cleaningSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CleaningSessionDeleteManyArgs>(args?: SelectSubset<T, CleaningSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CleaningSessions
     * const cleaningSession = await prisma.cleaningSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CleaningSessionUpdateManyArgs>(args: SelectSubset<T, CleaningSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningSessions and returns the data updated in the database.
     * @param {CleaningSessionUpdateManyAndReturnArgs} args - Arguments to update many CleaningSessions.
     * @example
     * // Update many CleaningSessions
     * const cleaningSession = await prisma.cleaningSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CleaningSessions and only return the `id`
     * const cleaningSessionWithIdOnly = await prisma.cleaningSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CleaningSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, CleaningSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CleaningSession.
     * @param {CleaningSessionUpsertArgs} args - Arguments to update or create a CleaningSession.
     * @example
     * // Update or create a CleaningSession
     * const cleaningSession = await prisma.cleaningSession.upsert({
     *   create: {
     *     // ... data to create a CleaningSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CleaningSession we want to update
     *   }
     * })
     */
    upsert<T extends CleaningSessionUpsertArgs>(args: SelectSubset<T, CleaningSessionUpsertArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CleaningSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSessionCountArgs} args - Arguments to filter CleaningSessions to count.
     * @example
     * // Count the number of CleaningSessions
     * const count = await prisma.cleaningSession.count({
     *   where: {
     *     // ... the filter for the CleaningSessions we want to count
     *   }
     * })
    **/
    count<T extends CleaningSessionCountArgs>(
      args?: Subset<T, CleaningSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CleaningSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CleaningSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CleaningSessionAggregateArgs>(args: Subset<T, CleaningSessionAggregateArgs>): Prisma.PrismaPromise<GetCleaningSessionAggregateType<T>>

    /**
     * Group by CleaningSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CleaningSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CleaningSessionGroupByArgs['orderBy'] }
        : { orderBy?: CleaningSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CleaningSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCleaningSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CleaningSession model
   */
  readonly fields: CleaningSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CleaningSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CleaningSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cleaning<T extends CleaningDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CleaningDefaultArgs<ExtArgs>>): Prisma__CleaningClient<$Result.GetResult<Prisma.$CleaningPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photos<T extends CleaningSession$photosArgs<ExtArgs> = {}>(args?: Subset<T, CleaningSession$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checklist<T extends CleaningSession$checklistArgs<ExtArgs> = {}>(args?: Subset<T, CleaningSession$checklistArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CleaningSession model
   */
  interface CleaningSessionFieldRefs {
    readonly id: FieldRef<"CleaningSession", 'String'>
    readonly propertyId: FieldRef<"CleaningSession", 'String'>
    readonly createdAt: FieldRef<"CleaningSession", 'DateTime'>
    readonly updatedAt: FieldRef<"CleaningSession", 'DateTime'>
    readonly cleaningId: FieldRef<"CleaningSession", 'String'>
    readonly agentId: FieldRef<"CleaningSession", 'String'>
    readonly startDate: FieldRef<"CleaningSession", 'DateTime'>
    readonly endDate: FieldRef<"CleaningSession", 'DateTime'>
    readonly duration: FieldRef<"CleaningSession", 'Int'>
    readonly notes: FieldRef<"CleaningSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CleaningSession findUnique
   */
  export type CleaningSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSession to fetch.
     */
    where: CleaningSessionWhereUniqueInput
  }

  /**
   * CleaningSession findUniqueOrThrow
   */
  export type CleaningSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSession to fetch.
     */
    where: CleaningSessionWhereUniqueInput
  }

  /**
   * CleaningSession findFirst
   */
  export type CleaningSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSession to fetch.
     */
    where?: CleaningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSessions to fetch.
     */
    orderBy?: CleaningSessionOrderByWithRelationInput | CleaningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningSessions.
     */
    cursor?: CleaningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningSessions.
     */
    distinct?: CleaningSessionScalarFieldEnum | CleaningSessionScalarFieldEnum[]
  }

  /**
   * CleaningSession findFirstOrThrow
   */
  export type CleaningSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSession to fetch.
     */
    where?: CleaningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSessions to fetch.
     */
    orderBy?: CleaningSessionOrderByWithRelationInput | CleaningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningSessions.
     */
    cursor?: CleaningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningSessions.
     */
    distinct?: CleaningSessionScalarFieldEnum | CleaningSessionScalarFieldEnum[]
  }

  /**
   * CleaningSession findMany
   */
  export type CleaningSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSessions to fetch.
     */
    where?: CleaningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSessions to fetch.
     */
    orderBy?: CleaningSessionOrderByWithRelationInput | CleaningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CleaningSessions.
     */
    cursor?: CleaningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSessions.
     */
    skip?: number
    distinct?: CleaningSessionScalarFieldEnum | CleaningSessionScalarFieldEnum[]
  }

  /**
   * CleaningSession create
   */
  export type CleaningSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a CleaningSession.
     */
    data: XOR<CleaningSessionCreateInput, CleaningSessionUncheckedCreateInput>
  }

  /**
   * CleaningSession createMany
   */
  export type CleaningSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CleaningSessions.
     */
    data: CleaningSessionCreateManyInput | CleaningSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CleaningSession createManyAndReturn
   */
  export type CleaningSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * The data used to create many CleaningSessions.
     */
    data: CleaningSessionCreateManyInput | CleaningSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningSession update
   */
  export type CleaningSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a CleaningSession.
     */
    data: XOR<CleaningSessionUpdateInput, CleaningSessionUncheckedUpdateInput>
    /**
     * Choose, which CleaningSession to update.
     */
    where: CleaningSessionWhereUniqueInput
  }

  /**
   * CleaningSession updateMany
   */
  export type CleaningSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CleaningSessions.
     */
    data: XOR<CleaningSessionUpdateManyMutationInput, CleaningSessionUncheckedUpdateManyInput>
    /**
     * Filter which CleaningSessions to update
     */
    where?: CleaningSessionWhereInput
    /**
     * Limit how many CleaningSessions to update.
     */
    limit?: number
  }

  /**
   * CleaningSession updateManyAndReturn
   */
  export type CleaningSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * The data used to update CleaningSessions.
     */
    data: XOR<CleaningSessionUpdateManyMutationInput, CleaningSessionUncheckedUpdateManyInput>
    /**
     * Filter which CleaningSessions to update
     */
    where?: CleaningSessionWhereInput
    /**
     * Limit how many CleaningSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningSession upsert
   */
  export type CleaningSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the CleaningSession to update in case it exists.
     */
    where: CleaningSessionWhereUniqueInput
    /**
     * In case the CleaningSession found by the `where` argument doesn't exist, create a new CleaningSession with this data.
     */
    create: XOR<CleaningSessionCreateInput, CleaningSessionUncheckedCreateInput>
    /**
     * In case the CleaningSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CleaningSessionUpdateInput, CleaningSessionUncheckedUpdateInput>
  }

  /**
   * CleaningSession delete
   */
  export type CleaningSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * Filter which CleaningSession to delete.
     */
    where: CleaningSessionWhereUniqueInput
  }

  /**
   * CleaningSession deleteMany
   */
  export type CleaningSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningSessions to delete
     */
    where?: CleaningSessionWhereInput
    /**
     * Limit how many CleaningSessions to delete.
     */
    limit?: number
  }

  /**
   * CleaningSession.photos
   */
  export type CleaningSession$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    where?: CleaningPhotoWhereInput
    orderBy?: CleaningPhotoOrderByWithRelationInput | CleaningPhotoOrderByWithRelationInput[]
    cursor?: CleaningPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningPhotoScalarFieldEnum | CleaningPhotoScalarFieldEnum[]
  }

  /**
   * CleaningSession.checklist
   */
  export type CleaningSession$checklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    where?: CleaningChecklistWhereInput
    orderBy?: CleaningChecklistOrderByWithRelationInput | CleaningChecklistOrderByWithRelationInput[]
    cursor?: CleaningChecklistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningChecklistScalarFieldEnum | CleaningChecklistScalarFieldEnum[]
  }

  /**
   * CleaningSession without action
   */
  export type CleaningSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
  }


  /**
   * Model Cleaning
   */

  export type AggregateCleaning = {
    _count: CleaningCountAggregateOutputType | null
    _min: CleaningMinAggregateOutputType | null
    _max: CleaningMaxAggregateOutputType | null
  }

  export type CleaningMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CleaningMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CleaningAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cleaning to aggregate.
     */
    where?: CleaningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cleanings to fetch.
     */
    orderBy?: CleaningOrderByWithRelationInput | CleaningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CleaningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cleanings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cleanings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cleanings
    **/
    _count?: true | CleaningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CleaningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CleaningMaxAggregateInputType
  }

  export type GetCleaningAggregateType<T extends CleaningAggregateArgs> = {
        [P in keyof T & keyof AggregateCleaning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCleaning[P]>
      : GetScalarType<T[P], AggregateCleaning[P]>
  }




  export type CleaningGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningWhereInput
    orderBy?: CleaningOrderByWithAggregationInput | CleaningOrderByWithAggregationInput[]
    by: CleaningScalarFieldEnum[] | CleaningScalarFieldEnum
    having?: CleaningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CleaningCountAggregateInputType | true
    _min?: CleaningMinAggregateInputType
    _max?: CleaningMaxAggregateInputType
  }

  export type CleaningGroupByOutputType = {
    id: string
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: CleaningCountAggregateOutputType | null
    _min: CleaningMinAggregateOutputType | null
    _max: CleaningMaxAggregateOutputType | null
  }

  type GetCleaningGroupByPayload<T extends CleaningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CleaningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CleaningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CleaningGroupByOutputType[P]>
            : GetScalarType<T[P], CleaningGroupByOutputType[P]>
        }
      >
    >


  export type CleaningSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cleaningSessions?: boolean | Cleaning$cleaningSessionsArgs<ExtArgs>
    _count?: boolean | CleaningCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaning"]>

  export type CleaningSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cleaning"]>

  export type CleaningSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cleaning"]>

  export type CleaningSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CleaningOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["cleaning"]>
  export type CleaningInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningSessions?: boolean | Cleaning$cleaningSessionsArgs<ExtArgs>
    _count?: boolean | CleaningCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CleaningIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CleaningIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CleaningPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cleaning"
    objects: {
      cleaningSessions: Prisma.$CleaningSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cleaning"]>
    composites: {}
  }

  type CleaningGetPayload<S extends boolean | null | undefined | CleaningDefaultArgs> = $Result.GetResult<Prisma.$CleaningPayload, S>

  type CleaningCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CleaningFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CleaningCountAggregateInputType | true
    }

  export interface CleaningDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cleaning'], meta: { name: 'Cleaning' } }
    /**
     * Find zero or one Cleaning that matches the filter.
     * @param {CleaningFindUniqueArgs} args - Arguments to find a Cleaning
     * @example
     * // Get one Cleaning
     * const cleaning = await prisma.cleaning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CleaningFindUniqueArgs>(args: SelectSubset<T, CleaningFindUniqueArgs<ExtArgs>>): Prisma__CleaningClient<$Result.GetResult<Prisma.$CleaningPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cleaning that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CleaningFindUniqueOrThrowArgs} args - Arguments to find a Cleaning
     * @example
     * // Get one Cleaning
     * const cleaning = await prisma.cleaning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CleaningFindUniqueOrThrowArgs>(args: SelectSubset<T, CleaningFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CleaningClient<$Result.GetResult<Prisma.$CleaningPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cleaning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningFindFirstArgs} args - Arguments to find a Cleaning
     * @example
     * // Get one Cleaning
     * const cleaning = await prisma.cleaning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CleaningFindFirstArgs>(args?: SelectSubset<T, CleaningFindFirstArgs<ExtArgs>>): Prisma__CleaningClient<$Result.GetResult<Prisma.$CleaningPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cleaning that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningFindFirstOrThrowArgs} args - Arguments to find a Cleaning
     * @example
     * // Get one Cleaning
     * const cleaning = await prisma.cleaning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CleaningFindFirstOrThrowArgs>(args?: SelectSubset<T, CleaningFindFirstOrThrowArgs<ExtArgs>>): Prisma__CleaningClient<$Result.GetResult<Prisma.$CleaningPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cleanings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cleanings
     * const cleanings = await prisma.cleaning.findMany()
     * 
     * // Get first 10 Cleanings
     * const cleanings = await prisma.cleaning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cleaningWithIdOnly = await prisma.cleaning.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CleaningFindManyArgs>(args?: SelectSubset<T, CleaningFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cleaning.
     * @param {CleaningCreateArgs} args - Arguments to create a Cleaning.
     * @example
     * // Create one Cleaning
     * const Cleaning = await prisma.cleaning.create({
     *   data: {
     *     // ... data to create a Cleaning
     *   }
     * })
     * 
     */
    create<T extends CleaningCreateArgs>(args: SelectSubset<T, CleaningCreateArgs<ExtArgs>>): Prisma__CleaningClient<$Result.GetResult<Prisma.$CleaningPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cleanings.
     * @param {CleaningCreateManyArgs} args - Arguments to create many Cleanings.
     * @example
     * // Create many Cleanings
     * const cleaning = await prisma.cleaning.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CleaningCreateManyArgs>(args?: SelectSubset<T, CleaningCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cleanings and returns the data saved in the database.
     * @param {CleaningCreateManyAndReturnArgs} args - Arguments to create many Cleanings.
     * @example
     * // Create many Cleanings
     * const cleaning = await prisma.cleaning.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cleanings and only return the `id`
     * const cleaningWithIdOnly = await prisma.cleaning.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CleaningCreateManyAndReturnArgs>(args?: SelectSubset<T, CleaningCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cleaning.
     * @param {CleaningDeleteArgs} args - Arguments to delete one Cleaning.
     * @example
     * // Delete one Cleaning
     * const Cleaning = await prisma.cleaning.delete({
     *   where: {
     *     // ... filter to delete one Cleaning
     *   }
     * })
     * 
     */
    delete<T extends CleaningDeleteArgs>(args: SelectSubset<T, CleaningDeleteArgs<ExtArgs>>): Prisma__CleaningClient<$Result.GetResult<Prisma.$CleaningPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cleaning.
     * @param {CleaningUpdateArgs} args - Arguments to update one Cleaning.
     * @example
     * // Update one Cleaning
     * const cleaning = await prisma.cleaning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CleaningUpdateArgs>(args: SelectSubset<T, CleaningUpdateArgs<ExtArgs>>): Prisma__CleaningClient<$Result.GetResult<Prisma.$CleaningPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cleanings.
     * @param {CleaningDeleteManyArgs} args - Arguments to filter Cleanings to delete.
     * @example
     * // Delete a few Cleanings
     * const { count } = await prisma.cleaning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CleaningDeleteManyArgs>(args?: SelectSubset<T, CleaningDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cleanings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cleanings
     * const cleaning = await prisma.cleaning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CleaningUpdateManyArgs>(args: SelectSubset<T, CleaningUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cleanings and returns the data updated in the database.
     * @param {CleaningUpdateManyAndReturnArgs} args - Arguments to update many Cleanings.
     * @example
     * // Update many Cleanings
     * const cleaning = await prisma.cleaning.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cleanings and only return the `id`
     * const cleaningWithIdOnly = await prisma.cleaning.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CleaningUpdateManyAndReturnArgs>(args: SelectSubset<T, CleaningUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cleaning.
     * @param {CleaningUpsertArgs} args - Arguments to update or create a Cleaning.
     * @example
     * // Update or create a Cleaning
     * const cleaning = await prisma.cleaning.upsert({
     *   create: {
     *     // ... data to create a Cleaning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cleaning we want to update
     *   }
     * })
     */
    upsert<T extends CleaningUpsertArgs>(args: SelectSubset<T, CleaningUpsertArgs<ExtArgs>>): Prisma__CleaningClient<$Result.GetResult<Prisma.$CleaningPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cleanings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningCountArgs} args - Arguments to filter Cleanings to count.
     * @example
     * // Count the number of Cleanings
     * const count = await prisma.cleaning.count({
     *   where: {
     *     // ... the filter for the Cleanings we want to count
     *   }
     * })
    **/
    count<T extends CleaningCountArgs>(
      args?: Subset<T, CleaningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CleaningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cleaning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CleaningAggregateArgs>(args: Subset<T, CleaningAggregateArgs>): Prisma.PrismaPromise<GetCleaningAggregateType<T>>

    /**
     * Group by Cleaning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CleaningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CleaningGroupByArgs['orderBy'] }
        : { orderBy?: CleaningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CleaningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCleaningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cleaning model
   */
  readonly fields: CleaningFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cleaning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CleaningClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cleaningSessions<T extends Cleaning$cleaningSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Cleaning$cleaningSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cleaning model
   */
  interface CleaningFieldRefs {
    readonly id: FieldRef<"Cleaning", 'String'>
    readonly name: FieldRef<"Cleaning", 'String'>
    readonly description: FieldRef<"Cleaning", 'String'>
    readonly createdAt: FieldRef<"Cleaning", 'DateTime'>
    readonly updatedAt: FieldRef<"Cleaning", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cleaning findUnique
   */
  export type CleaningFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cleaning
     */
    select?: CleaningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cleaning
     */
    omit?: CleaningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningInclude<ExtArgs> | null
    /**
     * Filter, which Cleaning to fetch.
     */
    where: CleaningWhereUniqueInput
  }

  /**
   * Cleaning findUniqueOrThrow
   */
  export type CleaningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cleaning
     */
    select?: CleaningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cleaning
     */
    omit?: CleaningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningInclude<ExtArgs> | null
    /**
     * Filter, which Cleaning to fetch.
     */
    where: CleaningWhereUniqueInput
  }

  /**
   * Cleaning findFirst
   */
  export type CleaningFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cleaning
     */
    select?: CleaningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cleaning
     */
    omit?: CleaningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningInclude<ExtArgs> | null
    /**
     * Filter, which Cleaning to fetch.
     */
    where?: CleaningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cleanings to fetch.
     */
    orderBy?: CleaningOrderByWithRelationInput | CleaningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cleanings.
     */
    cursor?: CleaningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cleanings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cleanings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cleanings.
     */
    distinct?: CleaningScalarFieldEnum | CleaningScalarFieldEnum[]
  }

  /**
   * Cleaning findFirstOrThrow
   */
  export type CleaningFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cleaning
     */
    select?: CleaningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cleaning
     */
    omit?: CleaningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningInclude<ExtArgs> | null
    /**
     * Filter, which Cleaning to fetch.
     */
    where?: CleaningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cleanings to fetch.
     */
    orderBy?: CleaningOrderByWithRelationInput | CleaningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cleanings.
     */
    cursor?: CleaningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cleanings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cleanings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cleanings.
     */
    distinct?: CleaningScalarFieldEnum | CleaningScalarFieldEnum[]
  }

  /**
   * Cleaning findMany
   */
  export type CleaningFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cleaning
     */
    select?: CleaningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cleaning
     */
    omit?: CleaningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningInclude<ExtArgs> | null
    /**
     * Filter, which Cleanings to fetch.
     */
    where?: CleaningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cleanings to fetch.
     */
    orderBy?: CleaningOrderByWithRelationInput | CleaningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cleanings.
     */
    cursor?: CleaningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cleanings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cleanings.
     */
    skip?: number
    distinct?: CleaningScalarFieldEnum | CleaningScalarFieldEnum[]
  }

  /**
   * Cleaning create
   */
  export type CleaningCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cleaning
     */
    select?: CleaningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cleaning
     */
    omit?: CleaningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningInclude<ExtArgs> | null
    /**
     * The data needed to create a Cleaning.
     */
    data: XOR<CleaningCreateInput, CleaningUncheckedCreateInput>
  }

  /**
   * Cleaning createMany
   */
  export type CleaningCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cleanings.
     */
    data: CleaningCreateManyInput | CleaningCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cleaning createManyAndReturn
   */
  export type CleaningCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cleaning
     */
    select?: CleaningSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cleaning
     */
    omit?: CleaningOmit<ExtArgs> | null
    /**
     * The data used to create many Cleanings.
     */
    data: CleaningCreateManyInput | CleaningCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cleaning update
   */
  export type CleaningUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cleaning
     */
    select?: CleaningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cleaning
     */
    omit?: CleaningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningInclude<ExtArgs> | null
    /**
     * The data needed to update a Cleaning.
     */
    data: XOR<CleaningUpdateInput, CleaningUncheckedUpdateInput>
    /**
     * Choose, which Cleaning to update.
     */
    where: CleaningWhereUniqueInput
  }

  /**
   * Cleaning updateMany
   */
  export type CleaningUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cleanings.
     */
    data: XOR<CleaningUpdateManyMutationInput, CleaningUncheckedUpdateManyInput>
    /**
     * Filter which Cleanings to update
     */
    where?: CleaningWhereInput
    /**
     * Limit how many Cleanings to update.
     */
    limit?: number
  }

  /**
   * Cleaning updateManyAndReturn
   */
  export type CleaningUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cleaning
     */
    select?: CleaningSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cleaning
     */
    omit?: CleaningOmit<ExtArgs> | null
    /**
     * The data used to update Cleanings.
     */
    data: XOR<CleaningUpdateManyMutationInput, CleaningUncheckedUpdateManyInput>
    /**
     * Filter which Cleanings to update
     */
    where?: CleaningWhereInput
    /**
     * Limit how many Cleanings to update.
     */
    limit?: number
  }

  /**
   * Cleaning upsert
   */
  export type CleaningUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cleaning
     */
    select?: CleaningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cleaning
     */
    omit?: CleaningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningInclude<ExtArgs> | null
    /**
     * The filter to search for the Cleaning to update in case it exists.
     */
    where: CleaningWhereUniqueInput
    /**
     * In case the Cleaning found by the `where` argument doesn't exist, create a new Cleaning with this data.
     */
    create: XOR<CleaningCreateInput, CleaningUncheckedCreateInput>
    /**
     * In case the Cleaning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CleaningUpdateInput, CleaningUncheckedUpdateInput>
  }

  /**
   * Cleaning delete
   */
  export type CleaningDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cleaning
     */
    select?: CleaningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cleaning
     */
    omit?: CleaningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningInclude<ExtArgs> | null
    /**
     * Filter which Cleaning to delete.
     */
    where: CleaningWhereUniqueInput
  }

  /**
   * Cleaning deleteMany
   */
  export type CleaningDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cleanings to delete
     */
    where?: CleaningWhereInput
    /**
     * Limit how many Cleanings to delete.
     */
    limit?: number
  }

  /**
   * Cleaning.cleaningSessions
   */
  export type Cleaning$cleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    where?: CleaningSessionWhereInput
    orderBy?: CleaningSessionOrderByWithRelationInput | CleaningSessionOrderByWithRelationInput[]
    cursor?: CleaningSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningSessionScalarFieldEnum | CleaningSessionScalarFieldEnum[]
  }

  /**
   * Cleaning without action
   */
  export type CleaningDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cleaning
     */
    select?: CleaningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cleaning
     */
    omit?: CleaningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningInclude<ExtArgs> | null
  }


  /**
   * Model CleaningManager
   */

  export type AggregateCleaningManager = {
    _count: CleaningManagerCountAggregateOutputType | null
    _min: CleaningManagerMinAggregateOutputType | null
    _max: CleaningManagerMaxAggregateOutputType | null
  }

  export type CleaningManagerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningManagerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningManagerCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CleaningManagerMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningManagerMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningManagerCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CleaningManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningManager to aggregate.
     */
    where?: CleaningManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningManagers to fetch.
     */
    orderBy?: CleaningManagerOrderByWithRelationInput | CleaningManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CleaningManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CleaningManagers
    **/
    _count?: true | CleaningManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CleaningManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CleaningManagerMaxAggregateInputType
  }

  export type GetCleaningManagerAggregateType<T extends CleaningManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateCleaningManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCleaningManager[P]>
      : GetScalarType<T[P], AggregateCleaningManager[P]>
  }




  export type CleaningManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningManagerWhereInput
    orderBy?: CleaningManagerOrderByWithAggregationInput | CleaningManagerOrderByWithAggregationInput[]
    by: CleaningManagerScalarFieldEnum[] | CleaningManagerScalarFieldEnum
    having?: CleaningManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CleaningManagerCountAggregateInputType | true
    _min?: CleaningManagerMinAggregateInputType
    _max?: CleaningManagerMaxAggregateInputType
  }

  export type CleaningManagerGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: CleaningManagerCountAggregateOutputType | null
    _min: CleaningManagerMinAggregateOutputType | null
    _max: CleaningManagerMaxAggregateOutputType | null
  }

  type GetCleaningManagerGroupByPayload<T extends CleaningManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CleaningManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CleaningManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CleaningManagerGroupByOutputType[P]>
            : GetScalarType<T[P], CleaningManagerGroupByOutputType[P]>
        }
      >
    >


  export type CleaningManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    interventionSites?: boolean | CleaningManager$interventionSitesArgs<ExtArgs>
    siteCleaningSessions?: boolean | CleaningManager$siteCleaningSessionsArgs<ExtArgs>
    cleaningAgents?: boolean | CleaningManager$cleaningAgentsArgs<ExtArgs>
    cleaningPlannings?: boolean | CleaningManager$cleaningPlanningsArgs<ExtArgs>
    _count?: boolean | CleaningManagerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningManager"]>

  export type CleaningManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningManager"]>

  export type CleaningManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningManager"]>

  export type CleaningManagerSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CleaningManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["cleaningManager"]>
  export type CleaningManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    interventionSites?: boolean | CleaningManager$interventionSitesArgs<ExtArgs>
    siteCleaningSessions?: boolean | CleaningManager$siteCleaningSessionsArgs<ExtArgs>
    cleaningAgents?: boolean | CleaningManager$cleaningAgentsArgs<ExtArgs>
    cleaningPlannings?: boolean | CleaningManager$cleaningPlanningsArgs<ExtArgs>
    _count?: boolean | CleaningManagerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CleaningManagerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CleaningManagerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CleaningManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CleaningManager"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      interventionSites: Prisma.$InterventionSitePayload<ExtArgs>[]
      siteCleaningSessions: Prisma.$SiteCleaningSessionPayload<ExtArgs>[]
      cleaningAgents: Prisma.$AgentPayload<ExtArgs>[]
      cleaningPlannings: Prisma.$CleaningPlanningPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cleaningManager"]>
    composites: {}
  }

  type CleaningManagerGetPayload<S extends boolean | null | undefined | CleaningManagerDefaultArgs> = $Result.GetResult<Prisma.$CleaningManagerPayload, S>

  type CleaningManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CleaningManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CleaningManagerCountAggregateInputType | true
    }

  export interface CleaningManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CleaningManager'], meta: { name: 'CleaningManager' } }
    /**
     * Find zero or one CleaningManager that matches the filter.
     * @param {CleaningManagerFindUniqueArgs} args - Arguments to find a CleaningManager
     * @example
     * // Get one CleaningManager
     * const cleaningManager = await prisma.cleaningManager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CleaningManagerFindUniqueArgs>(args: SelectSubset<T, CleaningManagerFindUniqueArgs<ExtArgs>>): Prisma__CleaningManagerClient<$Result.GetResult<Prisma.$CleaningManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CleaningManager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CleaningManagerFindUniqueOrThrowArgs} args - Arguments to find a CleaningManager
     * @example
     * // Get one CleaningManager
     * const cleaningManager = await prisma.cleaningManager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CleaningManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, CleaningManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CleaningManagerClient<$Result.GetResult<Prisma.$CleaningManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningManager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningManagerFindFirstArgs} args - Arguments to find a CleaningManager
     * @example
     * // Get one CleaningManager
     * const cleaningManager = await prisma.cleaningManager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CleaningManagerFindFirstArgs>(args?: SelectSubset<T, CleaningManagerFindFirstArgs<ExtArgs>>): Prisma__CleaningManagerClient<$Result.GetResult<Prisma.$CleaningManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningManager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningManagerFindFirstOrThrowArgs} args - Arguments to find a CleaningManager
     * @example
     * // Get one CleaningManager
     * const cleaningManager = await prisma.cleaningManager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CleaningManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, CleaningManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CleaningManagerClient<$Result.GetResult<Prisma.$CleaningManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CleaningManagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CleaningManagers
     * const cleaningManagers = await prisma.cleaningManager.findMany()
     * 
     * // Get first 10 CleaningManagers
     * const cleaningManagers = await prisma.cleaningManager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cleaningManagerWithIdOnly = await prisma.cleaningManager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CleaningManagerFindManyArgs>(args?: SelectSubset<T, CleaningManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CleaningManager.
     * @param {CleaningManagerCreateArgs} args - Arguments to create a CleaningManager.
     * @example
     * // Create one CleaningManager
     * const CleaningManager = await prisma.cleaningManager.create({
     *   data: {
     *     // ... data to create a CleaningManager
     *   }
     * })
     * 
     */
    create<T extends CleaningManagerCreateArgs>(args: SelectSubset<T, CleaningManagerCreateArgs<ExtArgs>>): Prisma__CleaningManagerClient<$Result.GetResult<Prisma.$CleaningManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CleaningManagers.
     * @param {CleaningManagerCreateManyArgs} args - Arguments to create many CleaningManagers.
     * @example
     * // Create many CleaningManagers
     * const cleaningManager = await prisma.cleaningManager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CleaningManagerCreateManyArgs>(args?: SelectSubset<T, CleaningManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CleaningManagers and returns the data saved in the database.
     * @param {CleaningManagerCreateManyAndReturnArgs} args - Arguments to create many CleaningManagers.
     * @example
     * // Create many CleaningManagers
     * const cleaningManager = await prisma.cleaningManager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CleaningManagers and only return the `id`
     * const cleaningManagerWithIdOnly = await prisma.cleaningManager.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CleaningManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, CleaningManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CleaningManager.
     * @param {CleaningManagerDeleteArgs} args - Arguments to delete one CleaningManager.
     * @example
     * // Delete one CleaningManager
     * const CleaningManager = await prisma.cleaningManager.delete({
     *   where: {
     *     // ... filter to delete one CleaningManager
     *   }
     * })
     * 
     */
    delete<T extends CleaningManagerDeleteArgs>(args: SelectSubset<T, CleaningManagerDeleteArgs<ExtArgs>>): Prisma__CleaningManagerClient<$Result.GetResult<Prisma.$CleaningManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CleaningManager.
     * @param {CleaningManagerUpdateArgs} args - Arguments to update one CleaningManager.
     * @example
     * // Update one CleaningManager
     * const cleaningManager = await prisma.cleaningManager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CleaningManagerUpdateArgs>(args: SelectSubset<T, CleaningManagerUpdateArgs<ExtArgs>>): Prisma__CleaningManagerClient<$Result.GetResult<Prisma.$CleaningManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CleaningManagers.
     * @param {CleaningManagerDeleteManyArgs} args - Arguments to filter CleaningManagers to delete.
     * @example
     * // Delete a few CleaningManagers
     * const { count } = await prisma.cleaningManager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CleaningManagerDeleteManyArgs>(args?: SelectSubset<T, CleaningManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CleaningManagers
     * const cleaningManager = await prisma.cleaningManager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CleaningManagerUpdateManyArgs>(args: SelectSubset<T, CleaningManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningManagers and returns the data updated in the database.
     * @param {CleaningManagerUpdateManyAndReturnArgs} args - Arguments to update many CleaningManagers.
     * @example
     * // Update many CleaningManagers
     * const cleaningManager = await prisma.cleaningManager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CleaningManagers and only return the `id`
     * const cleaningManagerWithIdOnly = await prisma.cleaningManager.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CleaningManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, CleaningManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CleaningManager.
     * @param {CleaningManagerUpsertArgs} args - Arguments to update or create a CleaningManager.
     * @example
     * // Update or create a CleaningManager
     * const cleaningManager = await prisma.cleaningManager.upsert({
     *   create: {
     *     // ... data to create a CleaningManager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CleaningManager we want to update
     *   }
     * })
     */
    upsert<T extends CleaningManagerUpsertArgs>(args: SelectSubset<T, CleaningManagerUpsertArgs<ExtArgs>>): Prisma__CleaningManagerClient<$Result.GetResult<Prisma.$CleaningManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CleaningManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningManagerCountArgs} args - Arguments to filter CleaningManagers to count.
     * @example
     * // Count the number of CleaningManagers
     * const count = await prisma.cleaningManager.count({
     *   where: {
     *     // ... the filter for the CleaningManagers we want to count
     *   }
     * })
    **/
    count<T extends CleaningManagerCountArgs>(
      args?: Subset<T, CleaningManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CleaningManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CleaningManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CleaningManagerAggregateArgs>(args: Subset<T, CleaningManagerAggregateArgs>): Prisma.PrismaPromise<GetCleaningManagerAggregateType<T>>

    /**
     * Group by CleaningManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CleaningManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CleaningManagerGroupByArgs['orderBy'] }
        : { orderBy?: CleaningManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CleaningManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCleaningManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CleaningManager model
   */
  readonly fields: CleaningManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CleaningManager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CleaningManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    interventionSites<T extends CleaningManager$interventionSitesArgs<ExtArgs> = {}>(args?: Subset<T, CleaningManager$interventionSitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionSitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    siteCleaningSessions<T extends CleaningManager$siteCleaningSessionsArgs<ExtArgs> = {}>(args?: Subset<T, CleaningManager$siteCleaningSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteCleaningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cleaningAgents<T extends CleaningManager$cleaningAgentsArgs<ExtArgs> = {}>(args?: Subset<T, CleaningManager$cleaningAgentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cleaningPlannings<T extends CleaningManager$cleaningPlanningsArgs<ExtArgs> = {}>(args?: Subset<T, CleaningManager$cleaningPlanningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningPlanningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CleaningManager model
   */
  interface CleaningManagerFieldRefs {
    readonly id: FieldRef<"CleaningManager", 'String'>
    readonly userId: FieldRef<"CleaningManager", 'String'>
    readonly createdAt: FieldRef<"CleaningManager", 'DateTime'>
    readonly updatedAt: FieldRef<"CleaningManager", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CleaningManager findUnique
   */
  export type CleaningManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningManager
     */
    select?: CleaningManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningManager
     */
    omit?: CleaningManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningManagerInclude<ExtArgs> | null
    /**
     * Filter, which CleaningManager to fetch.
     */
    where: CleaningManagerWhereUniqueInput
  }

  /**
   * CleaningManager findUniqueOrThrow
   */
  export type CleaningManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningManager
     */
    select?: CleaningManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningManager
     */
    omit?: CleaningManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningManagerInclude<ExtArgs> | null
    /**
     * Filter, which CleaningManager to fetch.
     */
    where: CleaningManagerWhereUniqueInput
  }

  /**
   * CleaningManager findFirst
   */
  export type CleaningManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningManager
     */
    select?: CleaningManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningManager
     */
    omit?: CleaningManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningManagerInclude<ExtArgs> | null
    /**
     * Filter, which CleaningManager to fetch.
     */
    where?: CleaningManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningManagers to fetch.
     */
    orderBy?: CleaningManagerOrderByWithRelationInput | CleaningManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningManagers.
     */
    cursor?: CleaningManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningManagers.
     */
    distinct?: CleaningManagerScalarFieldEnum | CleaningManagerScalarFieldEnum[]
  }

  /**
   * CleaningManager findFirstOrThrow
   */
  export type CleaningManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningManager
     */
    select?: CleaningManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningManager
     */
    omit?: CleaningManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningManagerInclude<ExtArgs> | null
    /**
     * Filter, which CleaningManager to fetch.
     */
    where?: CleaningManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningManagers to fetch.
     */
    orderBy?: CleaningManagerOrderByWithRelationInput | CleaningManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningManagers.
     */
    cursor?: CleaningManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningManagers.
     */
    distinct?: CleaningManagerScalarFieldEnum | CleaningManagerScalarFieldEnum[]
  }

  /**
   * CleaningManager findMany
   */
  export type CleaningManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningManager
     */
    select?: CleaningManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningManager
     */
    omit?: CleaningManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningManagerInclude<ExtArgs> | null
    /**
     * Filter, which CleaningManagers to fetch.
     */
    where?: CleaningManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningManagers to fetch.
     */
    orderBy?: CleaningManagerOrderByWithRelationInput | CleaningManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CleaningManagers.
     */
    cursor?: CleaningManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningManagers.
     */
    skip?: number
    distinct?: CleaningManagerScalarFieldEnum | CleaningManagerScalarFieldEnum[]
  }

  /**
   * CleaningManager create
   */
  export type CleaningManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningManager
     */
    select?: CleaningManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningManager
     */
    omit?: CleaningManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a CleaningManager.
     */
    data: XOR<CleaningManagerCreateInput, CleaningManagerUncheckedCreateInput>
  }

  /**
   * CleaningManager createMany
   */
  export type CleaningManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CleaningManagers.
     */
    data: CleaningManagerCreateManyInput | CleaningManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CleaningManager createManyAndReturn
   */
  export type CleaningManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningManager
     */
    select?: CleaningManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningManager
     */
    omit?: CleaningManagerOmit<ExtArgs> | null
    /**
     * The data used to create many CleaningManagers.
     */
    data: CleaningManagerCreateManyInput | CleaningManagerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningManagerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningManager update
   */
  export type CleaningManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningManager
     */
    select?: CleaningManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningManager
     */
    omit?: CleaningManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a CleaningManager.
     */
    data: XOR<CleaningManagerUpdateInput, CleaningManagerUncheckedUpdateInput>
    /**
     * Choose, which CleaningManager to update.
     */
    where: CleaningManagerWhereUniqueInput
  }

  /**
   * CleaningManager updateMany
   */
  export type CleaningManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CleaningManagers.
     */
    data: XOR<CleaningManagerUpdateManyMutationInput, CleaningManagerUncheckedUpdateManyInput>
    /**
     * Filter which CleaningManagers to update
     */
    where?: CleaningManagerWhereInput
    /**
     * Limit how many CleaningManagers to update.
     */
    limit?: number
  }

  /**
   * CleaningManager updateManyAndReturn
   */
  export type CleaningManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningManager
     */
    select?: CleaningManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningManager
     */
    omit?: CleaningManagerOmit<ExtArgs> | null
    /**
     * The data used to update CleaningManagers.
     */
    data: XOR<CleaningManagerUpdateManyMutationInput, CleaningManagerUncheckedUpdateManyInput>
    /**
     * Filter which CleaningManagers to update
     */
    where?: CleaningManagerWhereInput
    /**
     * Limit how many CleaningManagers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningManagerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningManager upsert
   */
  export type CleaningManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningManager
     */
    select?: CleaningManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningManager
     */
    omit?: CleaningManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the CleaningManager to update in case it exists.
     */
    where: CleaningManagerWhereUniqueInput
    /**
     * In case the CleaningManager found by the `where` argument doesn't exist, create a new CleaningManager with this data.
     */
    create: XOR<CleaningManagerCreateInput, CleaningManagerUncheckedCreateInput>
    /**
     * In case the CleaningManager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CleaningManagerUpdateInput, CleaningManagerUncheckedUpdateInput>
  }

  /**
   * CleaningManager delete
   */
  export type CleaningManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningManager
     */
    select?: CleaningManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningManager
     */
    omit?: CleaningManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningManagerInclude<ExtArgs> | null
    /**
     * Filter which CleaningManager to delete.
     */
    where: CleaningManagerWhereUniqueInput
  }

  /**
   * CleaningManager deleteMany
   */
  export type CleaningManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningManagers to delete
     */
    where?: CleaningManagerWhereInput
    /**
     * Limit how many CleaningManagers to delete.
     */
    limit?: number
  }

  /**
   * CleaningManager.interventionSites
   */
  export type CleaningManager$interventionSitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionSite
     */
    select?: InterventionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionSite
     */
    omit?: InterventionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionSiteInclude<ExtArgs> | null
    where?: InterventionSiteWhereInput
    orderBy?: InterventionSiteOrderByWithRelationInput | InterventionSiteOrderByWithRelationInput[]
    cursor?: InterventionSiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterventionSiteScalarFieldEnum | InterventionSiteScalarFieldEnum[]
  }

  /**
   * CleaningManager.siteCleaningSessions
   */
  export type CleaningManager$siteCleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningSession
     */
    select?: SiteCleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningSession
     */
    omit?: SiteCleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningSessionInclude<ExtArgs> | null
    where?: SiteCleaningSessionWhereInput
    orderBy?: SiteCleaningSessionOrderByWithRelationInput | SiteCleaningSessionOrderByWithRelationInput[]
    cursor?: SiteCleaningSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteCleaningSessionScalarFieldEnum | SiteCleaningSessionScalarFieldEnum[]
  }

  /**
   * CleaningManager.cleaningAgents
   */
  export type CleaningManager$cleaningAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    cursor?: AgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * CleaningManager.cleaningPlannings
   */
  export type CleaningManager$cleaningPlanningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPlanning
     */
    select?: CleaningPlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPlanning
     */
    omit?: CleaningPlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPlanningInclude<ExtArgs> | null
    where?: CleaningPlanningWhereInput
    orderBy?: CleaningPlanningOrderByWithRelationInput | CleaningPlanningOrderByWithRelationInput[]
    cursor?: CleaningPlanningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningPlanningScalarFieldEnum | CleaningPlanningScalarFieldEnum[]
  }

  /**
   * CleaningManager without action
   */
  export type CleaningManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningManager
     */
    select?: CleaningManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningManager
     */
    omit?: CleaningManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningManagerInclude<ExtArgs> | null
  }


  /**
   * Model InterventionSite
   */

  export type AggregateInterventionSite = {
    _count: InterventionSiteCountAggregateOutputType | null
    _avg: InterventionSiteAvgAggregateOutputType | null
    _sum: InterventionSiteSumAggregateOutputType | null
    _min: InterventionSiteMinAggregateOutputType | null
    _max: InterventionSiteMaxAggregateOutputType | null
  }

  export type InterventionSiteAvgAggregateOutputType = {
    surface: number | null
  }

  export type InterventionSiteSumAggregateOutputType = {
    surface: number | null
  }

  export type InterventionSiteMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    client: string | null
    site: string | null
    surface: number | null
    type: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
    cleaningManagerId: string | null
  }

  export type InterventionSiteMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    client: string | null
    site: string | null
    surface: number | null
    type: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
    cleaningManagerId: string | null
  }

  export type InterventionSiteCountAggregateOutputType = {
    id: number
    name: number
    description: number
    client: number
    site: number
    surface: number
    type: number
    address: number
    createdAt: number
    updatedAt: number
    cleaningManagerId: number
    _all: number
  }


  export type InterventionSiteAvgAggregateInputType = {
    surface?: true
  }

  export type InterventionSiteSumAggregateInputType = {
    surface?: true
  }

  export type InterventionSiteMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    client?: true
    site?: true
    surface?: true
    type?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    cleaningManagerId?: true
  }

  export type InterventionSiteMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    client?: true
    site?: true
    surface?: true
    type?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    cleaningManagerId?: true
  }

  export type InterventionSiteCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    client?: true
    site?: true
    surface?: true
    type?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    cleaningManagerId?: true
    _all?: true
  }

  export type InterventionSiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterventionSite to aggregate.
     */
    where?: InterventionSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterventionSites to fetch.
     */
    orderBy?: InterventionSiteOrderByWithRelationInput | InterventionSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterventionSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterventionSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterventionSites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterventionSites
    **/
    _count?: true | InterventionSiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterventionSiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterventionSiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterventionSiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterventionSiteMaxAggregateInputType
  }

  export type GetInterventionSiteAggregateType<T extends InterventionSiteAggregateArgs> = {
        [P in keyof T & keyof AggregateInterventionSite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterventionSite[P]>
      : GetScalarType<T[P], AggregateInterventionSite[P]>
  }




  export type InterventionSiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionSiteWhereInput
    orderBy?: InterventionSiteOrderByWithAggregationInput | InterventionSiteOrderByWithAggregationInput[]
    by: InterventionSiteScalarFieldEnum[] | InterventionSiteScalarFieldEnum
    having?: InterventionSiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterventionSiteCountAggregateInputType | true
    _avg?: InterventionSiteAvgAggregateInputType
    _sum?: InterventionSiteSumAggregateInputType
    _min?: InterventionSiteMinAggregateInputType
    _max?: InterventionSiteMaxAggregateInputType
  }

  export type InterventionSiteGroupByOutputType = {
    id: string
    name: string
    description: string
    client: string | null
    site: string | null
    surface: number | null
    type: string | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    cleaningManagerId: string
    _count: InterventionSiteCountAggregateOutputType | null
    _avg: InterventionSiteAvgAggregateOutputType | null
    _sum: InterventionSiteSumAggregateOutputType | null
    _min: InterventionSiteMinAggregateOutputType | null
    _max: InterventionSiteMaxAggregateOutputType | null
  }

  type GetInterventionSiteGroupByPayload<T extends InterventionSiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterventionSiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterventionSiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterventionSiteGroupByOutputType[P]>
            : GetScalarType<T[P], InterventionSiteGroupByOutputType[P]>
        }
      >
    >


  export type InterventionSiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    client?: boolean
    site?: boolean
    surface?: boolean
    type?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cleaningManagerId?: boolean
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
    siteCleaningSessions?: boolean | InterventionSite$siteCleaningSessionsArgs<ExtArgs>
    cleaningPlannings?: boolean | InterventionSite$cleaningPlanningsArgs<ExtArgs>
    _count?: boolean | InterventionSiteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interventionSite"]>

  export type InterventionSiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    client?: boolean
    site?: boolean
    surface?: boolean
    type?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cleaningManagerId?: boolean
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interventionSite"]>

  export type InterventionSiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    client?: boolean
    site?: boolean
    surface?: boolean
    type?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cleaningManagerId?: boolean
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interventionSite"]>

  export type InterventionSiteSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    client?: boolean
    site?: boolean
    surface?: boolean
    type?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cleaningManagerId?: boolean
  }

  export type InterventionSiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "client" | "site" | "surface" | "type" | "address" | "createdAt" | "updatedAt" | "cleaningManagerId", ExtArgs["result"]["interventionSite"]>
  export type InterventionSiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
    siteCleaningSessions?: boolean | InterventionSite$siteCleaningSessionsArgs<ExtArgs>
    cleaningPlannings?: boolean | InterventionSite$cleaningPlanningsArgs<ExtArgs>
    _count?: boolean | InterventionSiteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InterventionSiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
  }
  export type InterventionSiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
  }

  export type $InterventionSitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterventionSite"
    objects: {
      cleaningManager: Prisma.$CleaningManagerPayload<ExtArgs>
      siteCleaningSessions: Prisma.$SiteCleaningSessionPayload<ExtArgs>[]
      cleaningPlannings: Prisma.$CleaningPlanningPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      client: string | null
      site: string | null
      surface: number | null
      type: string | null
      address: string | null
      createdAt: Date
      updatedAt: Date
      cleaningManagerId: string
    }, ExtArgs["result"]["interventionSite"]>
    composites: {}
  }

  type InterventionSiteGetPayload<S extends boolean | null | undefined | InterventionSiteDefaultArgs> = $Result.GetResult<Prisma.$InterventionSitePayload, S>

  type InterventionSiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterventionSiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterventionSiteCountAggregateInputType | true
    }

  export interface InterventionSiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterventionSite'], meta: { name: 'InterventionSite' } }
    /**
     * Find zero or one InterventionSite that matches the filter.
     * @param {InterventionSiteFindUniqueArgs} args - Arguments to find a InterventionSite
     * @example
     * // Get one InterventionSite
     * const interventionSite = await prisma.interventionSite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterventionSiteFindUniqueArgs>(args: SelectSubset<T, InterventionSiteFindUniqueArgs<ExtArgs>>): Prisma__InterventionSiteClient<$Result.GetResult<Prisma.$InterventionSitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InterventionSite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterventionSiteFindUniqueOrThrowArgs} args - Arguments to find a InterventionSite
     * @example
     * // Get one InterventionSite
     * const interventionSite = await prisma.interventionSite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterventionSiteFindUniqueOrThrowArgs>(args: SelectSubset<T, InterventionSiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterventionSiteClient<$Result.GetResult<Prisma.$InterventionSitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterventionSite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionSiteFindFirstArgs} args - Arguments to find a InterventionSite
     * @example
     * // Get one InterventionSite
     * const interventionSite = await prisma.interventionSite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterventionSiteFindFirstArgs>(args?: SelectSubset<T, InterventionSiteFindFirstArgs<ExtArgs>>): Prisma__InterventionSiteClient<$Result.GetResult<Prisma.$InterventionSitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterventionSite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionSiteFindFirstOrThrowArgs} args - Arguments to find a InterventionSite
     * @example
     * // Get one InterventionSite
     * const interventionSite = await prisma.interventionSite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterventionSiteFindFirstOrThrowArgs>(args?: SelectSubset<T, InterventionSiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterventionSiteClient<$Result.GetResult<Prisma.$InterventionSitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InterventionSites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionSiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterventionSites
     * const interventionSites = await prisma.interventionSite.findMany()
     * 
     * // Get first 10 InterventionSites
     * const interventionSites = await prisma.interventionSite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interventionSiteWithIdOnly = await prisma.interventionSite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterventionSiteFindManyArgs>(args?: SelectSubset<T, InterventionSiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionSitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InterventionSite.
     * @param {InterventionSiteCreateArgs} args - Arguments to create a InterventionSite.
     * @example
     * // Create one InterventionSite
     * const InterventionSite = await prisma.interventionSite.create({
     *   data: {
     *     // ... data to create a InterventionSite
     *   }
     * })
     * 
     */
    create<T extends InterventionSiteCreateArgs>(args: SelectSubset<T, InterventionSiteCreateArgs<ExtArgs>>): Prisma__InterventionSiteClient<$Result.GetResult<Prisma.$InterventionSitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InterventionSites.
     * @param {InterventionSiteCreateManyArgs} args - Arguments to create many InterventionSites.
     * @example
     * // Create many InterventionSites
     * const interventionSite = await prisma.interventionSite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterventionSiteCreateManyArgs>(args?: SelectSubset<T, InterventionSiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterventionSites and returns the data saved in the database.
     * @param {InterventionSiteCreateManyAndReturnArgs} args - Arguments to create many InterventionSites.
     * @example
     * // Create many InterventionSites
     * const interventionSite = await prisma.interventionSite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterventionSites and only return the `id`
     * const interventionSiteWithIdOnly = await prisma.interventionSite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterventionSiteCreateManyAndReturnArgs>(args?: SelectSubset<T, InterventionSiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionSitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InterventionSite.
     * @param {InterventionSiteDeleteArgs} args - Arguments to delete one InterventionSite.
     * @example
     * // Delete one InterventionSite
     * const InterventionSite = await prisma.interventionSite.delete({
     *   where: {
     *     // ... filter to delete one InterventionSite
     *   }
     * })
     * 
     */
    delete<T extends InterventionSiteDeleteArgs>(args: SelectSubset<T, InterventionSiteDeleteArgs<ExtArgs>>): Prisma__InterventionSiteClient<$Result.GetResult<Prisma.$InterventionSitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InterventionSite.
     * @param {InterventionSiteUpdateArgs} args - Arguments to update one InterventionSite.
     * @example
     * // Update one InterventionSite
     * const interventionSite = await prisma.interventionSite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterventionSiteUpdateArgs>(args: SelectSubset<T, InterventionSiteUpdateArgs<ExtArgs>>): Prisma__InterventionSiteClient<$Result.GetResult<Prisma.$InterventionSitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InterventionSites.
     * @param {InterventionSiteDeleteManyArgs} args - Arguments to filter InterventionSites to delete.
     * @example
     * // Delete a few InterventionSites
     * const { count } = await prisma.interventionSite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterventionSiteDeleteManyArgs>(args?: SelectSubset<T, InterventionSiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterventionSites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionSiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterventionSites
     * const interventionSite = await prisma.interventionSite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterventionSiteUpdateManyArgs>(args: SelectSubset<T, InterventionSiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterventionSites and returns the data updated in the database.
     * @param {InterventionSiteUpdateManyAndReturnArgs} args - Arguments to update many InterventionSites.
     * @example
     * // Update many InterventionSites
     * const interventionSite = await prisma.interventionSite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InterventionSites and only return the `id`
     * const interventionSiteWithIdOnly = await prisma.interventionSite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterventionSiteUpdateManyAndReturnArgs>(args: SelectSubset<T, InterventionSiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionSitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InterventionSite.
     * @param {InterventionSiteUpsertArgs} args - Arguments to update or create a InterventionSite.
     * @example
     * // Update or create a InterventionSite
     * const interventionSite = await prisma.interventionSite.upsert({
     *   create: {
     *     // ... data to create a InterventionSite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterventionSite we want to update
     *   }
     * })
     */
    upsert<T extends InterventionSiteUpsertArgs>(args: SelectSubset<T, InterventionSiteUpsertArgs<ExtArgs>>): Prisma__InterventionSiteClient<$Result.GetResult<Prisma.$InterventionSitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InterventionSites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionSiteCountArgs} args - Arguments to filter InterventionSites to count.
     * @example
     * // Count the number of InterventionSites
     * const count = await prisma.interventionSite.count({
     *   where: {
     *     // ... the filter for the InterventionSites we want to count
     *   }
     * })
    **/
    count<T extends InterventionSiteCountArgs>(
      args?: Subset<T, InterventionSiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterventionSiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterventionSite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionSiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterventionSiteAggregateArgs>(args: Subset<T, InterventionSiteAggregateArgs>): Prisma.PrismaPromise<GetInterventionSiteAggregateType<T>>

    /**
     * Group by InterventionSite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionSiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterventionSiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterventionSiteGroupByArgs['orderBy'] }
        : { orderBy?: InterventionSiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterventionSiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterventionSiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterventionSite model
   */
  readonly fields: InterventionSiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterventionSite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterventionSiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cleaningManager<T extends CleaningManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CleaningManagerDefaultArgs<ExtArgs>>): Prisma__CleaningManagerClient<$Result.GetResult<Prisma.$CleaningManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    siteCleaningSessions<T extends InterventionSite$siteCleaningSessionsArgs<ExtArgs> = {}>(args?: Subset<T, InterventionSite$siteCleaningSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteCleaningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cleaningPlannings<T extends InterventionSite$cleaningPlanningsArgs<ExtArgs> = {}>(args?: Subset<T, InterventionSite$cleaningPlanningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningPlanningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterventionSite model
   */
  interface InterventionSiteFieldRefs {
    readonly id: FieldRef<"InterventionSite", 'String'>
    readonly name: FieldRef<"InterventionSite", 'String'>
    readonly description: FieldRef<"InterventionSite", 'String'>
    readonly client: FieldRef<"InterventionSite", 'String'>
    readonly site: FieldRef<"InterventionSite", 'String'>
    readonly surface: FieldRef<"InterventionSite", 'Float'>
    readonly type: FieldRef<"InterventionSite", 'String'>
    readonly address: FieldRef<"InterventionSite", 'String'>
    readonly createdAt: FieldRef<"InterventionSite", 'DateTime'>
    readonly updatedAt: FieldRef<"InterventionSite", 'DateTime'>
    readonly cleaningManagerId: FieldRef<"InterventionSite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InterventionSite findUnique
   */
  export type InterventionSiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionSite
     */
    select?: InterventionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionSite
     */
    omit?: InterventionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionSiteInclude<ExtArgs> | null
    /**
     * Filter, which InterventionSite to fetch.
     */
    where: InterventionSiteWhereUniqueInput
  }

  /**
   * InterventionSite findUniqueOrThrow
   */
  export type InterventionSiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionSite
     */
    select?: InterventionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionSite
     */
    omit?: InterventionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionSiteInclude<ExtArgs> | null
    /**
     * Filter, which InterventionSite to fetch.
     */
    where: InterventionSiteWhereUniqueInput
  }

  /**
   * InterventionSite findFirst
   */
  export type InterventionSiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionSite
     */
    select?: InterventionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionSite
     */
    omit?: InterventionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionSiteInclude<ExtArgs> | null
    /**
     * Filter, which InterventionSite to fetch.
     */
    where?: InterventionSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterventionSites to fetch.
     */
    orderBy?: InterventionSiteOrderByWithRelationInput | InterventionSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterventionSites.
     */
    cursor?: InterventionSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterventionSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterventionSites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterventionSites.
     */
    distinct?: InterventionSiteScalarFieldEnum | InterventionSiteScalarFieldEnum[]
  }

  /**
   * InterventionSite findFirstOrThrow
   */
  export type InterventionSiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionSite
     */
    select?: InterventionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionSite
     */
    omit?: InterventionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionSiteInclude<ExtArgs> | null
    /**
     * Filter, which InterventionSite to fetch.
     */
    where?: InterventionSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterventionSites to fetch.
     */
    orderBy?: InterventionSiteOrderByWithRelationInput | InterventionSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterventionSites.
     */
    cursor?: InterventionSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterventionSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterventionSites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterventionSites.
     */
    distinct?: InterventionSiteScalarFieldEnum | InterventionSiteScalarFieldEnum[]
  }

  /**
   * InterventionSite findMany
   */
  export type InterventionSiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionSite
     */
    select?: InterventionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionSite
     */
    omit?: InterventionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionSiteInclude<ExtArgs> | null
    /**
     * Filter, which InterventionSites to fetch.
     */
    where?: InterventionSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterventionSites to fetch.
     */
    orderBy?: InterventionSiteOrderByWithRelationInput | InterventionSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterventionSites.
     */
    cursor?: InterventionSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterventionSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterventionSites.
     */
    skip?: number
    distinct?: InterventionSiteScalarFieldEnum | InterventionSiteScalarFieldEnum[]
  }

  /**
   * InterventionSite create
   */
  export type InterventionSiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionSite
     */
    select?: InterventionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionSite
     */
    omit?: InterventionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionSiteInclude<ExtArgs> | null
    /**
     * The data needed to create a InterventionSite.
     */
    data: XOR<InterventionSiteCreateInput, InterventionSiteUncheckedCreateInput>
  }

  /**
   * InterventionSite createMany
   */
  export type InterventionSiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterventionSites.
     */
    data: InterventionSiteCreateManyInput | InterventionSiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterventionSite createManyAndReturn
   */
  export type InterventionSiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionSite
     */
    select?: InterventionSiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionSite
     */
    omit?: InterventionSiteOmit<ExtArgs> | null
    /**
     * The data used to create many InterventionSites.
     */
    data: InterventionSiteCreateManyInput | InterventionSiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionSiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterventionSite update
   */
  export type InterventionSiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionSite
     */
    select?: InterventionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionSite
     */
    omit?: InterventionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionSiteInclude<ExtArgs> | null
    /**
     * The data needed to update a InterventionSite.
     */
    data: XOR<InterventionSiteUpdateInput, InterventionSiteUncheckedUpdateInput>
    /**
     * Choose, which InterventionSite to update.
     */
    where: InterventionSiteWhereUniqueInput
  }

  /**
   * InterventionSite updateMany
   */
  export type InterventionSiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterventionSites.
     */
    data: XOR<InterventionSiteUpdateManyMutationInput, InterventionSiteUncheckedUpdateManyInput>
    /**
     * Filter which InterventionSites to update
     */
    where?: InterventionSiteWhereInput
    /**
     * Limit how many InterventionSites to update.
     */
    limit?: number
  }

  /**
   * InterventionSite updateManyAndReturn
   */
  export type InterventionSiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionSite
     */
    select?: InterventionSiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionSite
     */
    omit?: InterventionSiteOmit<ExtArgs> | null
    /**
     * The data used to update InterventionSites.
     */
    data: XOR<InterventionSiteUpdateManyMutationInput, InterventionSiteUncheckedUpdateManyInput>
    /**
     * Filter which InterventionSites to update
     */
    where?: InterventionSiteWhereInput
    /**
     * Limit how many InterventionSites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionSiteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterventionSite upsert
   */
  export type InterventionSiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionSite
     */
    select?: InterventionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionSite
     */
    omit?: InterventionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionSiteInclude<ExtArgs> | null
    /**
     * The filter to search for the InterventionSite to update in case it exists.
     */
    where: InterventionSiteWhereUniqueInput
    /**
     * In case the InterventionSite found by the `where` argument doesn't exist, create a new InterventionSite with this data.
     */
    create: XOR<InterventionSiteCreateInput, InterventionSiteUncheckedCreateInput>
    /**
     * In case the InterventionSite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterventionSiteUpdateInput, InterventionSiteUncheckedUpdateInput>
  }

  /**
   * InterventionSite delete
   */
  export type InterventionSiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionSite
     */
    select?: InterventionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionSite
     */
    omit?: InterventionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionSiteInclude<ExtArgs> | null
    /**
     * Filter which InterventionSite to delete.
     */
    where: InterventionSiteWhereUniqueInput
  }

  /**
   * InterventionSite deleteMany
   */
  export type InterventionSiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterventionSites to delete
     */
    where?: InterventionSiteWhereInput
    /**
     * Limit how many InterventionSites to delete.
     */
    limit?: number
  }

  /**
   * InterventionSite.siteCleaningSessions
   */
  export type InterventionSite$siteCleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningSession
     */
    select?: SiteCleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningSession
     */
    omit?: SiteCleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningSessionInclude<ExtArgs> | null
    where?: SiteCleaningSessionWhereInput
    orderBy?: SiteCleaningSessionOrderByWithRelationInput | SiteCleaningSessionOrderByWithRelationInput[]
    cursor?: SiteCleaningSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteCleaningSessionScalarFieldEnum | SiteCleaningSessionScalarFieldEnum[]
  }

  /**
   * InterventionSite.cleaningPlannings
   */
  export type InterventionSite$cleaningPlanningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPlanning
     */
    select?: CleaningPlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPlanning
     */
    omit?: CleaningPlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPlanningInclude<ExtArgs> | null
    where?: CleaningPlanningWhereInput
    orderBy?: CleaningPlanningOrderByWithRelationInput | CleaningPlanningOrderByWithRelationInput[]
    cursor?: CleaningPlanningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningPlanningScalarFieldEnum | CleaningPlanningScalarFieldEnum[]
  }

  /**
   * InterventionSite without action
   */
  export type InterventionSiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionSite
     */
    select?: InterventionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterventionSite
     */
    omit?: InterventionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionSiteInclude<ExtArgs> | null
  }


  /**
   * Model SiteCleaningSession
   */

  export type AggregateSiteCleaningSession = {
    _count: SiteCleaningSessionCountAggregateOutputType | null
    _avg: SiteCleaningSessionAvgAggregateOutputType | null
    _sum: SiteCleaningSessionSumAggregateOutputType | null
    _min: SiteCleaningSessionMinAggregateOutputType | null
    _max: SiteCleaningSessionMaxAggregateOutputType | null
  }

  export type SiteCleaningSessionAvgAggregateOutputType = {
    duration: number | null
  }

  export type SiteCleaningSessionSumAggregateOutputType = {
    duration: number | null
  }

  export type SiteCleaningSessionMinAggregateOutputType = {
    id: string | null
    interventionSiteId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    cleaningManagerId: string | null
    startDate: Date | null
    endDate: Date | null
    duration: number | null
    notes: string | null
    status: $Enums.InterventionStatus | null
    laundryManagerId: string | null
    cleaningAgentId: string | null
  }

  export type SiteCleaningSessionMaxAggregateOutputType = {
    id: string | null
    interventionSiteId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    cleaningManagerId: string | null
    startDate: Date | null
    endDate: Date | null
    duration: number | null
    notes: string | null
    status: $Enums.InterventionStatus | null
    laundryManagerId: string | null
    cleaningAgentId: string | null
  }

  export type SiteCleaningSessionCountAggregateOutputType = {
    id: number
    interventionSiteId: number
    createdAt: number
    updatedAt: number
    cleaningManagerId: number
    startDate: number
    endDate: number
    duration: number
    notes: number
    status: number
    laundryManagerId: number
    cleaningAgentId: number
    _all: number
  }


  export type SiteCleaningSessionAvgAggregateInputType = {
    duration?: true
  }

  export type SiteCleaningSessionSumAggregateInputType = {
    duration?: true
  }

  export type SiteCleaningSessionMinAggregateInputType = {
    id?: true
    interventionSiteId?: true
    createdAt?: true
    updatedAt?: true
    cleaningManagerId?: true
    startDate?: true
    endDate?: true
    duration?: true
    notes?: true
    status?: true
    laundryManagerId?: true
    cleaningAgentId?: true
  }

  export type SiteCleaningSessionMaxAggregateInputType = {
    id?: true
    interventionSiteId?: true
    createdAt?: true
    updatedAt?: true
    cleaningManagerId?: true
    startDate?: true
    endDate?: true
    duration?: true
    notes?: true
    status?: true
    laundryManagerId?: true
    cleaningAgentId?: true
  }

  export type SiteCleaningSessionCountAggregateInputType = {
    id?: true
    interventionSiteId?: true
    createdAt?: true
    updatedAt?: true
    cleaningManagerId?: true
    startDate?: true
    endDate?: true
    duration?: true
    notes?: true
    status?: true
    laundryManagerId?: true
    cleaningAgentId?: true
    _all?: true
  }

  export type SiteCleaningSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteCleaningSession to aggregate.
     */
    where?: SiteCleaningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteCleaningSessions to fetch.
     */
    orderBy?: SiteCleaningSessionOrderByWithRelationInput | SiteCleaningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteCleaningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteCleaningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteCleaningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteCleaningSessions
    **/
    _count?: true | SiteCleaningSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SiteCleaningSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SiteCleaningSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteCleaningSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteCleaningSessionMaxAggregateInputType
  }

  export type GetSiteCleaningSessionAggregateType<T extends SiteCleaningSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteCleaningSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteCleaningSession[P]>
      : GetScalarType<T[P], AggregateSiteCleaningSession[P]>
  }




  export type SiteCleaningSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteCleaningSessionWhereInput
    orderBy?: SiteCleaningSessionOrderByWithAggregationInput | SiteCleaningSessionOrderByWithAggregationInput[]
    by: SiteCleaningSessionScalarFieldEnum[] | SiteCleaningSessionScalarFieldEnum
    having?: SiteCleaningSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteCleaningSessionCountAggregateInputType | true
    _avg?: SiteCleaningSessionAvgAggregateInputType
    _sum?: SiteCleaningSessionSumAggregateInputType
    _min?: SiteCleaningSessionMinAggregateInputType
    _max?: SiteCleaningSessionMaxAggregateInputType
  }

  export type SiteCleaningSessionGroupByOutputType = {
    id: string
    interventionSiteId: string
    createdAt: Date
    updatedAt: Date
    cleaningManagerId: string
    startDate: Date | null
    endDate: Date | null
    duration: number | null
    notes: string | null
    status: $Enums.InterventionStatus
    laundryManagerId: string | null
    cleaningAgentId: string | null
    _count: SiteCleaningSessionCountAggregateOutputType | null
    _avg: SiteCleaningSessionAvgAggregateOutputType | null
    _sum: SiteCleaningSessionSumAggregateOutputType | null
    _min: SiteCleaningSessionMinAggregateOutputType | null
    _max: SiteCleaningSessionMaxAggregateOutputType | null
  }

  type GetSiteCleaningSessionGroupByPayload<T extends SiteCleaningSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteCleaningSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteCleaningSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteCleaningSessionGroupByOutputType[P]>
            : GetScalarType<T[P], SiteCleaningSessionGroupByOutputType[P]>
        }
      >
    >


  export type SiteCleaningSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interventionSiteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cleaningManagerId?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    notes?: boolean
    status?: boolean
    laundryManagerId?: boolean
    cleaningAgentId?: boolean
    interventionSite?: boolean | InterventionSiteDefaultArgs<ExtArgs>
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
    photos?: boolean | SiteCleaningSession$photosArgs<ExtArgs>
    checklist?: boolean | SiteCleaningSession$checklistArgs<ExtArgs>
    laundryManager?: boolean | SiteCleaningSession$laundryManagerArgs<ExtArgs>
    cleaningAgent?: boolean | SiteCleaningSession$cleaningAgentArgs<ExtArgs>
    _count?: boolean | SiteCleaningSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteCleaningSession"]>

  export type SiteCleaningSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interventionSiteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cleaningManagerId?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    notes?: boolean
    status?: boolean
    laundryManagerId?: boolean
    cleaningAgentId?: boolean
    interventionSite?: boolean | InterventionSiteDefaultArgs<ExtArgs>
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
    laundryManager?: boolean | SiteCleaningSession$laundryManagerArgs<ExtArgs>
    cleaningAgent?: boolean | SiteCleaningSession$cleaningAgentArgs<ExtArgs>
  }, ExtArgs["result"]["siteCleaningSession"]>

  export type SiteCleaningSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interventionSiteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cleaningManagerId?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    notes?: boolean
    status?: boolean
    laundryManagerId?: boolean
    cleaningAgentId?: boolean
    interventionSite?: boolean | InterventionSiteDefaultArgs<ExtArgs>
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
    laundryManager?: boolean | SiteCleaningSession$laundryManagerArgs<ExtArgs>
    cleaningAgent?: boolean | SiteCleaningSession$cleaningAgentArgs<ExtArgs>
  }, ExtArgs["result"]["siteCleaningSession"]>

  export type SiteCleaningSessionSelectScalar = {
    id?: boolean
    interventionSiteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cleaningManagerId?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    notes?: boolean
    status?: boolean
    laundryManagerId?: boolean
    cleaningAgentId?: boolean
  }

  export type SiteCleaningSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "interventionSiteId" | "createdAt" | "updatedAt" | "cleaningManagerId" | "startDate" | "endDate" | "duration" | "notes" | "status" | "laundryManagerId" | "cleaningAgentId", ExtArgs["result"]["siteCleaningSession"]>
  export type SiteCleaningSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interventionSite?: boolean | InterventionSiteDefaultArgs<ExtArgs>
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
    photos?: boolean | SiteCleaningSession$photosArgs<ExtArgs>
    checklist?: boolean | SiteCleaningSession$checklistArgs<ExtArgs>
    laundryManager?: boolean | SiteCleaningSession$laundryManagerArgs<ExtArgs>
    cleaningAgent?: boolean | SiteCleaningSession$cleaningAgentArgs<ExtArgs>
    _count?: boolean | SiteCleaningSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SiteCleaningSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interventionSite?: boolean | InterventionSiteDefaultArgs<ExtArgs>
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
    laundryManager?: boolean | SiteCleaningSession$laundryManagerArgs<ExtArgs>
    cleaningAgent?: boolean | SiteCleaningSession$cleaningAgentArgs<ExtArgs>
  }
  export type SiteCleaningSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interventionSite?: boolean | InterventionSiteDefaultArgs<ExtArgs>
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
    laundryManager?: boolean | SiteCleaningSession$laundryManagerArgs<ExtArgs>
    cleaningAgent?: boolean | SiteCleaningSession$cleaningAgentArgs<ExtArgs>
  }

  export type $SiteCleaningSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteCleaningSession"
    objects: {
      interventionSite: Prisma.$InterventionSitePayload<ExtArgs>
      cleaningManager: Prisma.$CleaningManagerPayload<ExtArgs>
      photos: Prisma.$SiteCleaningPhotoPayload<ExtArgs>[]
      checklist: Prisma.$SiteCleaningChecklistPayload<ExtArgs>[]
      laundryManager: Prisma.$LaundryManagerPayload<ExtArgs> | null
      cleaningAgent: Prisma.$AgentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      interventionSiteId: string
      createdAt: Date
      updatedAt: Date
      cleaningManagerId: string
      startDate: Date | null
      endDate: Date | null
      duration: number | null
      notes: string | null
      status: $Enums.InterventionStatus
      laundryManagerId: string | null
      cleaningAgentId: string | null
    }, ExtArgs["result"]["siteCleaningSession"]>
    composites: {}
  }

  type SiteCleaningSessionGetPayload<S extends boolean | null | undefined | SiteCleaningSessionDefaultArgs> = $Result.GetResult<Prisma.$SiteCleaningSessionPayload, S>

  type SiteCleaningSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteCleaningSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteCleaningSessionCountAggregateInputType | true
    }

  export interface SiteCleaningSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteCleaningSession'], meta: { name: 'SiteCleaningSession' } }
    /**
     * Find zero or one SiteCleaningSession that matches the filter.
     * @param {SiteCleaningSessionFindUniqueArgs} args - Arguments to find a SiteCleaningSession
     * @example
     * // Get one SiteCleaningSession
     * const siteCleaningSession = await prisma.siteCleaningSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteCleaningSessionFindUniqueArgs>(args: SelectSubset<T, SiteCleaningSessionFindUniqueArgs<ExtArgs>>): Prisma__SiteCleaningSessionClient<$Result.GetResult<Prisma.$SiteCleaningSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SiteCleaningSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteCleaningSessionFindUniqueOrThrowArgs} args - Arguments to find a SiteCleaningSession
     * @example
     * // Get one SiteCleaningSession
     * const siteCleaningSession = await prisma.siteCleaningSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteCleaningSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteCleaningSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteCleaningSessionClient<$Result.GetResult<Prisma.$SiteCleaningSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteCleaningSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningSessionFindFirstArgs} args - Arguments to find a SiteCleaningSession
     * @example
     * // Get one SiteCleaningSession
     * const siteCleaningSession = await prisma.siteCleaningSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteCleaningSessionFindFirstArgs>(args?: SelectSubset<T, SiteCleaningSessionFindFirstArgs<ExtArgs>>): Prisma__SiteCleaningSessionClient<$Result.GetResult<Prisma.$SiteCleaningSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteCleaningSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningSessionFindFirstOrThrowArgs} args - Arguments to find a SiteCleaningSession
     * @example
     * // Get one SiteCleaningSession
     * const siteCleaningSession = await prisma.siteCleaningSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteCleaningSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteCleaningSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteCleaningSessionClient<$Result.GetResult<Prisma.$SiteCleaningSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteCleaningSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteCleaningSessions
     * const siteCleaningSessions = await prisma.siteCleaningSession.findMany()
     * 
     * // Get first 10 SiteCleaningSessions
     * const siteCleaningSessions = await prisma.siteCleaningSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteCleaningSessionWithIdOnly = await prisma.siteCleaningSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SiteCleaningSessionFindManyArgs>(args?: SelectSubset<T, SiteCleaningSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteCleaningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SiteCleaningSession.
     * @param {SiteCleaningSessionCreateArgs} args - Arguments to create a SiteCleaningSession.
     * @example
     * // Create one SiteCleaningSession
     * const SiteCleaningSession = await prisma.siteCleaningSession.create({
     *   data: {
     *     // ... data to create a SiteCleaningSession
     *   }
     * })
     * 
     */
    create<T extends SiteCleaningSessionCreateArgs>(args: SelectSubset<T, SiteCleaningSessionCreateArgs<ExtArgs>>): Prisma__SiteCleaningSessionClient<$Result.GetResult<Prisma.$SiteCleaningSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SiteCleaningSessions.
     * @param {SiteCleaningSessionCreateManyArgs} args - Arguments to create many SiteCleaningSessions.
     * @example
     * // Create many SiteCleaningSessions
     * const siteCleaningSession = await prisma.siteCleaningSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteCleaningSessionCreateManyArgs>(args?: SelectSubset<T, SiteCleaningSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SiteCleaningSessions and returns the data saved in the database.
     * @param {SiteCleaningSessionCreateManyAndReturnArgs} args - Arguments to create many SiteCleaningSessions.
     * @example
     * // Create many SiteCleaningSessions
     * const siteCleaningSession = await prisma.siteCleaningSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SiteCleaningSessions and only return the `id`
     * const siteCleaningSessionWithIdOnly = await prisma.siteCleaningSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteCleaningSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteCleaningSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteCleaningSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SiteCleaningSession.
     * @param {SiteCleaningSessionDeleteArgs} args - Arguments to delete one SiteCleaningSession.
     * @example
     * // Delete one SiteCleaningSession
     * const SiteCleaningSession = await prisma.siteCleaningSession.delete({
     *   where: {
     *     // ... filter to delete one SiteCleaningSession
     *   }
     * })
     * 
     */
    delete<T extends SiteCleaningSessionDeleteArgs>(args: SelectSubset<T, SiteCleaningSessionDeleteArgs<ExtArgs>>): Prisma__SiteCleaningSessionClient<$Result.GetResult<Prisma.$SiteCleaningSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SiteCleaningSession.
     * @param {SiteCleaningSessionUpdateArgs} args - Arguments to update one SiteCleaningSession.
     * @example
     * // Update one SiteCleaningSession
     * const siteCleaningSession = await prisma.siteCleaningSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteCleaningSessionUpdateArgs>(args: SelectSubset<T, SiteCleaningSessionUpdateArgs<ExtArgs>>): Prisma__SiteCleaningSessionClient<$Result.GetResult<Prisma.$SiteCleaningSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SiteCleaningSessions.
     * @param {SiteCleaningSessionDeleteManyArgs} args - Arguments to filter SiteCleaningSessions to delete.
     * @example
     * // Delete a few SiteCleaningSessions
     * const { count } = await prisma.siteCleaningSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteCleaningSessionDeleteManyArgs>(args?: SelectSubset<T, SiteCleaningSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteCleaningSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteCleaningSessions
     * const siteCleaningSession = await prisma.siteCleaningSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteCleaningSessionUpdateManyArgs>(args: SelectSubset<T, SiteCleaningSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteCleaningSessions and returns the data updated in the database.
     * @param {SiteCleaningSessionUpdateManyAndReturnArgs} args - Arguments to update many SiteCleaningSessions.
     * @example
     * // Update many SiteCleaningSessions
     * const siteCleaningSession = await prisma.siteCleaningSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SiteCleaningSessions and only return the `id`
     * const siteCleaningSessionWithIdOnly = await prisma.siteCleaningSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteCleaningSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteCleaningSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteCleaningSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SiteCleaningSession.
     * @param {SiteCleaningSessionUpsertArgs} args - Arguments to update or create a SiteCleaningSession.
     * @example
     * // Update or create a SiteCleaningSession
     * const siteCleaningSession = await prisma.siteCleaningSession.upsert({
     *   create: {
     *     // ... data to create a SiteCleaningSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteCleaningSession we want to update
     *   }
     * })
     */
    upsert<T extends SiteCleaningSessionUpsertArgs>(args: SelectSubset<T, SiteCleaningSessionUpsertArgs<ExtArgs>>): Prisma__SiteCleaningSessionClient<$Result.GetResult<Prisma.$SiteCleaningSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SiteCleaningSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningSessionCountArgs} args - Arguments to filter SiteCleaningSessions to count.
     * @example
     * // Count the number of SiteCleaningSessions
     * const count = await prisma.siteCleaningSession.count({
     *   where: {
     *     // ... the filter for the SiteCleaningSessions we want to count
     *   }
     * })
    **/
    count<T extends SiteCleaningSessionCountArgs>(
      args?: Subset<T, SiteCleaningSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteCleaningSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteCleaningSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteCleaningSessionAggregateArgs>(args: Subset<T, SiteCleaningSessionAggregateArgs>): Prisma.PrismaPromise<GetSiteCleaningSessionAggregateType<T>>

    /**
     * Group by SiteCleaningSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteCleaningSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteCleaningSessionGroupByArgs['orderBy'] }
        : { orderBy?: SiteCleaningSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteCleaningSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteCleaningSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteCleaningSession model
   */
  readonly fields: SiteCleaningSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteCleaningSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteCleaningSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interventionSite<T extends InterventionSiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterventionSiteDefaultArgs<ExtArgs>>): Prisma__InterventionSiteClient<$Result.GetResult<Prisma.$InterventionSitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cleaningManager<T extends CleaningManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CleaningManagerDefaultArgs<ExtArgs>>): Prisma__CleaningManagerClient<$Result.GetResult<Prisma.$CleaningManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photos<T extends SiteCleaningSession$photosArgs<ExtArgs> = {}>(args?: Subset<T, SiteCleaningSession$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteCleaningPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checklist<T extends SiteCleaningSession$checklistArgs<ExtArgs> = {}>(args?: Subset<T, SiteCleaningSession$checklistArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteCleaningChecklistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    laundryManager<T extends SiteCleaningSession$laundryManagerArgs<ExtArgs> = {}>(args?: Subset<T, SiteCleaningSession$laundryManagerArgs<ExtArgs>>): Prisma__LaundryManagerClient<$Result.GetResult<Prisma.$LaundryManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cleaningAgent<T extends SiteCleaningSession$cleaningAgentArgs<ExtArgs> = {}>(args?: Subset<T, SiteCleaningSession$cleaningAgentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteCleaningSession model
   */
  interface SiteCleaningSessionFieldRefs {
    readonly id: FieldRef<"SiteCleaningSession", 'String'>
    readonly interventionSiteId: FieldRef<"SiteCleaningSession", 'String'>
    readonly createdAt: FieldRef<"SiteCleaningSession", 'DateTime'>
    readonly updatedAt: FieldRef<"SiteCleaningSession", 'DateTime'>
    readonly cleaningManagerId: FieldRef<"SiteCleaningSession", 'String'>
    readonly startDate: FieldRef<"SiteCleaningSession", 'DateTime'>
    readonly endDate: FieldRef<"SiteCleaningSession", 'DateTime'>
    readonly duration: FieldRef<"SiteCleaningSession", 'Int'>
    readonly notes: FieldRef<"SiteCleaningSession", 'String'>
    readonly status: FieldRef<"SiteCleaningSession", 'InterventionStatus'>
    readonly laundryManagerId: FieldRef<"SiteCleaningSession", 'String'>
    readonly cleaningAgentId: FieldRef<"SiteCleaningSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SiteCleaningSession findUnique
   */
  export type SiteCleaningSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningSession
     */
    select?: SiteCleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningSession
     */
    omit?: SiteCleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningSessionInclude<ExtArgs> | null
    /**
     * Filter, which SiteCleaningSession to fetch.
     */
    where: SiteCleaningSessionWhereUniqueInput
  }

  /**
   * SiteCleaningSession findUniqueOrThrow
   */
  export type SiteCleaningSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningSession
     */
    select?: SiteCleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningSession
     */
    omit?: SiteCleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningSessionInclude<ExtArgs> | null
    /**
     * Filter, which SiteCleaningSession to fetch.
     */
    where: SiteCleaningSessionWhereUniqueInput
  }

  /**
   * SiteCleaningSession findFirst
   */
  export type SiteCleaningSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningSession
     */
    select?: SiteCleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningSession
     */
    omit?: SiteCleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningSessionInclude<ExtArgs> | null
    /**
     * Filter, which SiteCleaningSession to fetch.
     */
    where?: SiteCleaningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteCleaningSessions to fetch.
     */
    orderBy?: SiteCleaningSessionOrderByWithRelationInput | SiteCleaningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteCleaningSessions.
     */
    cursor?: SiteCleaningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteCleaningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteCleaningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteCleaningSessions.
     */
    distinct?: SiteCleaningSessionScalarFieldEnum | SiteCleaningSessionScalarFieldEnum[]
  }

  /**
   * SiteCleaningSession findFirstOrThrow
   */
  export type SiteCleaningSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningSession
     */
    select?: SiteCleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningSession
     */
    omit?: SiteCleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningSessionInclude<ExtArgs> | null
    /**
     * Filter, which SiteCleaningSession to fetch.
     */
    where?: SiteCleaningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteCleaningSessions to fetch.
     */
    orderBy?: SiteCleaningSessionOrderByWithRelationInput | SiteCleaningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteCleaningSessions.
     */
    cursor?: SiteCleaningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteCleaningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteCleaningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteCleaningSessions.
     */
    distinct?: SiteCleaningSessionScalarFieldEnum | SiteCleaningSessionScalarFieldEnum[]
  }

  /**
   * SiteCleaningSession findMany
   */
  export type SiteCleaningSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningSession
     */
    select?: SiteCleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningSession
     */
    omit?: SiteCleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningSessionInclude<ExtArgs> | null
    /**
     * Filter, which SiteCleaningSessions to fetch.
     */
    where?: SiteCleaningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteCleaningSessions to fetch.
     */
    orderBy?: SiteCleaningSessionOrderByWithRelationInput | SiteCleaningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteCleaningSessions.
     */
    cursor?: SiteCleaningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteCleaningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteCleaningSessions.
     */
    skip?: number
    distinct?: SiteCleaningSessionScalarFieldEnum | SiteCleaningSessionScalarFieldEnum[]
  }

  /**
   * SiteCleaningSession create
   */
  export type SiteCleaningSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningSession
     */
    select?: SiteCleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningSession
     */
    omit?: SiteCleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a SiteCleaningSession.
     */
    data: XOR<SiteCleaningSessionCreateInput, SiteCleaningSessionUncheckedCreateInput>
  }

  /**
   * SiteCleaningSession createMany
   */
  export type SiteCleaningSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteCleaningSessions.
     */
    data: SiteCleaningSessionCreateManyInput | SiteCleaningSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteCleaningSession createManyAndReturn
   */
  export type SiteCleaningSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningSession
     */
    select?: SiteCleaningSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningSession
     */
    omit?: SiteCleaningSessionOmit<ExtArgs> | null
    /**
     * The data used to create many SiteCleaningSessions.
     */
    data: SiteCleaningSessionCreateManyInput | SiteCleaningSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteCleaningSession update
   */
  export type SiteCleaningSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningSession
     */
    select?: SiteCleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningSession
     */
    omit?: SiteCleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a SiteCleaningSession.
     */
    data: XOR<SiteCleaningSessionUpdateInput, SiteCleaningSessionUncheckedUpdateInput>
    /**
     * Choose, which SiteCleaningSession to update.
     */
    where: SiteCleaningSessionWhereUniqueInput
  }

  /**
   * SiteCleaningSession updateMany
   */
  export type SiteCleaningSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteCleaningSessions.
     */
    data: XOR<SiteCleaningSessionUpdateManyMutationInput, SiteCleaningSessionUncheckedUpdateManyInput>
    /**
     * Filter which SiteCleaningSessions to update
     */
    where?: SiteCleaningSessionWhereInput
    /**
     * Limit how many SiteCleaningSessions to update.
     */
    limit?: number
  }

  /**
   * SiteCleaningSession updateManyAndReturn
   */
  export type SiteCleaningSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningSession
     */
    select?: SiteCleaningSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningSession
     */
    omit?: SiteCleaningSessionOmit<ExtArgs> | null
    /**
     * The data used to update SiteCleaningSessions.
     */
    data: XOR<SiteCleaningSessionUpdateManyMutationInput, SiteCleaningSessionUncheckedUpdateManyInput>
    /**
     * Filter which SiteCleaningSessions to update
     */
    where?: SiteCleaningSessionWhereInput
    /**
     * Limit how many SiteCleaningSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteCleaningSession upsert
   */
  export type SiteCleaningSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningSession
     */
    select?: SiteCleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningSession
     */
    omit?: SiteCleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the SiteCleaningSession to update in case it exists.
     */
    where: SiteCleaningSessionWhereUniqueInput
    /**
     * In case the SiteCleaningSession found by the `where` argument doesn't exist, create a new SiteCleaningSession with this data.
     */
    create: XOR<SiteCleaningSessionCreateInput, SiteCleaningSessionUncheckedCreateInput>
    /**
     * In case the SiteCleaningSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteCleaningSessionUpdateInput, SiteCleaningSessionUncheckedUpdateInput>
  }

  /**
   * SiteCleaningSession delete
   */
  export type SiteCleaningSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningSession
     */
    select?: SiteCleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningSession
     */
    omit?: SiteCleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningSessionInclude<ExtArgs> | null
    /**
     * Filter which SiteCleaningSession to delete.
     */
    where: SiteCleaningSessionWhereUniqueInput
  }

  /**
   * SiteCleaningSession deleteMany
   */
  export type SiteCleaningSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteCleaningSessions to delete
     */
    where?: SiteCleaningSessionWhereInput
    /**
     * Limit how many SiteCleaningSessions to delete.
     */
    limit?: number
  }

  /**
   * SiteCleaningSession.photos
   */
  export type SiteCleaningSession$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningPhoto
     */
    select?: SiteCleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningPhoto
     */
    omit?: SiteCleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningPhotoInclude<ExtArgs> | null
    where?: SiteCleaningPhotoWhereInput
    orderBy?: SiteCleaningPhotoOrderByWithRelationInput | SiteCleaningPhotoOrderByWithRelationInput[]
    cursor?: SiteCleaningPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteCleaningPhotoScalarFieldEnum | SiteCleaningPhotoScalarFieldEnum[]
  }

  /**
   * SiteCleaningSession.checklist
   */
  export type SiteCleaningSession$checklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningChecklist
     */
    select?: SiteCleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningChecklist
     */
    omit?: SiteCleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningChecklistInclude<ExtArgs> | null
    where?: SiteCleaningChecklistWhereInput
    orderBy?: SiteCleaningChecklistOrderByWithRelationInput | SiteCleaningChecklistOrderByWithRelationInput[]
    cursor?: SiteCleaningChecklistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteCleaningChecklistScalarFieldEnum | SiteCleaningChecklistScalarFieldEnum[]
  }

  /**
   * SiteCleaningSession.laundryManager
   */
  export type SiteCleaningSession$laundryManagerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryManager
     */
    select?: LaundryManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryManager
     */
    omit?: LaundryManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryManagerInclude<ExtArgs> | null
    where?: LaundryManagerWhereInput
  }

  /**
   * SiteCleaningSession.cleaningAgent
   */
  export type SiteCleaningSession$cleaningAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * SiteCleaningSession without action
   */
  export type SiteCleaningSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningSession
     */
    select?: SiteCleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningSession
     */
    omit?: SiteCleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningSessionInclude<ExtArgs> | null
  }


  /**
   * Model LaundryManager
   */

  export type AggregateLaundryManager = {
    _count: LaundryManagerCountAggregateOutputType | null
    _min: LaundryManagerMinAggregateOutputType | null
    _max: LaundryManagerMaxAggregateOutputType | null
  }

  export type LaundryManagerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryManagerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryManagerCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaundryManagerMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryManagerMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryManagerCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaundryManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaundryManager to aggregate.
     */
    where?: LaundryManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryManagers to fetch.
     */
    orderBy?: LaundryManagerOrderByWithRelationInput | LaundryManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaundryManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaundryManagers
    **/
    _count?: true | LaundryManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaundryManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaundryManagerMaxAggregateInputType
  }

  export type GetLaundryManagerAggregateType<T extends LaundryManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateLaundryManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaundryManager[P]>
      : GetScalarType<T[P], AggregateLaundryManager[P]>
  }




  export type LaundryManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaundryManagerWhereInput
    orderBy?: LaundryManagerOrderByWithAggregationInput | LaundryManagerOrderByWithAggregationInput[]
    by: LaundryManagerScalarFieldEnum[] | LaundryManagerScalarFieldEnum
    having?: LaundryManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaundryManagerCountAggregateInputType | true
    _min?: LaundryManagerMinAggregateInputType
    _max?: LaundryManagerMaxAggregateInputType
  }

  export type LaundryManagerGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: LaundryManagerCountAggregateOutputType | null
    _min: LaundryManagerMinAggregateOutputType | null
    _max: LaundryManagerMaxAggregateOutputType | null
  }

  type GetLaundryManagerGroupByPayload<T extends LaundryManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LaundryManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaundryManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaundryManagerGroupByOutputType[P]>
            : GetScalarType<T[P], LaundryManagerGroupByOutputType[P]>
        }
      >
    >


  export type LaundryManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    products?: boolean | LaundryManager$productsArgs<ExtArgs>
    orders?: boolean | LaundryManager$ordersArgs<ExtArgs>
    deliveryNotes?: boolean | LaundryManager$deliveryNotesArgs<ExtArgs>
    siteCleaningSessions?: boolean | LaundryManager$siteCleaningSessionsArgs<ExtArgs>
    _count?: boolean | LaundryManagerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laundryManager"]>

  export type LaundryManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laundryManager"]>

  export type LaundryManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laundryManager"]>

  export type LaundryManagerSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LaundryManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["laundryManager"]>
  export type LaundryManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    products?: boolean | LaundryManager$productsArgs<ExtArgs>
    orders?: boolean | LaundryManager$ordersArgs<ExtArgs>
    deliveryNotes?: boolean | LaundryManager$deliveryNotesArgs<ExtArgs>
    siteCleaningSessions?: boolean | LaundryManager$siteCleaningSessionsArgs<ExtArgs>
    _count?: boolean | LaundryManagerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LaundryManagerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LaundryManagerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LaundryManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LaundryManager"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      products: Prisma.$ProductPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      deliveryNotes: Prisma.$DeliveryNotePayload<ExtArgs>[]
      siteCleaningSessions: Prisma.$SiteCleaningSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["laundryManager"]>
    composites: {}
  }

  type LaundryManagerGetPayload<S extends boolean | null | undefined | LaundryManagerDefaultArgs> = $Result.GetResult<Prisma.$LaundryManagerPayload, S>

  type LaundryManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LaundryManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LaundryManagerCountAggregateInputType | true
    }

  export interface LaundryManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LaundryManager'], meta: { name: 'LaundryManager' } }
    /**
     * Find zero or one LaundryManager that matches the filter.
     * @param {LaundryManagerFindUniqueArgs} args - Arguments to find a LaundryManager
     * @example
     * // Get one LaundryManager
     * const laundryManager = await prisma.laundryManager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LaundryManagerFindUniqueArgs>(args: SelectSubset<T, LaundryManagerFindUniqueArgs<ExtArgs>>): Prisma__LaundryManagerClient<$Result.GetResult<Prisma.$LaundryManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LaundryManager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LaundryManagerFindUniqueOrThrowArgs} args - Arguments to find a LaundryManager
     * @example
     * // Get one LaundryManager
     * const laundryManager = await prisma.laundryManager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LaundryManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, LaundryManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LaundryManagerClient<$Result.GetResult<Prisma.$LaundryManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LaundryManager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryManagerFindFirstArgs} args - Arguments to find a LaundryManager
     * @example
     * // Get one LaundryManager
     * const laundryManager = await prisma.laundryManager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LaundryManagerFindFirstArgs>(args?: SelectSubset<T, LaundryManagerFindFirstArgs<ExtArgs>>): Prisma__LaundryManagerClient<$Result.GetResult<Prisma.$LaundryManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LaundryManager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryManagerFindFirstOrThrowArgs} args - Arguments to find a LaundryManager
     * @example
     * // Get one LaundryManager
     * const laundryManager = await prisma.laundryManager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LaundryManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, LaundryManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__LaundryManagerClient<$Result.GetResult<Prisma.$LaundryManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LaundryManagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaundryManagers
     * const laundryManagers = await prisma.laundryManager.findMany()
     * 
     * // Get first 10 LaundryManagers
     * const laundryManagers = await prisma.laundryManager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laundryManagerWithIdOnly = await prisma.laundryManager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LaundryManagerFindManyArgs>(args?: SelectSubset<T, LaundryManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LaundryManager.
     * @param {LaundryManagerCreateArgs} args - Arguments to create a LaundryManager.
     * @example
     * // Create one LaundryManager
     * const LaundryManager = await prisma.laundryManager.create({
     *   data: {
     *     // ... data to create a LaundryManager
     *   }
     * })
     * 
     */
    create<T extends LaundryManagerCreateArgs>(args: SelectSubset<T, LaundryManagerCreateArgs<ExtArgs>>): Prisma__LaundryManagerClient<$Result.GetResult<Prisma.$LaundryManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LaundryManagers.
     * @param {LaundryManagerCreateManyArgs} args - Arguments to create many LaundryManagers.
     * @example
     * // Create many LaundryManagers
     * const laundryManager = await prisma.laundryManager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LaundryManagerCreateManyArgs>(args?: SelectSubset<T, LaundryManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LaundryManagers and returns the data saved in the database.
     * @param {LaundryManagerCreateManyAndReturnArgs} args - Arguments to create many LaundryManagers.
     * @example
     * // Create many LaundryManagers
     * const laundryManager = await prisma.laundryManager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LaundryManagers and only return the `id`
     * const laundryManagerWithIdOnly = await prisma.laundryManager.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LaundryManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, LaundryManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LaundryManager.
     * @param {LaundryManagerDeleteArgs} args - Arguments to delete one LaundryManager.
     * @example
     * // Delete one LaundryManager
     * const LaundryManager = await prisma.laundryManager.delete({
     *   where: {
     *     // ... filter to delete one LaundryManager
     *   }
     * })
     * 
     */
    delete<T extends LaundryManagerDeleteArgs>(args: SelectSubset<T, LaundryManagerDeleteArgs<ExtArgs>>): Prisma__LaundryManagerClient<$Result.GetResult<Prisma.$LaundryManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LaundryManager.
     * @param {LaundryManagerUpdateArgs} args - Arguments to update one LaundryManager.
     * @example
     * // Update one LaundryManager
     * const laundryManager = await prisma.laundryManager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LaundryManagerUpdateArgs>(args: SelectSubset<T, LaundryManagerUpdateArgs<ExtArgs>>): Prisma__LaundryManagerClient<$Result.GetResult<Prisma.$LaundryManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LaundryManagers.
     * @param {LaundryManagerDeleteManyArgs} args - Arguments to filter LaundryManagers to delete.
     * @example
     * // Delete a few LaundryManagers
     * const { count } = await prisma.laundryManager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LaundryManagerDeleteManyArgs>(args?: SelectSubset<T, LaundryManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaundryManagers
     * const laundryManager = await prisma.laundryManager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LaundryManagerUpdateManyArgs>(args: SelectSubset<T, LaundryManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryManagers and returns the data updated in the database.
     * @param {LaundryManagerUpdateManyAndReturnArgs} args - Arguments to update many LaundryManagers.
     * @example
     * // Update many LaundryManagers
     * const laundryManager = await prisma.laundryManager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LaundryManagers and only return the `id`
     * const laundryManagerWithIdOnly = await prisma.laundryManager.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LaundryManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, LaundryManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LaundryManager.
     * @param {LaundryManagerUpsertArgs} args - Arguments to update or create a LaundryManager.
     * @example
     * // Update or create a LaundryManager
     * const laundryManager = await prisma.laundryManager.upsert({
     *   create: {
     *     // ... data to create a LaundryManager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaundryManager we want to update
     *   }
     * })
     */
    upsert<T extends LaundryManagerUpsertArgs>(args: SelectSubset<T, LaundryManagerUpsertArgs<ExtArgs>>): Prisma__LaundryManagerClient<$Result.GetResult<Prisma.$LaundryManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LaundryManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryManagerCountArgs} args - Arguments to filter LaundryManagers to count.
     * @example
     * // Count the number of LaundryManagers
     * const count = await prisma.laundryManager.count({
     *   where: {
     *     // ... the filter for the LaundryManagers we want to count
     *   }
     * })
    **/
    count<T extends LaundryManagerCountArgs>(
      args?: Subset<T, LaundryManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaundryManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaundryManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaundryManagerAggregateArgs>(args: Subset<T, LaundryManagerAggregateArgs>): Prisma.PrismaPromise<GetLaundryManagerAggregateType<T>>

    /**
     * Group by LaundryManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaundryManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaundryManagerGroupByArgs['orderBy'] }
        : { orderBy?: LaundryManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaundryManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaundryManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LaundryManager model
   */
  readonly fields: LaundryManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LaundryManager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LaundryManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    products<T extends LaundryManager$productsArgs<ExtArgs> = {}>(args?: Subset<T, LaundryManager$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends LaundryManager$ordersArgs<ExtArgs> = {}>(args?: Subset<T, LaundryManager$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryNotes<T extends LaundryManager$deliveryNotesArgs<ExtArgs> = {}>(args?: Subset<T, LaundryManager$deliveryNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    siteCleaningSessions<T extends LaundryManager$siteCleaningSessionsArgs<ExtArgs> = {}>(args?: Subset<T, LaundryManager$siteCleaningSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteCleaningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LaundryManager model
   */
  interface LaundryManagerFieldRefs {
    readonly id: FieldRef<"LaundryManager", 'String'>
    readonly userId: FieldRef<"LaundryManager", 'String'>
    readonly createdAt: FieldRef<"LaundryManager", 'DateTime'>
    readonly updatedAt: FieldRef<"LaundryManager", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LaundryManager findUnique
   */
  export type LaundryManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryManager
     */
    select?: LaundryManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryManager
     */
    omit?: LaundryManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryManagerInclude<ExtArgs> | null
    /**
     * Filter, which LaundryManager to fetch.
     */
    where: LaundryManagerWhereUniqueInput
  }

  /**
   * LaundryManager findUniqueOrThrow
   */
  export type LaundryManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryManager
     */
    select?: LaundryManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryManager
     */
    omit?: LaundryManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryManagerInclude<ExtArgs> | null
    /**
     * Filter, which LaundryManager to fetch.
     */
    where: LaundryManagerWhereUniqueInput
  }

  /**
   * LaundryManager findFirst
   */
  export type LaundryManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryManager
     */
    select?: LaundryManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryManager
     */
    omit?: LaundryManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryManagerInclude<ExtArgs> | null
    /**
     * Filter, which LaundryManager to fetch.
     */
    where?: LaundryManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryManagers to fetch.
     */
    orderBy?: LaundryManagerOrderByWithRelationInput | LaundryManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryManagers.
     */
    cursor?: LaundryManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryManagers.
     */
    distinct?: LaundryManagerScalarFieldEnum | LaundryManagerScalarFieldEnum[]
  }

  /**
   * LaundryManager findFirstOrThrow
   */
  export type LaundryManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryManager
     */
    select?: LaundryManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryManager
     */
    omit?: LaundryManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryManagerInclude<ExtArgs> | null
    /**
     * Filter, which LaundryManager to fetch.
     */
    where?: LaundryManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryManagers to fetch.
     */
    orderBy?: LaundryManagerOrderByWithRelationInput | LaundryManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryManagers.
     */
    cursor?: LaundryManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryManagers.
     */
    distinct?: LaundryManagerScalarFieldEnum | LaundryManagerScalarFieldEnum[]
  }

  /**
   * LaundryManager findMany
   */
  export type LaundryManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryManager
     */
    select?: LaundryManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryManager
     */
    omit?: LaundryManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryManagerInclude<ExtArgs> | null
    /**
     * Filter, which LaundryManagers to fetch.
     */
    where?: LaundryManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryManagers to fetch.
     */
    orderBy?: LaundryManagerOrderByWithRelationInput | LaundryManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaundryManagers.
     */
    cursor?: LaundryManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryManagers.
     */
    skip?: number
    distinct?: LaundryManagerScalarFieldEnum | LaundryManagerScalarFieldEnum[]
  }

  /**
   * LaundryManager create
   */
  export type LaundryManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryManager
     */
    select?: LaundryManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryManager
     */
    omit?: LaundryManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a LaundryManager.
     */
    data: XOR<LaundryManagerCreateInput, LaundryManagerUncheckedCreateInput>
  }

  /**
   * LaundryManager createMany
   */
  export type LaundryManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LaundryManagers.
     */
    data: LaundryManagerCreateManyInput | LaundryManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LaundryManager createManyAndReturn
   */
  export type LaundryManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryManager
     */
    select?: LaundryManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryManager
     */
    omit?: LaundryManagerOmit<ExtArgs> | null
    /**
     * The data used to create many LaundryManagers.
     */
    data: LaundryManagerCreateManyInput | LaundryManagerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryManagerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LaundryManager update
   */
  export type LaundryManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryManager
     */
    select?: LaundryManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryManager
     */
    omit?: LaundryManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a LaundryManager.
     */
    data: XOR<LaundryManagerUpdateInput, LaundryManagerUncheckedUpdateInput>
    /**
     * Choose, which LaundryManager to update.
     */
    where: LaundryManagerWhereUniqueInput
  }

  /**
   * LaundryManager updateMany
   */
  export type LaundryManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LaundryManagers.
     */
    data: XOR<LaundryManagerUpdateManyMutationInput, LaundryManagerUncheckedUpdateManyInput>
    /**
     * Filter which LaundryManagers to update
     */
    where?: LaundryManagerWhereInput
    /**
     * Limit how many LaundryManagers to update.
     */
    limit?: number
  }

  /**
   * LaundryManager updateManyAndReturn
   */
  export type LaundryManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryManager
     */
    select?: LaundryManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryManager
     */
    omit?: LaundryManagerOmit<ExtArgs> | null
    /**
     * The data used to update LaundryManagers.
     */
    data: XOR<LaundryManagerUpdateManyMutationInput, LaundryManagerUncheckedUpdateManyInput>
    /**
     * Filter which LaundryManagers to update
     */
    where?: LaundryManagerWhereInput
    /**
     * Limit how many LaundryManagers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryManagerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LaundryManager upsert
   */
  export type LaundryManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryManager
     */
    select?: LaundryManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryManager
     */
    omit?: LaundryManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the LaundryManager to update in case it exists.
     */
    where: LaundryManagerWhereUniqueInput
    /**
     * In case the LaundryManager found by the `where` argument doesn't exist, create a new LaundryManager with this data.
     */
    create: XOR<LaundryManagerCreateInput, LaundryManagerUncheckedCreateInput>
    /**
     * In case the LaundryManager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaundryManagerUpdateInput, LaundryManagerUncheckedUpdateInput>
  }

  /**
   * LaundryManager delete
   */
  export type LaundryManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryManager
     */
    select?: LaundryManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryManager
     */
    omit?: LaundryManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryManagerInclude<ExtArgs> | null
    /**
     * Filter which LaundryManager to delete.
     */
    where: LaundryManagerWhereUniqueInput
  }

  /**
   * LaundryManager deleteMany
   */
  export type LaundryManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaundryManagers to delete
     */
    where?: LaundryManagerWhereInput
    /**
     * Limit how many LaundryManagers to delete.
     */
    limit?: number
  }

  /**
   * LaundryManager.products
   */
  export type LaundryManager$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * LaundryManager.orders
   */
  export type LaundryManager$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * LaundryManager.deliveryNotes
   */
  export type LaundryManager$deliveryNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    where?: DeliveryNoteWhereInput
    orderBy?: DeliveryNoteOrderByWithRelationInput | DeliveryNoteOrderByWithRelationInput[]
    cursor?: DeliveryNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryNoteScalarFieldEnum | DeliveryNoteScalarFieldEnum[]
  }

  /**
   * LaundryManager.siteCleaningSessions
   */
  export type LaundryManager$siteCleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningSession
     */
    select?: SiteCleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningSession
     */
    omit?: SiteCleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningSessionInclude<ExtArgs> | null
    where?: SiteCleaningSessionWhereInput
    orderBy?: SiteCleaningSessionOrderByWithRelationInput | SiteCleaningSessionOrderByWithRelationInput[]
    cursor?: SiteCleaningSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteCleaningSessionScalarFieldEnum | SiteCleaningSessionScalarFieldEnum[]
  }

  /**
   * LaundryManager without action
   */
  export type LaundryManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryManager
     */
    select?: LaundryManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryManager
     */
    omit?: LaundryManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryManagerInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    stock: number | null
    createdAt: Date | null
    updatedAt: Date | null
    laundryManagerId: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    stock: number | null
    createdAt: Date | null
    updatedAt: Date | null
    laundryManagerId: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    stock: number
    createdAt: number
    updatedAt: number
    laundryManagerId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    stock?: true
    createdAt?: true
    updatedAt?: true
    laundryManagerId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    stock?: true
    createdAt?: true
    updatedAt?: true
    laundryManagerId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    stock?: true
    createdAt?: true
    updatedAt?: true
    laundryManagerId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    description: string
    price: number | null
    stock: number | null
    createdAt: Date
    updatedAt: Date
    laundryManagerId: string
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    laundryManagerId?: boolean
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    laundryManagerId?: boolean
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    laundryManagerId?: boolean
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    laundryManagerId?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "stock" | "createdAt" | "updatedAt" | "laundryManagerId", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      laundryManager: Prisma.$LaundryManagerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      price: number | null
      stock: number | null
      createdAt: Date
      updatedAt: Date
      laundryManagerId: string
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    laundryManager<T extends LaundryManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LaundryManagerDefaultArgs<ExtArgs>>): Prisma__LaundryManagerClient<$Result.GetResult<Prisma.$LaundryManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly laundryManagerId: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    total: number | null
  }

  export type OrderSumAggregateOutputType = {
    total: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.OrderStatus | null
    receivedDate: Date | null
    deliveryDate: Date | null
    client: string | null
    address: string | null
    phone: string | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
    laundryManagerId: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.OrderStatus | null
    receivedDate: Date | null
    deliveryDate: Date | null
    client: string | null
    address: string | null
    phone: string | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
    laundryManagerId: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    receivedDate: number
    deliveryDate: number
    client: number
    address: number
    phone: number
    total: number
    createdAt: number
    updatedAt: number
    laundryManagerId: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    total?: true
  }

  export type OrderSumAggregateInputType = {
    total?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    receivedDate?: true
    deliveryDate?: true
    client?: true
    address?: true
    phone?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    laundryManagerId?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    receivedDate?: true
    deliveryDate?: true
    client?: true
    address?: true
    phone?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    laundryManagerId?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    receivedDate?: true
    deliveryDate?: true
    client?: true
    address?: true
    phone?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    laundryManagerId?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    name: string
    description: string
    status: $Enums.OrderStatus
    receivedDate: Date | null
    deliveryDate: Date | null
    client: string | null
    address: string | null
    phone: string | null
    total: number | null
    createdAt: Date
    updatedAt: Date
    laundryManagerId: string
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    receivedDate?: boolean
    deliveryDate?: boolean
    client?: boolean
    address?: boolean
    phone?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    laundryManagerId?: boolean
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    deliveryNotes?: boolean | Order$deliveryNotesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    receivedDate?: boolean
    deliveryDate?: boolean
    client?: boolean
    address?: boolean
    phone?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    laundryManagerId?: boolean
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    receivedDate?: boolean
    deliveryDate?: boolean
    client?: boolean
    address?: boolean
    phone?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    laundryManagerId?: boolean
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    receivedDate?: boolean
    deliveryDate?: boolean
    client?: boolean
    address?: boolean
    phone?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    laundryManagerId?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "receivedDate" | "deliveryDate" | "client" | "address" | "phone" | "total" | "createdAt" | "updatedAt" | "laundryManagerId", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    deliveryNotes?: boolean | Order$deliveryNotesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      laundryManager: Prisma.$LaundryManagerPayload<ExtArgs>
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      deliveryNotes: Prisma.$DeliveryNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      status: $Enums.OrderStatus
      receivedDate: Date | null
      deliveryDate: Date | null
      client: string | null
      address: string | null
      phone: string | null
      total: number | null
      createdAt: Date
      updatedAt: Date
      laundryManagerId: string
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    laundryManager<T extends LaundryManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LaundryManagerDefaultArgs<ExtArgs>>): Prisma__LaundryManagerClient<$Result.GetResult<Prisma.$LaundryManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderItems<T extends Order$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryNotes<T extends Order$deliveryNotesArgs<ExtArgs> = {}>(args?: Subset<T, Order$deliveryNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly name: FieldRef<"Order", 'String'>
    readonly description: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly receivedDate: FieldRef<"Order", 'DateTime'>
    readonly deliveryDate: FieldRef<"Order", 'DateTime'>
    readonly client: FieldRef<"Order", 'String'>
    readonly address: FieldRef<"Order", 'String'>
    readonly phone: FieldRef<"Order", 'String'>
    readonly total: FieldRef<"Order", 'Float'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly laundryManagerId: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.orderItems
   */
  export type Order$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.deliveryNotes
   */
  export type Order$deliveryNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    where?: DeliveryNoteWhereInput
    orderBy?: DeliveryNoteOrderByWithRelationInput | DeliveryNoteOrderByWithRelationInput[]
    cursor?: DeliveryNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryNoteScalarFieldEnum | DeliveryNoteScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    priority: string | null
    propertyId: string | null
    agentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    priority: string | null
    propertyId: string | null
    agentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    propertyId: number
    agentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TicketMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    propertyId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    propertyId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    propertyId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    title: string
    description: string
    status: $Enums.TicketStatus
    priority: string | null
    propertyId: string
    agentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    propertyId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | Ticket$agentArgs<ExtArgs>
    photos?: boolean | Ticket$photosArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    propertyId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | Ticket$agentArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    propertyId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | Ticket$agentArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    propertyId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "priority" | "propertyId" | "agentId" | "createdAt" | "updatedAt", ExtArgs["result"]["ticket"]>
  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | Ticket$agentArgs<ExtArgs>
    photos?: boolean | Ticket$photosArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | Ticket$agentArgs<ExtArgs>
  }
  export type TicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | Ticket$agentArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs> | null
      photos: Prisma.$TicketPhotoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      status: $Enums.TicketStatus
      priority: string | null
      propertyId: string
      agentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets and returns the data updated in the database.
     * @param {TicketUpdateManyAndReturnArgs} args - Arguments to update many Tickets.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends Ticket$agentArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    photos<T extends Ticket$photosArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
    readonly title: FieldRef<"Ticket", 'String'>
    readonly description: FieldRef<"Ticket", 'String'>
    readonly status: FieldRef<"Ticket", 'TicketStatus'>
    readonly priority: FieldRef<"Ticket", 'String'>
    readonly propertyId: FieldRef<"Ticket", 'String'>
    readonly agentId: FieldRef<"Ticket", 'String'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
    readonly updatedAt: FieldRef<"Ticket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Ticket updateManyAndReturn
   */
  export type TicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Ticket.agent
   */
  export type Ticket$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Ticket.photos
   */
  export type Ticket$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    where?: TicketPhotoWhereInput
    orderBy?: TicketPhotoOrderByWithRelationInput | TicketPhotoOrderByWithRelationInput[]
    cursor?: TicketPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketPhotoScalarFieldEnum | TicketPhotoScalarFieldEnum[]
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    amount: number | null
    currency: string | null
    method: string | null
    status: string | null
    propertyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    currency: string | null
    method: string | null
    status: string | null
    propertyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    amount: number
    currency: number
    method: number
    status: number
    propertyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    propertyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    propertyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    propertyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    amount: number
    currency: string
    method: string | null
    status: string | null
    propertyId: string
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    propertyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    propertyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    propertyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    propertyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "currency" | "method" | "status" | "propertyId" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      currency: string
      method: string | null
      status: string | null
      propertyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly method: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly propertyId: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model PropertyPhoto
   */

  export type AggregatePropertyPhoto = {
    _count: PropertyPhotoCountAggregateOutputType | null
    _min: PropertyPhotoMinAggregateOutputType | null
    _max: PropertyPhotoMaxAggregateOutputType | null
  }

  export type PropertyPhotoMinAggregateOutputType = {
    id: string | null
    url: string | null
    type: string | null
    propertyId: string | null
    createdAt: Date | null
  }

  export type PropertyPhotoMaxAggregateOutputType = {
    id: string | null
    url: string | null
    type: string | null
    propertyId: string | null
    createdAt: Date | null
  }

  export type PropertyPhotoCountAggregateOutputType = {
    id: number
    url: number
    type: number
    propertyId: number
    createdAt: number
    _all: number
  }


  export type PropertyPhotoMinAggregateInputType = {
    id?: true
    url?: true
    type?: true
    propertyId?: true
    createdAt?: true
  }

  export type PropertyPhotoMaxAggregateInputType = {
    id?: true
    url?: true
    type?: true
    propertyId?: true
    createdAt?: true
  }

  export type PropertyPhotoCountAggregateInputType = {
    id?: true
    url?: true
    type?: true
    propertyId?: true
    createdAt?: true
    _all?: true
  }

  export type PropertyPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyPhoto to aggregate.
     */
    where?: PropertyPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPhotos to fetch.
     */
    orderBy?: PropertyPhotoOrderByWithRelationInput | PropertyPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyPhotos
    **/
    _count?: true | PropertyPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyPhotoMaxAggregateInputType
  }

  export type GetPropertyPhotoAggregateType<T extends PropertyPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyPhoto[P]>
      : GetScalarType<T[P], AggregatePropertyPhoto[P]>
  }




  export type PropertyPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyPhotoWhereInput
    orderBy?: PropertyPhotoOrderByWithAggregationInput | PropertyPhotoOrderByWithAggregationInput[]
    by: PropertyPhotoScalarFieldEnum[] | PropertyPhotoScalarFieldEnum
    having?: PropertyPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyPhotoCountAggregateInputType | true
    _min?: PropertyPhotoMinAggregateInputType
    _max?: PropertyPhotoMaxAggregateInputType
  }

  export type PropertyPhotoGroupByOutputType = {
    id: string
    url: string
    type: string | null
    propertyId: string
    createdAt: Date
    _count: PropertyPhotoCountAggregateOutputType | null
    _min: PropertyPhotoMinAggregateOutputType | null
    _max: PropertyPhotoMaxAggregateOutputType | null
  }

  type GetPropertyPhotoGroupByPayload<T extends PropertyPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyPhotoGroupByOutputType[P]>
        }
      >
    >


  export type PropertyPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    propertyId?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyPhoto"]>

  export type PropertyPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    propertyId?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyPhoto"]>

  export type PropertyPhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    propertyId?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyPhoto"]>

  export type PropertyPhotoSelectScalar = {
    id?: boolean
    url?: boolean
    type?: boolean
    propertyId?: boolean
    createdAt?: boolean
  }

  export type PropertyPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "type" | "propertyId" | "createdAt", ExtArgs["result"]["propertyPhoto"]>
  export type PropertyPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyPhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyPhoto"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      type: string | null
      propertyId: string
      createdAt: Date
    }, ExtArgs["result"]["propertyPhoto"]>
    composites: {}
  }

  type PropertyPhotoGetPayload<S extends boolean | null | undefined | PropertyPhotoDefaultArgs> = $Result.GetResult<Prisma.$PropertyPhotoPayload, S>

  type PropertyPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyPhotoCountAggregateInputType | true
    }

  export interface PropertyPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyPhoto'], meta: { name: 'PropertyPhoto' } }
    /**
     * Find zero or one PropertyPhoto that matches the filter.
     * @param {PropertyPhotoFindUniqueArgs} args - Arguments to find a PropertyPhoto
     * @example
     * // Get one PropertyPhoto
     * const propertyPhoto = await prisma.propertyPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyPhotoFindUniqueArgs>(args: SelectSubset<T, PropertyPhotoFindUniqueArgs<ExtArgs>>): Prisma__PropertyPhotoClient<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyPhotoFindUniqueOrThrowArgs} args - Arguments to find a PropertyPhoto
     * @example
     * // Get one PropertyPhoto
     * const propertyPhoto = await prisma.propertyPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyPhotoClient<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPhotoFindFirstArgs} args - Arguments to find a PropertyPhoto
     * @example
     * // Get one PropertyPhoto
     * const propertyPhoto = await prisma.propertyPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyPhotoFindFirstArgs>(args?: SelectSubset<T, PropertyPhotoFindFirstArgs<ExtArgs>>): Prisma__PropertyPhotoClient<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPhotoFindFirstOrThrowArgs} args - Arguments to find a PropertyPhoto
     * @example
     * // Get one PropertyPhoto
     * const propertyPhoto = await prisma.propertyPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyPhotoClient<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyPhotos
     * const propertyPhotos = await prisma.propertyPhoto.findMany()
     * 
     * // Get first 10 PropertyPhotos
     * const propertyPhotos = await prisma.propertyPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyPhotoWithIdOnly = await prisma.propertyPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyPhotoFindManyArgs>(args?: SelectSubset<T, PropertyPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyPhoto.
     * @param {PropertyPhotoCreateArgs} args - Arguments to create a PropertyPhoto.
     * @example
     * // Create one PropertyPhoto
     * const PropertyPhoto = await prisma.propertyPhoto.create({
     *   data: {
     *     // ... data to create a PropertyPhoto
     *   }
     * })
     * 
     */
    create<T extends PropertyPhotoCreateArgs>(args: SelectSubset<T, PropertyPhotoCreateArgs<ExtArgs>>): Prisma__PropertyPhotoClient<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyPhotos.
     * @param {PropertyPhotoCreateManyArgs} args - Arguments to create many PropertyPhotos.
     * @example
     * // Create many PropertyPhotos
     * const propertyPhoto = await prisma.propertyPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyPhotoCreateManyArgs>(args?: SelectSubset<T, PropertyPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyPhotos and returns the data saved in the database.
     * @param {PropertyPhotoCreateManyAndReturnArgs} args - Arguments to create many PropertyPhotos.
     * @example
     * // Create many PropertyPhotos
     * const propertyPhoto = await prisma.propertyPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyPhotos and only return the `id`
     * const propertyPhotoWithIdOnly = await prisma.propertyPhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyPhoto.
     * @param {PropertyPhotoDeleteArgs} args - Arguments to delete one PropertyPhoto.
     * @example
     * // Delete one PropertyPhoto
     * const PropertyPhoto = await prisma.propertyPhoto.delete({
     *   where: {
     *     // ... filter to delete one PropertyPhoto
     *   }
     * })
     * 
     */
    delete<T extends PropertyPhotoDeleteArgs>(args: SelectSubset<T, PropertyPhotoDeleteArgs<ExtArgs>>): Prisma__PropertyPhotoClient<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyPhoto.
     * @param {PropertyPhotoUpdateArgs} args - Arguments to update one PropertyPhoto.
     * @example
     * // Update one PropertyPhoto
     * const propertyPhoto = await prisma.propertyPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyPhotoUpdateArgs>(args: SelectSubset<T, PropertyPhotoUpdateArgs<ExtArgs>>): Prisma__PropertyPhotoClient<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyPhotos.
     * @param {PropertyPhotoDeleteManyArgs} args - Arguments to filter PropertyPhotos to delete.
     * @example
     * // Delete a few PropertyPhotos
     * const { count } = await prisma.propertyPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyPhotoDeleteManyArgs>(args?: SelectSubset<T, PropertyPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyPhotos
     * const propertyPhoto = await prisma.propertyPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyPhotoUpdateManyArgs>(args: SelectSubset<T, PropertyPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyPhotos and returns the data updated in the database.
     * @param {PropertyPhotoUpdateManyAndReturnArgs} args - Arguments to update many PropertyPhotos.
     * @example
     * // Update many PropertyPhotos
     * const propertyPhoto = await prisma.propertyPhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyPhotos and only return the `id`
     * const propertyPhotoWithIdOnly = await prisma.propertyPhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyPhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyPhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyPhoto.
     * @param {PropertyPhotoUpsertArgs} args - Arguments to update or create a PropertyPhoto.
     * @example
     * // Update or create a PropertyPhoto
     * const propertyPhoto = await prisma.propertyPhoto.upsert({
     *   create: {
     *     // ... data to create a PropertyPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyPhoto we want to update
     *   }
     * })
     */
    upsert<T extends PropertyPhotoUpsertArgs>(args: SelectSubset<T, PropertyPhotoUpsertArgs<ExtArgs>>): Prisma__PropertyPhotoClient<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPhotoCountArgs} args - Arguments to filter PropertyPhotos to count.
     * @example
     * // Count the number of PropertyPhotos
     * const count = await prisma.propertyPhoto.count({
     *   where: {
     *     // ... the filter for the PropertyPhotos we want to count
     *   }
     * })
    **/
    count<T extends PropertyPhotoCountArgs>(
      args?: Subset<T, PropertyPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyPhotoAggregateArgs>(args: Subset<T, PropertyPhotoAggregateArgs>): Prisma.PrismaPromise<GetPropertyPhotoAggregateType<T>>

    /**
     * Group by PropertyPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyPhotoGroupByArgs['orderBy'] }
        : { orderBy?: PropertyPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyPhoto model
   */
  readonly fields: PropertyPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyPhoto model
   */
  interface PropertyPhotoFieldRefs {
    readonly id: FieldRef<"PropertyPhoto", 'String'>
    readonly url: FieldRef<"PropertyPhoto", 'String'>
    readonly type: FieldRef<"PropertyPhoto", 'String'>
    readonly propertyId: FieldRef<"PropertyPhoto", 'String'>
    readonly createdAt: FieldRef<"PropertyPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyPhoto findUnique
   */
  export type PropertyPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPhoto to fetch.
     */
    where: PropertyPhotoWhereUniqueInput
  }

  /**
   * PropertyPhoto findUniqueOrThrow
   */
  export type PropertyPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPhoto to fetch.
     */
    where: PropertyPhotoWhereUniqueInput
  }

  /**
   * PropertyPhoto findFirst
   */
  export type PropertyPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPhoto to fetch.
     */
    where?: PropertyPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPhotos to fetch.
     */
    orderBy?: PropertyPhotoOrderByWithRelationInput | PropertyPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyPhotos.
     */
    cursor?: PropertyPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyPhotos.
     */
    distinct?: PropertyPhotoScalarFieldEnum | PropertyPhotoScalarFieldEnum[]
  }

  /**
   * PropertyPhoto findFirstOrThrow
   */
  export type PropertyPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPhoto to fetch.
     */
    where?: PropertyPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPhotos to fetch.
     */
    orderBy?: PropertyPhotoOrderByWithRelationInput | PropertyPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyPhotos.
     */
    cursor?: PropertyPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyPhotos.
     */
    distinct?: PropertyPhotoScalarFieldEnum | PropertyPhotoScalarFieldEnum[]
  }

  /**
   * PropertyPhoto findMany
   */
  export type PropertyPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPhotos to fetch.
     */
    where?: PropertyPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPhotos to fetch.
     */
    orderBy?: PropertyPhotoOrderByWithRelationInput | PropertyPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyPhotos.
     */
    cursor?: PropertyPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPhotos.
     */
    skip?: number
    distinct?: PropertyPhotoScalarFieldEnum | PropertyPhotoScalarFieldEnum[]
  }

  /**
   * PropertyPhoto create
   */
  export type PropertyPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyPhoto.
     */
    data: XOR<PropertyPhotoCreateInput, PropertyPhotoUncheckedCreateInput>
  }

  /**
   * PropertyPhoto createMany
   */
  export type PropertyPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyPhotos.
     */
    data: PropertyPhotoCreateManyInput | PropertyPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyPhoto createManyAndReturn
   */
  export type PropertyPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyPhotos.
     */
    data: PropertyPhotoCreateManyInput | PropertyPhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyPhoto update
   */
  export type PropertyPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyPhoto.
     */
    data: XOR<PropertyPhotoUpdateInput, PropertyPhotoUncheckedUpdateInput>
    /**
     * Choose, which PropertyPhoto to update.
     */
    where: PropertyPhotoWhereUniqueInput
  }

  /**
   * PropertyPhoto updateMany
   */
  export type PropertyPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyPhotos.
     */
    data: XOR<PropertyPhotoUpdateManyMutationInput, PropertyPhotoUncheckedUpdateManyInput>
    /**
     * Filter which PropertyPhotos to update
     */
    where?: PropertyPhotoWhereInput
    /**
     * Limit how many PropertyPhotos to update.
     */
    limit?: number
  }

  /**
   * PropertyPhoto updateManyAndReturn
   */
  export type PropertyPhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * The data used to update PropertyPhotos.
     */
    data: XOR<PropertyPhotoUpdateManyMutationInput, PropertyPhotoUncheckedUpdateManyInput>
    /**
     * Filter which PropertyPhotos to update
     */
    where?: PropertyPhotoWhereInput
    /**
     * Limit how many PropertyPhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyPhoto upsert
   */
  export type PropertyPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyPhoto to update in case it exists.
     */
    where: PropertyPhotoWhereUniqueInput
    /**
     * In case the PropertyPhoto found by the `where` argument doesn't exist, create a new PropertyPhoto with this data.
     */
    create: XOR<PropertyPhotoCreateInput, PropertyPhotoUncheckedCreateInput>
    /**
     * In case the PropertyPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyPhotoUpdateInput, PropertyPhotoUncheckedUpdateInput>
  }

  /**
   * PropertyPhoto delete
   */
  export type PropertyPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * Filter which PropertyPhoto to delete.
     */
    where: PropertyPhotoWhereUniqueInput
  }

  /**
   * PropertyPhoto deleteMany
   */
  export type PropertyPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyPhotos to delete
     */
    where?: PropertyPhotoWhereInput
    /**
     * Limit how many PropertyPhotos to delete.
     */
    limit?: number
  }

  /**
   * PropertyPhoto without action
   */
  export type PropertyPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
  }


  /**
   * Model CleaningPhoto
   */

  export type AggregateCleaningPhoto = {
    _count: CleaningPhotoCountAggregateOutputType | null
    _min: CleaningPhotoMinAggregateOutputType | null
    _max: CleaningPhotoMaxAggregateOutputType | null
  }

  export type CleaningPhotoMinAggregateOutputType = {
    id: string | null
    url: string | null
    type: string | null
    cleaningSessionId: string | null
    createdAt: Date | null
  }

  export type CleaningPhotoMaxAggregateOutputType = {
    id: string | null
    url: string | null
    type: string | null
    cleaningSessionId: string | null
    createdAt: Date | null
  }

  export type CleaningPhotoCountAggregateOutputType = {
    id: number
    url: number
    type: number
    cleaningSessionId: number
    createdAt: number
    _all: number
  }


  export type CleaningPhotoMinAggregateInputType = {
    id?: true
    url?: true
    type?: true
    cleaningSessionId?: true
    createdAt?: true
  }

  export type CleaningPhotoMaxAggregateInputType = {
    id?: true
    url?: true
    type?: true
    cleaningSessionId?: true
    createdAt?: true
  }

  export type CleaningPhotoCountAggregateInputType = {
    id?: true
    url?: true
    type?: true
    cleaningSessionId?: true
    createdAt?: true
    _all?: true
  }

  export type CleaningPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningPhoto to aggregate.
     */
    where?: CleaningPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningPhotos to fetch.
     */
    orderBy?: CleaningPhotoOrderByWithRelationInput | CleaningPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CleaningPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CleaningPhotos
    **/
    _count?: true | CleaningPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CleaningPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CleaningPhotoMaxAggregateInputType
  }

  export type GetCleaningPhotoAggregateType<T extends CleaningPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateCleaningPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCleaningPhoto[P]>
      : GetScalarType<T[P], AggregateCleaningPhoto[P]>
  }




  export type CleaningPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningPhotoWhereInput
    orderBy?: CleaningPhotoOrderByWithAggregationInput | CleaningPhotoOrderByWithAggregationInput[]
    by: CleaningPhotoScalarFieldEnum[] | CleaningPhotoScalarFieldEnum
    having?: CleaningPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CleaningPhotoCountAggregateInputType | true
    _min?: CleaningPhotoMinAggregateInputType
    _max?: CleaningPhotoMaxAggregateInputType
  }

  export type CleaningPhotoGroupByOutputType = {
    id: string
    url: string
    type: string | null
    cleaningSessionId: string
    createdAt: Date
    _count: CleaningPhotoCountAggregateOutputType | null
    _min: CleaningPhotoMinAggregateOutputType | null
    _max: CleaningPhotoMaxAggregateOutputType | null
  }

  type GetCleaningPhotoGroupByPayload<T extends CleaningPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CleaningPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CleaningPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CleaningPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], CleaningPhotoGroupByOutputType[P]>
        }
      >
    >


  export type CleaningPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    cleaningSessionId?: boolean
    createdAt?: boolean
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningPhoto"]>

  export type CleaningPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    cleaningSessionId?: boolean
    createdAt?: boolean
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningPhoto"]>

  export type CleaningPhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    cleaningSessionId?: boolean
    createdAt?: boolean
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningPhoto"]>

  export type CleaningPhotoSelectScalar = {
    id?: boolean
    url?: boolean
    type?: boolean
    cleaningSessionId?: boolean
    createdAt?: boolean
  }

  export type CleaningPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "type" | "cleaningSessionId" | "createdAt", ExtArgs["result"]["cleaningPhoto"]>
  export type CleaningPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }
  export type CleaningPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }
  export type CleaningPhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }

  export type $CleaningPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CleaningPhoto"
    objects: {
      cleaningSession: Prisma.$CleaningSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      type: string | null
      cleaningSessionId: string
      createdAt: Date
    }, ExtArgs["result"]["cleaningPhoto"]>
    composites: {}
  }

  type CleaningPhotoGetPayload<S extends boolean | null | undefined | CleaningPhotoDefaultArgs> = $Result.GetResult<Prisma.$CleaningPhotoPayload, S>

  type CleaningPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CleaningPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CleaningPhotoCountAggregateInputType | true
    }

  export interface CleaningPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CleaningPhoto'], meta: { name: 'CleaningPhoto' } }
    /**
     * Find zero or one CleaningPhoto that matches the filter.
     * @param {CleaningPhotoFindUniqueArgs} args - Arguments to find a CleaningPhoto
     * @example
     * // Get one CleaningPhoto
     * const cleaningPhoto = await prisma.cleaningPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CleaningPhotoFindUniqueArgs>(args: SelectSubset<T, CleaningPhotoFindUniqueArgs<ExtArgs>>): Prisma__CleaningPhotoClient<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CleaningPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CleaningPhotoFindUniqueOrThrowArgs} args - Arguments to find a CleaningPhoto
     * @example
     * // Get one CleaningPhoto
     * const cleaningPhoto = await prisma.cleaningPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CleaningPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, CleaningPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CleaningPhotoClient<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPhotoFindFirstArgs} args - Arguments to find a CleaningPhoto
     * @example
     * // Get one CleaningPhoto
     * const cleaningPhoto = await prisma.cleaningPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CleaningPhotoFindFirstArgs>(args?: SelectSubset<T, CleaningPhotoFindFirstArgs<ExtArgs>>): Prisma__CleaningPhotoClient<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPhotoFindFirstOrThrowArgs} args - Arguments to find a CleaningPhoto
     * @example
     * // Get one CleaningPhoto
     * const cleaningPhoto = await prisma.cleaningPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CleaningPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, CleaningPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CleaningPhotoClient<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CleaningPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CleaningPhotos
     * const cleaningPhotos = await prisma.cleaningPhoto.findMany()
     * 
     * // Get first 10 CleaningPhotos
     * const cleaningPhotos = await prisma.cleaningPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cleaningPhotoWithIdOnly = await prisma.cleaningPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CleaningPhotoFindManyArgs>(args?: SelectSubset<T, CleaningPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CleaningPhoto.
     * @param {CleaningPhotoCreateArgs} args - Arguments to create a CleaningPhoto.
     * @example
     * // Create one CleaningPhoto
     * const CleaningPhoto = await prisma.cleaningPhoto.create({
     *   data: {
     *     // ... data to create a CleaningPhoto
     *   }
     * })
     * 
     */
    create<T extends CleaningPhotoCreateArgs>(args: SelectSubset<T, CleaningPhotoCreateArgs<ExtArgs>>): Prisma__CleaningPhotoClient<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CleaningPhotos.
     * @param {CleaningPhotoCreateManyArgs} args - Arguments to create many CleaningPhotos.
     * @example
     * // Create many CleaningPhotos
     * const cleaningPhoto = await prisma.cleaningPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CleaningPhotoCreateManyArgs>(args?: SelectSubset<T, CleaningPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CleaningPhotos and returns the data saved in the database.
     * @param {CleaningPhotoCreateManyAndReturnArgs} args - Arguments to create many CleaningPhotos.
     * @example
     * // Create many CleaningPhotos
     * const cleaningPhoto = await prisma.cleaningPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CleaningPhotos and only return the `id`
     * const cleaningPhotoWithIdOnly = await prisma.cleaningPhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CleaningPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, CleaningPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CleaningPhoto.
     * @param {CleaningPhotoDeleteArgs} args - Arguments to delete one CleaningPhoto.
     * @example
     * // Delete one CleaningPhoto
     * const CleaningPhoto = await prisma.cleaningPhoto.delete({
     *   where: {
     *     // ... filter to delete one CleaningPhoto
     *   }
     * })
     * 
     */
    delete<T extends CleaningPhotoDeleteArgs>(args: SelectSubset<T, CleaningPhotoDeleteArgs<ExtArgs>>): Prisma__CleaningPhotoClient<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CleaningPhoto.
     * @param {CleaningPhotoUpdateArgs} args - Arguments to update one CleaningPhoto.
     * @example
     * // Update one CleaningPhoto
     * const cleaningPhoto = await prisma.cleaningPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CleaningPhotoUpdateArgs>(args: SelectSubset<T, CleaningPhotoUpdateArgs<ExtArgs>>): Prisma__CleaningPhotoClient<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CleaningPhotos.
     * @param {CleaningPhotoDeleteManyArgs} args - Arguments to filter CleaningPhotos to delete.
     * @example
     * // Delete a few CleaningPhotos
     * const { count } = await prisma.cleaningPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CleaningPhotoDeleteManyArgs>(args?: SelectSubset<T, CleaningPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CleaningPhotos
     * const cleaningPhoto = await prisma.cleaningPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CleaningPhotoUpdateManyArgs>(args: SelectSubset<T, CleaningPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningPhotos and returns the data updated in the database.
     * @param {CleaningPhotoUpdateManyAndReturnArgs} args - Arguments to update many CleaningPhotos.
     * @example
     * // Update many CleaningPhotos
     * const cleaningPhoto = await prisma.cleaningPhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CleaningPhotos and only return the `id`
     * const cleaningPhotoWithIdOnly = await prisma.cleaningPhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CleaningPhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, CleaningPhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CleaningPhoto.
     * @param {CleaningPhotoUpsertArgs} args - Arguments to update or create a CleaningPhoto.
     * @example
     * // Update or create a CleaningPhoto
     * const cleaningPhoto = await prisma.cleaningPhoto.upsert({
     *   create: {
     *     // ... data to create a CleaningPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CleaningPhoto we want to update
     *   }
     * })
     */
    upsert<T extends CleaningPhotoUpsertArgs>(args: SelectSubset<T, CleaningPhotoUpsertArgs<ExtArgs>>): Prisma__CleaningPhotoClient<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CleaningPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPhotoCountArgs} args - Arguments to filter CleaningPhotos to count.
     * @example
     * // Count the number of CleaningPhotos
     * const count = await prisma.cleaningPhoto.count({
     *   where: {
     *     // ... the filter for the CleaningPhotos we want to count
     *   }
     * })
    **/
    count<T extends CleaningPhotoCountArgs>(
      args?: Subset<T, CleaningPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CleaningPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CleaningPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CleaningPhotoAggregateArgs>(args: Subset<T, CleaningPhotoAggregateArgs>): Prisma.PrismaPromise<GetCleaningPhotoAggregateType<T>>

    /**
     * Group by CleaningPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CleaningPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CleaningPhotoGroupByArgs['orderBy'] }
        : { orderBy?: CleaningPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CleaningPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCleaningPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CleaningPhoto model
   */
  readonly fields: CleaningPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CleaningPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CleaningPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cleaningSession<T extends CleaningSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CleaningSessionDefaultArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CleaningPhoto model
   */
  interface CleaningPhotoFieldRefs {
    readonly id: FieldRef<"CleaningPhoto", 'String'>
    readonly url: FieldRef<"CleaningPhoto", 'String'>
    readonly type: FieldRef<"CleaningPhoto", 'String'>
    readonly cleaningSessionId: FieldRef<"CleaningPhoto", 'String'>
    readonly createdAt: FieldRef<"CleaningPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CleaningPhoto findUnique
   */
  export type CleaningPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter, which CleaningPhoto to fetch.
     */
    where: CleaningPhotoWhereUniqueInput
  }

  /**
   * CleaningPhoto findUniqueOrThrow
   */
  export type CleaningPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter, which CleaningPhoto to fetch.
     */
    where: CleaningPhotoWhereUniqueInput
  }

  /**
   * CleaningPhoto findFirst
   */
  export type CleaningPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter, which CleaningPhoto to fetch.
     */
    where?: CleaningPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningPhotos to fetch.
     */
    orderBy?: CleaningPhotoOrderByWithRelationInput | CleaningPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningPhotos.
     */
    cursor?: CleaningPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningPhotos.
     */
    distinct?: CleaningPhotoScalarFieldEnum | CleaningPhotoScalarFieldEnum[]
  }

  /**
   * CleaningPhoto findFirstOrThrow
   */
  export type CleaningPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter, which CleaningPhoto to fetch.
     */
    where?: CleaningPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningPhotos to fetch.
     */
    orderBy?: CleaningPhotoOrderByWithRelationInput | CleaningPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningPhotos.
     */
    cursor?: CleaningPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningPhotos.
     */
    distinct?: CleaningPhotoScalarFieldEnum | CleaningPhotoScalarFieldEnum[]
  }

  /**
   * CleaningPhoto findMany
   */
  export type CleaningPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter, which CleaningPhotos to fetch.
     */
    where?: CleaningPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningPhotos to fetch.
     */
    orderBy?: CleaningPhotoOrderByWithRelationInput | CleaningPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CleaningPhotos.
     */
    cursor?: CleaningPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningPhotos.
     */
    skip?: number
    distinct?: CleaningPhotoScalarFieldEnum | CleaningPhotoScalarFieldEnum[]
  }

  /**
   * CleaningPhoto create
   */
  export type CleaningPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a CleaningPhoto.
     */
    data: XOR<CleaningPhotoCreateInput, CleaningPhotoUncheckedCreateInput>
  }

  /**
   * CleaningPhoto createMany
   */
  export type CleaningPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CleaningPhotos.
     */
    data: CleaningPhotoCreateManyInput | CleaningPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CleaningPhoto createManyAndReturn
   */
  export type CleaningPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * The data used to create many CleaningPhotos.
     */
    data: CleaningPhotoCreateManyInput | CleaningPhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningPhoto update
   */
  export type CleaningPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a CleaningPhoto.
     */
    data: XOR<CleaningPhotoUpdateInput, CleaningPhotoUncheckedUpdateInput>
    /**
     * Choose, which CleaningPhoto to update.
     */
    where: CleaningPhotoWhereUniqueInput
  }

  /**
   * CleaningPhoto updateMany
   */
  export type CleaningPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CleaningPhotos.
     */
    data: XOR<CleaningPhotoUpdateManyMutationInput, CleaningPhotoUncheckedUpdateManyInput>
    /**
     * Filter which CleaningPhotos to update
     */
    where?: CleaningPhotoWhereInput
    /**
     * Limit how many CleaningPhotos to update.
     */
    limit?: number
  }

  /**
   * CleaningPhoto updateManyAndReturn
   */
  export type CleaningPhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * The data used to update CleaningPhotos.
     */
    data: XOR<CleaningPhotoUpdateManyMutationInput, CleaningPhotoUncheckedUpdateManyInput>
    /**
     * Filter which CleaningPhotos to update
     */
    where?: CleaningPhotoWhereInput
    /**
     * Limit how many CleaningPhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningPhoto upsert
   */
  export type CleaningPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the CleaningPhoto to update in case it exists.
     */
    where: CleaningPhotoWhereUniqueInput
    /**
     * In case the CleaningPhoto found by the `where` argument doesn't exist, create a new CleaningPhoto with this data.
     */
    create: XOR<CleaningPhotoCreateInput, CleaningPhotoUncheckedCreateInput>
    /**
     * In case the CleaningPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CleaningPhotoUpdateInput, CleaningPhotoUncheckedUpdateInput>
  }

  /**
   * CleaningPhoto delete
   */
  export type CleaningPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter which CleaningPhoto to delete.
     */
    where: CleaningPhotoWhereUniqueInput
  }

  /**
   * CleaningPhoto deleteMany
   */
  export type CleaningPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningPhotos to delete
     */
    where?: CleaningPhotoWhereInput
    /**
     * Limit how many CleaningPhotos to delete.
     */
    limit?: number
  }

  /**
   * CleaningPhoto without action
   */
  export type CleaningPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
  }


  /**
   * Model MaintenancePhoto
   */

  export type AggregateMaintenancePhoto = {
    _count: MaintenancePhotoCountAggregateOutputType | null
    _min: MaintenancePhotoMinAggregateOutputType | null
    _max: MaintenancePhotoMaxAggregateOutputType | null
  }

  export type MaintenancePhotoMinAggregateOutputType = {
    id: string | null
    url: string | null
    type: string | null
    maintenanceSessionId: string | null
    createdAt: Date | null
  }

  export type MaintenancePhotoMaxAggregateOutputType = {
    id: string | null
    url: string | null
    type: string | null
    maintenanceSessionId: string | null
    createdAt: Date | null
  }

  export type MaintenancePhotoCountAggregateOutputType = {
    id: number
    url: number
    type: number
    maintenanceSessionId: number
    createdAt: number
    _all: number
  }


  export type MaintenancePhotoMinAggregateInputType = {
    id?: true
    url?: true
    type?: true
    maintenanceSessionId?: true
    createdAt?: true
  }

  export type MaintenancePhotoMaxAggregateInputType = {
    id?: true
    url?: true
    type?: true
    maintenanceSessionId?: true
    createdAt?: true
  }

  export type MaintenancePhotoCountAggregateInputType = {
    id?: true
    url?: true
    type?: true
    maintenanceSessionId?: true
    createdAt?: true
    _all?: true
  }

  export type MaintenancePhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenancePhoto to aggregate.
     */
    where?: MaintenancePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenancePhotos to fetch.
     */
    orderBy?: MaintenancePhotoOrderByWithRelationInput | MaintenancePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenancePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenancePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenancePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenancePhotos
    **/
    _count?: true | MaintenancePhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenancePhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenancePhotoMaxAggregateInputType
  }

  export type GetMaintenancePhotoAggregateType<T extends MaintenancePhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenancePhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenancePhoto[P]>
      : GetScalarType<T[P], AggregateMaintenancePhoto[P]>
  }




  export type MaintenancePhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenancePhotoWhereInput
    orderBy?: MaintenancePhotoOrderByWithAggregationInput | MaintenancePhotoOrderByWithAggregationInput[]
    by: MaintenancePhotoScalarFieldEnum[] | MaintenancePhotoScalarFieldEnum
    having?: MaintenancePhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenancePhotoCountAggregateInputType | true
    _min?: MaintenancePhotoMinAggregateInputType
    _max?: MaintenancePhotoMaxAggregateInputType
  }

  export type MaintenancePhotoGroupByOutputType = {
    id: string
    url: string
    type: string | null
    maintenanceSessionId: string
    createdAt: Date
    _count: MaintenancePhotoCountAggregateOutputType | null
    _min: MaintenancePhotoMinAggregateOutputType | null
    _max: MaintenancePhotoMaxAggregateOutputType | null
  }

  type GetMaintenancePhotoGroupByPayload<T extends MaintenancePhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenancePhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenancePhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenancePhotoGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenancePhotoGroupByOutputType[P]>
        }
      >
    >


  export type MaintenancePhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    maintenanceSessionId?: boolean
    createdAt?: boolean
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenancePhoto"]>

  export type MaintenancePhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    maintenanceSessionId?: boolean
    createdAt?: boolean
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenancePhoto"]>

  export type MaintenancePhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    maintenanceSessionId?: boolean
    createdAt?: boolean
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenancePhoto"]>

  export type MaintenancePhotoSelectScalar = {
    id?: boolean
    url?: boolean
    type?: boolean
    maintenanceSessionId?: boolean
    createdAt?: boolean
  }

  export type MaintenancePhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "type" | "maintenanceSessionId" | "createdAt", ExtArgs["result"]["maintenancePhoto"]>
  export type MaintenancePhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }
  export type MaintenancePhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }
  export type MaintenancePhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }

  export type $MaintenancePhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenancePhoto"
    objects: {
      maintenanceSession: Prisma.$MaintenanceSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      type: string | null
      maintenanceSessionId: string
      createdAt: Date
    }, ExtArgs["result"]["maintenancePhoto"]>
    composites: {}
  }

  type MaintenancePhotoGetPayload<S extends boolean | null | undefined | MaintenancePhotoDefaultArgs> = $Result.GetResult<Prisma.$MaintenancePhotoPayload, S>

  type MaintenancePhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenancePhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenancePhotoCountAggregateInputType | true
    }

  export interface MaintenancePhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenancePhoto'], meta: { name: 'MaintenancePhoto' } }
    /**
     * Find zero or one MaintenancePhoto that matches the filter.
     * @param {MaintenancePhotoFindUniqueArgs} args - Arguments to find a MaintenancePhoto
     * @example
     * // Get one MaintenancePhoto
     * const maintenancePhoto = await prisma.maintenancePhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenancePhotoFindUniqueArgs>(args: SelectSubset<T, MaintenancePhotoFindUniqueArgs<ExtArgs>>): Prisma__MaintenancePhotoClient<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaintenancePhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenancePhotoFindUniqueOrThrowArgs} args - Arguments to find a MaintenancePhoto
     * @example
     * // Get one MaintenancePhoto
     * const maintenancePhoto = await prisma.maintenancePhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenancePhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenancePhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenancePhotoClient<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenancePhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenancePhotoFindFirstArgs} args - Arguments to find a MaintenancePhoto
     * @example
     * // Get one MaintenancePhoto
     * const maintenancePhoto = await prisma.maintenancePhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenancePhotoFindFirstArgs>(args?: SelectSubset<T, MaintenancePhotoFindFirstArgs<ExtArgs>>): Prisma__MaintenancePhotoClient<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenancePhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenancePhotoFindFirstOrThrowArgs} args - Arguments to find a MaintenancePhoto
     * @example
     * // Get one MaintenancePhoto
     * const maintenancePhoto = await prisma.maintenancePhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenancePhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenancePhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenancePhotoClient<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaintenancePhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenancePhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenancePhotos
     * const maintenancePhotos = await prisma.maintenancePhoto.findMany()
     * 
     * // Get first 10 MaintenancePhotos
     * const maintenancePhotos = await prisma.maintenancePhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenancePhotoWithIdOnly = await prisma.maintenancePhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenancePhotoFindManyArgs>(args?: SelectSubset<T, MaintenancePhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaintenancePhoto.
     * @param {MaintenancePhotoCreateArgs} args - Arguments to create a MaintenancePhoto.
     * @example
     * // Create one MaintenancePhoto
     * const MaintenancePhoto = await prisma.maintenancePhoto.create({
     *   data: {
     *     // ... data to create a MaintenancePhoto
     *   }
     * })
     * 
     */
    create<T extends MaintenancePhotoCreateArgs>(args: SelectSubset<T, MaintenancePhotoCreateArgs<ExtArgs>>): Prisma__MaintenancePhotoClient<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaintenancePhotos.
     * @param {MaintenancePhotoCreateManyArgs} args - Arguments to create many MaintenancePhotos.
     * @example
     * // Create many MaintenancePhotos
     * const maintenancePhoto = await prisma.maintenancePhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenancePhotoCreateManyArgs>(args?: SelectSubset<T, MaintenancePhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenancePhotos and returns the data saved in the database.
     * @param {MaintenancePhotoCreateManyAndReturnArgs} args - Arguments to create many MaintenancePhotos.
     * @example
     * // Create many MaintenancePhotos
     * const maintenancePhoto = await prisma.maintenancePhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenancePhotos and only return the `id`
     * const maintenancePhotoWithIdOnly = await prisma.maintenancePhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenancePhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenancePhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaintenancePhoto.
     * @param {MaintenancePhotoDeleteArgs} args - Arguments to delete one MaintenancePhoto.
     * @example
     * // Delete one MaintenancePhoto
     * const MaintenancePhoto = await prisma.maintenancePhoto.delete({
     *   where: {
     *     // ... filter to delete one MaintenancePhoto
     *   }
     * })
     * 
     */
    delete<T extends MaintenancePhotoDeleteArgs>(args: SelectSubset<T, MaintenancePhotoDeleteArgs<ExtArgs>>): Prisma__MaintenancePhotoClient<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaintenancePhoto.
     * @param {MaintenancePhotoUpdateArgs} args - Arguments to update one MaintenancePhoto.
     * @example
     * // Update one MaintenancePhoto
     * const maintenancePhoto = await prisma.maintenancePhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenancePhotoUpdateArgs>(args: SelectSubset<T, MaintenancePhotoUpdateArgs<ExtArgs>>): Prisma__MaintenancePhotoClient<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaintenancePhotos.
     * @param {MaintenancePhotoDeleteManyArgs} args - Arguments to filter MaintenancePhotos to delete.
     * @example
     * // Delete a few MaintenancePhotos
     * const { count } = await prisma.maintenancePhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenancePhotoDeleteManyArgs>(args?: SelectSubset<T, MaintenancePhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenancePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenancePhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenancePhotos
     * const maintenancePhoto = await prisma.maintenancePhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenancePhotoUpdateManyArgs>(args: SelectSubset<T, MaintenancePhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenancePhotos and returns the data updated in the database.
     * @param {MaintenancePhotoUpdateManyAndReturnArgs} args - Arguments to update many MaintenancePhotos.
     * @example
     * // Update many MaintenancePhotos
     * const maintenancePhoto = await prisma.maintenancePhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaintenancePhotos and only return the `id`
     * const maintenancePhotoWithIdOnly = await prisma.maintenancePhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintenancePhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintenancePhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaintenancePhoto.
     * @param {MaintenancePhotoUpsertArgs} args - Arguments to update or create a MaintenancePhoto.
     * @example
     * // Update or create a MaintenancePhoto
     * const maintenancePhoto = await prisma.maintenancePhoto.upsert({
     *   create: {
     *     // ... data to create a MaintenancePhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenancePhoto we want to update
     *   }
     * })
     */
    upsert<T extends MaintenancePhotoUpsertArgs>(args: SelectSubset<T, MaintenancePhotoUpsertArgs<ExtArgs>>): Prisma__MaintenancePhotoClient<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaintenancePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenancePhotoCountArgs} args - Arguments to filter MaintenancePhotos to count.
     * @example
     * // Count the number of MaintenancePhotos
     * const count = await prisma.maintenancePhoto.count({
     *   where: {
     *     // ... the filter for the MaintenancePhotos we want to count
     *   }
     * })
    **/
    count<T extends MaintenancePhotoCountArgs>(
      args?: Subset<T, MaintenancePhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenancePhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenancePhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenancePhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenancePhotoAggregateArgs>(args: Subset<T, MaintenancePhotoAggregateArgs>): Prisma.PrismaPromise<GetMaintenancePhotoAggregateType<T>>

    /**
     * Group by MaintenancePhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenancePhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenancePhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenancePhotoGroupByArgs['orderBy'] }
        : { orderBy?: MaintenancePhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenancePhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenancePhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenancePhoto model
   */
  readonly fields: MaintenancePhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenancePhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenancePhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    maintenanceSession<T extends MaintenanceSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceSessionDefaultArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenancePhoto model
   */
  interface MaintenancePhotoFieldRefs {
    readonly id: FieldRef<"MaintenancePhoto", 'String'>
    readonly url: FieldRef<"MaintenancePhoto", 'String'>
    readonly type: FieldRef<"MaintenancePhoto", 'String'>
    readonly maintenanceSessionId: FieldRef<"MaintenancePhoto", 'String'>
    readonly createdAt: FieldRef<"MaintenancePhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaintenancePhoto findUnique
   */
  export type MaintenancePhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * Filter, which MaintenancePhoto to fetch.
     */
    where: MaintenancePhotoWhereUniqueInput
  }

  /**
   * MaintenancePhoto findUniqueOrThrow
   */
  export type MaintenancePhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * Filter, which MaintenancePhoto to fetch.
     */
    where: MaintenancePhotoWhereUniqueInput
  }

  /**
   * MaintenancePhoto findFirst
   */
  export type MaintenancePhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * Filter, which MaintenancePhoto to fetch.
     */
    where?: MaintenancePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenancePhotos to fetch.
     */
    orderBy?: MaintenancePhotoOrderByWithRelationInput | MaintenancePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenancePhotos.
     */
    cursor?: MaintenancePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenancePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenancePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenancePhotos.
     */
    distinct?: MaintenancePhotoScalarFieldEnum | MaintenancePhotoScalarFieldEnum[]
  }

  /**
   * MaintenancePhoto findFirstOrThrow
   */
  export type MaintenancePhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * Filter, which MaintenancePhoto to fetch.
     */
    where?: MaintenancePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenancePhotos to fetch.
     */
    orderBy?: MaintenancePhotoOrderByWithRelationInput | MaintenancePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenancePhotos.
     */
    cursor?: MaintenancePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenancePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenancePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenancePhotos.
     */
    distinct?: MaintenancePhotoScalarFieldEnum | MaintenancePhotoScalarFieldEnum[]
  }

  /**
   * MaintenancePhoto findMany
   */
  export type MaintenancePhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * Filter, which MaintenancePhotos to fetch.
     */
    where?: MaintenancePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenancePhotos to fetch.
     */
    orderBy?: MaintenancePhotoOrderByWithRelationInput | MaintenancePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenancePhotos.
     */
    cursor?: MaintenancePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenancePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenancePhotos.
     */
    skip?: number
    distinct?: MaintenancePhotoScalarFieldEnum | MaintenancePhotoScalarFieldEnum[]
  }

  /**
   * MaintenancePhoto create
   */
  export type MaintenancePhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenancePhoto.
     */
    data: XOR<MaintenancePhotoCreateInput, MaintenancePhotoUncheckedCreateInput>
  }

  /**
   * MaintenancePhoto createMany
   */
  export type MaintenancePhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenancePhotos.
     */
    data: MaintenancePhotoCreateManyInput | MaintenancePhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaintenancePhoto createManyAndReturn
   */
  export type MaintenancePhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * The data used to create many MaintenancePhotos.
     */
    data: MaintenancePhotoCreateManyInput | MaintenancePhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenancePhoto update
   */
  export type MaintenancePhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenancePhoto.
     */
    data: XOR<MaintenancePhotoUpdateInput, MaintenancePhotoUncheckedUpdateInput>
    /**
     * Choose, which MaintenancePhoto to update.
     */
    where: MaintenancePhotoWhereUniqueInput
  }

  /**
   * MaintenancePhoto updateMany
   */
  export type MaintenancePhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenancePhotos.
     */
    data: XOR<MaintenancePhotoUpdateManyMutationInput, MaintenancePhotoUncheckedUpdateManyInput>
    /**
     * Filter which MaintenancePhotos to update
     */
    where?: MaintenancePhotoWhereInput
    /**
     * Limit how many MaintenancePhotos to update.
     */
    limit?: number
  }

  /**
   * MaintenancePhoto updateManyAndReturn
   */
  export type MaintenancePhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * The data used to update MaintenancePhotos.
     */
    data: XOR<MaintenancePhotoUpdateManyMutationInput, MaintenancePhotoUncheckedUpdateManyInput>
    /**
     * Filter which MaintenancePhotos to update
     */
    where?: MaintenancePhotoWhereInput
    /**
     * Limit how many MaintenancePhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenancePhoto upsert
   */
  export type MaintenancePhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenancePhoto to update in case it exists.
     */
    where: MaintenancePhotoWhereUniqueInput
    /**
     * In case the MaintenancePhoto found by the `where` argument doesn't exist, create a new MaintenancePhoto with this data.
     */
    create: XOR<MaintenancePhotoCreateInput, MaintenancePhotoUncheckedCreateInput>
    /**
     * In case the MaintenancePhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenancePhotoUpdateInput, MaintenancePhotoUncheckedUpdateInput>
  }

  /**
   * MaintenancePhoto delete
   */
  export type MaintenancePhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * Filter which MaintenancePhoto to delete.
     */
    where: MaintenancePhotoWhereUniqueInput
  }

  /**
   * MaintenancePhoto deleteMany
   */
  export type MaintenancePhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenancePhotos to delete
     */
    where?: MaintenancePhotoWhereInput
    /**
     * Limit how many MaintenancePhotos to delete.
     */
    limit?: number
  }

  /**
   * MaintenancePhoto without action
   */
  export type MaintenancePhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
  }


  /**
   * Model SiteCleaningPhoto
   */

  export type AggregateSiteCleaningPhoto = {
    _count: SiteCleaningPhotoCountAggregateOutputType | null
    _min: SiteCleaningPhotoMinAggregateOutputType | null
    _max: SiteCleaningPhotoMaxAggregateOutputType | null
  }

  export type SiteCleaningPhotoMinAggregateOutputType = {
    id: string | null
    url: string | null
    type: string | null
    siteCleaningSessionId: string | null
    createdAt: Date | null
  }

  export type SiteCleaningPhotoMaxAggregateOutputType = {
    id: string | null
    url: string | null
    type: string | null
    siteCleaningSessionId: string | null
    createdAt: Date | null
  }

  export type SiteCleaningPhotoCountAggregateOutputType = {
    id: number
    url: number
    type: number
    siteCleaningSessionId: number
    createdAt: number
    _all: number
  }


  export type SiteCleaningPhotoMinAggregateInputType = {
    id?: true
    url?: true
    type?: true
    siteCleaningSessionId?: true
    createdAt?: true
  }

  export type SiteCleaningPhotoMaxAggregateInputType = {
    id?: true
    url?: true
    type?: true
    siteCleaningSessionId?: true
    createdAt?: true
  }

  export type SiteCleaningPhotoCountAggregateInputType = {
    id?: true
    url?: true
    type?: true
    siteCleaningSessionId?: true
    createdAt?: true
    _all?: true
  }

  export type SiteCleaningPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteCleaningPhoto to aggregate.
     */
    where?: SiteCleaningPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteCleaningPhotos to fetch.
     */
    orderBy?: SiteCleaningPhotoOrderByWithRelationInput | SiteCleaningPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteCleaningPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteCleaningPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteCleaningPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteCleaningPhotos
    **/
    _count?: true | SiteCleaningPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteCleaningPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteCleaningPhotoMaxAggregateInputType
  }

  export type GetSiteCleaningPhotoAggregateType<T extends SiteCleaningPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteCleaningPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteCleaningPhoto[P]>
      : GetScalarType<T[P], AggregateSiteCleaningPhoto[P]>
  }




  export type SiteCleaningPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteCleaningPhotoWhereInput
    orderBy?: SiteCleaningPhotoOrderByWithAggregationInput | SiteCleaningPhotoOrderByWithAggregationInput[]
    by: SiteCleaningPhotoScalarFieldEnum[] | SiteCleaningPhotoScalarFieldEnum
    having?: SiteCleaningPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteCleaningPhotoCountAggregateInputType | true
    _min?: SiteCleaningPhotoMinAggregateInputType
    _max?: SiteCleaningPhotoMaxAggregateInputType
  }

  export type SiteCleaningPhotoGroupByOutputType = {
    id: string
    url: string
    type: string | null
    siteCleaningSessionId: string
    createdAt: Date
    _count: SiteCleaningPhotoCountAggregateOutputType | null
    _min: SiteCleaningPhotoMinAggregateOutputType | null
    _max: SiteCleaningPhotoMaxAggregateOutputType | null
  }

  type GetSiteCleaningPhotoGroupByPayload<T extends SiteCleaningPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteCleaningPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteCleaningPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteCleaningPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], SiteCleaningPhotoGroupByOutputType[P]>
        }
      >
    >


  export type SiteCleaningPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    siteCleaningSessionId?: boolean
    createdAt?: boolean
    siteCleaningSession?: boolean | SiteCleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteCleaningPhoto"]>

  export type SiteCleaningPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    siteCleaningSessionId?: boolean
    createdAt?: boolean
    siteCleaningSession?: boolean | SiteCleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteCleaningPhoto"]>

  export type SiteCleaningPhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    siteCleaningSessionId?: boolean
    createdAt?: boolean
    siteCleaningSession?: boolean | SiteCleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteCleaningPhoto"]>

  export type SiteCleaningPhotoSelectScalar = {
    id?: boolean
    url?: boolean
    type?: boolean
    siteCleaningSessionId?: boolean
    createdAt?: boolean
  }

  export type SiteCleaningPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "type" | "siteCleaningSessionId" | "createdAt", ExtArgs["result"]["siteCleaningPhoto"]>
  export type SiteCleaningPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    siteCleaningSession?: boolean | SiteCleaningSessionDefaultArgs<ExtArgs>
  }
  export type SiteCleaningPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    siteCleaningSession?: boolean | SiteCleaningSessionDefaultArgs<ExtArgs>
  }
  export type SiteCleaningPhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    siteCleaningSession?: boolean | SiteCleaningSessionDefaultArgs<ExtArgs>
  }

  export type $SiteCleaningPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteCleaningPhoto"
    objects: {
      siteCleaningSession: Prisma.$SiteCleaningSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      type: string | null
      siteCleaningSessionId: string
      createdAt: Date
    }, ExtArgs["result"]["siteCleaningPhoto"]>
    composites: {}
  }

  type SiteCleaningPhotoGetPayload<S extends boolean | null | undefined | SiteCleaningPhotoDefaultArgs> = $Result.GetResult<Prisma.$SiteCleaningPhotoPayload, S>

  type SiteCleaningPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteCleaningPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteCleaningPhotoCountAggregateInputType | true
    }

  export interface SiteCleaningPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteCleaningPhoto'], meta: { name: 'SiteCleaningPhoto' } }
    /**
     * Find zero or one SiteCleaningPhoto that matches the filter.
     * @param {SiteCleaningPhotoFindUniqueArgs} args - Arguments to find a SiteCleaningPhoto
     * @example
     * // Get one SiteCleaningPhoto
     * const siteCleaningPhoto = await prisma.siteCleaningPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteCleaningPhotoFindUniqueArgs>(args: SelectSubset<T, SiteCleaningPhotoFindUniqueArgs<ExtArgs>>): Prisma__SiteCleaningPhotoClient<$Result.GetResult<Prisma.$SiteCleaningPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SiteCleaningPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteCleaningPhotoFindUniqueOrThrowArgs} args - Arguments to find a SiteCleaningPhoto
     * @example
     * // Get one SiteCleaningPhoto
     * const siteCleaningPhoto = await prisma.siteCleaningPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteCleaningPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteCleaningPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteCleaningPhotoClient<$Result.GetResult<Prisma.$SiteCleaningPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteCleaningPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningPhotoFindFirstArgs} args - Arguments to find a SiteCleaningPhoto
     * @example
     * // Get one SiteCleaningPhoto
     * const siteCleaningPhoto = await prisma.siteCleaningPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteCleaningPhotoFindFirstArgs>(args?: SelectSubset<T, SiteCleaningPhotoFindFirstArgs<ExtArgs>>): Prisma__SiteCleaningPhotoClient<$Result.GetResult<Prisma.$SiteCleaningPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteCleaningPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningPhotoFindFirstOrThrowArgs} args - Arguments to find a SiteCleaningPhoto
     * @example
     * // Get one SiteCleaningPhoto
     * const siteCleaningPhoto = await prisma.siteCleaningPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteCleaningPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteCleaningPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteCleaningPhotoClient<$Result.GetResult<Prisma.$SiteCleaningPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteCleaningPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteCleaningPhotos
     * const siteCleaningPhotos = await prisma.siteCleaningPhoto.findMany()
     * 
     * // Get first 10 SiteCleaningPhotos
     * const siteCleaningPhotos = await prisma.siteCleaningPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteCleaningPhotoWithIdOnly = await prisma.siteCleaningPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SiteCleaningPhotoFindManyArgs>(args?: SelectSubset<T, SiteCleaningPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteCleaningPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SiteCleaningPhoto.
     * @param {SiteCleaningPhotoCreateArgs} args - Arguments to create a SiteCleaningPhoto.
     * @example
     * // Create one SiteCleaningPhoto
     * const SiteCleaningPhoto = await prisma.siteCleaningPhoto.create({
     *   data: {
     *     // ... data to create a SiteCleaningPhoto
     *   }
     * })
     * 
     */
    create<T extends SiteCleaningPhotoCreateArgs>(args: SelectSubset<T, SiteCleaningPhotoCreateArgs<ExtArgs>>): Prisma__SiteCleaningPhotoClient<$Result.GetResult<Prisma.$SiteCleaningPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SiteCleaningPhotos.
     * @param {SiteCleaningPhotoCreateManyArgs} args - Arguments to create many SiteCleaningPhotos.
     * @example
     * // Create many SiteCleaningPhotos
     * const siteCleaningPhoto = await prisma.siteCleaningPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteCleaningPhotoCreateManyArgs>(args?: SelectSubset<T, SiteCleaningPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SiteCleaningPhotos and returns the data saved in the database.
     * @param {SiteCleaningPhotoCreateManyAndReturnArgs} args - Arguments to create many SiteCleaningPhotos.
     * @example
     * // Create many SiteCleaningPhotos
     * const siteCleaningPhoto = await prisma.siteCleaningPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SiteCleaningPhotos and only return the `id`
     * const siteCleaningPhotoWithIdOnly = await prisma.siteCleaningPhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteCleaningPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteCleaningPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteCleaningPhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SiteCleaningPhoto.
     * @param {SiteCleaningPhotoDeleteArgs} args - Arguments to delete one SiteCleaningPhoto.
     * @example
     * // Delete one SiteCleaningPhoto
     * const SiteCleaningPhoto = await prisma.siteCleaningPhoto.delete({
     *   where: {
     *     // ... filter to delete one SiteCleaningPhoto
     *   }
     * })
     * 
     */
    delete<T extends SiteCleaningPhotoDeleteArgs>(args: SelectSubset<T, SiteCleaningPhotoDeleteArgs<ExtArgs>>): Prisma__SiteCleaningPhotoClient<$Result.GetResult<Prisma.$SiteCleaningPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SiteCleaningPhoto.
     * @param {SiteCleaningPhotoUpdateArgs} args - Arguments to update one SiteCleaningPhoto.
     * @example
     * // Update one SiteCleaningPhoto
     * const siteCleaningPhoto = await prisma.siteCleaningPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteCleaningPhotoUpdateArgs>(args: SelectSubset<T, SiteCleaningPhotoUpdateArgs<ExtArgs>>): Prisma__SiteCleaningPhotoClient<$Result.GetResult<Prisma.$SiteCleaningPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SiteCleaningPhotos.
     * @param {SiteCleaningPhotoDeleteManyArgs} args - Arguments to filter SiteCleaningPhotos to delete.
     * @example
     * // Delete a few SiteCleaningPhotos
     * const { count } = await prisma.siteCleaningPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteCleaningPhotoDeleteManyArgs>(args?: SelectSubset<T, SiteCleaningPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteCleaningPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteCleaningPhotos
     * const siteCleaningPhoto = await prisma.siteCleaningPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteCleaningPhotoUpdateManyArgs>(args: SelectSubset<T, SiteCleaningPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteCleaningPhotos and returns the data updated in the database.
     * @param {SiteCleaningPhotoUpdateManyAndReturnArgs} args - Arguments to update many SiteCleaningPhotos.
     * @example
     * // Update many SiteCleaningPhotos
     * const siteCleaningPhoto = await prisma.siteCleaningPhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SiteCleaningPhotos and only return the `id`
     * const siteCleaningPhotoWithIdOnly = await prisma.siteCleaningPhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteCleaningPhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteCleaningPhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteCleaningPhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SiteCleaningPhoto.
     * @param {SiteCleaningPhotoUpsertArgs} args - Arguments to update or create a SiteCleaningPhoto.
     * @example
     * // Update or create a SiteCleaningPhoto
     * const siteCleaningPhoto = await prisma.siteCleaningPhoto.upsert({
     *   create: {
     *     // ... data to create a SiteCleaningPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteCleaningPhoto we want to update
     *   }
     * })
     */
    upsert<T extends SiteCleaningPhotoUpsertArgs>(args: SelectSubset<T, SiteCleaningPhotoUpsertArgs<ExtArgs>>): Prisma__SiteCleaningPhotoClient<$Result.GetResult<Prisma.$SiteCleaningPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SiteCleaningPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningPhotoCountArgs} args - Arguments to filter SiteCleaningPhotos to count.
     * @example
     * // Count the number of SiteCleaningPhotos
     * const count = await prisma.siteCleaningPhoto.count({
     *   where: {
     *     // ... the filter for the SiteCleaningPhotos we want to count
     *   }
     * })
    **/
    count<T extends SiteCleaningPhotoCountArgs>(
      args?: Subset<T, SiteCleaningPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteCleaningPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteCleaningPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteCleaningPhotoAggregateArgs>(args: Subset<T, SiteCleaningPhotoAggregateArgs>): Prisma.PrismaPromise<GetSiteCleaningPhotoAggregateType<T>>

    /**
     * Group by SiteCleaningPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteCleaningPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteCleaningPhotoGroupByArgs['orderBy'] }
        : { orderBy?: SiteCleaningPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteCleaningPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteCleaningPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteCleaningPhoto model
   */
  readonly fields: SiteCleaningPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteCleaningPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteCleaningPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    siteCleaningSession<T extends SiteCleaningSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteCleaningSessionDefaultArgs<ExtArgs>>): Prisma__SiteCleaningSessionClient<$Result.GetResult<Prisma.$SiteCleaningSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteCleaningPhoto model
   */
  interface SiteCleaningPhotoFieldRefs {
    readonly id: FieldRef<"SiteCleaningPhoto", 'String'>
    readonly url: FieldRef<"SiteCleaningPhoto", 'String'>
    readonly type: FieldRef<"SiteCleaningPhoto", 'String'>
    readonly siteCleaningSessionId: FieldRef<"SiteCleaningPhoto", 'String'>
    readonly createdAt: FieldRef<"SiteCleaningPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SiteCleaningPhoto findUnique
   */
  export type SiteCleaningPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningPhoto
     */
    select?: SiteCleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningPhoto
     */
    omit?: SiteCleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter, which SiteCleaningPhoto to fetch.
     */
    where: SiteCleaningPhotoWhereUniqueInput
  }

  /**
   * SiteCleaningPhoto findUniqueOrThrow
   */
  export type SiteCleaningPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningPhoto
     */
    select?: SiteCleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningPhoto
     */
    omit?: SiteCleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter, which SiteCleaningPhoto to fetch.
     */
    where: SiteCleaningPhotoWhereUniqueInput
  }

  /**
   * SiteCleaningPhoto findFirst
   */
  export type SiteCleaningPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningPhoto
     */
    select?: SiteCleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningPhoto
     */
    omit?: SiteCleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter, which SiteCleaningPhoto to fetch.
     */
    where?: SiteCleaningPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteCleaningPhotos to fetch.
     */
    orderBy?: SiteCleaningPhotoOrderByWithRelationInput | SiteCleaningPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteCleaningPhotos.
     */
    cursor?: SiteCleaningPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteCleaningPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteCleaningPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteCleaningPhotos.
     */
    distinct?: SiteCleaningPhotoScalarFieldEnum | SiteCleaningPhotoScalarFieldEnum[]
  }

  /**
   * SiteCleaningPhoto findFirstOrThrow
   */
  export type SiteCleaningPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningPhoto
     */
    select?: SiteCleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningPhoto
     */
    omit?: SiteCleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter, which SiteCleaningPhoto to fetch.
     */
    where?: SiteCleaningPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteCleaningPhotos to fetch.
     */
    orderBy?: SiteCleaningPhotoOrderByWithRelationInput | SiteCleaningPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteCleaningPhotos.
     */
    cursor?: SiteCleaningPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteCleaningPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteCleaningPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteCleaningPhotos.
     */
    distinct?: SiteCleaningPhotoScalarFieldEnum | SiteCleaningPhotoScalarFieldEnum[]
  }

  /**
   * SiteCleaningPhoto findMany
   */
  export type SiteCleaningPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningPhoto
     */
    select?: SiteCleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningPhoto
     */
    omit?: SiteCleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter, which SiteCleaningPhotos to fetch.
     */
    where?: SiteCleaningPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteCleaningPhotos to fetch.
     */
    orderBy?: SiteCleaningPhotoOrderByWithRelationInput | SiteCleaningPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteCleaningPhotos.
     */
    cursor?: SiteCleaningPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteCleaningPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteCleaningPhotos.
     */
    skip?: number
    distinct?: SiteCleaningPhotoScalarFieldEnum | SiteCleaningPhotoScalarFieldEnum[]
  }

  /**
   * SiteCleaningPhoto create
   */
  export type SiteCleaningPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningPhoto
     */
    select?: SiteCleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningPhoto
     */
    omit?: SiteCleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a SiteCleaningPhoto.
     */
    data: XOR<SiteCleaningPhotoCreateInput, SiteCleaningPhotoUncheckedCreateInput>
  }

  /**
   * SiteCleaningPhoto createMany
   */
  export type SiteCleaningPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteCleaningPhotos.
     */
    data: SiteCleaningPhotoCreateManyInput | SiteCleaningPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteCleaningPhoto createManyAndReturn
   */
  export type SiteCleaningPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningPhoto
     */
    select?: SiteCleaningPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningPhoto
     */
    omit?: SiteCleaningPhotoOmit<ExtArgs> | null
    /**
     * The data used to create many SiteCleaningPhotos.
     */
    data: SiteCleaningPhotoCreateManyInput | SiteCleaningPhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteCleaningPhoto update
   */
  export type SiteCleaningPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningPhoto
     */
    select?: SiteCleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningPhoto
     */
    omit?: SiteCleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a SiteCleaningPhoto.
     */
    data: XOR<SiteCleaningPhotoUpdateInput, SiteCleaningPhotoUncheckedUpdateInput>
    /**
     * Choose, which SiteCleaningPhoto to update.
     */
    where: SiteCleaningPhotoWhereUniqueInput
  }

  /**
   * SiteCleaningPhoto updateMany
   */
  export type SiteCleaningPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteCleaningPhotos.
     */
    data: XOR<SiteCleaningPhotoUpdateManyMutationInput, SiteCleaningPhotoUncheckedUpdateManyInput>
    /**
     * Filter which SiteCleaningPhotos to update
     */
    where?: SiteCleaningPhotoWhereInput
    /**
     * Limit how many SiteCleaningPhotos to update.
     */
    limit?: number
  }

  /**
   * SiteCleaningPhoto updateManyAndReturn
   */
  export type SiteCleaningPhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningPhoto
     */
    select?: SiteCleaningPhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningPhoto
     */
    omit?: SiteCleaningPhotoOmit<ExtArgs> | null
    /**
     * The data used to update SiteCleaningPhotos.
     */
    data: XOR<SiteCleaningPhotoUpdateManyMutationInput, SiteCleaningPhotoUncheckedUpdateManyInput>
    /**
     * Filter which SiteCleaningPhotos to update
     */
    where?: SiteCleaningPhotoWhereInput
    /**
     * Limit how many SiteCleaningPhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningPhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteCleaningPhoto upsert
   */
  export type SiteCleaningPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningPhoto
     */
    select?: SiteCleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningPhoto
     */
    omit?: SiteCleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the SiteCleaningPhoto to update in case it exists.
     */
    where: SiteCleaningPhotoWhereUniqueInput
    /**
     * In case the SiteCleaningPhoto found by the `where` argument doesn't exist, create a new SiteCleaningPhoto with this data.
     */
    create: XOR<SiteCleaningPhotoCreateInput, SiteCleaningPhotoUncheckedCreateInput>
    /**
     * In case the SiteCleaningPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteCleaningPhotoUpdateInput, SiteCleaningPhotoUncheckedUpdateInput>
  }

  /**
   * SiteCleaningPhoto delete
   */
  export type SiteCleaningPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningPhoto
     */
    select?: SiteCleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningPhoto
     */
    omit?: SiteCleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter which SiteCleaningPhoto to delete.
     */
    where: SiteCleaningPhotoWhereUniqueInput
  }

  /**
   * SiteCleaningPhoto deleteMany
   */
  export type SiteCleaningPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteCleaningPhotos to delete
     */
    where?: SiteCleaningPhotoWhereInput
    /**
     * Limit how many SiteCleaningPhotos to delete.
     */
    limit?: number
  }

  /**
   * SiteCleaningPhoto without action
   */
  export type SiteCleaningPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningPhoto
     */
    select?: SiteCleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningPhoto
     */
    omit?: SiteCleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningPhotoInclude<ExtArgs> | null
  }


  /**
   * Model TicketPhoto
   */

  export type AggregateTicketPhoto = {
    _count: TicketPhotoCountAggregateOutputType | null
    _min: TicketPhotoMinAggregateOutputType | null
    _max: TicketPhotoMaxAggregateOutputType | null
  }

  export type TicketPhotoMinAggregateOutputType = {
    id: string | null
    url: string | null
    ticketId: string | null
    createdAt: Date | null
  }

  export type TicketPhotoMaxAggregateOutputType = {
    id: string | null
    url: string | null
    ticketId: string | null
    createdAt: Date | null
  }

  export type TicketPhotoCountAggregateOutputType = {
    id: number
    url: number
    ticketId: number
    createdAt: number
    _all: number
  }


  export type TicketPhotoMinAggregateInputType = {
    id?: true
    url?: true
    ticketId?: true
    createdAt?: true
  }

  export type TicketPhotoMaxAggregateInputType = {
    id?: true
    url?: true
    ticketId?: true
    createdAt?: true
  }

  export type TicketPhotoCountAggregateInputType = {
    id?: true
    url?: true
    ticketId?: true
    createdAt?: true
    _all?: true
  }

  export type TicketPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketPhoto to aggregate.
     */
    where?: TicketPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketPhotos to fetch.
     */
    orderBy?: TicketPhotoOrderByWithRelationInput | TicketPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketPhotos
    **/
    _count?: true | TicketPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketPhotoMaxAggregateInputType
  }

  export type GetTicketPhotoAggregateType<T extends TicketPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketPhoto[P]>
      : GetScalarType<T[P], AggregateTicketPhoto[P]>
  }




  export type TicketPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketPhotoWhereInput
    orderBy?: TicketPhotoOrderByWithAggregationInput | TicketPhotoOrderByWithAggregationInput[]
    by: TicketPhotoScalarFieldEnum[] | TicketPhotoScalarFieldEnum
    having?: TicketPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketPhotoCountAggregateInputType | true
    _min?: TicketPhotoMinAggregateInputType
    _max?: TicketPhotoMaxAggregateInputType
  }

  export type TicketPhotoGroupByOutputType = {
    id: string
    url: string
    ticketId: string
    createdAt: Date
    _count: TicketPhotoCountAggregateOutputType | null
    _min: TicketPhotoMinAggregateOutputType | null
    _max: TicketPhotoMaxAggregateOutputType | null
  }

  type GetTicketPhotoGroupByPayload<T extends TicketPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], TicketPhotoGroupByOutputType[P]>
        }
      >
    >


  export type TicketPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    ticketId?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketPhoto"]>

  export type TicketPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    ticketId?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketPhoto"]>

  export type TicketPhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    ticketId?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketPhoto"]>

  export type TicketPhotoSelectScalar = {
    id?: boolean
    url?: boolean
    ticketId?: boolean
    createdAt?: boolean
  }

  export type TicketPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "ticketId" | "createdAt", ExtArgs["result"]["ticketPhoto"]>
  export type TicketPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type TicketPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type TicketPhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }

  export type $TicketPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketPhoto"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      ticketId: string
      createdAt: Date
    }, ExtArgs["result"]["ticketPhoto"]>
    composites: {}
  }

  type TicketPhotoGetPayload<S extends boolean | null | undefined | TicketPhotoDefaultArgs> = $Result.GetResult<Prisma.$TicketPhotoPayload, S>

  type TicketPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketPhotoCountAggregateInputType | true
    }

  export interface TicketPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketPhoto'], meta: { name: 'TicketPhoto' } }
    /**
     * Find zero or one TicketPhoto that matches the filter.
     * @param {TicketPhotoFindUniqueArgs} args - Arguments to find a TicketPhoto
     * @example
     * // Get one TicketPhoto
     * const ticketPhoto = await prisma.ticketPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketPhotoFindUniqueArgs>(args: SelectSubset<T, TicketPhotoFindUniqueArgs<ExtArgs>>): Prisma__TicketPhotoClient<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketPhotoFindUniqueOrThrowArgs} args - Arguments to find a TicketPhoto
     * @example
     * // Get one TicketPhoto
     * const ticketPhoto = await prisma.ticketPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketPhotoClient<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketPhotoFindFirstArgs} args - Arguments to find a TicketPhoto
     * @example
     * // Get one TicketPhoto
     * const ticketPhoto = await prisma.ticketPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketPhotoFindFirstArgs>(args?: SelectSubset<T, TicketPhotoFindFirstArgs<ExtArgs>>): Prisma__TicketPhotoClient<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketPhotoFindFirstOrThrowArgs} args - Arguments to find a TicketPhoto
     * @example
     * // Get one TicketPhoto
     * const ticketPhoto = await prisma.ticketPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketPhotoClient<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketPhotos
     * const ticketPhotos = await prisma.ticketPhoto.findMany()
     * 
     * // Get first 10 TicketPhotos
     * const ticketPhotos = await prisma.ticketPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketPhotoWithIdOnly = await prisma.ticketPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketPhotoFindManyArgs>(args?: SelectSubset<T, TicketPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketPhoto.
     * @param {TicketPhotoCreateArgs} args - Arguments to create a TicketPhoto.
     * @example
     * // Create one TicketPhoto
     * const TicketPhoto = await prisma.ticketPhoto.create({
     *   data: {
     *     // ... data to create a TicketPhoto
     *   }
     * })
     * 
     */
    create<T extends TicketPhotoCreateArgs>(args: SelectSubset<T, TicketPhotoCreateArgs<ExtArgs>>): Prisma__TicketPhotoClient<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketPhotos.
     * @param {TicketPhotoCreateManyArgs} args - Arguments to create many TicketPhotos.
     * @example
     * // Create many TicketPhotos
     * const ticketPhoto = await prisma.ticketPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketPhotoCreateManyArgs>(args?: SelectSubset<T, TicketPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketPhotos and returns the data saved in the database.
     * @param {TicketPhotoCreateManyAndReturnArgs} args - Arguments to create many TicketPhotos.
     * @example
     * // Create many TicketPhotos
     * const ticketPhoto = await prisma.ticketPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketPhotos and only return the `id`
     * const ticketPhotoWithIdOnly = await prisma.ticketPhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketPhoto.
     * @param {TicketPhotoDeleteArgs} args - Arguments to delete one TicketPhoto.
     * @example
     * // Delete one TicketPhoto
     * const TicketPhoto = await prisma.ticketPhoto.delete({
     *   where: {
     *     // ... filter to delete one TicketPhoto
     *   }
     * })
     * 
     */
    delete<T extends TicketPhotoDeleteArgs>(args: SelectSubset<T, TicketPhotoDeleteArgs<ExtArgs>>): Prisma__TicketPhotoClient<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketPhoto.
     * @param {TicketPhotoUpdateArgs} args - Arguments to update one TicketPhoto.
     * @example
     * // Update one TicketPhoto
     * const ticketPhoto = await prisma.ticketPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketPhotoUpdateArgs>(args: SelectSubset<T, TicketPhotoUpdateArgs<ExtArgs>>): Prisma__TicketPhotoClient<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketPhotos.
     * @param {TicketPhotoDeleteManyArgs} args - Arguments to filter TicketPhotos to delete.
     * @example
     * // Delete a few TicketPhotos
     * const { count } = await prisma.ticketPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketPhotoDeleteManyArgs>(args?: SelectSubset<T, TicketPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketPhotos
     * const ticketPhoto = await prisma.ticketPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketPhotoUpdateManyArgs>(args: SelectSubset<T, TicketPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketPhotos and returns the data updated in the database.
     * @param {TicketPhotoUpdateManyAndReturnArgs} args - Arguments to update many TicketPhotos.
     * @example
     * // Update many TicketPhotos
     * const ticketPhoto = await prisma.ticketPhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketPhotos and only return the `id`
     * const ticketPhotoWithIdOnly = await prisma.ticketPhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketPhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketPhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketPhoto.
     * @param {TicketPhotoUpsertArgs} args - Arguments to update or create a TicketPhoto.
     * @example
     * // Update or create a TicketPhoto
     * const ticketPhoto = await prisma.ticketPhoto.upsert({
     *   create: {
     *     // ... data to create a TicketPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketPhoto we want to update
     *   }
     * })
     */
    upsert<T extends TicketPhotoUpsertArgs>(args: SelectSubset<T, TicketPhotoUpsertArgs<ExtArgs>>): Prisma__TicketPhotoClient<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketPhotoCountArgs} args - Arguments to filter TicketPhotos to count.
     * @example
     * // Count the number of TicketPhotos
     * const count = await prisma.ticketPhoto.count({
     *   where: {
     *     // ... the filter for the TicketPhotos we want to count
     *   }
     * })
    **/
    count<T extends TicketPhotoCountArgs>(
      args?: Subset<T, TicketPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketPhotoAggregateArgs>(args: Subset<T, TicketPhotoAggregateArgs>): Prisma.PrismaPromise<GetTicketPhotoAggregateType<T>>

    /**
     * Group by TicketPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketPhotoGroupByArgs['orderBy'] }
        : { orderBy?: TicketPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketPhoto model
   */
  readonly fields: TicketPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketPhoto model
   */
  interface TicketPhotoFieldRefs {
    readonly id: FieldRef<"TicketPhoto", 'String'>
    readonly url: FieldRef<"TicketPhoto", 'String'>
    readonly ticketId: FieldRef<"TicketPhoto", 'String'>
    readonly createdAt: FieldRef<"TicketPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketPhoto findUnique
   */
  export type TicketPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TicketPhoto to fetch.
     */
    where: TicketPhotoWhereUniqueInput
  }

  /**
   * TicketPhoto findUniqueOrThrow
   */
  export type TicketPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TicketPhoto to fetch.
     */
    where: TicketPhotoWhereUniqueInput
  }

  /**
   * TicketPhoto findFirst
   */
  export type TicketPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TicketPhoto to fetch.
     */
    where?: TicketPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketPhotos to fetch.
     */
    orderBy?: TicketPhotoOrderByWithRelationInput | TicketPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketPhotos.
     */
    cursor?: TicketPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketPhotos.
     */
    distinct?: TicketPhotoScalarFieldEnum | TicketPhotoScalarFieldEnum[]
  }

  /**
   * TicketPhoto findFirstOrThrow
   */
  export type TicketPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TicketPhoto to fetch.
     */
    where?: TicketPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketPhotos to fetch.
     */
    orderBy?: TicketPhotoOrderByWithRelationInput | TicketPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketPhotos.
     */
    cursor?: TicketPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketPhotos.
     */
    distinct?: TicketPhotoScalarFieldEnum | TicketPhotoScalarFieldEnum[]
  }

  /**
   * TicketPhoto findMany
   */
  export type TicketPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TicketPhotos to fetch.
     */
    where?: TicketPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketPhotos to fetch.
     */
    orderBy?: TicketPhotoOrderByWithRelationInput | TicketPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketPhotos.
     */
    cursor?: TicketPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketPhotos.
     */
    skip?: number
    distinct?: TicketPhotoScalarFieldEnum | TicketPhotoScalarFieldEnum[]
  }

  /**
   * TicketPhoto create
   */
  export type TicketPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketPhoto.
     */
    data: XOR<TicketPhotoCreateInput, TicketPhotoUncheckedCreateInput>
  }

  /**
   * TicketPhoto createMany
   */
  export type TicketPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketPhotos.
     */
    data: TicketPhotoCreateManyInput | TicketPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketPhoto createManyAndReturn
   */
  export type TicketPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * The data used to create many TicketPhotos.
     */
    data: TicketPhotoCreateManyInput | TicketPhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketPhoto update
   */
  export type TicketPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketPhoto.
     */
    data: XOR<TicketPhotoUpdateInput, TicketPhotoUncheckedUpdateInput>
    /**
     * Choose, which TicketPhoto to update.
     */
    where: TicketPhotoWhereUniqueInput
  }

  /**
   * TicketPhoto updateMany
   */
  export type TicketPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketPhotos.
     */
    data: XOR<TicketPhotoUpdateManyMutationInput, TicketPhotoUncheckedUpdateManyInput>
    /**
     * Filter which TicketPhotos to update
     */
    where?: TicketPhotoWhereInput
    /**
     * Limit how many TicketPhotos to update.
     */
    limit?: number
  }

  /**
   * TicketPhoto updateManyAndReturn
   */
  export type TicketPhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * The data used to update TicketPhotos.
     */
    data: XOR<TicketPhotoUpdateManyMutationInput, TicketPhotoUncheckedUpdateManyInput>
    /**
     * Filter which TicketPhotos to update
     */
    where?: TicketPhotoWhereInput
    /**
     * Limit how many TicketPhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketPhoto upsert
   */
  export type TicketPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketPhoto to update in case it exists.
     */
    where: TicketPhotoWhereUniqueInput
    /**
     * In case the TicketPhoto found by the `where` argument doesn't exist, create a new TicketPhoto with this data.
     */
    create: XOR<TicketPhotoCreateInput, TicketPhotoUncheckedCreateInput>
    /**
     * In case the TicketPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketPhotoUpdateInput, TicketPhotoUncheckedUpdateInput>
  }

  /**
   * TicketPhoto delete
   */
  export type TicketPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * Filter which TicketPhoto to delete.
     */
    where: TicketPhotoWhereUniqueInput
  }

  /**
   * TicketPhoto deleteMany
   */
  export type TicketPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketPhotos to delete
     */
    where?: TicketPhotoWhereInput
    /**
     * Limit how many TicketPhotos to delete.
     */
    limit?: number
  }

  /**
   * TicketPhoto without action
   */
  export type TicketPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
  }


  /**
   * Model CleaningChecklist
   */

  export type AggregateCleaningChecklist = {
    _count: CleaningChecklistCountAggregateOutputType | null
    _min: CleaningChecklistMinAggregateOutputType | null
    _max: CleaningChecklistMaxAggregateOutputType | null
  }

  export type CleaningChecklistMinAggregateOutputType = {
    id: string | null
    item: string | null
    completed: boolean | null
    cleaningSessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningChecklistMaxAggregateOutputType = {
    id: string | null
    item: string | null
    completed: boolean | null
    cleaningSessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningChecklistCountAggregateOutputType = {
    id: number
    item: number
    completed: number
    cleaningSessionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CleaningChecklistMinAggregateInputType = {
    id?: true
    item?: true
    completed?: true
    cleaningSessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningChecklistMaxAggregateInputType = {
    id?: true
    item?: true
    completed?: true
    cleaningSessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningChecklistCountAggregateInputType = {
    id?: true
    item?: true
    completed?: true
    cleaningSessionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CleaningChecklistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningChecklist to aggregate.
     */
    where?: CleaningChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningChecklists to fetch.
     */
    orderBy?: CleaningChecklistOrderByWithRelationInput | CleaningChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CleaningChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CleaningChecklists
    **/
    _count?: true | CleaningChecklistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CleaningChecklistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CleaningChecklistMaxAggregateInputType
  }

  export type GetCleaningChecklistAggregateType<T extends CleaningChecklistAggregateArgs> = {
        [P in keyof T & keyof AggregateCleaningChecklist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCleaningChecklist[P]>
      : GetScalarType<T[P], AggregateCleaningChecklist[P]>
  }




  export type CleaningChecklistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningChecklistWhereInput
    orderBy?: CleaningChecklistOrderByWithAggregationInput | CleaningChecklistOrderByWithAggregationInput[]
    by: CleaningChecklistScalarFieldEnum[] | CleaningChecklistScalarFieldEnum
    having?: CleaningChecklistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CleaningChecklistCountAggregateInputType | true
    _min?: CleaningChecklistMinAggregateInputType
    _max?: CleaningChecklistMaxAggregateInputType
  }

  export type CleaningChecklistGroupByOutputType = {
    id: string
    item: string
    completed: boolean
    cleaningSessionId: string
    createdAt: Date
    updatedAt: Date
    _count: CleaningChecklistCountAggregateOutputType | null
    _min: CleaningChecklistMinAggregateOutputType | null
    _max: CleaningChecklistMaxAggregateOutputType | null
  }

  type GetCleaningChecklistGroupByPayload<T extends CleaningChecklistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CleaningChecklistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CleaningChecklistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CleaningChecklistGroupByOutputType[P]>
            : GetScalarType<T[P], CleaningChecklistGroupByOutputType[P]>
        }
      >
    >


  export type CleaningChecklistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item?: boolean
    completed?: boolean
    cleaningSessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningChecklist"]>

  export type CleaningChecklistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item?: boolean
    completed?: boolean
    cleaningSessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningChecklist"]>

  export type CleaningChecklistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item?: boolean
    completed?: boolean
    cleaningSessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningChecklist"]>

  export type CleaningChecklistSelectScalar = {
    id?: boolean
    item?: boolean
    completed?: boolean
    cleaningSessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CleaningChecklistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "item" | "completed" | "cleaningSessionId" | "createdAt" | "updatedAt", ExtArgs["result"]["cleaningChecklist"]>
  export type CleaningChecklistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }
  export type CleaningChecklistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }
  export type CleaningChecklistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }

  export type $CleaningChecklistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CleaningChecklist"
    objects: {
      cleaningSession: Prisma.$CleaningSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      item: string
      completed: boolean
      cleaningSessionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cleaningChecklist"]>
    composites: {}
  }

  type CleaningChecklistGetPayload<S extends boolean | null | undefined | CleaningChecklistDefaultArgs> = $Result.GetResult<Prisma.$CleaningChecklistPayload, S>

  type CleaningChecklistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CleaningChecklistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CleaningChecklistCountAggregateInputType | true
    }

  export interface CleaningChecklistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CleaningChecklist'], meta: { name: 'CleaningChecklist' } }
    /**
     * Find zero or one CleaningChecklist that matches the filter.
     * @param {CleaningChecklistFindUniqueArgs} args - Arguments to find a CleaningChecklist
     * @example
     * // Get one CleaningChecklist
     * const cleaningChecklist = await prisma.cleaningChecklist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CleaningChecklistFindUniqueArgs>(args: SelectSubset<T, CleaningChecklistFindUniqueArgs<ExtArgs>>): Prisma__CleaningChecklistClient<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CleaningChecklist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CleaningChecklistFindUniqueOrThrowArgs} args - Arguments to find a CleaningChecklist
     * @example
     * // Get one CleaningChecklist
     * const cleaningChecklist = await prisma.cleaningChecklist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CleaningChecklistFindUniqueOrThrowArgs>(args: SelectSubset<T, CleaningChecklistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CleaningChecklistClient<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningChecklist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningChecklistFindFirstArgs} args - Arguments to find a CleaningChecklist
     * @example
     * // Get one CleaningChecklist
     * const cleaningChecklist = await prisma.cleaningChecklist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CleaningChecklistFindFirstArgs>(args?: SelectSubset<T, CleaningChecklistFindFirstArgs<ExtArgs>>): Prisma__CleaningChecklistClient<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningChecklist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningChecklistFindFirstOrThrowArgs} args - Arguments to find a CleaningChecklist
     * @example
     * // Get one CleaningChecklist
     * const cleaningChecklist = await prisma.cleaningChecklist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CleaningChecklistFindFirstOrThrowArgs>(args?: SelectSubset<T, CleaningChecklistFindFirstOrThrowArgs<ExtArgs>>): Prisma__CleaningChecklistClient<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CleaningChecklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningChecklistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CleaningChecklists
     * const cleaningChecklists = await prisma.cleaningChecklist.findMany()
     * 
     * // Get first 10 CleaningChecklists
     * const cleaningChecklists = await prisma.cleaningChecklist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cleaningChecklistWithIdOnly = await prisma.cleaningChecklist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CleaningChecklistFindManyArgs>(args?: SelectSubset<T, CleaningChecklistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CleaningChecklist.
     * @param {CleaningChecklistCreateArgs} args - Arguments to create a CleaningChecklist.
     * @example
     * // Create one CleaningChecklist
     * const CleaningChecklist = await prisma.cleaningChecklist.create({
     *   data: {
     *     // ... data to create a CleaningChecklist
     *   }
     * })
     * 
     */
    create<T extends CleaningChecklistCreateArgs>(args: SelectSubset<T, CleaningChecklistCreateArgs<ExtArgs>>): Prisma__CleaningChecklistClient<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CleaningChecklists.
     * @param {CleaningChecklistCreateManyArgs} args - Arguments to create many CleaningChecklists.
     * @example
     * // Create many CleaningChecklists
     * const cleaningChecklist = await prisma.cleaningChecklist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CleaningChecklistCreateManyArgs>(args?: SelectSubset<T, CleaningChecklistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CleaningChecklists and returns the data saved in the database.
     * @param {CleaningChecklistCreateManyAndReturnArgs} args - Arguments to create many CleaningChecklists.
     * @example
     * // Create many CleaningChecklists
     * const cleaningChecklist = await prisma.cleaningChecklist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CleaningChecklists and only return the `id`
     * const cleaningChecklistWithIdOnly = await prisma.cleaningChecklist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CleaningChecklistCreateManyAndReturnArgs>(args?: SelectSubset<T, CleaningChecklistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CleaningChecklist.
     * @param {CleaningChecklistDeleteArgs} args - Arguments to delete one CleaningChecklist.
     * @example
     * // Delete one CleaningChecklist
     * const CleaningChecklist = await prisma.cleaningChecklist.delete({
     *   where: {
     *     // ... filter to delete one CleaningChecklist
     *   }
     * })
     * 
     */
    delete<T extends CleaningChecklistDeleteArgs>(args: SelectSubset<T, CleaningChecklistDeleteArgs<ExtArgs>>): Prisma__CleaningChecklistClient<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CleaningChecklist.
     * @param {CleaningChecklistUpdateArgs} args - Arguments to update one CleaningChecklist.
     * @example
     * // Update one CleaningChecklist
     * const cleaningChecklist = await prisma.cleaningChecklist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CleaningChecklistUpdateArgs>(args: SelectSubset<T, CleaningChecklistUpdateArgs<ExtArgs>>): Prisma__CleaningChecklistClient<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CleaningChecklists.
     * @param {CleaningChecklistDeleteManyArgs} args - Arguments to filter CleaningChecklists to delete.
     * @example
     * // Delete a few CleaningChecklists
     * const { count } = await prisma.cleaningChecklist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CleaningChecklistDeleteManyArgs>(args?: SelectSubset<T, CleaningChecklistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningChecklistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CleaningChecklists
     * const cleaningChecklist = await prisma.cleaningChecklist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CleaningChecklistUpdateManyArgs>(args: SelectSubset<T, CleaningChecklistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningChecklists and returns the data updated in the database.
     * @param {CleaningChecklistUpdateManyAndReturnArgs} args - Arguments to update many CleaningChecklists.
     * @example
     * // Update many CleaningChecklists
     * const cleaningChecklist = await prisma.cleaningChecklist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CleaningChecklists and only return the `id`
     * const cleaningChecklistWithIdOnly = await prisma.cleaningChecklist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CleaningChecklistUpdateManyAndReturnArgs>(args: SelectSubset<T, CleaningChecklistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CleaningChecklist.
     * @param {CleaningChecklistUpsertArgs} args - Arguments to update or create a CleaningChecklist.
     * @example
     * // Update or create a CleaningChecklist
     * const cleaningChecklist = await prisma.cleaningChecklist.upsert({
     *   create: {
     *     // ... data to create a CleaningChecklist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CleaningChecklist we want to update
     *   }
     * })
     */
    upsert<T extends CleaningChecklistUpsertArgs>(args: SelectSubset<T, CleaningChecklistUpsertArgs<ExtArgs>>): Prisma__CleaningChecklistClient<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CleaningChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningChecklistCountArgs} args - Arguments to filter CleaningChecklists to count.
     * @example
     * // Count the number of CleaningChecklists
     * const count = await prisma.cleaningChecklist.count({
     *   where: {
     *     // ... the filter for the CleaningChecklists we want to count
     *   }
     * })
    **/
    count<T extends CleaningChecklistCountArgs>(
      args?: Subset<T, CleaningChecklistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CleaningChecklistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CleaningChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningChecklistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CleaningChecklistAggregateArgs>(args: Subset<T, CleaningChecklistAggregateArgs>): Prisma.PrismaPromise<GetCleaningChecklistAggregateType<T>>

    /**
     * Group by CleaningChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningChecklistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CleaningChecklistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CleaningChecklistGroupByArgs['orderBy'] }
        : { orderBy?: CleaningChecklistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CleaningChecklistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCleaningChecklistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CleaningChecklist model
   */
  readonly fields: CleaningChecklistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CleaningChecklist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CleaningChecklistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cleaningSession<T extends CleaningSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CleaningSessionDefaultArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CleaningChecklist model
   */
  interface CleaningChecklistFieldRefs {
    readonly id: FieldRef<"CleaningChecklist", 'String'>
    readonly item: FieldRef<"CleaningChecklist", 'String'>
    readonly completed: FieldRef<"CleaningChecklist", 'Boolean'>
    readonly cleaningSessionId: FieldRef<"CleaningChecklist", 'String'>
    readonly createdAt: FieldRef<"CleaningChecklist", 'DateTime'>
    readonly updatedAt: FieldRef<"CleaningChecklist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CleaningChecklist findUnique
   */
  export type CleaningChecklistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter, which CleaningChecklist to fetch.
     */
    where: CleaningChecklistWhereUniqueInput
  }

  /**
   * CleaningChecklist findUniqueOrThrow
   */
  export type CleaningChecklistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter, which CleaningChecklist to fetch.
     */
    where: CleaningChecklistWhereUniqueInput
  }

  /**
   * CleaningChecklist findFirst
   */
  export type CleaningChecklistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter, which CleaningChecklist to fetch.
     */
    where?: CleaningChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningChecklists to fetch.
     */
    orderBy?: CleaningChecklistOrderByWithRelationInput | CleaningChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningChecklists.
     */
    cursor?: CleaningChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningChecklists.
     */
    distinct?: CleaningChecklistScalarFieldEnum | CleaningChecklistScalarFieldEnum[]
  }

  /**
   * CleaningChecklist findFirstOrThrow
   */
  export type CleaningChecklistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter, which CleaningChecklist to fetch.
     */
    where?: CleaningChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningChecklists to fetch.
     */
    orderBy?: CleaningChecklistOrderByWithRelationInput | CleaningChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningChecklists.
     */
    cursor?: CleaningChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningChecklists.
     */
    distinct?: CleaningChecklistScalarFieldEnum | CleaningChecklistScalarFieldEnum[]
  }

  /**
   * CleaningChecklist findMany
   */
  export type CleaningChecklistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter, which CleaningChecklists to fetch.
     */
    where?: CleaningChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningChecklists to fetch.
     */
    orderBy?: CleaningChecklistOrderByWithRelationInput | CleaningChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CleaningChecklists.
     */
    cursor?: CleaningChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningChecklists.
     */
    skip?: number
    distinct?: CleaningChecklistScalarFieldEnum | CleaningChecklistScalarFieldEnum[]
  }

  /**
   * CleaningChecklist create
   */
  export type CleaningChecklistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * The data needed to create a CleaningChecklist.
     */
    data: XOR<CleaningChecklistCreateInput, CleaningChecklistUncheckedCreateInput>
  }

  /**
   * CleaningChecklist createMany
   */
  export type CleaningChecklistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CleaningChecklists.
     */
    data: CleaningChecklistCreateManyInput | CleaningChecklistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CleaningChecklist createManyAndReturn
   */
  export type CleaningChecklistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * The data used to create many CleaningChecklists.
     */
    data: CleaningChecklistCreateManyInput | CleaningChecklistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningChecklist update
   */
  export type CleaningChecklistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * The data needed to update a CleaningChecklist.
     */
    data: XOR<CleaningChecklistUpdateInput, CleaningChecklistUncheckedUpdateInput>
    /**
     * Choose, which CleaningChecklist to update.
     */
    where: CleaningChecklistWhereUniqueInput
  }

  /**
   * CleaningChecklist updateMany
   */
  export type CleaningChecklistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CleaningChecklists.
     */
    data: XOR<CleaningChecklistUpdateManyMutationInput, CleaningChecklistUncheckedUpdateManyInput>
    /**
     * Filter which CleaningChecklists to update
     */
    where?: CleaningChecklistWhereInput
    /**
     * Limit how many CleaningChecklists to update.
     */
    limit?: number
  }

  /**
   * CleaningChecklist updateManyAndReturn
   */
  export type CleaningChecklistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * The data used to update CleaningChecklists.
     */
    data: XOR<CleaningChecklistUpdateManyMutationInput, CleaningChecklistUncheckedUpdateManyInput>
    /**
     * Filter which CleaningChecklists to update
     */
    where?: CleaningChecklistWhereInput
    /**
     * Limit how many CleaningChecklists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningChecklist upsert
   */
  export type CleaningChecklistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * The filter to search for the CleaningChecklist to update in case it exists.
     */
    where: CleaningChecklistWhereUniqueInput
    /**
     * In case the CleaningChecklist found by the `where` argument doesn't exist, create a new CleaningChecklist with this data.
     */
    create: XOR<CleaningChecklistCreateInput, CleaningChecklistUncheckedCreateInput>
    /**
     * In case the CleaningChecklist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CleaningChecklistUpdateInput, CleaningChecklistUncheckedUpdateInput>
  }

  /**
   * CleaningChecklist delete
   */
  export type CleaningChecklistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter which CleaningChecklist to delete.
     */
    where: CleaningChecklistWhereUniqueInput
  }

  /**
   * CleaningChecklist deleteMany
   */
  export type CleaningChecklistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningChecklists to delete
     */
    where?: CleaningChecklistWhereInput
    /**
     * Limit how many CleaningChecklists to delete.
     */
    limit?: number
  }

  /**
   * CleaningChecklist without action
   */
  export type CleaningChecklistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
  }


  /**
   * Model SiteCleaningChecklist
   */

  export type AggregateSiteCleaningChecklist = {
    _count: SiteCleaningChecklistCountAggregateOutputType | null
    _min: SiteCleaningChecklistMinAggregateOutputType | null
    _max: SiteCleaningChecklistMaxAggregateOutputType | null
  }

  export type SiteCleaningChecklistMinAggregateOutputType = {
    id: string | null
    item: string | null
    completed: boolean | null
    siteCleaningSessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteCleaningChecklistMaxAggregateOutputType = {
    id: string | null
    item: string | null
    completed: boolean | null
    siteCleaningSessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteCleaningChecklistCountAggregateOutputType = {
    id: number
    item: number
    completed: number
    siteCleaningSessionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SiteCleaningChecklistMinAggregateInputType = {
    id?: true
    item?: true
    completed?: true
    siteCleaningSessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteCleaningChecklistMaxAggregateInputType = {
    id?: true
    item?: true
    completed?: true
    siteCleaningSessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteCleaningChecklistCountAggregateInputType = {
    id?: true
    item?: true
    completed?: true
    siteCleaningSessionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SiteCleaningChecklistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteCleaningChecklist to aggregate.
     */
    where?: SiteCleaningChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteCleaningChecklists to fetch.
     */
    orderBy?: SiteCleaningChecklistOrderByWithRelationInput | SiteCleaningChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteCleaningChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteCleaningChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteCleaningChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteCleaningChecklists
    **/
    _count?: true | SiteCleaningChecklistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteCleaningChecklistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteCleaningChecklistMaxAggregateInputType
  }

  export type GetSiteCleaningChecklistAggregateType<T extends SiteCleaningChecklistAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteCleaningChecklist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteCleaningChecklist[P]>
      : GetScalarType<T[P], AggregateSiteCleaningChecklist[P]>
  }




  export type SiteCleaningChecklistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteCleaningChecklistWhereInput
    orderBy?: SiteCleaningChecklistOrderByWithAggregationInput | SiteCleaningChecklistOrderByWithAggregationInput[]
    by: SiteCleaningChecklistScalarFieldEnum[] | SiteCleaningChecklistScalarFieldEnum
    having?: SiteCleaningChecklistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteCleaningChecklistCountAggregateInputType | true
    _min?: SiteCleaningChecklistMinAggregateInputType
    _max?: SiteCleaningChecklistMaxAggregateInputType
  }

  export type SiteCleaningChecklistGroupByOutputType = {
    id: string
    item: string
    completed: boolean
    siteCleaningSessionId: string
    createdAt: Date
    updatedAt: Date
    _count: SiteCleaningChecklistCountAggregateOutputType | null
    _min: SiteCleaningChecklistMinAggregateOutputType | null
    _max: SiteCleaningChecklistMaxAggregateOutputType | null
  }

  type GetSiteCleaningChecklistGroupByPayload<T extends SiteCleaningChecklistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteCleaningChecklistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteCleaningChecklistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteCleaningChecklistGroupByOutputType[P]>
            : GetScalarType<T[P], SiteCleaningChecklistGroupByOutputType[P]>
        }
      >
    >


  export type SiteCleaningChecklistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item?: boolean
    completed?: boolean
    siteCleaningSessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    siteCleaningSession?: boolean | SiteCleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteCleaningChecklist"]>

  export type SiteCleaningChecklistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item?: boolean
    completed?: boolean
    siteCleaningSessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    siteCleaningSession?: boolean | SiteCleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteCleaningChecklist"]>

  export type SiteCleaningChecklistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item?: boolean
    completed?: boolean
    siteCleaningSessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    siteCleaningSession?: boolean | SiteCleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteCleaningChecklist"]>

  export type SiteCleaningChecklistSelectScalar = {
    id?: boolean
    item?: boolean
    completed?: boolean
    siteCleaningSessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SiteCleaningChecklistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "item" | "completed" | "siteCleaningSessionId" | "createdAt" | "updatedAt", ExtArgs["result"]["siteCleaningChecklist"]>
  export type SiteCleaningChecklistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    siteCleaningSession?: boolean | SiteCleaningSessionDefaultArgs<ExtArgs>
  }
  export type SiteCleaningChecklistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    siteCleaningSession?: boolean | SiteCleaningSessionDefaultArgs<ExtArgs>
  }
  export type SiteCleaningChecklistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    siteCleaningSession?: boolean | SiteCleaningSessionDefaultArgs<ExtArgs>
  }

  export type $SiteCleaningChecklistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteCleaningChecklist"
    objects: {
      siteCleaningSession: Prisma.$SiteCleaningSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      item: string
      completed: boolean
      siteCleaningSessionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["siteCleaningChecklist"]>
    composites: {}
  }

  type SiteCleaningChecklistGetPayload<S extends boolean | null | undefined | SiteCleaningChecklistDefaultArgs> = $Result.GetResult<Prisma.$SiteCleaningChecklistPayload, S>

  type SiteCleaningChecklistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteCleaningChecklistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteCleaningChecklistCountAggregateInputType | true
    }

  export interface SiteCleaningChecklistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteCleaningChecklist'], meta: { name: 'SiteCleaningChecklist' } }
    /**
     * Find zero or one SiteCleaningChecklist that matches the filter.
     * @param {SiteCleaningChecklistFindUniqueArgs} args - Arguments to find a SiteCleaningChecklist
     * @example
     * // Get one SiteCleaningChecklist
     * const siteCleaningChecklist = await prisma.siteCleaningChecklist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteCleaningChecklistFindUniqueArgs>(args: SelectSubset<T, SiteCleaningChecklistFindUniqueArgs<ExtArgs>>): Prisma__SiteCleaningChecklistClient<$Result.GetResult<Prisma.$SiteCleaningChecklistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SiteCleaningChecklist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteCleaningChecklistFindUniqueOrThrowArgs} args - Arguments to find a SiteCleaningChecklist
     * @example
     * // Get one SiteCleaningChecklist
     * const siteCleaningChecklist = await prisma.siteCleaningChecklist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteCleaningChecklistFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteCleaningChecklistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteCleaningChecklistClient<$Result.GetResult<Prisma.$SiteCleaningChecklistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteCleaningChecklist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningChecklistFindFirstArgs} args - Arguments to find a SiteCleaningChecklist
     * @example
     * // Get one SiteCleaningChecklist
     * const siteCleaningChecklist = await prisma.siteCleaningChecklist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteCleaningChecklistFindFirstArgs>(args?: SelectSubset<T, SiteCleaningChecklistFindFirstArgs<ExtArgs>>): Prisma__SiteCleaningChecklistClient<$Result.GetResult<Prisma.$SiteCleaningChecklistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteCleaningChecklist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningChecklistFindFirstOrThrowArgs} args - Arguments to find a SiteCleaningChecklist
     * @example
     * // Get one SiteCleaningChecklist
     * const siteCleaningChecklist = await prisma.siteCleaningChecklist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteCleaningChecklistFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteCleaningChecklistFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteCleaningChecklistClient<$Result.GetResult<Prisma.$SiteCleaningChecklistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteCleaningChecklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningChecklistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteCleaningChecklists
     * const siteCleaningChecklists = await prisma.siteCleaningChecklist.findMany()
     * 
     * // Get first 10 SiteCleaningChecklists
     * const siteCleaningChecklists = await prisma.siteCleaningChecklist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteCleaningChecklistWithIdOnly = await prisma.siteCleaningChecklist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SiteCleaningChecklistFindManyArgs>(args?: SelectSubset<T, SiteCleaningChecklistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteCleaningChecklistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SiteCleaningChecklist.
     * @param {SiteCleaningChecklistCreateArgs} args - Arguments to create a SiteCleaningChecklist.
     * @example
     * // Create one SiteCleaningChecklist
     * const SiteCleaningChecklist = await prisma.siteCleaningChecklist.create({
     *   data: {
     *     // ... data to create a SiteCleaningChecklist
     *   }
     * })
     * 
     */
    create<T extends SiteCleaningChecklistCreateArgs>(args: SelectSubset<T, SiteCleaningChecklistCreateArgs<ExtArgs>>): Prisma__SiteCleaningChecklistClient<$Result.GetResult<Prisma.$SiteCleaningChecklistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SiteCleaningChecklists.
     * @param {SiteCleaningChecklistCreateManyArgs} args - Arguments to create many SiteCleaningChecklists.
     * @example
     * // Create many SiteCleaningChecklists
     * const siteCleaningChecklist = await prisma.siteCleaningChecklist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteCleaningChecklistCreateManyArgs>(args?: SelectSubset<T, SiteCleaningChecklistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SiteCleaningChecklists and returns the data saved in the database.
     * @param {SiteCleaningChecklistCreateManyAndReturnArgs} args - Arguments to create many SiteCleaningChecklists.
     * @example
     * // Create many SiteCleaningChecklists
     * const siteCleaningChecklist = await prisma.siteCleaningChecklist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SiteCleaningChecklists and only return the `id`
     * const siteCleaningChecklistWithIdOnly = await prisma.siteCleaningChecklist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteCleaningChecklistCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteCleaningChecklistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteCleaningChecklistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SiteCleaningChecklist.
     * @param {SiteCleaningChecklistDeleteArgs} args - Arguments to delete one SiteCleaningChecklist.
     * @example
     * // Delete one SiteCleaningChecklist
     * const SiteCleaningChecklist = await prisma.siteCleaningChecklist.delete({
     *   where: {
     *     // ... filter to delete one SiteCleaningChecklist
     *   }
     * })
     * 
     */
    delete<T extends SiteCleaningChecklistDeleteArgs>(args: SelectSubset<T, SiteCleaningChecklistDeleteArgs<ExtArgs>>): Prisma__SiteCleaningChecklistClient<$Result.GetResult<Prisma.$SiteCleaningChecklistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SiteCleaningChecklist.
     * @param {SiteCleaningChecklistUpdateArgs} args - Arguments to update one SiteCleaningChecklist.
     * @example
     * // Update one SiteCleaningChecklist
     * const siteCleaningChecklist = await prisma.siteCleaningChecklist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteCleaningChecklistUpdateArgs>(args: SelectSubset<T, SiteCleaningChecklistUpdateArgs<ExtArgs>>): Prisma__SiteCleaningChecklistClient<$Result.GetResult<Prisma.$SiteCleaningChecklistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SiteCleaningChecklists.
     * @param {SiteCleaningChecklistDeleteManyArgs} args - Arguments to filter SiteCleaningChecklists to delete.
     * @example
     * // Delete a few SiteCleaningChecklists
     * const { count } = await prisma.siteCleaningChecklist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteCleaningChecklistDeleteManyArgs>(args?: SelectSubset<T, SiteCleaningChecklistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteCleaningChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningChecklistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteCleaningChecklists
     * const siteCleaningChecklist = await prisma.siteCleaningChecklist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteCleaningChecklistUpdateManyArgs>(args: SelectSubset<T, SiteCleaningChecklistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteCleaningChecklists and returns the data updated in the database.
     * @param {SiteCleaningChecklistUpdateManyAndReturnArgs} args - Arguments to update many SiteCleaningChecklists.
     * @example
     * // Update many SiteCleaningChecklists
     * const siteCleaningChecklist = await prisma.siteCleaningChecklist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SiteCleaningChecklists and only return the `id`
     * const siteCleaningChecklistWithIdOnly = await prisma.siteCleaningChecklist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteCleaningChecklistUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteCleaningChecklistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteCleaningChecklistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SiteCleaningChecklist.
     * @param {SiteCleaningChecklistUpsertArgs} args - Arguments to update or create a SiteCleaningChecklist.
     * @example
     * // Update or create a SiteCleaningChecklist
     * const siteCleaningChecklist = await prisma.siteCleaningChecklist.upsert({
     *   create: {
     *     // ... data to create a SiteCleaningChecklist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteCleaningChecklist we want to update
     *   }
     * })
     */
    upsert<T extends SiteCleaningChecklistUpsertArgs>(args: SelectSubset<T, SiteCleaningChecklistUpsertArgs<ExtArgs>>): Prisma__SiteCleaningChecklistClient<$Result.GetResult<Prisma.$SiteCleaningChecklistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SiteCleaningChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningChecklistCountArgs} args - Arguments to filter SiteCleaningChecklists to count.
     * @example
     * // Count the number of SiteCleaningChecklists
     * const count = await prisma.siteCleaningChecklist.count({
     *   where: {
     *     // ... the filter for the SiteCleaningChecklists we want to count
     *   }
     * })
    **/
    count<T extends SiteCleaningChecklistCountArgs>(
      args?: Subset<T, SiteCleaningChecklistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteCleaningChecklistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteCleaningChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningChecklistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteCleaningChecklistAggregateArgs>(args: Subset<T, SiteCleaningChecklistAggregateArgs>): Prisma.PrismaPromise<GetSiteCleaningChecklistAggregateType<T>>

    /**
     * Group by SiteCleaningChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCleaningChecklistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteCleaningChecklistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteCleaningChecklistGroupByArgs['orderBy'] }
        : { orderBy?: SiteCleaningChecklistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteCleaningChecklistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteCleaningChecklistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteCleaningChecklist model
   */
  readonly fields: SiteCleaningChecklistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteCleaningChecklist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteCleaningChecklistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    siteCleaningSession<T extends SiteCleaningSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteCleaningSessionDefaultArgs<ExtArgs>>): Prisma__SiteCleaningSessionClient<$Result.GetResult<Prisma.$SiteCleaningSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteCleaningChecklist model
   */
  interface SiteCleaningChecklistFieldRefs {
    readonly id: FieldRef<"SiteCleaningChecklist", 'String'>
    readonly item: FieldRef<"SiteCleaningChecklist", 'String'>
    readonly completed: FieldRef<"SiteCleaningChecklist", 'Boolean'>
    readonly siteCleaningSessionId: FieldRef<"SiteCleaningChecklist", 'String'>
    readonly createdAt: FieldRef<"SiteCleaningChecklist", 'DateTime'>
    readonly updatedAt: FieldRef<"SiteCleaningChecklist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SiteCleaningChecklist findUnique
   */
  export type SiteCleaningChecklistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningChecklist
     */
    select?: SiteCleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningChecklist
     */
    omit?: SiteCleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter, which SiteCleaningChecklist to fetch.
     */
    where: SiteCleaningChecklistWhereUniqueInput
  }

  /**
   * SiteCleaningChecklist findUniqueOrThrow
   */
  export type SiteCleaningChecklistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningChecklist
     */
    select?: SiteCleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningChecklist
     */
    omit?: SiteCleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter, which SiteCleaningChecklist to fetch.
     */
    where: SiteCleaningChecklistWhereUniqueInput
  }

  /**
   * SiteCleaningChecklist findFirst
   */
  export type SiteCleaningChecklistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningChecklist
     */
    select?: SiteCleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningChecklist
     */
    omit?: SiteCleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter, which SiteCleaningChecklist to fetch.
     */
    where?: SiteCleaningChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteCleaningChecklists to fetch.
     */
    orderBy?: SiteCleaningChecklistOrderByWithRelationInput | SiteCleaningChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteCleaningChecklists.
     */
    cursor?: SiteCleaningChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteCleaningChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteCleaningChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteCleaningChecklists.
     */
    distinct?: SiteCleaningChecklistScalarFieldEnum | SiteCleaningChecklistScalarFieldEnum[]
  }

  /**
   * SiteCleaningChecklist findFirstOrThrow
   */
  export type SiteCleaningChecklistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningChecklist
     */
    select?: SiteCleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningChecklist
     */
    omit?: SiteCleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter, which SiteCleaningChecklist to fetch.
     */
    where?: SiteCleaningChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteCleaningChecklists to fetch.
     */
    orderBy?: SiteCleaningChecklistOrderByWithRelationInput | SiteCleaningChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteCleaningChecklists.
     */
    cursor?: SiteCleaningChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteCleaningChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteCleaningChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteCleaningChecklists.
     */
    distinct?: SiteCleaningChecklistScalarFieldEnum | SiteCleaningChecklistScalarFieldEnum[]
  }

  /**
   * SiteCleaningChecklist findMany
   */
  export type SiteCleaningChecklistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningChecklist
     */
    select?: SiteCleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningChecklist
     */
    omit?: SiteCleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter, which SiteCleaningChecklists to fetch.
     */
    where?: SiteCleaningChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteCleaningChecklists to fetch.
     */
    orderBy?: SiteCleaningChecklistOrderByWithRelationInput | SiteCleaningChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteCleaningChecklists.
     */
    cursor?: SiteCleaningChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteCleaningChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteCleaningChecklists.
     */
    skip?: number
    distinct?: SiteCleaningChecklistScalarFieldEnum | SiteCleaningChecklistScalarFieldEnum[]
  }

  /**
   * SiteCleaningChecklist create
   */
  export type SiteCleaningChecklistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningChecklist
     */
    select?: SiteCleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningChecklist
     */
    omit?: SiteCleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningChecklistInclude<ExtArgs> | null
    /**
     * The data needed to create a SiteCleaningChecklist.
     */
    data: XOR<SiteCleaningChecklistCreateInput, SiteCleaningChecklistUncheckedCreateInput>
  }

  /**
   * SiteCleaningChecklist createMany
   */
  export type SiteCleaningChecklistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteCleaningChecklists.
     */
    data: SiteCleaningChecklistCreateManyInput | SiteCleaningChecklistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteCleaningChecklist createManyAndReturn
   */
  export type SiteCleaningChecklistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningChecklist
     */
    select?: SiteCleaningChecklistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningChecklist
     */
    omit?: SiteCleaningChecklistOmit<ExtArgs> | null
    /**
     * The data used to create many SiteCleaningChecklists.
     */
    data: SiteCleaningChecklistCreateManyInput | SiteCleaningChecklistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningChecklistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteCleaningChecklist update
   */
  export type SiteCleaningChecklistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningChecklist
     */
    select?: SiteCleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningChecklist
     */
    omit?: SiteCleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningChecklistInclude<ExtArgs> | null
    /**
     * The data needed to update a SiteCleaningChecklist.
     */
    data: XOR<SiteCleaningChecklistUpdateInput, SiteCleaningChecklistUncheckedUpdateInput>
    /**
     * Choose, which SiteCleaningChecklist to update.
     */
    where: SiteCleaningChecklistWhereUniqueInput
  }

  /**
   * SiteCleaningChecklist updateMany
   */
  export type SiteCleaningChecklistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteCleaningChecklists.
     */
    data: XOR<SiteCleaningChecklistUpdateManyMutationInput, SiteCleaningChecklistUncheckedUpdateManyInput>
    /**
     * Filter which SiteCleaningChecklists to update
     */
    where?: SiteCleaningChecklistWhereInput
    /**
     * Limit how many SiteCleaningChecklists to update.
     */
    limit?: number
  }

  /**
   * SiteCleaningChecklist updateManyAndReturn
   */
  export type SiteCleaningChecklistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningChecklist
     */
    select?: SiteCleaningChecklistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningChecklist
     */
    omit?: SiteCleaningChecklistOmit<ExtArgs> | null
    /**
     * The data used to update SiteCleaningChecklists.
     */
    data: XOR<SiteCleaningChecklistUpdateManyMutationInput, SiteCleaningChecklistUncheckedUpdateManyInput>
    /**
     * Filter which SiteCleaningChecklists to update
     */
    where?: SiteCleaningChecklistWhereInput
    /**
     * Limit how many SiteCleaningChecklists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningChecklistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteCleaningChecklist upsert
   */
  export type SiteCleaningChecklistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningChecklist
     */
    select?: SiteCleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningChecklist
     */
    omit?: SiteCleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningChecklistInclude<ExtArgs> | null
    /**
     * The filter to search for the SiteCleaningChecklist to update in case it exists.
     */
    where: SiteCleaningChecklistWhereUniqueInput
    /**
     * In case the SiteCleaningChecklist found by the `where` argument doesn't exist, create a new SiteCleaningChecklist with this data.
     */
    create: XOR<SiteCleaningChecklistCreateInput, SiteCleaningChecklistUncheckedCreateInput>
    /**
     * In case the SiteCleaningChecklist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteCleaningChecklistUpdateInput, SiteCleaningChecklistUncheckedUpdateInput>
  }

  /**
   * SiteCleaningChecklist delete
   */
  export type SiteCleaningChecklistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningChecklist
     */
    select?: SiteCleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningChecklist
     */
    omit?: SiteCleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter which SiteCleaningChecklist to delete.
     */
    where: SiteCleaningChecklistWhereUniqueInput
  }

  /**
   * SiteCleaningChecklist deleteMany
   */
  export type SiteCleaningChecklistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteCleaningChecklists to delete
     */
    where?: SiteCleaningChecklistWhereInput
    /**
     * Limit how many SiteCleaningChecklists to delete.
     */
    limit?: number
  }

  /**
   * SiteCleaningChecklist without action
   */
  export type SiteCleaningChecklistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCleaningChecklist
     */
    select?: SiteCleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteCleaningChecklist
     */
    omit?: SiteCleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteCleaningChecklistInclude<ExtArgs> | null
  }


  /**
   * Model CleaningPlanning
   */

  export type AggregateCleaningPlanning = {
    _count: CleaningPlanningCountAggregateOutputType | null
    _min: CleaningPlanningMinAggregateOutputType | null
    _max: CleaningPlanningMaxAggregateOutputType | null
  }

  export type CleaningPlanningMinAggregateOutputType = {
    id: string | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    interventionSiteId: string | null
    cleaningManagerId: string | null
    agentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningPlanningMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    interventionSiteId: string | null
    cleaningManagerId: string | null
    agentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningPlanningCountAggregateOutputType = {
    id: number
    date: number
    startTime: number
    endTime: number
    interventionSiteId: number
    cleaningManagerId: number
    agentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CleaningPlanningMinAggregateInputType = {
    id?: true
    date?: true
    startTime?: true
    endTime?: true
    interventionSiteId?: true
    cleaningManagerId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningPlanningMaxAggregateInputType = {
    id?: true
    date?: true
    startTime?: true
    endTime?: true
    interventionSiteId?: true
    cleaningManagerId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningPlanningCountAggregateInputType = {
    id?: true
    date?: true
    startTime?: true
    endTime?: true
    interventionSiteId?: true
    cleaningManagerId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CleaningPlanningAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningPlanning to aggregate.
     */
    where?: CleaningPlanningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningPlannings to fetch.
     */
    orderBy?: CleaningPlanningOrderByWithRelationInput | CleaningPlanningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CleaningPlanningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningPlannings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningPlannings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CleaningPlannings
    **/
    _count?: true | CleaningPlanningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CleaningPlanningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CleaningPlanningMaxAggregateInputType
  }

  export type GetCleaningPlanningAggregateType<T extends CleaningPlanningAggregateArgs> = {
        [P in keyof T & keyof AggregateCleaningPlanning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCleaningPlanning[P]>
      : GetScalarType<T[P], AggregateCleaningPlanning[P]>
  }




  export type CleaningPlanningGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningPlanningWhereInput
    orderBy?: CleaningPlanningOrderByWithAggregationInput | CleaningPlanningOrderByWithAggregationInput[]
    by: CleaningPlanningScalarFieldEnum[] | CleaningPlanningScalarFieldEnum
    having?: CleaningPlanningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CleaningPlanningCountAggregateInputType | true
    _min?: CleaningPlanningMinAggregateInputType
    _max?: CleaningPlanningMaxAggregateInputType
  }

  export type CleaningPlanningGroupByOutputType = {
    id: string
    date: Date
    startTime: string | null
    endTime: string | null
    interventionSiteId: string
    cleaningManagerId: string
    agentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CleaningPlanningCountAggregateOutputType | null
    _min: CleaningPlanningMinAggregateOutputType | null
    _max: CleaningPlanningMaxAggregateOutputType | null
  }

  type GetCleaningPlanningGroupByPayload<T extends CleaningPlanningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CleaningPlanningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CleaningPlanningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CleaningPlanningGroupByOutputType[P]>
            : GetScalarType<T[P], CleaningPlanningGroupByOutputType[P]>
        }
      >
    >


  export type CleaningPlanningSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    interventionSiteId?: boolean
    cleaningManagerId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    interventionSite?: boolean | InterventionSiteDefaultArgs<ExtArgs>
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
    agent?: boolean | CleaningPlanning$agentArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningPlanning"]>

  export type CleaningPlanningSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    interventionSiteId?: boolean
    cleaningManagerId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    interventionSite?: boolean | InterventionSiteDefaultArgs<ExtArgs>
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
    agent?: boolean | CleaningPlanning$agentArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningPlanning"]>

  export type CleaningPlanningSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    interventionSiteId?: boolean
    cleaningManagerId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    interventionSite?: boolean | InterventionSiteDefaultArgs<ExtArgs>
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
    agent?: boolean | CleaningPlanning$agentArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningPlanning"]>

  export type CleaningPlanningSelectScalar = {
    id?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    interventionSiteId?: boolean
    cleaningManagerId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CleaningPlanningOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "startTime" | "endTime" | "interventionSiteId" | "cleaningManagerId" | "agentId" | "createdAt" | "updatedAt", ExtArgs["result"]["cleaningPlanning"]>
  export type CleaningPlanningInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interventionSite?: boolean | InterventionSiteDefaultArgs<ExtArgs>
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
    agent?: boolean | CleaningPlanning$agentArgs<ExtArgs>
  }
  export type CleaningPlanningIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interventionSite?: boolean | InterventionSiteDefaultArgs<ExtArgs>
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
    agent?: boolean | CleaningPlanning$agentArgs<ExtArgs>
  }
  export type CleaningPlanningIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interventionSite?: boolean | InterventionSiteDefaultArgs<ExtArgs>
    cleaningManager?: boolean | CleaningManagerDefaultArgs<ExtArgs>
    agent?: boolean | CleaningPlanning$agentArgs<ExtArgs>
  }

  export type $CleaningPlanningPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CleaningPlanning"
    objects: {
      interventionSite: Prisma.$InterventionSitePayload<ExtArgs>
      cleaningManager: Prisma.$CleaningManagerPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      startTime: string | null
      endTime: string | null
      interventionSiteId: string
      cleaningManagerId: string
      agentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cleaningPlanning"]>
    composites: {}
  }

  type CleaningPlanningGetPayload<S extends boolean | null | undefined | CleaningPlanningDefaultArgs> = $Result.GetResult<Prisma.$CleaningPlanningPayload, S>

  type CleaningPlanningCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CleaningPlanningFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CleaningPlanningCountAggregateInputType | true
    }

  export interface CleaningPlanningDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CleaningPlanning'], meta: { name: 'CleaningPlanning' } }
    /**
     * Find zero or one CleaningPlanning that matches the filter.
     * @param {CleaningPlanningFindUniqueArgs} args - Arguments to find a CleaningPlanning
     * @example
     * // Get one CleaningPlanning
     * const cleaningPlanning = await prisma.cleaningPlanning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CleaningPlanningFindUniqueArgs>(args: SelectSubset<T, CleaningPlanningFindUniqueArgs<ExtArgs>>): Prisma__CleaningPlanningClient<$Result.GetResult<Prisma.$CleaningPlanningPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CleaningPlanning that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CleaningPlanningFindUniqueOrThrowArgs} args - Arguments to find a CleaningPlanning
     * @example
     * // Get one CleaningPlanning
     * const cleaningPlanning = await prisma.cleaningPlanning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CleaningPlanningFindUniqueOrThrowArgs>(args: SelectSubset<T, CleaningPlanningFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CleaningPlanningClient<$Result.GetResult<Prisma.$CleaningPlanningPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningPlanning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPlanningFindFirstArgs} args - Arguments to find a CleaningPlanning
     * @example
     * // Get one CleaningPlanning
     * const cleaningPlanning = await prisma.cleaningPlanning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CleaningPlanningFindFirstArgs>(args?: SelectSubset<T, CleaningPlanningFindFirstArgs<ExtArgs>>): Prisma__CleaningPlanningClient<$Result.GetResult<Prisma.$CleaningPlanningPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningPlanning that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPlanningFindFirstOrThrowArgs} args - Arguments to find a CleaningPlanning
     * @example
     * // Get one CleaningPlanning
     * const cleaningPlanning = await prisma.cleaningPlanning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CleaningPlanningFindFirstOrThrowArgs>(args?: SelectSubset<T, CleaningPlanningFindFirstOrThrowArgs<ExtArgs>>): Prisma__CleaningPlanningClient<$Result.GetResult<Prisma.$CleaningPlanningPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CleaningPlannings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPlanningFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CleaningPlannings
     * const cleaningPlannings = await prisma.cleaningPlanning.findMany()
     * 
     * // Get first 10 CleaningPlannings
     * const cleaningPlannings = await prisma.cleaningPlanning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cleaningPlanningWithIdOnly = await prisma.cleaningPlanning.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CleaningPlanningFindManyArgs>(args?: SelectSubset<T, CleaningPlanningFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningPlanningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CleaningPlanning.
     * @param {CleaningPlanningCreateArgs} args - Arguments to create a CleaningPlanning.
     * @example
     * // Create one CleaningPlanning
     * const CleaningPlanning = await prisma.cleaningPlanning.create({
     *   data: {
     *     // ... data to create a CleaningPlanning
     *   }
     * })
     * 
     */
    create<T extends CleaningPlanningCreateArgs>(args: SelectSubset<T, CleaningPlanningCreateArgs<ExtArgs>>): Prisma__CleaningPlanningClient<$Result.GetResult<Prisma.$CleaningPlanningPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CleaningPlannings.
     * @param {CleaningPlanningCreateManyArgs} args - Arguments to create many CleaningPlannings.
     * @example
     * // Create many CleaningPlannings
     * const cleaningPlanning = await prisma.cleaningPlanning.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CleaningPlanningCreateManyArgs>(args?: SelectSubset<T, CleaningPlanningCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CleaningPlannings and returns the data saved in the database.
     * @param {CleaningPlanningCreateManyAndReturnArgs} args - Arguments to create many CleaningPlannings.
     * @example
     * // Create many CleaningPlannings
     * const cleaningPlanning = await prisma.cleaningPlanning.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CleaningPlannings and only return the `id`
     * const cleaningPlanningWithIdOnly = await prisma.cleaningPlanning.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CleaningPlanningCreateManyAndReturnArgs>(args?: SelectSubset<T, CleaningPlanningCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningPlanningPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CleaningPlanning.
     * @param {CleaningPlanningDeleteArgs} args - Arguments to delete one CleaningPlanning.
     * @example
     * // Delete one CleaningPlanning
     * const CleaningPlanning = await prisma.cleaningPlanning.delete({
     *   where: {
     *     // ... filter to delete one CleaningPlanning
     *   }
     * })
     * 
     */
    delete<T extends CleaningPlanningDeleteArgs>(args: SelectSubset<T, CleaningPlanningDeleteArgs<ExtArgs>>): Prisma__CleaningPlanningClient<$Result.GetResult<Prisma.$CleaningPlanningPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CleaningPlanning.
     * @param {CleaningPlanningUpdateArgs} args - Arguments to update one CleaningPlanning.
     * @example
     * // Update one CleaningPlanning
     * const cleaningPlanning = await prisma.cleaningPlanning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CleaningPlanningUpdateArgs>(args: SelectSubset<T, CleaningPlanningUpdateArgs<ExtArgs>>): Prisma__CleaningPlanningClient<$Result.GetResult<Prisma.$CleaningPlanningPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CleaningPlannings.
     * @param {CleaningPlanningDeleteManyArgs} args - Arguments to filter CleaningPlannings to delete.
     * @example
     * // Delete a few CleaningPlannings
     * const { count } = await prisma.cleaningPlanning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CleaningPlanningDeleteManyArgs>(args?: SelectSubset<T, CleaningPlanningDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningPlannings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPlanningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CleaningPlannings
     * const cleaningPlanning = await prisma.cleaningPlanning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CleaningPlanningUpdateManyArgs>(args: SelectSubset<T, CleaningPlanningUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningPlannings and returns the data updated in the database.
     * @param {CleaningPlanningUpdateManyAndReturnArgs} args - Arguments to update many CleaningPlannings.
     * @example
     * // Update many CleaningPlannings
     * const cleaningPlanning = await prisma.cleaningPlanning.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CleaningPlannings and only return the `id`
     * const cleaningPlanningWithIdOnly = await prisma.cleaningPlanning.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CleaningPlanningUpdateManyAndReturnArgs>(args: SelectSubset<T, CleaningPlanningUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningPlanningPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CleaningPlanning.
     * @param {CleaningPlanningUpsertArgs} args - Arguments to update or create a CleaningPlanning.
     * @example
     * // Update or create a CleaningPlanning
     * const cleaningPlanning = await prisma.cleaningPlanning.upsert({
     *   create: {
     *     // ... data to create a CleaningPlanning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CleaningPlanning we want to update
     *   }
     * })
     */
    upsert<T extends CleaningPlanningUpsertArgs>(args: SelectSubset<T, CleaningPlanningUpsertArgs<ExtArgs>>): Prisma__CleaningPlanningClient<$Result.GetResult<Prisma.$CleaningPlanningPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CleaningPlannings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPlanningCountArgs} args - Arguments to filter CleaningPlannings to count.
     * @example
     * // Count the number of CleaningPlannings
     * const count = await prisma.cleaningPlanning.count({
     *   where: {
     *     // ... the filter for the CleaningPlannings we want to count
     *   }
     * })
    **/
    count<T extends CleaningPlanningCountArgs>(
      args?: Subset<T, CleaningPlanningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CleaningPlanningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CleaningPlanning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPlanningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CleaningPlanningAggregateArgs>(args: Subset<T, CleaningPlanningAggregateArgs>): Prisma.PrismaPromise<GetCleaningPlanningAggregateType<T>>

    /**
     * Group by CleaningPlanning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPlanningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CleaningPlanningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CleaningPlanningGroupByArgs['orderBy'] }
        : { orderBy?: CleaningPlanningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CleaningPlanningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCleaningPlanningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CleaningPlanning model
   */
  readonly fields: CleaningPlanningFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CleaningPlanning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CleaningPlanningClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interventionSite<T extends InterventionSiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterventionSiteDefaultArgs<ExtArgs>>): Prisma__InterventionSiteClient<$Result.GetResult<Prisma.$InterventionSitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cleaningManager<T extends CleaningManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CleaningManagerDefaultArgs<ExtArgs>>): Prisma__CleaningManagerClient<$Result.GetResult<Prisma.$CleaningManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends CleaningPlanning$agentArgs<ExtArgs> = {}>(args?: Subset<T, CleaningPlanning$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CleaningPlanning model
   */
  interface CleaningPlanningFieldRefs {
    readonly id: FieldRef<"CleaningPlanning", 'String'>
    readonly date: FieldRef<"CleaningPlanning", 'DateTime'>
    readonly startTime: FieldRef<"CleaningPlanning", 'String'>
    readonly endTime: FieldRef<"CleaningPlanning", 'String'>
    readonly interventionSiteId: FieldRef<"CleaningPlanning", 'String'>
    readonly cleaningManagerId: FieldRef<"CleaningPlanning", 'String'>
    readonly agentId: FieldRef<"CleaningPlanning", 'String'>
    readonly createdAt: FieldRef<"CleaningPlanning", 'DateTime'>
    readonly updatedAt: FieldRef<"CleaningPlanning", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CleaningPlanning findUnique
   */
  export type CleaningPlanningFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPlanning
     */
    select?: CleaningPlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPlanning
     */
    omit?: CleaningPlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPlanningInclude<ExtArgs> | null
    /**
     * Filter, which CleaningPlanning to fetch.
     */
    where: CleaningPlanningWhereUniqueInput
  }

  /**
   * CleaningPlanning findUniqueOrThrow
   */
  export type CleaningPlanningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPlanning
     */
    select?: CleaningPlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPlanning
     */
    omit?: CleaningPlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPlanningInclude<ExtArgs> | null
    /**
     * Filter, which CleaningPlanning to fetch.
     */
    where: CleaningPlanningWhereUniqueInput
  }

  /**
   * CleaningPlanning findFirst
   */
  export type CleaningPlanningFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPlanning
     */
    select?: CleaningPlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPlanning
     */
    omit?: CleaningPlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPlanningInclude<ExtArgs> | null
    /**
     * Filter, which CleaningPlanning to fetch.
     */
    where?: CleaningPlanningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningPlannings to fetch.
     */
    orderBy?: CleaningPlanningOrderByWithRelationInput | CleaningPlanningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningPlannings.
     */
    cursor?: CleaningPlanningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningPlannings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningPlannings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningPlannings.
     */
    distinct?: CleaningPlanningScalarFieldEnum | CleaningPlanningScalarFieldEnum[]
  }

  /**
   * CleaningPlanning findFirstOrThrow
   */
  export type CleaningPlanningFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPlanning
     */
    select?: CleaningPlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPlanning
     */
    omit?: CleaningPlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPlanningInclude<ExtArgs> | null
    /**
     * Filter, which CleaningPlanning to fetch.
     */
    where?: CleaningPlanningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningPlannings to fetch.
     */
    orderBy?: CleaningPlanningOrderByWithRelationInput | CleaningPlanningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningPlannings.
     */
    cursor?: CleaningPlanningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningPlannings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningPlannings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningPlannings.
     */
    distinct?: CleaningPlanningScalarFieldEnum | CleaningPlanningScalarFieldEnum[]
  }

  /**
   * CleaningPlanning findMany
   */
  export type CleaningPlanningFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPlanning
     */
    select?: CleaningPlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPlanning
     */
    omit?: CleaningPlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPlanningInclude<ExtArgs> | null
    /**
     * Filter, which CleaningPlannings to fetch.
     */
    where?: CleaningPlanningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningPlannings to fetch.
     */
    orderBy?: CleaningPlanningOrderByWithRelationInput | CleaningPlanningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CleaningPlannings.
     */
    cursor?: CleaningPlanningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningPlannings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningPlannings.
     */
    skip?: number
    distinct?: CleaningPlanningScalarFieldEnum | CleaningPlanningScalarFieldEnum[]
  }

  /**
   * CleaningPlanning create
   */
  export type CleaningPlanningCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPlanning
     */
    select?: CleaningPlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPlanning
     */
    omit?: CleaningPlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPlanningInclude<ExtArgs> | null
    /**
     * The data needed to create a CleaningPlanning.
     */
    data: XOR<CleaningPlanningCreateInput, CleaningPlanningUncheckedCreateInput>
  }

  /**
   * CleaningPlanning createMany
   */
  export type CleaningPlanningCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CleaningPlannings.
     */
    data: CleaningPlanningCreateManyInput | CleaningPlanningCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CleaningPlanning createManyAndReturn
   */
  export type CleaningPlanningCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPlanning
     */
    select?: CleaningPlanningSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPlanning
     */
    omit?: CleaningPlanningOmit<ExtArgs> | null
    /**
     * The data used to create many CleaningPlannings.
     */
    data: CleaningPlanningCreateManyInput | CleaningPlanningCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPlanningIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningPlanning update
   */
  export type CleaningPlanningUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPlanning
     */
    select?: CleaningPlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPlanning
     */
    omit?: CleaningPlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPlanningInclude<ExtArgs> | null
    /**
     * The data needed to update a CleaningPlanning.
     */
    data: XOR<CleaningPlanningUpdateInput, CleaningPlanningUncheckedUpdateInput>
    /**
     * Choose, which CleaningPlanning to update.
     */
    where: CleaningPlanningWhereUniqueInput
  }

  /**
   * CleaningPlanning updateMany
   */
  export type CleaningPlanningUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CleaningPlannings.
     */
    data: XOR<CleaningPlanningUpdateManyMutationInput, CleaningPlanningUncheckedUpdateManyInput>
    /**
     * Filter which CleaningPlannings to update
     */
    where?: CleaningPlanningWhereInput
    /**
     * Limit how many CleaningPlannings to update.
     */
    limit?: number
  }

  /**
   * CleaningPlanning updateManyAndReturn
   */
  export type CleaningPlanningUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPlanning
     */
    select?: CleaningPlanningSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPlanning
     */
    omit?: CleaningPlanningOmit<ExtArgs> | null
    /**
     * The data used to update CleaningPlannings.
     */
    data: XOR<CleaningPlanningUpdateManyMutationInput, CleaningPlanningUncheckedUpdateManyInput>
    /**
     * Filter which CleaningPlannings to update
     */
    where?: CleaningPlanningWhereInput
    /**
     * Limit how many CleaningPlannings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPlanningIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningPlanning upsert
   */
  export type CleaningPlanningUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPlanning
     */
    select?: CleaningPlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPlanning
     */
    omit?: CleaningPlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPlanningInclude<ExtArgs> | null
    /**
     * The filter to search for the CleaningPlanning to update in case it exists.
     */
    where: CleaningPlanningWhereUniqueInput
    /**
     * In case the CleaningPlanning found by the `where` argument doesn't exist, create a new CleaningPlanning with this data.
     */
    create: XOR<CleaningPlanningCreateInput, CleaningPlanningUncheckedCreateInput>
    /**
     * In case the CleaningPlanning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CleaningPlanningUpdateInput, CleaningPlanningUncheckedUpdateInput>
  }

  /**
   * CleaningPlanning delete
   */
  export type CleaningPlanningDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPlanning
     */
    select?: CleaningPlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPlanning
     */
    omit?: CleaningPlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPlanningInclude<ExtArgs> | null
    /**
     * Filter which CleaningPlanning to delete.
     */
    where: CleaningPlanningWhereUniqueInput
  }

  /**
   * CleaningPlanning deleteMany
   */
  export type CleaningPlanningDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningPlannings to delete
     */
    where?: CleaningPlanningWhereInput
    /**
     * Limit how many CleaningPlannings to delete.
     */
    limit?: number
  }

  /**
   * CleaningPlanning.agent
   */
  export type CleaningPlanning$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * CleaningPlanning without action
   */
  export type CleaningPlanningDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPlanning
     */
    select?: CleaningPlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPlanning
     */
    omit?: CleaningPlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPlanningInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    quantity: number | null
    price: number | null
    orderId: string | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    quantity: number | null
    price: number | null
    orderId: string | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    quantity: number
    price: number
    orderId: number
    productId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    quantity?: true
    price?: true
    orderId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    quantity?: true
    price?: true
    orderId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    quantity?: true
    price?: true
    orderId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    quantity: number
    price: number | null
    orderId: string
    productId: string
    createdAt: Date
    updatedAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    price?: boolean
    orderId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    price?: boolean
    orderId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    price?: boolean
    orderId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    quantity?: boolean
    price?: boolean
    orderId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantity" | "price" | "orderId" | "productId" | "createdAt" | "updatedAt", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quantity: number
      price: number | null
      orderId: string
      productId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly price: FieldRef<"OrderItem", 'Float'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'String'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryNote
   */

  export type AggregateDeliveryNote = {
    _count: DeliveryNoteCountAggregateOutputType | null
    _min: DeliveryNoteMinAggregateOutputType | null
    _max: DeliveryNoteMaxAggregateOutputType | null
  }

  export type DeliveryNoteMinAggregateOutputType = {
    id: string | null
    number: string | null
    date: Date | null
    orderId: string | null
    laundryManagerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryNoteMaxAggregateOutputType = {
    id: string | null
    number: string | null
    date: Date | null
    orderId: string | null
    laundryManagerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryNoteCountAggregateOutputType = {
    id: number
    number: number
    date: number
    orderId: number
    laundryManagerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeliveryNoteMinAggregateInputType = {
    id?: true
    number?: true
    date?: true
    orderId?: true
    laundryManagerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryNoteMaxAggregateInputType = {
    id?: true
    number?: true
    date?: true
    orderId?: true
    laundryManagerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryNoteCountAggregateInputType = {
    id?: true
    number?: true
    date?: true
    orderId?: true
    laundryManagerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeliveryNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryNote to aggregate.
     */
    where?: DeliveryNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryNotes to fetch.
     */
    orderBy?: DeliveryNoteOrderByWithRelationInput | DeliveryNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryNotes
    **/
    _count?: true | DeliveryNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryNoteMaxAggregateInputType
  }

  export type GetDeliveryNoteAggregateType<T extends DeliveryNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryNote[P]>
      : GetScalarType<T[P], AggregateDeliveryNote[P]>
  }




  export type DeliveryNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryNoteWhereInput
    orderBy?: DeliveryNoteOrderByWithAggregationInput | DeliveryNoteOrderByWithAggregationInput[]
    by: DeliveryNoteScalarFieldEnum[] | DeliveryNoteScalarFieldEnum
    having?: DeliveryNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryNoteCountAggregateInputType | true
    _min?: DeliveryNoteMinAggregateInputType
    _max?: DeliveryNoteMaxAggregateInputType
  }

  export type DeliveryNoteGroupByOutputType = {
    id: string
    number: string
    date: Date
    orderId: string
    laundryManagerId: string
    createdAt: Date
    updatedAt: Date
    _count: DeliveryNoteCountAggregateOutputType | null
    _min: DeliveryNoteMinAggregateOutputType | null
    _max: DeliveryNoteMaxAggregateOutputType | null
  }

  type GetDeliveryNoteGroupByPayload<T extends DeliveryNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryNoteGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryNoteGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    orderId?: boolean
    laundryManagerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryNote"]>

  export type DeliveryNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    orderId?: boolean
    laundryManagerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryNote"]>

  export type DeliveryNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    orderId?: boolean
    laundryManagerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryNote"]>

  export type DeliveryNoteSelectScalar = {
    id?: boolean
    number?: boolean
    date?: boolean
    orderId?: boolean
    laundryManagerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeliveryNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number" | "date" | "orderId" | "laundryManagerId" | "createdAt" | "updatedAt", ExtArgs["result"]["deliveryNote"]>
  export type DeliveryNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
  }
  export type DeliveryNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
  }
  export type DeliveryNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    laundryManager?: boolean | LaundryManagerDefaultArgs<ExtArgs>
  }

  export type $DeliveryNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryNote"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      laundryManager: Prisma.$LaundryManagerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number: string
      date: Date
      orderId: string
      laundryManagerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deliveryNote"]>
    composites: {}
  }

  type DeliveryNoteGetPayload<S extends boolean | null | undefined | DeliveryNoteDefaultArgs> = $Result.GetResult<Prisma.$DeliveryNotePayload, S>

  type DeliveryNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryNoteCountAggregateInputType | true
    }

  export interface DeliveryNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryNote'], meta: { name: 'DeliveryNote' } }
    /**
     * Find zero or one DeliveryNote that matches the filter.
     * @param {DeliveryNoteFindUniqueArgs} args - Arguments to find a DeliveryNote
     * @example
     * // Get one DeliveryNote
     * const deliveryNote = await prisma.deliveryNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryNoteFindUniqueArgs>(args: SelectSubset<T, DeliveryNoteFindUniqueArgs<ExtArgs>>): Prisma__DeliveryNoteClient<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryNoteFindUniqueOrThrowArgs} args - Arguments to find a DeliveryNote
     * @example
     * // Get one DeliveryNote
     * const deliveryNote = await prisma.deliveryNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryNoteClient<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryNoteFindFirstArgs} args - Arguments to find a DeliveryNote
     * @example
     * // Get one DeliveryNote
     * const deliveryNote = await prisma.deliveryNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryNoteFindFirstArgs>(args?: SelectSubset<T, DeliveryNoteFindFirstArgs<ExtArgs>>): Prisma__DeliveryNoteClient<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryNoteFindFirstOrThrowArgs} args - Arguments to find a DeliveryNote
     * @example
     * // Get one DeliveryNote
     * const deliveryNote = await prisma.deliveryNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryNoteClient<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryNotes
     * const deliveryNotes = await prisma.deliveryNote.findMany()
     * 
     * // Get first 10 DeliveryNotes
     * const deliveryNotes = await prisma.deliveryNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryNoteWithIdOnly = await prisma.deliveryNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryNoteFindManyArgs>(args?: SelectSubset<T, DeliveryNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryNote.
     * @param {DeliveryNoteCreateArgs} args - Arguments to create a DeliveryNote.
     * @example
     * // Create one DeliveryNote
     * const DeliveryNote = await prisma.deliveryNote.create({
     *   data: {
     *     // ... data to create a DeliveryNote
     *   }
     * })
     * 
     */
    create<T extends DeliveryNoteCreateArgs>(args: SelectSubset<T, DeliveryNoteCreateArgs<ExtArgs>>): Prisma__DeliveryNoteClient<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryNotes.
     * @param {DeliveryNoteCreateManyArgs} args - Arguments to create many DeliveryNotes.
     * @example
     * // Create many DeliveryNotes
     * const deliveryNote = await prisma.deliveryNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryNoteCreateManyArgs>(args?: SelectSubset<T, DeliveryNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryNotes and returns the data saved in the database.
     * @param {DeliveryNoteCreateManyAndReturnArgs} args - Arguments to create many DeliveryNotes.
     * @example
     * // Create many DeliveryNotes
     * const deliveryNote = await prisma.deliveryNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryNotes and only return the `id`
     * const deliveryNoteWithIdOnly = await prisma.deliveryNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryNote.
     * @param {DeliveryNoteDeleteArgs} args - Arguments to delete one DeliveryNote.
     * @example
     * // Delete one DeliveryNote
     * const DeliveryNote = await prisma.deliveryNote.delete({
     *   where: {
     *     // ... filter to delete one DeliveryNote
     *   }
     * })
     * 
     */
    delete<T extends DeliveryNoteDeleteArgs>(args: SelectSubset<T, DeliveryNoteDeleteArgs<ExtArgs>>): Prisma__DeliveryNoteClient<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryNote.
     * @param {DeliveryNoteUpdateArgs} args - Arguments to update one DeliveryNote.
     * @example
     * // Update one DeliveryNote
     * const deliveryNote = await prisma.deliveryNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryNoteUpdateArgs>(args: SelectSubset<T, DeliveryNoteUpdateArgs<ExtArgs>>): Prisma__DeliveryNoteClient<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryNotes.
     * @param {DeliveryNoteDeleteManyArgs} args - Arguments to filter DeliveryNotes to delete.
     * @example
     * // Delete a few DeliveryNotes
     * const { count } = await prisma.deliveryNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryNoteDeleteManyArgs>(args?: SelectSubset<T, DeliveryNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryNotes
     * const deliveryNote = await prisma.deliveryNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryNoteUpdateManyArgs>(args: SelectSubset<T, DeliveryNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryNotes and returns the data updated in the database.
     * @param {DeliveryNoteUpdateManyAndReturnArgs} args - Arguments to update many DeliveryNotes.
     * @example
     * // Update many DeliveryNotes
     * const deliveryNote = await prisma.deliveryNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryNotes and only return the `id`
     * const deliveryNoteWithIdOnly = await prisma.deliveryNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryNote.
     * @param {DeliveryNoteUpsertArgs} args - Arguments to update or create a DeliveryNote.
     * @example
     * // Update or create a DeliveryNote
     * const deliveryNote = await prisma.deliveryNote.upsert({
     *   create: {
     *     // ... data to create a DeliveryNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryNote we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryNoteUpsertArgs>(args: SelectSubset<T, DeliveryNoteUpsertArgs<ExtArgs>>): Prisma__DeliveryNoteClient<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryNoteCountArgs} args - Arguments to filter DeliveryNotes to count.
     * @example
     * // Count the number of DeliveryNotes
     * const count = await prisma.deliveryNote.count({
     *   where: {
     *     // ... the filter for the DeliveryNotes we want to count
     *   }
     * })
    **/
    count<T extends DeliveryNoteCountArgs>(
      args?: Subset<T, DeliveryNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryNoteAggregateArgs>(args: Subset<T, DeliveryNoteAggregateArgs>): Prisma.PrismaPromise<GetDeliveryNoteAggregateType<T>>

    /**
     * Group by DeliveryNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryNoteGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryNote model
   */
  readonly fields: DeliveryNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    laundryManager<T extends LaundryManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LaundryManagerDefaultArgs<ExtArgs>>): Prisma__LaundryManagerClient<$Result.GetResult<Prisma.$LaundryManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryNote model
   */
  interface DeliveryNoteFieldRefs {
    readonly id: FieldRef<"DeliveryNote", 'String'>
    readonly number: FieldRef<"DeliveryNote", 'String'>
    readonly date: FieldRef<"DeliveryNote", 'DateTime'>
    readonly orderId: FieldRef<"DeliveryNote", 'String'>
    readonly laundryManagerId: FieldRef<"DeliveryNote", 'String'>
    readonly createdAt: FieldRef<"DeliveryNote", 'DateTime'>
    readonly updatedAt: FieldRef<"DeliveryNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryNote findUnique
   */
  export type DeliveryNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryNote to fetch.
     */
    where: DeliveryNoteWhereUniqueInput
  }

  /**
   * DeliveryNote findUniqueOrThrow
   */
  export type DeliveryNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryNote to fetch.
     */
    where: DeliveryNoteWhereUniqueInput
  }

  /**
   * DeliveryNote findFirst
   */
  export type DeliveryNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryNote to fetch.
     */
    where?: DeliveryNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryNotes to fetch.
     */
    orderBy?: DeliveryNoteOrderByWithRelationInput | DeliveryNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryNotes.
     */
    cursor?: DeliveryNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryNotes.
     */
    distinct?: DeliveryNoteScalarFieldEnum | DeliveryNoteScalarFieldEnum[]
  }

  /**
   * DeliveryNote findFirstOrThrow
   */
  export type DeliveryNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryNote to fetch.
     */
    where?: DeliveryNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryNotes to fetch.
     */
    orderBy?: DeliveryNoteOrderByWithRelationInput | DeliveryNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryNotes.
     */
    cursor?: DeliveryNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryNotes.
     */
    distinct?: DeliveryNoteScalarFieldEnum | DeliveryNoteScalarFieldEnum[]
  }

  /**
   * DeliveryNote findMany
   */
  export type DeliveryNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryNotes to fetch.
     */
    where?: DeliveryNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryNotes to fetch.
     */
    orderBy?: DeliveryNoteOrderByWithRelationInput | DeliveryNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryNotes.
     */
    cursor?: DeliveryNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryNotes.
     */
    skip?: number
    distinct?: DeliveryNoteScalarFieldEnum | DeliveryNoteScalarFieldEnum[]
  }

  /**
   * DeliveryNote create
   */
  export type DeliveryNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryNote.
     */
    data: XOR<DeliveryNoteCreateInput, DeliveryNoteUncheckedCreateInput>
  }

  /**
   * DeliveryNote createMany
   */
  export type DeliveryNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryNotes.
     */
    data: DeliveryNoteCreateManyInput | DeliveryNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryNote createManyAndReturn
   */
  export type DeliveryNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryNotes.
     */
    data: DeliveryNoteCreateManyInput | DeliveryNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryNote update
   */
  export type DeliveryNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryNote.
     */
    data: XOR<DeliveryNoteUpdateInput, DeliveryNoteUncheckedUpdateInput>
    /**
     * Choose, which DeliveryNote to update.
     */
    where: DeliveryNoteWhereUniqueInput
  }

  /**
   * DeliveryNote updateMany
   */
  export type DeliveryNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryNotes.
     */
    data: XOR<DeliveryNoteUpdateManyMutationInput, DeliveryNoteUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryNotes to update
     */
    where?: DeliveryNoteWhereInput
    /**
     * Limit how many DeliveryNotes to update.
     */
    limit?: number
  }

  /**
   * DeliveryNote updateManyAndReturn
   */
  export type DeliveryNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryNotes.
     */
    data: XOR<DeliveryNoteUpdateManyMutationInput, DeliveryNoteUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryNotes to update
     */
    where?: DeliveryNoteWhereInput
    /**
     * Limit how many DeliveryNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryNote upsert
   */
  export type DeliveryNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryNote to update in case it exists.
     */
    where: DeliveryNoteWhereUniqueInput
    /**
     * In case the DeliveryNote found by the `where` argument doesn't exist, create a new DeliveryNote with this data.
     */
    create: XOR<DeliveryNoteCreateInput, DeliveryNoteUncheckedCreateInput>
    /**
     * In case the DeliveryNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryNoteUpdateInput, DeliveryNoteUncheckedUpdateInput>
  }

  /**
   * DeliveryNote delete
   */
  export type DeliveryNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * Filter which DeliveryNote to delete.
     */
    where: DeliveryNoteWhereUniqueInput
  }

  /**
   * DeliveryNote deleteMany
   */
  export type DeliveryNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryNotes to delete
     */
    where?: DeliveryNoteWhereInput
    /**
     * Limit how many DeliveryNotes to delete.
     */
    limit?: number
  }

  /**
   * DeliveryNote without action
   */
  export type DeliveryNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    type: string | null
    userId: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    type: string | null
    userId: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    message: number
    type: number
    userId: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    userId?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    userId?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    userId?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string
    message: string
    type: string | null
    userId: string
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    userId?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    userId?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    userId?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    userId?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "message" | "type" | "userId" | "read" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      message: string
      type: string | null
      userId: string
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    description: string
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    users?: boolean | Service$usersArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Service$usersArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      users: Prisma.$ServiceUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Service$usersArgs<ExtArgs> = {}>(args?: Subset<T, Service$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.users
   */
  export type Service$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceUser
     */
    select?: ServiceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceUser
     */
    omit?: ServiceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceUserInclude<ExtArgs> | null
    where?: ServiceUserWhereInput
    orderBy?: ServiceUserOrderByWithRelationInput | ServiceUserOrderByWithRelationInput[]
    cursor?: ServiceUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceUserScalarFieldEnum | ServiceUserScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model ServiceUser
   */

  export type AggregateServiceUser = {
    _count: ServiceUserCountAggregateOutputType | null
    _min: ServiceUserMinAggregateOutputType | null
    _max: ServiceUserMaxAggregateOutputType | null
  }

  export type ServiceUserMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: $Enums.ServiceUserStatus | null
    serviceId: string | null
    userId: string | null
  }

  export type ServiceUserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: $Enums.ServiceUserStatus | null
    serviceId: string | null
    userId: string | null
  }

  export type ServiceUserCountAggregateOutputType = {
    id: number
    name: number
    status: number
    serviceId: number
    userId: number
    _all: number
  }


  export type ServiceUserMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    serviceId?: true
    userId?: true
  }

  export type ServiceUserMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    serviceId?: true
    userId?: true
  }

  export type ServiceUserCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    serviceId?: true
    userId?: true
    _all?: true
  }

  export type ServiceUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceUser to aggregate.
     */
    where?: ServiceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceUsers to fetch.
     */
    orderBy?: ServiceUserOrderByWithRelationInput | ServiceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceUsers
    **/
    _count?: true | ServiceUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceUserMaxAggregateInputType
  }

  export type GetServiceUserAggregateType<T extends ServiceUserAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceUser[P]>
      : GetScalarType<T[P], AggregateServiceUser[P]>
  }




  export type ServiceUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceUserWhereInput
    orderBy?: ServiceUserOrderByWithAggregationInput | ServiceUserOrderByWithAggregationInput[]
    by: ServiceUserScalarFieldEnum[] | ServiceUserScalarFieldEnum
    having?: ServiceUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceUserCountAggregateInputType | true
    _min?: ServiceUserMinAggregateInputType
    _max?: ServiceUserMaxAggregateInputType
  }

  export type ServiceUserGroupByOutputType = {
    id: string
    name: string
    status: $Enums.ServiceUserStatus
    serviceId: string
    userId: string
    _count: ServiceUserCountAggregateOutputType | null
    _min: ServiceUserMinAggregateOutputType | null
    _max: ServiceUserMaxAggregateOutputType | null
  }

  type GetServiceUserGroupByPayload<T extends ServiceUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceUserGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceUserGroupByOutputType[P]>
        }
      >
    >


  export type ServiceUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    serviceId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceUser"]>

  export type ServiceUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    serviceId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceUser"]>

  export type ServiceUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    serviceId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceUser"]>

  export type ServiceUserSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    serviceId?: boolean
    userId?: boolean
  }

  export type ServiceUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "serviceId" | "userId", ExtArgs["result"]["serviceUser"]>
  export type ServiceUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ServiceUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ServiceUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $ServiceUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      status: $Enums.ServiceUserStatus
      serviceId: string
      userId: string
    }, ExtArgs["result"]["serviceUser"]>
    composites: {}
  }

  type ServiceUserGetPayload<S extends boolean | null | undefined | ServiceUserDefaultArgs> = $Result.GetResult<Prisma.$ServiceUserPayload, S>

  type ServiceUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceUserCountAggregateInputType | true
    }

  export interface ServiceUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceUser'], meta: { name: 'ServiceUser' } }
    /**
     * Find zero or one ServiceUser that matches the filter.
     * @param {ServiceUserFindUniqueArgs} args - Arguments to find a ServiceUser
     * @example
     * // Get one ServiceUser
     * const serviceUser = await prisma.serviceUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceUserFindUniqueArgs>(args: SelectSubset<T, ServiceUserFindUniqueArgs<ExtArgs>>): Prisma__ServiceUserClient<$Result.GetResult<Prisma.$ServiceUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceUserFindUniqueOrThrowArgs} args - Arguments to find a ServiceUser
     * @example
     * // Get one ServiceUser
     * const serviceUser = await prisma.serviceUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceUserFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceUserClient<$Result.GetResult<Prisma.$ServiceUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUserFindFirstArgs} args - Arguments to find a ServiceUser
     * @example
     * // Get one ServiceUser
     * const serviceUser = await prisma.serviceUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceUserFindFirstArgs>(args?: SelectSubset<T, ServiceUserFindFirstArgs<ExtArgs>>): Prisma__ServiceUserClient<$Result.GetResult<Prisma.$ServiceUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUserFindFirstOrThrowArgs} args - Arguments to find a ServiceUser
     * @example
     * // Get one ServiceUser
     * const serviceUser = await prisma.serviceUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceUserFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceUserClient<$Result.GetResult<Prisma.$ServiceUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceUsers
     * const serviceUsers = await prisma.serviceUser.findMany()
     * 
     * // Get first 10 ServiceUsers
     * const serviceUsers = await prisma.serviceUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceUserWithIdOnly = await prisma.serviceUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceUserFindManyArgs>(args?: SelectSubset<T, ServiceUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceUser.
     * @param {ServiceUserCreateArgs} args - Arguments to create a ServiceUser.
     * @example
     * // Create one ServiceUser
     * const ServiceUser = await prisma.serviceUser.create({
     *   data: {
     *     // ... data to create a ServiceUser
     *   }
     * })
     * 
     */
    create<T extends ServiceUserCreateArgs>(args: SelectSubset<T, ServiceUserCreateArgs<ExtArgs>>): Prisma__ServiceUserClient<$Result.GetResult<Prisma.$ServiceUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceUsers.
     * @param {ServiceUserCreateManyArgs} args - Arguments to create many ServiceUsers.
     * @example
     * // Create many ServiceUsers
     * const serviceUser = await prisma.serviceUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceUserCreateManyArgs>(args?: SelectSubset<T, ServiceUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceUsers and returns the data saved in the database.
     * @param {ServiceUserCreateManyAndReturnArgs} args - Arguments to create many ServiceUsers.
     * @example
     * // Create many ServiceUsers
     * const serviceUser = await prisma.serviceUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceUsers and only return the `id`
     * const serviceUserWithIdOnly = await prisma.serviceUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceUserCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceUser.
     * @param {ServiceUserDeleteArgs} args - Arguments to delete one ServiceUser.
     * @example
     * // Delete one ServiceUser
     * const ServiceUser = await prisma.serviceUser.delete({
     *   where: {
     *     // ... filter to delete one ServiceUser
     *   }
     * })
     * 
     */
    delete<T extends ServiceUserDeleteArgs>(args: SelectSubset<T, ServiceUserDeleteArgs<ExtArgs>>): Prisma__ServiceUserClient<$Result.GetResult<Prisma.$ServiceUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceUser.
     * @param {ServiceUserUpdateArgs} args - Arguments to update one ServiceUser.
     * @example
     * // Update one ServiceUser
     * const serviceUser = await prisma.serviceUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUserUpdateArgs>(args: SelectSubset<T, ServiceUserUpdateArgs<ExtArgs>>): Prisma__ServiceUserClient<$Result.GetResult<Prisma.$ServiceUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceUsers.
     * @param {ServiceUserDeleteManyArgs} args - Arguments to filter ServiceUsers to delete.
     * @example
     * // Delete a few ServiceUsers
     * const { count } = await prisma.serviceUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceUserDeleteManyArgs>(args?: SelectSubset<T, ServiceUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceUsers
     * const serviceUser = await prisma.serviceUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUserUpdateManyArgs>(args: SelectSubset<T, ServiceUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceUsers and returns the data updated in the database.
     * @param {ServiceUserUpdateManyAndReturnArgs} args - Arguments to update many ServiceUsers.
     * @example
     * // Update many ServiceUsers
     * const serviceUser = await prisma.serviceUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceUsers and only return the `id`
     * const serviceUserWithIdOnly = await prisma.serviceUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUserUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceUser.
     * @param {ServiceUserUpsertArgs} args - Arguments to update or create a ServiceUser.
     * @example
     * // Update or create a ServiceUser
     * const serviceUser = await prisma.serviceUser.upsert({
     *   create: {
     *     // ... data to create a ServiceUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceUser we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUserUpsertArgs>(args: SelectSubset<T, ServiceUserUpsertArgs<ExtArgs>>): Prisma__ServiceUserClient<$Result.GetResult<Prisma.$ServiceUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUserCountArgs} args - Arguments to filter ServiceUsers to count.
     * @example
     * // Count the number of ServiceUsers
     * const count = await prisma.serviceUser.count({
     *   where: {
     *     // ... the filter for the ServiceUsers we want to count
     *   }
     * })
    **/
    count<T extends ServiceUserCountArgs>(
      args?: Subset<T, ServiceUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceUserAggregateArgs>(args: Subset<T, ServiceUserAggregateArgs>): Prisma.PrismaPromise<GetServiceUserAggregateType<T>>

    /**
     * Group by ServiceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceUserGroupByArgs['orderBy'] }
        : { orderBy?: ServiceUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceUser model
   */
  readonly fields: ServiceUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceUser model
   */
  interface ServiceUserFieldRefs {
    readonly id: FieldRef<"ServiceUser", 'String'>
    readonly name: FieldRef<"ServiceUser", 'String'>
    readonly status: FieldRef<"ServiceUser", 'ServiceUserStatus'>
    readonly serviceId: FieldRef<"ServiceUser", 'String'>
    readonly userId: FieldRef<"ServiceUser", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceUser findUnique
   */
  export type ServiceUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceUser
     */
    select?: ServiceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceUser
     */
    omit?: ServiceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceUserInclude<ExtArgs> | null
    /**
     * Filter, which ServiceUser to fetch.
     */
    where: ServiceUserWhereUniqueInput
  }

  /**
   * ServiceUser findUniqueOrThrow
   */
  export type ServiceUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceUser
     */
    select?: ServiceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceUser
     */
    omit?: ServiceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceUserInclude<ExtArgs> | null
    /**
     * Filter, which ServiceUser to fetch.
     */
    where: ServiceUserWhereUniqueInput
  }

  /**
   * ServiceUser findFirst
   */
  export type ServiceUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceUser
     */
    select?: ServiceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceUser
     */
    omit?: ServiceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceUserInclude<ExtArgs> | null
    /**
     * Filter, which ServiceUser to fetch.
     */
    where?: ServiceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceUsers to fetch.
     */
    orderBy?: ServiceUserOrderByWithRelationInput | ServiceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceUsers.
     */
    cursor?: ServiceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceUsers.
     */
    distinct?: ServiceUserScalarFieldEnum | ServiceUserScalarFieldEnum[]
  }

  /**
   * ServiceUser findFirstOrThrow
   */
  export type ServiceUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceUser
     */
    select?: ServiceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceUser
     */
    omit?: ServiceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceUserInclude<ExtArgs> | null
    /**
     * Filter, which ServiceUser to fetch.
     */
    where?: ServiceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceUsers to fetch.
     */
    orderBy?: ServiceUserOrderByWithRelationInput | ServiceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceUsers.
     */
    cursor?: ServiceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceUsers.
     */
    distinct?: ServiceUserScalarFieldEnum | ServiceUserScalarFieldEnum[]
  }

  /**
   * ServiceUser findMany
   */
  export type ServiceUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceUser
     */
    select?: ServiceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceUser
     */
    omit?: ServiceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceUserInclude<ExtArgs> | null
    /**
     * Filter, which ServiceUsers to fetch.
     */
    where?: ServiceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceUsers to fetch.
     */
    orderBy?: ServiceUserOrderByWithRelationInput | ServiceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceUsers.
     */
    cursor?: ServiceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceUsers.
     */
    skip?: number
    distinct?: ServiceUserScalarFieldEnum | ServiceUserScalarFieldEnum[]
  }

  /**
   * ServiceUser create
   */
  export type ServiceUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceUser
     */
    select?: ServiceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceUser
     */
    omit?: ServiceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceUserInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceUser.
     */
    data: XOR<ServiceUserCreateInput, ServiceUserUncheckedCreateInput>
  }

  /**
   * ServiceUser createMany
   */
  export type ServiceUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceUsers.
     */
    data: ServiceUserCreateManyInput | ServiceUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceUser createManyAndReturn
   */
  export type ServiceUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceUser
     */
    select?: ServiceUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceUser
     */
    omit?: ServiceUserOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceUsers.
     */
    data: ServiceUserCreateManyInput | ServiceUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceUser update
   */
  export type ServiceUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceUser
     */
    select?: ServiceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceUser
     */
    omit?: ServiceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceUserInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceUser.
     */
    data: XOR<ServiceUserUpdateInput, ServiceUserUncheckedUpdateInput>
    /**
     * Choose, which ServiceUser to update.
     */
    where: ServiceUserWhereUniqueInput
  }

  /**
   * ServiceUser updateMany
   */
  export type ServiceUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceUsers.
     */
    data: XOR<ServiceUserUpdateManyMutationInput, ServiceUserUncheckedUpdateManyInput>
    /**
     * Filter which ServiceUsers to update
     */
    where?: ServiceUserWhereInput
    /**
     * Limit how many ServiceUsers to update.
     */
    limit?: number
  }

  /**
   * ServiceUser updateManyAndReturn
   */
  export type ServiceUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceUser
     */
    select?: ServiceUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceUser
     */
    omit?: ServiceUserOmit<ExtArgs> | null
    /**
     * The data used to update ServiceUsers.
     */
    data: XOR<ServiceUserUpdateManyMutationInput, ServiceUserUncheckedUpdateManyInput>
    /**
     * Filter which ServiceUsers to update
     */
    where?: ServiceUserWhereInput
    /**
     * Limit how many ServiceUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceUser upsert
   */
  export type ServiceUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceUser
     */
    select?: ServiceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceUser
     */
    omit?: ServiceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceUserInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceUser to update in case it exists.
     */
    where: ServiceUserWhereUniqueInput
    /**
     * In case the ServiceUser found by the `where` argument doesn't exist, create a new ServiceUser with this data.
     */
    create: XOR<ServiceUserCreateInput, ServiceUserUncheckedCreateInput>
    /**
     * In case the ServiceUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUserUpdateInput, ServiceUserUncheckedUpdateInput>
  }

  /**
   * ServiceUser delete
   */
  export type ServiceUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceUser
     */
    select?: ServiceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceUser
     */
    omit?: ServiceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceUserInclude<ExtArgs> | null
    /**
     * Filter which ServiceUser to delete.
     */
    where: ServiceUserWhereUniqueInput
  }

  /**
   * ServiceUser deleteMany
   */
  export type ServiceUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceUsers to delete
     */
    where?: ServiceUserWhereInput
    /**
     * Limit how many ServiceUsers to delete.
     */
    limit?: number
  }

  /**
   * ServiceUser without action
   */
  export type ServiceUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceUser
     */
    select?: ServiceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceUser
     */
    omit?: ServiceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceUserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date | null
    updatedAt: Date | null
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    role: 'role',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ConciergerieManagerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConciergerieManagerScalarFieldEnum = (typeof ConciergerieManagerScalarFieldEnum)[keyof typeof ConciergerieManagerScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    conciergerieManagerId: 'conciergerieManagerId',
    agentId: 'agentId'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    location: 'location',
    surface: 'surface',
    numberOfRooms: 'numberOfRooms',
    numberOfBathrooms: 'numberOfBathrooms',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    conciergerieManagerId: 'conciergerieManagerId'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const ReservationScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    startDate: 'startDate',
    endDate: 'endDate',
    client: 'client',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReservationScalarFieldEnum = (typeof ReservationScalarFieldEnum)[keyof typeof ReservationScalarFieldEnum]


  export const AgentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    type: 'type',
    conciergerieManagerId: 'conciergerieManagerId',
    userId: 'userId',
    cleaningManagerId: 'cleaningManagerId'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const MaintenanceSessionScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    maintenanceId: 'maintenanceId',
    agentId: 'agentId',
    startDate: 'startDate',
    endDate: 'endDate',
    notes: 'notes'
  };

  export type MaintenanceSessionScalarFieldEnum = (typeof MaintenanceSessionScalarFieldEnum)[keyof typeof MaintenanceSessionScalarFieldEnum]


  export const MaintenanceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaintenanceScalarFieldEnum = (typeof MaintenanceScalarFieldEnum)[keyof typeof MaintenanceScalarFieldEnum]


  export const CleaningSessionScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    cleaningId: 'cleaningId',
    agentId: 'agentId',
    startDate: 'startDate',
    endDate: 'endDate',
    duration: 'duration',
    notes: 'notes'
  };

  export type CleaningSessionScalarFieldEnum = (typeof CleaningSessionScalarFieldEnum)[keyof typeof CleaningSessionScalarFieldEnum]


  export const CleaningScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CleaningScalarFieldEnum = (typeof CleaningScalarFieldEnum)[keyof typeof CleaningScalarFieldEnum]


  export const CleaningManagerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CleaningManagerScalarFieldEnum = (typeof CleaningManagerScalarFieldEnum)[keyof typeof CleaningManagerScalarFieldEnum]


  export const InterventionSiteScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    client: 'client',
    site: 'site',
    surface: 'surface',
    type: 'type',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    cleaningManagerId: 'cleaningManagerId'
  };

  export type InterventionSiteScalarFieldEnum = (typeof InterventionSiteScalarFieldEnum)[keyof typeof InterventionSiteScalarFieldEnum]


  export const SiteCleaningSessionScalarFieldEnum: {
    id: 'id',
    interventionSiteId: 'interventionSiteId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    cleaningManagerId: 'cleaningManagerId',
    startDate: 'startDate',
    endDate: 'endDate',
    duration: 'duration',
    notes: 'notes',
    status: 'status',
    laundryManagerId: 'laundryManagerId',
    cleaningAgentId: 'cleaningAgentId'
  };

  export type SiteCleaningSessionScalarFieldEnum = (typeof SiteCleaningSessionScalarFieldEnum)[keyof typeof SiteCleaningSessionScalarFieldEnum]


  export const LaundryManagerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaundryManagerScalarFieldEnum = (typeof LaundryManagerScalarFieldEnum)[keyof typeof LaundryManagerScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    stock: 'stock',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    laundryManagerId: 'laundryManagerId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    receivedDate: 'receivedDate',
    deliveryDate: 'deliveryDate',
    client: 'client',
    address: 'address',
    phone: 'phone',
    total: 'total',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    laundryManagerId: 'laundryManagerId'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    propertyId: 'propertyId',
    agentId: 'agentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    currency: 'currency',
    method: 'method',
    status: 'status',
    propertyId: 'propertyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const PropertyPhotoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    type: 'type',
    propertyId: 'propertyId',
    createdAt: 'createdAt'
  };

  export type PropertyPhotoScalarFieldEnum = (typeof PropertyPhotoScalarFieldEnum)[keyof typeof PropertyPhotoScalarFieldEnum]


  export const CleaningPhotoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    type: 'type',
    cleaningSessionId: 'cleaningSessionId',
    createdAt: 'createdAt'
  };

  export type CleaningPhotoScalarFieldEnum = (typeof CleaningPhotoScalarFieldEnum)[keyof typeof CleaningPhotoScalarFieldEnum]


  export const MaintenancePhotoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    type: 'type',
    maintenanceSessionId: 'maintenanceSessionId',
    createdAt: 'createdAt'
  };

  export type MaintenancePhotoScalarFieldEnum = (typeof MaintenancePhotoScalarFieldEnum)[keyof typeof MaintenancePhotoScalarFieldEnum]


  export const SiteCleaningPhotoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    type: 'type',
    siteCleaningSessionId: 'siteCleaningSessionId',
    createdAt: 'createdAt'
  };

  export type SiteCleaningPhotoScalarFieldEnum = (typeof SiteCleaningPhotoScalarFieldEnum)[keyof typeof SiteCleaningPhotoScalarFieldEnum]


  export const TicketPhotoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    ticketId: 'ticketId',
    createdAt: 'createdAt'
  };

  export type TicketPhotoScalarFieldEnum = (typeof TicketPhotoScalarFieldEnum)[keyof typeof TicketPhotoScalarFieldEnum]


  export const CleaningChecklistScalarFieldEnum: {
    id: 'id',
    item: 'item',
    completed: 'completed',
    cleaningSessionId: 'cleaningSessionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CleaningChecklistScalarFieldEnum = (typeof CleaningChecklistScalarFieldEnum)[keyof typeof CleaningChecklistScalarFieldEnum]


  export const SiteCleaningChecklistScalarFieldEnum: {
    id: 'id',
    item: 'item',
    completed: 'completed',
    siteCleaningSessionId: 'siteCleaningSessionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SiteCleaningChecklistScalarFieldEnum = (typeof SiteCleaningChecklistScalarFieldEnum)[keyof typeof SiteCleaningChecklistScalarFieldEnum]


  export const CleaningPlanningScalarFieldEnum: {
    id: 'id',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    interventionSiteId: 'interventionSiteId',
    cleaningManagerId: 'cleaningManagerId',
    agentId: 'agentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CleaningPlanningScalarFieldEnum = (typeof CleaningPlanningScalarFieldEnum)[keyof typeof CleaningPlanningScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    price: 'price',
    orderId: 'orderId',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const DeliveryNoteScalarFieldEnum: {
    id: 'id',
    number: 'number',
    date: 'date',
    orderId: 'orderId',
    laundryManagerId: 'laundryManagerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeliveryNoteScalarFieldEnum = (typeof DeliveryNoteScalarFieldEnum)[keyof typeof DeliveryNoteScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    type: 'type',
    userId: 'userId',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ServiceUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    serviceId: 'serviceId',
    userId: 'userId'
  };

  export type ServiceUserScalarFieldEnum = (typeof ServiceUserScalarFieldEnum)[keyof typeof ServiceUserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PropertyStatus'
   */
  export type EnumPropertyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyStatus'>
    


  /**
   * Reference to a field of type 'PropertyStatus[]'
   */
  export type ListEnumPropertyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'AgentType'
   */
  export type EnumAgentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentType'>
    


  /**
   * Reference to a field of type 'AgentType[]'
   */
  export type ListEnumAgentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentType[]'>
    


  /**
   * Reference to a field of type 'InterventionStatus'
   */
  export type EnumInterventionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterventionStatus'>
    


  /**
   * Reference to a field of type 'InterventionStatus[]'
   */
  export type ListEnumInterventionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterventionStatus[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    


  /**
   * Reference to a field of type 'TicketStatus[]'
   */
  export type ListEnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus[]'>
    


  /**
   * Reference to a field of type 'ServiceUserStatus'
   */
  export type EnumServiceUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceUserStatus'>
    


  /**
   * Reference to a field of type 'ServiceUserStatus[]'
   */
  export type ListEnumServiceUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceUserStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    conciergerieManagers?: ConciergerieManagerListRelationFilter
    cleaningManagers?: CleaningManagerListRelationFilter
    laundryManagers?: LaundryManagerListRelationFilter
    notifications?: NotificationListRelationFilter
    serviceUsers?: ServiceUserListRelationFilter
    agent?: AgentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    conciergerieManagers?: ConciergerieManagerOrderByRelationAggregateInput
    cleaningManagers?: CleaningManagerOrderByRelationAggregateInput
    laundryManagers?: LaundryManagerOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    serviceUsers?: ServiceUserOrderByRelationAggregateInput
    agent?: AgentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    role?: EnumRoleFilter<"User"> | $Enums.Role
    name?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    conciergerieManagers?: ConciergerieManagerListRelationFilter
    cleaningManagers?: CleaningManagerListRelationFilter
    laundryManagers?: LaundryManagerListRelationFilter
    notifications?: NotificationListRelationFilter
    serviceUsers?: ServiceUserListRelationFilter
    agent?: AgentListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ConciergerieManagerWhereInput = {
    AND?: ConciergerieManagerWhereInput | ConciergerieManagerWhereInput[]
    OR?: ConciergerieManagerWhereInput[]
    NOT?: ConciergerieManagerWhereInput | ConciergerieManagerWhereInput[]
    id?: StringFilter<"ConciergerieManager"> | string
    name?: StringFilter<"ConciergerieManager"> | string
    userId?: StringFilter<"ConciergerieManager"> | string
    createdAt?: DateTimeFilter<"ConciergerieManager"> | Date | string
    updatedAt?: DateTimeFilter<"ConciergerieManager"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    properties?: PropertyListRelationFilter
    agents?: AgentListRelationFilter
    tasks?: TaskListRelationFilter
  }

  export type ConciergerieManagerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    properties?: PropertyOrderByRelationAggregateInput
    agents?: AgentOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type ConciergerieManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConciergerieManagerWhereInput | ConciergerieManagerWhereInput[]
    OR?: ConciergerieManagerWhereInput[]
    NOT?: ConciergerieManagerWhereInput | ConciergerieManagerWhereInput[]
    name?: StringFilter<"ConciergerieManager"> | string
    userId?: StringFilter<"ConciergerieManager"> | string
    createdAt?: DateTimeFilter<"ConciergerieManager"> | Date | string
    updatedAt?: DateTimeFilter<"ConciergerieManager"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    properties?: PropertyListRelationFilter
    agents?: AgentListRelationFilter
    tasks?: TaskListRelationFilter
  }, "id">

  export type ConciergerieManagerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConciergerieManagerCountOrderByAggregateInput
    _max?: ConciergerieManagerMaxOrderByAggregateInput
    _min?: ConciergerieManagerMinOrderByAggregateInput
  }

  export type ConciergerieManagerScalarWhereWithAggregatesInput = {
    AND?: ConciergerieManagerScalarWhereWithAggregatesInput | ConciergerieManagerScalarWhereWithAggregatesInput[]
    OR?: ConciergerieManagerScalarWhereWithAggregatesInput[]
    NOT?: ConciergerieManagerScalarWhereWithAggregatesInput | ConciergerieManagerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConciergerieManager"> | string
    name?: StringWithAggregatesFilter<"ConciergerieManager"> | string
    userId?: StringWithAggregatesFilter<"ConciergerieManager"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConciergerieManager"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConciergerieManager"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    name?: StringFilter<"Task"> | string
    description?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    conciergerieManagerId?: StringNullableFilter<"Task"> | string | null
    agentId?: StringNullableFilter<"Task"> | string | null
    conciergerieManager?: XOR<ConciergerieManagerNullableScalarRelationFilter, ConciergerieManagerWhereInput> | null
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conciergerieManagerId?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    conciergerieManager?: ConciergerieManagerOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    name?: StringFilter<"Task"> | string
    description?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    conciergerieManagerId?: StringNullableFilter<"Task"> | string | null
    agentId?: StringNullableFilter<"Task"> | string | null
    conciergerieManager?: XOR<ConciergerieManagerNullableScalarRelationFilter, ConciergerieManagerWhereInput> | null
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conciergerieManagerId?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    name?: StringWithAggregatesFilter<"Task"> | string
    description?: StringWithAggregatesFilter<"Task"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    conciergerieManagerId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    agentId?: StringNullableWithAggregatesFilter<"Task"> | string | null
  }

  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: StringFilter<"Property"> | string
    name?: StringFilter<"Property"> | string
    description?: StringFilter<"Property"> | string
    status?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    location?: StringNullableFilter<"Property"> | string | null
    surface?: FloatNullableFilter<"Property"> | number | null
    numberOfRooms?: IntNullableFilter<"Property"> | number | null
    numberOfBathrooms?: IntNullableFilter<"Property"> | number | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    conciergerieManagerId?: StringFilter<"Property"> | string
    conciergerieManager?: XOR<ConciergerieManagerScalarRelationFilter, ConciergerieManagerWhereInput>
    cleaningSessions?: CleaningSessionListRelationFilter
    maintenanceSessions?: MaintenanceSessionListRelationFilter
    reservations?: ReservationListRelationFilter
    payments?: PaymentListRelationFilter
    tickets?: TicketListRelationFilter
    photos?: PropertyPhotoListRelationFilter
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    surface?: SortOrderInput | SortOrder
    numberOfRooms?: SortOrderInput | SortOrder
    numberOfBathrooms?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conciergerieManagerId?: SortOrder
    conciergerieManager?: ConciergerieManagerOrderByWithRelationInput
    cleaningSessions?: CleaningSessionOrderByRelationAggregateInput
    maintenanceSessions?: MaintenanceSessionOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    photos?: PropertyPhotoOrderByRelationAggregateInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    name?: StringFilter<"Property"> | string
    description?: StringFilter<"Property"> | string
    status?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    location?: StringNullableFilter<"Property"> | string | null
    surface?: FloatNullableFilter<"Property"> | number | null
    numberOfRooms?: IntNullableFilter<"Property"> | number | null
    numberOfBathrooms?: IntNullableFilter<"Property"> | number | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    conciergerieManagerId?: StringFilter<"Property"> | string
    conciergerieManager?: XOR<ConciergerieManagerScalarRelationFilter, ConciergerieManagerWhereInput>
    cleaningSessions?: CleaningSessionListRelationFilter
    maintenanceSessions?: MaintenanceSessionListRelationFilter
    reservations?: ReservationListRelationFilter
    payments?: PaymentListRelationFilter
    tickets?: TicketListRelationFilter
    photos?: PropertyPhotoListRelationFilter
  }, "id">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    surface?: SortOrderInput | SortOrder
    numberOfRooms?: SortOrderInput | SortOrder
    numberOfBathrooms?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conciergerieManagerId?: SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _avg?: PropertyAvgOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
    _sum?: PropertySumOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Property"> | string
    name?: StringWithAggregatesFilter<"Property"> | string
    description?: StringWithAggregatesFilter<"Property"> | string
    status?: EnumPropertyStatusWithAggregatesFilter<"Property"> | $Enums.PropertyStatus
    location?: StringNullableWithAggregatesFilter<"Property"> | string | null
    surface?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    numberOfRooms?: IntNullableWithAggregatesFilter<"Property"> | number | null
    numberOfBathrooms?: IntNullableWithAggregatesFilter<"Property"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    conciergerieManagerId?: StringWithAggregatesFilter<"Property"> | string
  }

  export type ReservationWhereInput = {
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    id?: StringFilter<"Reservation"> | string
    propertyId?: StringFilter<"Reservation"> | string
    startDate?: DateTimeFilter<"Reservation"> | Date | string
    endDate?: DateTimeFilter<"Reservation"> | Date | string
    client?: StringNullableFilter<"Reservation"> | string | null
    notes?: StringNullableFilter<"Reservation"> | string | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type ReservationOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    client?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type ReservationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    propertyId?: StringFilter<"Reservation"> | string
    startDate?: DateTimeFilter<"Reservation"> | Date | string
    endDate?: DateTimeFilter<"Reservation"> | Date | string
    client?: StringNullableFilter<"Reservation"> | string | null
    notes?: StringNullableFilter<"Reservation"> | string | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type ReservationOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    client?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReservationCountOrderByAggregateInput
    _max?: ReservationMaxOrderByAggregateInput
    _min?: ReservationMinOrderByAggregateInput
  }

  export type ReservationScalarWhereWithAggregatesInput = {
    AND?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    OR?: ReservationScalarWhereWithAggregatesInput[]
    NOT?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reservation"> | string
    propertyId?: StringWithAggregatesFilter<"Reservation"> | string
    startDate?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    client?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
  }

  export type AgentWhereInput = {
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    id?: StringFilter<"Agent"> | string
    name?: StringFilter<"Agent"> | string
    description?: StringFilter<"Agent"> | string
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    type?: EnumAgentTypeFilter<"Agent"> | $Enums.AgentType
    conciergerieManagerId?: StringFilter<"Agent"> | string
    userId?: StringFilter<"Agent"> | string
    cleaningManagerId?: StringNullableFilter<"Agent"> | string | null
    maintenanceSessions?: MaintenanceSessionListRelationFilter
    cleaningSessions?: CleaningSessionListRelationFilter
    conciergerieManager?: XOR<ConciergerieManagerScalarRelationFilter, ConciergerieManagerWhereInput>
    tasks?: TaskListRelationFilter
    tickets?: TicketListRelationFilter
    cleaningPlannings?: CleaningPlanningListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    siteCleaningSessions?: SiteCleaningSessionListRelationFilter
    cleaningManager?: XOR<CleaningManagerNullableScalarRelationFilter, CleaningManagerWhereInput> | null
  }

  export type AgentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    conciergerieManagerId?: SortOrder
    userId?: SortOrder
    cleaningManagerId?: SortOrderInput | SortOrder
    maintenanceSessions?: MaintenanceSessionOrderByRelationAggregateInput
    cleaningSessions?: CleaningSessionOrderByRelationAggregateInput
    conciergerieManager?: ConciergerieManagerOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    cleaningPlannings?: CleaningPlanningOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    siteCleaningSessions?: SiteCleaningSessionOrderByRelationAggregateInput
    cleaningManager?: CleaningManagerOrderByWithRelationInput
  }

  export type AgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    name?: StringFilter<"Agent"> | string
    description?: StringFilter<"Agent"> | string
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    type?: EnumAgentTypeFilter<"Agent"> | $Enums.AgentType
    conciergerieManagerId?: StringFilter<"Agent"> | string
    userId?: StringFilter<"Agent"> | string
    cleaningManagerId?: StringNullableFilter<"Agent"> | string | null
    maintenanceSessions?: MaintenanceSessionListRelationFilter
    cleaningSessions?: CleaningSessionListRelationFilter
    conciergerieManager?: XOR<ConciergerieManagerScalarRelationFilter, ConciergerieManagerWhereInput>
    tasks?: TaskListRelationFilter
    tickets?: TicketListRelationFilter
    cleaningPlannings?: CleaningPlanningListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    siteCleaningSessions?: SiteCleaningSessionListRelationFilter
    cleaningManager?: XOR<CleaningManagerNullableScalarRelationFilter, CleaningManagerWhereInput> | null
  }, "id">

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    conciergerieManagerId?: SortOrder
    userId?: SortOrder
    cleaningManagerId?: SortOrderInput | SortOrder
    _count?: AgentCountOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    OR?: AgentScalarWhereWithAggregatesInput[]
    NOT?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agent"> | string
    name?: StringWithAggregatesFilter<"Agent"> | string
    description?: StringWithAggregatesFilter<"Agent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    type?: EnumAgentTypeWithAggregatesFilter<"Agent"> | $Enums.AgentType
    conciergerieManagerId?: StringWithAggregatesFilter<"Agent"> | string
    userId?: StringWithAggregatesFilter<"Agent"> | string
    cleaningManagerId?: StringNullableWithAggregatesFilter<"Agent"> | string | null
  }

  export type MaintenanceSessionWhereInput = {
    AND?: MaintenanceSessionWhereInput | MaintenanceSessionWhereInput[]
    OR?: MaintenanceSessionWhereInput[]
    NOT?: MaintenanceSessionWhereInput | MaintenanceSessionWhereInput[]
    id?: StringFilter<"MaintenanceSession"> | string
    propertyId?: StringFilter<"MaintenanceSession"> | string
    createdAt?: DateTimeFilter<"MaintenanceSession"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceSession"> | Date | string
    maintenanceId?: StringFilter<"MaintenanceSession"> | string
    agentId?: StringFilter<"MaintenanceSession"> | string
    startDate?: DateTimeNullableFilter<"MaintenanceSession"> | Date | string | null
    endDate?: DateTimeNullableFilter<"MaintenanceSession"> | Date | string | null
    notes?: StringNullableFilter<"MaintenanceSession"> | string | null
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    maintenance?: XOR<MaintenanceScalarRelationFilter, MaintenanceWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    photos?: MaintenancePhotoListRelationFilter
  }

  export type MaintenanceSessionOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maintenanceId?: SortOrder
    agentId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    property?: PropertyOrderByWithRelationInput
    maintenance?: MaintenanceOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
    photos?: MaintenancePhotoOrderByRelationAggregateInput
  }

  export type MaintenanceSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceSessionWhereInput | MaintenanceSessionWhereInput[]
    OR?: MaintenanceSessionWhereInput[]
    NOT?: MaintenanceSessionWhereInput | MaintenanceSessionWhereInput[]
    propertyId?: StringFilter<"MaintenanceSession"> | string
    createdAt?: DateTimeFilter<"MaintenanceSession"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceSession"> | Date | string
    maintenanceId?: StringFilter<"MaintenanceSession"> | string
    agentId?: StringFilter<"MaintenanceSession"> | string
    startDate?: DateTimeNullableFilter<"MaintenanceSession"> | Date | string | null
    endDate?: DateTimeNullableFilter<"MaintenanceSession"> | Date | string | null
    notes?: StringNullableFilter<"MaintenanceSession"> | string | null
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    maintenance?: XOR<MaintenanceScalarRelationFilter, MaintenanceWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    photos?: MaintenancePhotoListRelationFilter
  }, "id">

  export type MaintenanceSessionOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maintenanceId?: SortOrder
    agentId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: MaintenanceSessionCountOrderByAggregateInput
    _max?: MaintenanceSessionMaxOrderByAggregateInput
    _min?: MaintenanceSessionMinOrderByAggregateInput
  }

  export type MaintenanceSessionScalarWhereWithAggregatesInput = {
    AND?: MaintenanceSessionScalarWhereWithAggregatesInput | MaintenanceSessionScalarWhereWithAggregatesInput[]
    OR?: MaintenanceSessionScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceSessionScalarWhereWithAggregatesInput | MaintenanceSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenanceSession"> | string
    propertyId?: StringWithAggregatesFilter<"MaintenanceSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MaintenanceSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MaintenanceSession"> | Date | string
    maintenanceId?: StringWithAggregatesFilter<"MaintenanceSession"> | string
    agentId?: StringWithAggregatesFilter<"MaintenanceSession"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"MaintenanceSession"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"MaintenanceSession"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"MaintenanceSession"> | string | null
  }

  export type MaintenanceWhereInput = {
    AND?: MaintenanceWhereInput | MaintenanceWhereInput[]
    OR?: MaintenanceWhereInput[]
    NOT?: MaintenanceWhereInput | MaintenanceWhereInput[]
    id?: StringFilter<"Maintenance"> | string
    name?: StringFilter<"Maintenance"> | string
    description?: StringFilter<"Maintenance"> | string
    createdAt?: DateTimeFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeFilter<"Maintenance"> | Date | string
    sessionMaintenances?: MaintenanceSessionListRelationFilter
  }

  export type MaintenanceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionMaintenances?: MaintenanceSessionOrderByRelationAggregateInput
  }

  export type MaintenanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceWhereInput | MaintenanceWhereInput[]
    OR?: MaintenanceWhereInput[]
    NOT?: MaintenanceWhereInput | MaintenanceWhereInput[]
    name?: StringFilter<"Maintenance"> | string
    description?: StringFilter<"Maintenance"> | string
    createdAt?: DateTimeFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeFilter<"Maintenance"> | Date | string
    sessionMaintenances?: MaintenanceSessionListRelationFilter
  }, "id">

  export type MaintenanceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaintenanceCountOrderByAggregateInput
    _max?: MaintenanceMaxOrderByAggregateInput
    _min?: MaintenanceMinOrderByAggregateInput
  }

  export type MaintenanceScalarWhereWithAggregatesInput = {
    AND?: MaintenanceScalarWhereWithAggregatesInput | MaintenanceScalarWhereWithAggregatesInput[]
    OR?: MaintenanceScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceScalarWhereWithAggregatesInput | MaintenanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Maintenance"> | string
    name?: StringWithAggregatesFilter<"Maintenance"> | string
    description?: StringWithAggregatesFilter<"Maintenance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Maintenance"> | Date | string
  }

  export type CleaningSessionWhereInput = {
    AND?: CleaningSessionWhereInput | CleaningSessionWhereInput[]
    OR?: CleaningSessionWhereInput[]
    NOT?: CleaningSessionWhereInput | CleaningSessionWhereInput[]
    id?: StringFilter<"CleaningSession"> | string
    propertyId?: StringFilter<"CleaningSession"> | string
    createdAt?: DateTimeFilter<"CleaningSession"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningSession"> | Date | string
    cleaningId?: StringFilter<"CleaningSession"> | string
    agentId?: StringFilter<"CleaningSession"> | string
    startDate?: DateTimeNullableFilter<"CleaningSession"> | Date | string | null
    endDate?: DateTimeNullableFilter<"CleaningSession"> | Date | string | null
    duration?: IntNullableFilter<"CleaningSession"> | number | null
    notes?: StringNullableFilter<"CleaningSession"> | string | null
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    cleaning?: XOR<CleaningScalarRelationFilter, CleaningWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    photos?: CleaningPhotoListRelationFilter
    checklist?: CleaningChecklistListRelationFilter
  }

  export type CleaningSessionOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningId?: SortOrder
    agentId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    property?: PropertyOrderByWithRelationInput
    cleaning?: CleaningOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
    photos?: CleaningPhotoOrderByRelationAggregateInput
    checklist?: CleaningChecklistOrderByRelationAggregateInput
  }

  export type CleaningSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CleaningSessionWhereInput | CleaningSessionWhereInput[]
    OR?: CleaningSessionWhereInput[]
    NOT?: CleaningSessionWhereInput | CleaningSessionWhereInput[]
    propertyId?: StringFilter<"CleaningSession"> | string
    createdAt?: DateTimeFilter<"CleaningSession"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningSession"> | Date | string
    cleaningId?: StringFilter<"CleaningSession"> | string
    agentId?: StringFilter<"CleaningSession"> | string
    startDate?: DateTimeNullableFilter<"CleaningSession"> | Date | string | null
    endDate?: DateTimeNullableFilter<"CleaningSession"> | Date | string | null
    duration?: IntNullableFilter<"CleaningSession"> | number | null
    notes?: StringNullableFilter<"CleaningSession"> | string | null
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    cleaning?: XOR<CleaningScalarRelationFilter, CleaningWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    photos?: CleaningPhotoListRelationFilter
    checklist?: CleaningChecklistListRelationFilter
  }, "id">

  export type CleaningSessionOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningId?: SortOrder
    agentId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: CleaningSessionCountOrderByAggregateInput
    _avg?: CleaningSessionAvgOrderByAggregateInput
    _max?: CleaningSessionMaxOrderByAggregateInput
    _min?: CleaningSessionMinOrderByAggregateInput
    _sum?: CleaningSessionSumOrderByAggregateInput
  }

  export type CleaningSessionScalarWhereWithAggregatesInput = {
    AND?: CleaningSessionScalarWhereWithAggregatesInput | CleaningSessionScalarWhereWithAggregatesInput[]
    OR?: CleaningSessionScalarWhereWithAggregatesInput[]
    NOT?: CleaningSessionScalarWhereWithAggregatesInput | CleaningSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CleaningSession"> | string
    propertyId?: StringWithAggregatesFilter<"CleaningSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CleaningSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CleaningSession"> | Date | string
    cleaningId?: StringWithAggregatesFilter<"CleaningSession"> | string
    agentId?: StringWithAggregatesFilter<"CleaningSession"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"CleaningSession"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"CleaningSession"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"CleaningSession"> | number | null
    notes?: StringNullableWithAggregatesFilter<"CleaningSession"> | string | null
  }

  export type CleaningWhereInput = {
    AND?: CleaningWhereInput | CleaningWhereInput[]
    OR?: CleaningWhereInput[]
    NOT?: CleaningWhereInput | CleaningWhereInput[]
    id?: StringFilter<"Cleaning"> | string
    name?: StringFilter<"Cleaning"> | string
    description?: StringFilter<"Cleaning"> | string
    createdAt?: DateTimeFilter<"Cleaning"> | Date | string
    updatedAt?: DateTimeFilter<"Cleaning"> | Date | string
    cleaningSessions?: CleaningSessionListRelationFilter
  }

  export type CleaningOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningSessions?: CleaningSessionOrderByRelationAggregateInput
  }

  export type CleaningWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CleaningWhereInput | CleaningWhereInput[]
    OR?: CleaningWhereInput[]
    NOT?: CleaningWhereInput | CleaningWhereInput[]
    name?: StringFilter<"Cleaning"> | string
    description?: StringFilter<"Cleaning"> | string
    createdAt?: DateTimeFilter<"Cleaning"> | Date | string
    updatedAt?: DateTimeFilter<"Cleaning"> | Date | string
    cleaningSessions?: CleaningSessionListRelationFilter
  }, "id">

  export type CleaningOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CleaningCountOrderByAggregateInput
    _max?: CleaningMaxOrderByAggregateInput
    _min?: CleaningMinOrderByAggregateInput
  }

  export type CleaningScalarWhereWithAggregatesInput = {
    AND?: CleaningScalarWhereWithAggregatesInput | CleaningScalarWhereWithAggregatesInput[]
    OR?: CleaningScalarWhereWithAggregatesInput[]
    NOT?: CleaningScalarWhereWithAggregatesInput | CleaningScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cleaning"> | string
    name?: StringWithAggregatesFilter<"Cleaning"> | string
    description?: StringWithAggregatesFilter<"Cleaning"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Cleaning"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cleaning"> | Date | string
  }

  export type CleaningManagerWhereInput = {
    AND?: CleaningManagerWhereInput | CleaningManagerWhereInput[]
    OR?: CleaningManagerWhereInput[]
    NOT?: CleaningManagerWhereInput | CleaningManagerWhereInput[]
    id?: StringFilter<"CleaningManager"> | string
    userId?: StringFilter<"CleaningManager"> | string
    createdAt?: DateTimeFilter<"CleaningManager"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningManager"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    interventionSites?: InterventionSiteListRelationFilter
    siteCleaningSessions?: SiteCleaningSessionListRelationFilter
    cleaningAgents?: AgentListRelationFilter
    cleaningPlannings?: CleaningPlanningListRelationFilter
  }

  export type CleaningManagerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    interventionSites?: InterventionSiteOrderByRelationAggregateInput
    siteCleaningSessions?: SiteCleaningSessionOrderByRelationAggregateInput
    cleaningAgents?: AgentOrderByRelationAggregateInput
    cleaningPlannings?: CleaningPlanningOrderByRelationAggregateInput
  }

  export type CleaningManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CleaningManagerWhereInput | CleaningManagerWhereInput[]
    OR?: CleaningManagerWhereInput[]
    NOT?: CleaningManagerWhereInput | CleaningManagerWhereInput[]
    userId?: StringFilter<"CleaningManager"> | string
    createdAt?: DateTimeFilter<"CleaningManager"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningManager"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    interventionSites?: InterventionSiteListRelationFilter
    siteCleaningSessions?: SiteCleaningSessionListRelationFilter
    cleaningAgents?: AgentListRelationFilter
    cleaningPlannings?: CleaningPlanningListRelationFilter
  }, "id">

  export type CleaningManagerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CleaningManagerCountOrderByAggregateInput
    _max?: CleaningManagerMaxOrderByAggregateInput
    _min?: CleaningManagerMinOrderByAggregateInput
  }

  export type CleaningManagerScalarWhereWithAggregatesInput = {
    AND?: CleaningManagerScalarWhereWithAggregatesInput | CleaningManagerScalarWhereWithAggregatesInput[]
    OR?: CleaningManagerScalarWhereWithAggregatesInput[]
    NOT?: CleaningManagerScalarWhereWithAggregatesInput | CleaningManagerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CleaningManager"> | string
    userId?: StringWithAggregatesFilter<"CleaningManager"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CleaningManager"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CleaningManager"> | Date | string
  }

  export type InterventionSiteWhereInput = {
    AND?: InterventionSiteWhereInput | InterventionSiteWhereInput[]
    OR?: InterventionSiteWhereInput[]
    NOT?: InterventionSiteWhereInput | InterventionSiteWhereInput[]
    id?: StringFilter<"InterventionSite"> | string
    name?: StringFilter<"InterventionSite"> | string
    description?: StringFilter<"InterventionSite"> | string
    client?: StringNullableFilter<"InterventionSite"> | string | null
    site?: StringNullableFilter<"InterventionSite"> | string | null
    surface?: FloatNullableFilter<"InterventionSite"> | number | null
    type?: StringNullableFilter<"InterventionSite"> | string | null
    address?: StringNullableFilter<"InterventionSite"> | string | null
    createdAt?: DateTimeFilter<"InterventionSite"> | Date | string
    updatedAt?: DateTimeFilter<"InterventionSite"> | Date | string
    cleaningManagerId?: StringFilter<"InterventionSite"> | string
    cleaningManager?: XOR<CleaningManagerScalarRelationFilter, CleaningManagerWhereInput>
    siteCleaningSessions?: SiteCleaningSessionListRelationFilter
    cleaningPlannings?: CleaningPlanningListRelationFilter
  }

  export type InterventionSiteOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    client?: SortOrderInput | SortOrder
    site?: SortOrderInput | SortOrder
    surface?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningManagerId?: SortOrder
    cleaningManager?: CleaningManagerOrderByWithRelationInput
    siteCleaningSessions?: SiteCleaningSessionOrderByRelationAggregateInput
    cleaningPlannings?: CleaningPlanningOrderByRelationAggregateInput
  }

  export type InterventionSiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InterventionSiteWhereInput | InterventionSiteWhereInput[]
    OR?: InterventionSiteWhereInput[]
    NOT?: InterventionSiteWhereInput | InterventionSiteWhereInput[]
    name?: StringFilter<"InterventionSite"> | string
    description?: StringFilter<"InterventionSite"> | string
    client?: StringNullableFilter<"InterventionSite"> | string | null
    site?: StringNullableFilter<"InterventionSite"> | string | null
    surface?: FloatNullableFilter<"InterventionSite"> | number | null
    type?: StringNullableFilter<"InterventionSite"> | string | null
    address?: StringNullableFilter<"InterventionSite"> | string | null
    createdAt?: DateTimeFilter<"InterventionSite"> | Date | string
    updatedAt?: DateTimeFilter<"InterventionSite"> | Date | string
    cleaningManagerId?: StringFilter<"InterventionSite"> | string
    cleaningManager?: XOR<CleaningManagerScalarRelationFilter, CleaningManagerWhereInput>
    siteCleaningSessions?: SiteCleaningSessionListRelationFilter
    cleaningPlannings?: CleaningPlanningListRelationFilter
  }, "id">

  export type InterventionSiteOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    client?: SortOrderInput | SortOrder
    site?: SortOrderInput | SortOrder
    surface?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningManagerId?: SortOrder
    _count?: InterventionSiteCountOrderByAggregateInput
    _avg?: InterventionSiteAvgOrderByAggregateInput
    _max?: InterventionSiteMaxOrderByAggregateInput
    _min?: InterventionSiteMinOrderByAggregateInput
    _sum?: InterventionSiteSumOrderByAggregateInput
  }

  export type InterventionSiteScalarWhereWithAggregatesInput = {
    AND?: InterventionSiteScalarWhereWithAggregatesInput | InterventionSiteScalarWhereWithAggregatesInput[]
    OR?: InterventionSiteScalarWhereWithAggregatesInput[]
    NOT?: InterventionSiteScalarWhereWithAggregatesInput | InterventionSiteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InterventionSite"> | string
    name?: StringWithAggregatesFilter<"InterventionSite"> | string
    description?: StringWithAggregatesFilter<"InterventionSite"> | string
    client?: StringNullableWithAggregatesFilter<"InterventionSite"> | string | null
    site?: StringNullableWithAggregatesFilter<"InterventionSite"> | string | null
    surface?: FloatNullableWithAggregatesFilter<"InterventionSite"> | number | null
    type?: StringNullableWithAggregatesFilter<"InterventionSite"> | string | null
    address?: StringNullableWithAggregatesFilter<"InterventionSite"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InterventionSite"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InterventionSite"> | Date | string
    cleaningManagerId?: StringWithAggregatesFilter<"InterventionSite"> | string
  }

  export type SiteCleaningSessionWhereInput = {
    AND?: SiteCleaningSessionWhereInput | SiteCleaningSessionWhereInput[]
    OR?: SiteCleaningSessionWhereInput[]
    NOT?: SiteCleaningSessionWhereInput | SiteCleaningSessionWhereInput[]
    id?: StringFilter<"SiteCleaningSession"> | string
    interventionSiteId?: StringFilter<"SiteCleaningSession"> | string
    createdAt?: DateTimeFilter<"SiteCleaningSession"> | Date | string
    updatedAt?: DateTimeFilter<"SiteCleaningSession"> | Date | string
    cleaningManagerId?: StringFilter<"SiteCleaningSession"> | string
    startDate?: DateTimeNullableFilter<"SiteCleaningSession"> | Date | string | null
    endDate?: DateTimeNullableFilter<"SiteCleaningSession"> | Date | string | null
    duration?: IntNullableFilter<"SiteCleaningSession"> | number | null
    notes?: StringNullableFilter<"SiteCleaningSession"> | string | null
    status?: EnumInterventionStatusFilter<"SiteCleaningSession"> | $Enums.InterventionStatus
    laundryManagerId?: StringNullableFilter<"SiteCleaningSession"> | string | null
    cleaningAgentId?: StringNullableFilter<"SiteCleaningSession"> | string | null
    interventionSite?: XOR<InterventionSiteScalarRelationFilter, InterventionSiteWhereInput>
    cleaningManager?: XOR<CleaningManagerScalarRelationFilter, CleaningManagerWhereInput>
    photos?: SiteCleaningPhotoListRelationFilter
    checklist?: SiteCleaningChecklistListRelationFilter
    laundryManager?: XOR<LaundryManagerNullableScalarRelationFilter, LaundryManagerWhereInput> | null
    cleaningAgent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
  }

  export type SiteCleaningSessionOrderByWithRelationInput = {
    id?: SortOrder
    interventionSiteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningManagerId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    laundryManagerId?: SortOrderInput | SortOrder
    cleaningAgentId?: SortOrderInput | SortOrder
    interventionSite?: InterventionSiteOrderByWithRelationInput
    cleaningManager?: CleaningManagerOrderByWithRelationInput
    photos?: SiteCleaningPhotoOrderByRelationAggregateInput
    checklist?: SiteCleaningChecklistOrderByRelationAggregateInput
    laundryManager?: LaundryManagerOrderByWithRelationInput
    cleaningAgent?: AgentOrderByWithRelationInput
  }

  export type SiteCleaningSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SiteCleaningSessionWhereInput | SiteCleaningSessionWhereInput[]
    OR?: SiteCleaningSessionWhereInput[]
    NOT?: SiteCleaningSessionWhereInput | SiteCleaningSessionWhereInput[]
    interventionSiteId?: StringFilter<"SiteCleaningSession"> | string
    createdAt?: DateTimeFilter<"SiteCleaningSession"> | Date | string
    updatedAt?: DateTimeFilter<"SiteCleaningSession"> | Date | string
    cleaningManagerId?: StringFilter<"SiteCleaningSession"> | string
    startDate?: DateTimeNullableFilter<"SiteCleaningSession"> | Date | string | null
    endDate?: DateTimeNullableFilter<"SiteCleaningSession"> | Date | string | null
    duration?: IntNullableFilter<"SiteCleaningSession"> | number | null
    notes?: StringNullableFilter<"SiteCleaningSession"> | string | null
    status?: EnumInterventionStatusFilter<"SiteCleaningSession"> | $Enums.InterventionStatus
    laundryManagerId?: StringNullableFilter<"SiteCleaningSession"> | string | null
    cleaningAgentId?: StringNullableFilter<"SiteCleaningSession"> | string | null
    interventionSite?: XOR<InterventionSiteScalarRelationFilter, InterventionSiteWhereInput>
    cleaningManager?: XOR<CleaningManagerScalarRelationFilter, CleaningManagerWhereInput>
    photos?: SiteCleaningPhotoListRelationFilter
    checklist?: SiteCleaningChecklistListRelationFilter
    laundryManager?: XOR<LaundryManagerNullableScalarRelationFilter, LaundryManagerWhereInput> | null
    cleaningAgent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
  }, "id">

  export type SiteCleaningSessionOrderByWithAggregationInput = {
    id?: SortOrder
    interventionSiteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningManagerId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    laundryManagerId?: SortOrderInput | SortOrder
    cleaningAgentId?: SortOrderInput | SortOrder
    _count?: SiteCleaningSessionCountOrderByAggregateInput
    _avg?: SiteCleaningSessionAvgOrderByAggregateInput
    _max?: SiteCleaningSessionMaxOrderByAggregateInput
    _min?: SiteCleaningSessionMinOrderByAggregateInput
    _sum?: SiteCleaningSessionSumOrderByAggregateInput
  }

  export type SiteCleaningSessionScalarWhereWithAggregatesInput = {
    AND?: SiteCleaningSessionScalarWhereWithAggregatesInput | SiteCleaningSessionScalarWhereWithAggregatesInput[]
    OR?: SiteCleaningSessionScalarWhereWithAggregatesInput[]
    NOT?: SiteCleaningSessionScalarWhereWithAggregatesInput | SiteCleaningSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SiteCleaningSession"> | string
    interventionSiteId?: StringWithAggregatesFilter<"SiteCleaningSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SiteCleaningSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SiteCleaningSession"> | Date | string
    cleaningManagerId?: StringWithAggregatesFilter<"SiteCleaningSession"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"SiteCleaningSession"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"SiteCleaningSession"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"SiteCleaningSession"> | number | null
    notes?: StringNullableWithAggregatesFilter<"SiteCleaningSession"> | string | null
    status?: EnumInterventionStatusWithAggregatesFilter<"SiteCleaningSession"> | $Enums.InterventionStatus
    laundryManagerId?: StringNullableWithAggregatesFilter<"SiteCleaningSession"> | string | null
    cleaningAgentId?: StringNullableWithAggregatesFilter<"SiteCleaningSession"> | string | null
  }

  export type LaundryManagerWhereInput = {
    AND?: LaundryManagerWhereInput | LaundryManagerWhereInput[]
    OR?: LaundryManagerWhereInput[]
    NOT?: LaundryManagerWhereInput | LaundryManagerWhereInput[]
    id?: StringFilter<"LaundryManager"> | string
    userId?: StringFilter<"LaundryManager"> | string
    createdAt?: DateTimeFilter<"LaundryManager"> | Date | string
    updatedAt?: DateTimeFilter<"LaundryManager"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    products?: ProductListRelationFilter
    orders?: OrderListRelationFilter
    deliveryNotes?: DeliveryNoteListRelationFilter
    siteCleaningSessions?: SiteCleaningSessionListRelationFilter
  }

  export type LaundryManagerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    deliveryNotes?: DeliveryNoteOrderByRelationAggregateInput
    siteCleaningSessions?: SiteCleaningSessionOrderByRelationAggregateInput
  }

  export type LaundryManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LaundryManagerWhereInput | LaundryManagerWhereInput[]
    OR?: LaundryManagerWhereInput[]
    NOT?: LaundryManagerWhereInput | LaundryManagerWhereInput[]
    userId?: StringFilter<"LaundryManager"> | string
    createdAt?: DateTimeFilter<"LaundryManager"> | Date | string
    updatedAt?: DateTimeFilter<"LaundryManager"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    products?: ProductListRelationFilter
    orders?: OrderListRelationFilter
    deliveryNotes?: DeliveryNoteListRelationFilter
    siteCleaningSessions?: SiteCleaningSessionListRelationFilter
  }, "id">

  export type LaundryManagerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaundryManagerCountOrderByAggregateInput
    _max?: LaundryManagerMaxOrderByAggregateInput
    _min?: LaundryManagerMinOrderByAggregateInput
  }

  export type LaundryManagerScalarWhereWithAggregatesInput = {
    AND?: LaundryManagerScalarWhereWithAggregatesInput | LaundryManagerScalarWhereWithAggregatesInput[]
    OR?: LaundryManagerScalarWhereWithAggregatesInput[]
    NOT?: LaundryManagerScalarWhereWithAggregatesInput | LaundryManagerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LaundryManager"> | string
    userId?: StringWithAggregatesFilter<"LaundryManager"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LaundryManager"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LaundryManager"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    price?: FloatNullableFilter<"Product"> | number | null
    stock?: IntNullableFilter<"Product"> | number | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    laundryManagerId?: StringFilter<"Product"> | string
    orderItems?: OrderItemListRelationFilter
    laundryManager?: XOR<LaundryManagerScalarRelationFilter, LaundryManagerWhereInput>
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryManagerId?: SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
    laundryManager?: LaundryManagerOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    price?: FloatNullableFilter<"Product"> | number | null
    stock?: IntNullableFilter<"Product"> | number | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    laundryManagerId?: StringFilter<"Product"> | string
    orderItems?: OrderItemListRelationFilter
    laundryManager?: XOR<LaundryManagerScalarRelationFilter, LaundryManagerWhereInput>
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryManagerId?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringWithAggregatesFilter<"Product"> | string
    price?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    stock?: IntNullableWithAggregatesFilter<"Product"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    laundryManagerId?: StringWithAggregatesFilter<"Product"> | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    name?: StringFilter<"Order"> | string
    description?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    receivedDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveryDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    client?: StringNullableFilter<"Order"> | string | null
    address?: StringNullableFilter<"Order"> | string | null
    phone?: StringNullableFilter<"Order"> | string | null
    total?: FloatNullableFilter<"Order"> | number | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    laundryManagerId?: StringFilter<"Order"> | string
    laundryManager?: XOR<LaundryManagerScalarRelationFilter, LaundryManagerWhereInput>
    orderItems?: OrderItemListRelationFilter
    deliveryNotes?: DeliveryNoteListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    receivedDate?: SortOrderInput | SortOrder
    deliveryDate?: SortOrderInput | SortOrder
    client?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryManagerId?: SortOrder
    laundryManager?: LaundryManagerOrderByWithRelationInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    deliveryNotes?: DeliveryNoteOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    name?: StringFilter<"Order"> | string
    description?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    receivedDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveryDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    client?: StringNullableFilter<"Order"> | string | null
    address?: StringNullableFilter<"Order"> | string | null
    phone?: StringNullableFilter<"Order"> | string | null
    total?: FloatNullableFilter<"Order"> | number | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    laundryManagerId?: StringFilter<"Order"> | string
    laundryManager?: XOR<LaundryManagerScalarRelationFilter, LaundryManagerWhereInput>
    orderItems?: OrderItemListRelationFilter
    deliveryNotes?: DeliveryNoteListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    receivedDate?: SortOrderInput | SortOrder
    deliveryDate?: SortOrderInput | SortOrder
    client?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryManagerId?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    name?: StringWithAggregatesFilter<"Order"> | string
    description?: StringWithAggregatesFilter<"Order"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    receivedDate?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    deliveryDate?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    client?: StringNullableWithAggregatesFilter<"Order"> | string | null
    address?: StringNullableWithAggregatesFilter<"Order"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Order"> | string | null
    total?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    laundryManagerId?: StringWithAggregatesFilter<"Order"> | string
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: StringFilter<"Ticket"> | string
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: StringNullableFilter<"Ticket"> | string | null
    propertyId?: StringFilter<"Ticket"> | string
    agentId?: StringNullableFilter<"Ticket"> | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    photos?: TicketPhotoListRelationFilter
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
    photos?: TicketPhotoOrderByRelationAggregateInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: StringNullableFilter<"Ticket"> | string | null
    propertyId?: StringFilter<"Ticket"> | string
    agentId?: StringNullableFilter<"Ticket"> | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    photos?: TicketPhotoListRelationFilter
  }, "id">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TicketCountOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticket"> | string
    title?: StringWithAggregatesFilter<"Ticket"> | string
    description?: StringWithAggregatesFilter<"Ticket"> | string
    status?: EnumTicketStatusWithAggregatesFilter<"Ticket"> | $Enums.TicketStatus
    priority?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    propertyId?: StringWithAggregatesFilter<"Ticket"> | string
    agentId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    method?: StringNullableFilter<"Payment"> | string | null
    status?: StringNullableFilter<"Payment"> | string | null
    propertyId?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    method?: StringNullableFilter<"Payment"> | string | null
    status?: StringNullableFilter<"Payment"> | string | null
    propertyId?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    method?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    propertyId?: StringWithAggregatesFilter<"Payment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type PropertyPhotoWhereInput = {
    AND?: PropertyPhotoWhereInput | PropertyPhotoWhereInput[]
    OR?: PropertyPhotoWhereInput[]
    NOT?: PropertyPhotoWhereInput | PropertyPhotoWhereInput[]
    id?: StringFilter<"PropertyPhoto"> | string
    url?: StringFilter<"PropertyPhoto"> | string
    type?: StringNullableFilter<"PropertyPhoto"> | string | null
    propertyId?: StringFilter<"PropertyPhoto"> | string
    createdAt?: DateTimeFilter<"PropertyPhoto"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertyPhotoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyPhotoWhereInput | PropertyPhotoWhereInput[]
    OR?: PropertyPhotoWhereInput[]
    NOT?: PropertyPhotoWhereInput | PropertyPhotoWhereInput[]
    url?: StringFilter<"PropertyPhoto"> | string
    type?: StringNullableFilter<"PropertyPhoto"> | string | null
    propertyId?: StringFilter<"PropertyPhoto"> | string
    createdAt?: DateTimeFilter<"PropertyPhoto"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type PropertyPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    _count?: PropertyPhotoCountOrderByAggregateInput
    _max?: PropertyPhotoMaxOrderByAggregateInput
    _min?: PropertyPhotoMinOrderByAggregateInput
  }

  export type PropertyPhotoScalarWhereWithAggregatesInput = {
    AND?: PropertyPhotoScalarWhereWithAggregatesInput | PropertyPhotoScalarWhereWithAggregatesInput[]
    OR?: PropertyPhotoScalarWhereWithAggregatesInput[]
    NOT?: PropertyPhotoScalarWhereWithAggregatesInput | PropertyPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyPhoto"> | string
    url?: StringWithAggregatesFilter<"PropertyPhoto"> | string
    type?: StringNullableWithAggregatesFilter<"PropertyPhoto"> | string | null
    propertyId?: StringWithAggregatesFilter<"PropertyPhoto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PropertyPhoto"> | Date | string
  }

  export type CleaningPhotoWhereInput = {
    AND?: CleaningPhotoWhereInput | CleaningPhotoWhereInput[]
    OR?: CleaningPhotoWhereInput[]
    NOT?: CleaningPhotoWhereInput | CleaningPhotoWhereInput[]
    id?: StringFilter<"CleaningPhoto"> | string
    url?: StringFilter<"CleaningPhoto"> | string
    type?: StringNullableFilter<"CleaningPhoto"> | string | null
    cleaningSessionId?: StringFilter<"CleaningPhoto"> | string
    createdAt?: DateTimeFilter<"CleaningPhoto"> | Date | string
    cleaningSession?: XOR<CleaningSessionScalarRelationFilter, CleaningSessionWhereInput>
  }

  export type CleaningPhotoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrderInput | SortOrder
    cleaningSessionId?: SortOrder
    createdAt?: SortOrder
    cleaningSession?: CleaningSessionOrderByWithRelationInput
  }

  export type CleaningPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CleaningPhotoWhereInput | CleaningPhotoWhereInput[]
    OR?: CleaningPhotoWhereInput[]
    NOT?: CleaningPhotoWhereInput | CleaningPhotoWhereInput[]
    url?: StringFilter<"CleaningPhoto"> | string
    type?: StringNullableFilter<"CleaningPhoto"> | string | null
    cleaningSessionId?: StringFilter<"CleaningPhoto"> | string
    createdAt?: DateTimeFilter<"CleaningPhoto"> | Date | string
    cleaningSession?: XOR<CleaningSessionScalarRelationFilter, CleaningSessionWhereInput>
  }, "id">

  export type CleaningPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrderInput | SortOrder
    cleaningSessionId?: SortOrder
    createdAt?: SortOrder
    _count?: CleaningPhotoCountOrderByAggregateInput
    _max?: CleaningPhotoMaxOrderByAggregateInput
    _min?: CleaningPhotoMinOrderByAggregateInput
  }

  export type CleaningPhotoScalarWhereWithAggregatesInput = {
    AND?: CleaningPhotoScalarWhereWithAggregatesInput | CleaningPhotoScalarWhereWithAggregatesInput[]
    OR?: CleaningPhotoScalarWhereWithAggregatesInput[]
    NOT?: CleaningPhotoScalarWhereWithAggregatesInput | CleaningPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CleaningPhoto"> | string
    url?: StringWithAggregatesFilter<"CleaningPhoto"> | string
    type?: StringNullableWithAggregatesFilter<"CleaningPhoto"> | string | null
    cleaningSessionId?: StringWithAggregatesFilter<"CleaningPhoto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CleaningPhoto"> | Date | string
  }

  export type MaintenancePhotoWhereInput = {
    AND?: MaintenancePhotoWhereInput | MaintenancePhotoWhereInput[]
    OR?: MaintenancePhotoWhereInput[]
    NOT?: MaintenancePhotoWhereInput | MaintenancePhotoWhereInput[]
    id?: StringFilter<"MaintenancePhoto"> | string
    url?: StringFilter<"MaintenancePhoto"> | string
    type?: StringNullableFilter<"MaintenancePhoto"> | string | null
    maintenanceSessionId?: StringFilter<"MaintenancePhoto"> | string
    createdAt?: DateTimeFilter<"MaintenancePhoto"> | Date | string
    maintenanceSession?: XOR<MaintenanceSessionScalarRelationFilter, MaintenanceSessionWhereInput>
  }

  export type MaintenancePhotoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrderInput | SortOrder
    maintenanceSessionId?: SortOrder
    createdAt?: SortOrder
    maintenanceSession?: MaintenanceSessionOrderByWithRelationInput
  }

  export type MaintenancePhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenancePhotoWhereInput | MaintenancePhotoWhereInput[]
    OR?: MaintenancePhotoWhereInput[]
    NOT?: MaintenancePhotoWhereInput | MaintenancePhotoWhereInput[]
    url?: StringFilter<"MaintenancePhoto"> | string
    type?: StringNullableFilter<"MaintenancePhoto"> | string | null
    maintenanceSessionId?: StringFilter<"MaintenancePhoto"> | string
    createdAt?: DateTimeFilter<"MaintenancePhoto"> | Date | string
    maintenanceSession?: XOR<MaintenanceSessionScalarRelationFilter, MaintenanceSessionWhereInput>
  }, "id">

  export type MaintenancePhotoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrderInput | SortOrder
    maintenanceSessionId?: SortOrder
    createdAt?: SortOrder
    _count?: MaintenancePhotoCountOrderByAggregateInput
    _max?: MaintenancePhotoMaxOrderByAggregateInput
    _min?: MaintenancePhotoMinOrderByAggregateInput
  }

  export type MaintenancePhotoScalarWhereWithAggregatesInput = {
    AND?: MaintenancePhotoScalarWhereWithAggregatesInput | MaintenancePhotoScalarWhereWithAggregatesInput[]
    OR?: MaintenancePhotoScalarWhereWithAggregatesInput[]
    NOT?: MaintenancePhotoScalarWhereWithAggregatesInput | MaintenancePhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenancePhoto"> | string
    url?: StringWithAggregatesFilter<"MaintenancePhoto"> | string
    type?: StringNullableWithAggregatesFilter<"MaintenancePhoto"> | string | null
    maintenanceSessionId?: StringWithAggregatesFilter<"MaintenancePhoto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MaintenancePhoto"> | Date | string
  }

  export type SiteCleaningPhotoWhereInput = {
    AND?: SiteCleaningPhotoWhereInput | SiteCleaningPhotoWhereInput[]
    OR?: SiteCleaningPhotoWhereInput[]
    NOT?: SiteCleaningPhotoWhereInput | SiteCleaningPhotoWhereInput[]
    id?: StringFilter<"SiteCleaningPhoto"> | string
    url?: StringFilter<"SiteCleaningPhoto"> | string
    type?: StringNullableFilter<"SiteCleaningPhoto"> | string | null
    siteCleaningSessionId?: StringFilter<"SiteCleaningPhoto"> | string
    createdAt?: DateTimeFilter<"SiteCleaningPhoto"> | Date | string
    siteCleaningSession?: XOR<SiteCleaningSessionScalarRelationFilter, SiteCleaningSessionWhereInput>
  }

  export type SiteCleaningPhotoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrderInput | SortOrder
    siteCleaningSessionId?: SortOrder
    createdAt?: SortOrder
    siteCleaningSession?: SiteCleaningSessionOrderByWithRelationInput
  }

  export type SiteCleaningPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SiteCleaningPhotoWhereInput | SiteCleaningPhotoWhereInput[]
    OR?: SiteCleaningPhotoWhereInput[]
    NOT?: SiteCleaningPhotoWhereInput | SiteCleaningPhotoWhereInput[]
    url?: StringFilter<"SiteCleaningPhoto"> | string
    type?: StringNullableFilter<"SiteCleaningPhoto"> | string | null
    siteCleaningSessionId?: StringFilter<"SiteCleaningPhoto"> | string
    createdAt?: DateTimeFilter<"SiteCleaningPhoto"> | Date | string
    siteCleaningSession?: XOR<SiteCleaningSessionScalarRelationFilter, SiteCleaningSessionWhereInput>
  }, "id">

  export type SiteCleaningPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrderInput | SortOrder
    siteCleaningSessionId?: SortOrder
    createdAt?: SortOrder
    _count?: SiteCleaningPhotoCountOrderByAggregateInput
    _max?: SiteCleaningPhotoMaxOrderByAggregateInput
    _min?: SiteCleaningPhotoMinOrderByAggregateInput
  }

  export type SiteCleaningPhotoScalarWhereWithAggregatesInput = {
    AND?: SiteCleaningPhotoScalarWhereWithAggregatesInput | SiteCleaningPhotoScalarWhereWithAggregatesInput[]
    OR?: SiteCleaningPhotoScalarWhereWithAggregatesInput[]
    NOT?: SiteCleaningPhotoScalarWhereWithAggregatesInput | SiteCleaningPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SiteCleaningPhoto"> | string
    url?: StringWithAggregatesFilter<"SiteCleaningPhoto"> | string
    type?: StringNullableWithAggregatesFilter<"SiteCleaningPhoto"> | string | null
    siteCleaningSessionId?: StringWithAggregatesFilter<"SiteCleaningPhoto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SiteCleaningPhoto"> | Date | string
  }

  export type TicketPhotoWhereInput = {
    AND?: TicketPhotoWhereInput | TicketPhotoWhereInput[]
    OR?: TicketPhotoWhereInput[]
    NOT?: TicketPhotoWhereInput | TicketPhotoWhereInput[]
    id?: StringFilter<"TicketPhoto"> | string
    url?: StringFilter<"TicketPhoto"> | string
    ticketId?: StringFilter<"TicketPhoto"> | string
    createdAt?: DateTimeFilter<"TicketPhoto"> | Date | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }

  export type TicketPhotoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    ticketId?: SortOrder
    createdAt?: SortOrder
    ticket?: TicketOrderByWithRelationInput
  }

  export type TicketPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketPhotoWhereInput | TicketPhotoWhereInput[]
    OR?: TicketPhotoWhereInput[]
    NOT?: TicketPhotoWhereInput | TicketPhotoWhereInput[]
    url?: StringFilter<"TicketPhoto"> | string
    ticketId?: StringFilter<"TicketPhoto"> | string
    createdAt?: DateTimeFilter<"TicketPhoto"> | Date | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }, "id">

  export type TicketPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    ticketId?: SortOrder
    createdAt?: SortOrder
    _count?: TicketPhotoCountOrderByAggregateInput
    _max?: TicketPhotoMaxOrderByAggregateInput
    _min?: TicketPhotoMinOrderByAggregateInput
  }

  export type TicketPhotoScalarWhereWithAggregatesInput = {
    AND?: TicketPhotoScalarWhereWithAggregatesInput | TicketPhotoScalarWhereWithAggregatesInput[]
    OR?: TicketPhotoScalarWhereWithAggregatesInput[]
    NOT?: TicketPhotoScalarWhereWithAggregatesInput | TicketPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketPhoto"> | string
    url?: StringWithAggregatesFilter<"TicketPhoto"> | string
    ticketId?: StringWithAggregatesFilter<"TicketPhoto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketPhoto"> | Date | string
  }

  export type CleaningChecklistWhereInput = {
    AND?: CleaningChecklistWhereInput | CleaningChecklistWhereInput[]
    OR?: CleaningChecklistWhereInput[]
    NOT?: CleaningChecklistWhereInput | CleaningChecklistWhereInput[]
    id?: StringFilter<"CleaningChecklist"> | string
    item?: StringFilter<"CleaningChecklist"> | string
    completed?: BoolFilter<"CleaningChecklist"> | boolean
    cleaningSessionId?: StringFilter<"CleaningChecklist"> | string
    createdAt?: DateTimeFilter<"CleaningChecklist"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningChecklist"> | Date | string
    cleaningSession?: XOR<CleaningSessionScalarRelationFilter, CleaningSessionWhereInput>
  }

  export type CleaningChecklistOrderByWithRelationInput = {
    id?: SortOrder
    item?: SortOrder
    completed?: SortOrder
    cleaningSessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningSession?: CleaningSessionOrderByWithRelationInput
  }

  export type CleaningChecklistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CleaningChecklistWhereInput | CleaningChecklistWhereInput[]
    OR?: CleaningChecklistWhereInput[]
    NOT?: CleaningChecklistWhereInput | CleaningChecklistWhereInput[]
    item?: StringFilter<"CleaningChecklist"> | string
    completed?: BoolFilter<"CleaningChecklist"> | boolean
    cleaningSessionId?: StringFilter<"CleaningChecklist"> | string
    createdAt?: DateTimeFilter<"CleaningChecklist"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningChecklist"> | Date | string
    cleaningSession?: XOR<CleaningSessionScalarRelationFilter, CleaningSessionWhereInput>
  }, "id">

  export type CleaningChecklistOrderByWithAggregationInput = {
    id?: SortOrder
    item?: SortOrder
    completed?: SortOrder
    cleaningSessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CleaningChecklistCountOrderByAggregateInput
    _max?: CleaningChecklistMaxOrderByAggregateInput
    _min?: CleaningChecklistMinOrderByAggregateInput
  }

  export type CleaningChecklistScalarWhereWithAggregatesInput = {
    AND?: CleaningChecklistScalarWhereWithAggregatesInput | CleaningChecklistScalarWhereWithAggregatesInput[]
    OR?: CleaningChecklistScalarWhereWithAggregatesInput[]
    NOT?: CleaningChecklistScalarWhereWithAggregatesInput | CleaningChecklistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CleaningChecklist"> | string
    item?: StringWithAggregatesFilter<"CleaningChecklist"> | string
    completed?: BoolWithAggregatesFilter<"CleaningChecklist"> | boolean
    cleaningSessionId?: StringWithAggregatesFilter<"CleaningChecklist"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CleaningChecklist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CleaningChecklist"> | Date | string
  }

  export type SiteCleaningChecklistWhereInput = {
    AND?: SiteCleaningChecklistWhereInput | SiteCleaningChecklistWhereInput[]
    OR?: SiteCleaningChecklistWhereInput[]
    NOT?: SiteCleaningChecklistWhereInput | SiteCleaningChecklistWhereInput[]
    id?: StringFilter<"SiteCleaningChecklist"> | string
    item?: StringFilter<"SiteCleaningChecklist"> | string
    completed?: BoolFilter<"SiteCleaningChecklist"> | boolean
    siteCleaningSessionId?: StringFilter<"SiteCleaningChecklist"> | string
    createdAt?: DateTimeFilter<"SiteCleaningChecklist"> | Date | string
    updatedAt?: DateTimeFilter<"SiteCleaningChecklist"> | Date | string
    siteCleaningSession?: XOR<SiteCleaningSessionScalarRelationFilter, SiteCleaningSessionWhereInput>
  }

  export type SiteCleaningChecklistOrderByWithRelationInput = {
    id?: SortOrder
    item?: SortOrder
    completed?: SortOrder
    siteCleaningSessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    siteCleaningSession?: SiteCleaningSessionOrderByWithRelationInput
  }

  export type SiteCleaningChecklistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SiteCleaningChecklistWhereInput | SiteCleaningChecklistWhereInput[]
    OR?: SiteCleaningChecklistWhereInput[]
    NOT?: SiteCleaningChecklistWhereInput | SiteCleaningChecklistWhereInput[]
    item?: StringFilter<"SiteCleaningChecklist"> | string
    completed?: BoolFilter<"SiteCleaningChecklist"> | boolean
    siteCleaningSessionId?: StringFilter<"SiteCleaningChecklist"> | string
    createdAt?: DateTimeFilter<"SiteCleaningChecklist"> | Date | string
    updatedAt?: DateTimeFilter<"SiteCleaningChecklist"> | Date | string
    siteCleaningSession?: XOR<SiteCleaningSessionScalarRelationFilter, SiteCleaningSessionWhereInput>
  }, "id">

  export type SiteCleaningChecklistOrderByWithAggregationInput = {
    id?: SortOrder
    item?: SortOrder
    completed?: SortOrder
    siteCleaningSessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SiteCleaningChecklistCountOrderByAggregateInput
    _max?: SiteCleaningChecklistMaxOrderByAggregateInput
    _min?: SiteCleaningChecklistMinOrderByAggregateInput
  }

  export type SiteCleaningChecklistScalarWhereWithAggregatesInput = {
    AND?: SiteCleaningChecklistScalarWhereWithAggregatesInput | SiteCleaningChecklistScalarWhereWithAggregatesInput[]
    OR?: SiteCleaningChecklistScalarWhereWithAggregatesInput[]
    NOT?: SiteCleaningChecklistScalarWhereWithAggregatesInput | SiteCleaningChecklistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SiteCleaningChecklist"> | string
    item?: StringWithAggregatesFilter<"SiteCleaningChecklist"> | string
    completed?: BoolWithAggregatesFilter<"SiteCleaningChecklist"> | boolean
    siteCleaningSessionId?: StringWithAggregatesFilter<"SiteCleaningChecklist"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SiteCleaningChecklist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SiteCleaningChecklist"> | Date | string
  }

  export type CleaningPlanningWhereInput = {
    AND?: CleaningPlanningWhereInput | CleaningPlanningWhereInput[]
    OR?: CleaningPlanningWhereInput[]
    NOT?: CleaningPlanningWhereInput | CleaningPlanningWhereInput[]
    id?: StringFilter<"CleaningPlanning"> | string
    date?: DateTimeFilter<"CleaningPlanning"> | Date | string
    startTime?: StringNullableFilter<"CleaningPlanning"> | string | null
    endTime?: StringNullableFilter<"CleaningPlanning"> | string | null
    interventionSiteId?: StringFilter<"CleaningPlanning"> | string
    cleaningManagerId?: StringFilter<"CleaningPlanning"> | string
    agentId?: StringNullableFilter<"CleaningPlanning"> | string | null
    createdAt?: DateTimeFilter<"CleaningPlanning"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningPlanning"> | Date | string
    interventionSite?: XOR<InterventionSiteScalarRelationFilter, InterventionSiteWhereInput>
    cleaningManager?: XOR<CleaningManagerScalarRelationFilter, CleaningManagerWhereInput>
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
  }

  export type CleaningPlanningOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    interventionSiteId?: SortOrder
    cleaningManagerId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    interventionSite?: InterventionSiteOrderByWithRelationInput
    cleaningManager?: CleaningManagerOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
  }

  export type CleaningPlanningWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CleaningPlanningWhereInput | CleaningPlanningWhereInput[]
    OR?: CleaningPlanningWhereInput[]
    NOT?: CleaningPlanningWhereInput | CleaningPlanningWhereInput[]
    date?: DateTimeFilter<"CleaningPlanning"> | Date | string
    startTime?: StringNullableFilter<"CleaningPlanning"> | string | null
    endTime?: StringNullableFilter<"CleaningPlanning"> | string | null
    interventionSiteId?: StringFilter<"CleaningPlanning"> | string
    cleaningManagerId?: StringFilter<"CleaningPlanning"> | string
    agentId?: StringNullableFilter<"CleaningPlanning"> | string | null
    createdAt?: DateTimeFilter<"CleaningPlanning"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningPlanning"> | Date | string
    interventionSite?: XOR<InterventionSiteScalarRelationFilter, InterventionSiteWhereInput>
    cleaningManager?: XOR<CleaningManagerScalarRelationFilter, CleaningManagerWhereInput>
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
  }, "id">

  export type CleaningPlanningOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    interventionSiteId?: SortOrder
    cleaningManagerId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CleaningPlanningCountOrderByAggregateInput
    _max?: CleaningPlanningMaxOrderByAggregateInput
    _min?: CleaningPlanningMinOrderByAggregateInput
  }

  export type CleaningPlanningScalarWhereWithAggregatesInput = {
    AND?: CleaningPlanningScalarWhereWithAggregatesInput | CleaningPlanningScalarWhereWithAggregatesInput[]
    OR?: CleaningPlanningScalarWhereWithAggregatesInput[]
    NOT?: CleaningPlanningScalarWhereWithAggregatesInput | CleaningPlanningScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CleaningPlanning"> | string
    date?: DateTimeWithAggregatesFilter<"CleaningPlanning"> | Date | string
    startTime?: StringNullableWithAggregatesFilter<"CleaningPlanning"> | string | null
    endTime?: StringNullableWithAggregatesFilter<"CleaningPlanning"> | string | null
    interventionSiteId?: StringWithAggregatesFilter<"CleaningPlanning"> | string
    cleaningManagerId?: StringWithAggregatesFilter<"CleaningPlanning"> | string
    agentId?: StringNullableWithAggregatesFilter<"CleaningPlanning"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CleaningPlanning"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CleaningPlanning"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatNullableFilter<"OrderItem"> | number | null
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    price?: SortOrderInput | SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatNullableFilter<"OrderItem"> | number | null
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    price?: SortOrderInput | SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    price?: FloatNullableWithAggregatesFilter<"OrderItem"> | number | null
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    productId?: StringWithAggregatesFilter<"OrderItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
  }

  export type DeliveryNoteWhereInput = {
    AND?: DeliveryNoteWhereInput | DeliveryNoteWhereInput[]
    OR?: DeliveryNoteWhereInput[]
    NOT?: DeliveryNoteWhereInput | DeliveryNoteWhereInput[]
    id?: StringFilter<"DeliveryNote"> | string
    number?: StringFilter<"DeliveryNote"> | string
    date?: DateTimeFilter<"DeliveryNote"> | Date | string
    orderId?: StringFilter<"DeliveryNote"> | string
    laundryManagerId?: StringFilter<"DeliveryNote"> | string
    createdAt?: DateTimeFilter<"DeliveryNote"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryNote"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    laundryManager?: XOR<LaundryManagerScalarRelationFilter, LaundryManagerWhereInput>
  }

  export type DeliveryNoteOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    orderId?: SortOrder
    laundryManagerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    laundryManager?: LaundryManagerOrderByWithRelationInput
  }

  export type DeliveryNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryNoteWhereInput | DeliveryNoteWhereInput[]
    OR?: DeliveryNoteWhereInput[]
    NOT?: DeliveryNoteWhereInput | DeliveryNoteWhereInput[]
    number?: StringFilter<"DeliveryNote"> | string
    date?: DateTimeFilter<"DeliveryNote"> | Date | string
    orderId?: StringFilter<"DeliveryNote"> | string
    laundryManagerId?: StringFilter<"DeliveryNote"> | string
    createdAt?: DateTimeFilter<"DeliveryNote"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryNote"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    laundryManager?: XOR<LaundryManagerScalarRelationFilter, LaundryManagerWhereInput>
  }, "id">

  export type DeliveryNoteOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    orderId?: SortOrder
    laundryManagerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeliveryNoteCountOrderByAggregateInput
    _max?: DeliveryNoteMaxOrderByAggregateInput
    _min?: DeliveryNoteMinOrderByAggregateInput
  }

  export type DeliveryNoteScalarWhereWithAggregatesInput = {
    AND?: DeliveryNoteScalarWhereWithAggregatesInput | DeliveryNoteScalarWhereWithAggregatesInput[]
    OR?: DeliveryNoteScalarWhereWithAggregatesInput[]
    NOT?: DeliveryNoteScalarWhereWithAggregatesInput | DeliveryNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryNote"> | string
    number?: StringWithAggregatesFilter<"DeliveryNote"> | string
    date?: DateTimeWithAggregatesFilter<"DeliveryNote"> | Date | string
    orderId?: StringWithAggregatesFilter<"DeliveryNote"> | string
    laundryManagerId?: StringWithAggregatesFilter<"DeliveryNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeliveryNote"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringNullableFilter<"Notification"> | string | null
    userId?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrderInput | SortOrder
    userId?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringNullableFilter<"Notification"> | string | null
    userId?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrderInput | SortOrder
    userId?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    userId?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringFilter<"Service"> | string
    users?: ServiceUserListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    users?: ServiceUserOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    description?: StringFilter<"Service"> | string
    users?: ServiceUserListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    description?: StringWithAggregatesFilter<"Service"> | string
  }

  export type ServiceUserWhereInput = {
    AND?: ServiceUserWhereInput | ServiceUserWhereInput[]
    OR?: ServiceUserWhereInput[]
    NOT?: ServiceUserWhereInput | ServiceUserWhereInput[]
    id?: StringFilter<"ServiceUser"> | string
    name?: StringFilter<"ServiceUser"> | string
    status?: EnumServiceUserStatusFilter<"ServiceUser"> | $Enums.ServiceUserStatus
    serviceId?: StringFilter<"ServiceUser"> | string
    userId?: StringFilter<"ServiceUser"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type ServiceUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type ServiceUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceUserWhereInput | ServiceUserWhereInput[]
    OR?: ServiceUserWhereInput[]
    NOT?: ServiceUserWhereInput | ServiceUserWhereInput[]
    name?: StringFilter<"ServiceUser"> | string
    status?: EnumServiceUserStatusFilter<"ServiceUser"> | $Enums.ServiceUserStatus
    serviceId?: StringFilter<"ServiceUser"> | string
    userId?: StringFilter<"ServiceUser"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id">

  export type ServiceUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
    _count?: ServiceUserCountOrderByAggregateInput
    _max?: ServiceUserMaxOrderByAggregateInput
    _min?: ServiceUserMinOrderByAggregateInput
  }

  export type ServiceUserScalarWhereWithAggregatesInput = {
    AND?: ServiceUserScalarWhereWithAggregatesInput | ServiceUserScalarWhereWithAggregatesInput[]
    OR?: ServiceUserScalarWhereWithAggregatesInput[]
    NOT?: ServiceUserScalarWhereWithAggregatesInput | ServiceUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceUser"> | string
    name?: StringWithAggregatesFilter<"ServiceUser"> | string
    status?: EnumServiceUserStatusWithAggregatesFilter<"ServiceUser"> | $Enums.ServiceUserStatus
    serviceId?: StringWithAggregatesFilter<"ServiceUser"> | string
    userId?: StringWithAggregatesFilter<"ServiceUser"> | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    conciergerieManagers?: ConciergerieManagerCreateNestedManyWithoutUserInput
    cleaningManagers?: CleaningManagerCreateNestedManyWithoutUserInput
    laundryManagers?: LaundryManagerCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    serviceUsers?: ServiceUserCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    conciergerieManagers?: ConciergerieManagerUncheckedCreateNestedManyWithoutUserInput
    cleaningManagers?: CleaningManagerUncheckedCreateNestedManyWithoutUserInput
    laundryManagers?: LaundryManagerUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    serviceUsers?: ServiceUserUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    conciergerieManagers?: ConciergerieManagerUpdateManyWithoutUserNestedInput
    cleaningManagers?: CleaningManagerUpdateManyWithoutUserNestedInput
    laundryManagers?: LaundryManagerUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    serviceUsers?: ServiceUserUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    conciergerieManagers?: ConciergerieManagerUncheckedUpdateManyWithoutUserNestedInput
    cleaningManagers?: CleaningManagerUncheckedUpdateManyWithoutUserNestedInput
    laundryManagers?: LaundryManagerUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    serviceUsers?: ServiceUserUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConciergerieManagerCreateInput = {
    id?: string
    name: string
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutConciergerieManagersInput
    properties?: PropertyCreateNestedManyWithoutConciergerieManagerInput
    agents?: AgentCreateNestedManyWithoutConciergerieManagerInput
    tasks?: TaskCreateNestedManyWithoutConciergerieManagerInput
  }

  export type ConciergerieManagerUncheckedCreateInput = {
    id?: string
    name: string
    userId: string
    createdAt: Date | string
    updatedAt: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutConciergerieManagerInput
    agents?: AgentUncheckedCreateNestedManyWithoutConciergerieManagerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutConciergerieManagerInput
  }

  export type ConciergerieManagerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConciergerieManagersNestedInput
    properties?: PropertyUpdateManyWithoutConciergerieManagerNestedInput
    agents?: AgentUpdateManyWithoutConciergerieManagerNestedInput
    tasks?: TaskUpdateManyWithoutConciergerieManagerNestedInput
  }

  export type ConciergerieManagerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutConciergerieManagerNestedInput
    agents?: AgentUncheckedUpdateManyWithoutConciergerieManagerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutConciergerieManagerNestedInput
  }

  export type ConciergerieManagerCreateManyInput = {
    id?: string
    name: string
    userId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ConciergerieManagerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConciergerieManagerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManager?: ConciergerieManagerCreateNestedOneWithoutTasksInput
    agent?: AgentCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManagerId?: string | null
    agentId?: string | null
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManager?: ConciergerieManagerUpdateOneWithoutTasksNestedInput
    agent?: AgentUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateManyInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManagerId?: string | null
    agentId?: string | null
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyCreateInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManager: ConciergerieManagerCreateNestedOneWithoutPropertiesInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutPropertyInput
    reservations?: ReservationCreateNestedManyWithoutPropertyInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    tickets?: TicketCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManagerId: string
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManager?: ConciergerieManagerUpdateOneRequiredWithoutPropertiesNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateManyInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManagerId: string
  }

  export type PropertyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
  }

  export type ReservationCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    client?: string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    property: PropertyCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateInput = {
    id?: string
    propertyId: string
    startDate: Date | string
    endDate: Date | string
    client?: string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ReservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateManyInput = {
    id?: string
    propertyId: string
    startDate: Date | string
    endDate: Date | string
    client?: string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ReservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentCreateInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutAgentInput
    conciergerieManager: ConciergerieManagerCreateNestedOneWithoutAgentsInput
    tasks?: TaskCreateNestedManyWithoutAgentInput
    tickets?: TicketCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningCreateNestedManyWithoutAgentInput
    user: UserCreateNestedOneWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutCleaningAgentInput
    cleaningManager?: CleaningManagerCreateNestedOneWithoutCleaningAgentsInput
  }

  export type AgentUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    conciergerieManagerId: string
    userId: string
    cleaningManagerId?: string | null
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutAgentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAgentInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningUncheckedCreateNestedManyWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutCleaningAgentInput
  }

  export type AgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutAgentNestedInput
    conciergerieManager?: ConciergerieManagerUpdateOneRequiredWithoutAgentsNestedInput
    tasks?: TaskUpdateManyWithoutAgentNestedInput
    tickets?: TicketUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUpdateManyWithoutAgentNestedInput
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutCleaningAgentNestedInput
    cleaningManager?: CleaningManagerUpdateOneWithoutCleaningAgentsNestedInput
  }

  export type AgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cleaningManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUncheckedUpdateManyWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutCleaningAgentNestedInput
  }

  export type AgentCreateManyInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    conciergerieManagerId: string
    userId: string
    cleaningManagerId?: string | null
  }

  export type AgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
  }

  export type AgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cleaningManagerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceSessionCreateInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    notes?: string | null
    property: PropertyCreateNestedOneWithoutMaintenanceSessionsInput
    maintenance: MaintenanceCreateNestedOneWithoutSessionMaintenancesInput
    agent: AgentCreateNestedOneWithoutMaintenanceSessionsInput
    photos?: MaintenancePhotoCreateNestedManyWithoutMaintenanceSessionInput
  }

  export type MaintenanceSessionUncheckedCreateInput = {
    id?: string
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
    maintenanceId: string
    agentId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    notes?: string | null
    photos?: MaintenancePhotoUncheckedCreateNestedManyWithoutMaintenanceSessionInput
  }

  export type MaintenanceSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    property?: PropertyUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    maintenance?: MaintenanceUpdateOneRequiredWithoutSessionMaintenancesNestedInput
    agent?: AgentUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    photos?: MaintenancePhotoUpdateManyWithoutMaintenanceSessionNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: MaintenancePhotoUncheckedUpdateManyWithoutMaintenanceSessionNestedInput
  }

  export type MaintenanceSessionCreateManyInput = {
    id?: string
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
    maintenanceId: string
    agentId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    notes?: string | null
  }

  export type MaintenanceSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceCreateInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    sessionMaintenances?: MaintenanceSessionCreateNestedManyWithoutMaintenanceInput
  }

  export type MaintenanceUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    sessionMaintenances?: MaintenanceSessionUncheckedCreateNestedManyWithoutMaintenanceInput
  }

  export type MaintenanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionMaintenances?: MaintenanceSessionUpdateManyWithoutMaintenanceNestedInput
  }

  export type MaintenanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionMaintenances?: MaintenanceSessionUncheckedUpdateManyWithoutMaintenanceNestedInput
  }

  export type MaintenanceCreateManyInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type MaintenanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSessionCreateInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    property: PropertyCreateNestedOneWithoutCleaningSessionsInput
    cleaning: CleaningCreateNestedOneWithoutCleaningSessionsInput
    agent: AgentCreateNestedOneWithoutCleaningSessionsInput
    photos?: CleaningPhotoCreateNestedManyWithoutCleaningSessionInput
    checklist?: CleaningChecklistCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionUncheckedCreateInput = {
    id?: string
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningId: string
    agentId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    photos?: CleaningPhotoUncheckedCreateNestedManyWithoutCleaningSessionInput
    checklist?: CleaningChecklistUncheckedCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    property?: PropertyUpdateOneRequiredWithoutCleaningSessionsNestedInput
    cleaning?: CleaningUpdateOneRequiredWithoutCleaningSessionsNestedInput
    agent?: AgentUpdateOneRequiredWithoutCleaningSessionsNestedInput
    photos?: CleaningPhotoUpdateManyWithoutCleaningSessionNestedInput
    checklist?: CleaningChecklistUpdateManyWithoutCleaningSessionNestedInput
  }

  export type CleaningSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: CleaningPhotoUncheckedUpdateManyWithoutCleaningSessionNestedInput
    checklist?: CleaningChecklistUncheckedUpdateManyWithoutCleaningSessionNestedInput
  }

  export type CleaningSessionCreateManyInput = {
    id?: string
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningId: string
    agentId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
  }

  export type CleaningSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CleaningSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CleaningCreateInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutCleaningInput
  }

  export type CleaningUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutCleaningInput
  }

  export type CleaningUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningSessions?: CleaningSessionUpdateManyWithoutCleaningNestedInput
  }

  export type CleaningUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutCleaningNestedInput
  }

  export type CleaningCreateManyInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CleaningUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningManagerCreateInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutCleaningManagersInput
    interventionSites?: InterventionSiteCreateNestedManyWithoutCleaningManagerInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutCleaningManagerInput
    cleaningAgents?: AgentCreateNestedManyWithoutCleaningManagerInput
    cleaningPlannings?: CleaningPlanningCreateNestedManyWithoutCleaningManagerInput
  }

  export type CleaningManagerUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt: Date | string
    updatedAt: Date | string
    interventionSites?: InterventionSiteUncheckedCreateNestedManyWithoutCleaningManagerInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutCleaningManagerInput
    cleaningAgents?: AgentUncheckedCreateNestedManyWithoutCleaningManagerInput
    cleaningPlannings?: CleaningPlanningUncheckedCreateNestedManyWithoutCleaningManagerInput
  }

  export type CleaningManagerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCleaningManagersNestedInput
    interventionSites?: InterventionSiteUpdateManyWithoutCleaningManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutCleaningManagerNestedInput
    cleaningAgents?: AgentUpdateManyWithoutCleaningManagerNestedInput
    cleaningPlannings?: CleaningPlanningUpdateManyWithoutCleaningManagerNestedInput
  }

  export type CleaningManagerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventionSites?: InterventionSiteUncheckedUpdateManyWithoutCleaningManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutCleaningManagerNestedInput
    cleaningAgents?: AgentUncheckedUpdateManyWithoutCleaningManagerNestedInput
    cleaningPlannings?: CleaningPlanningUncheckedUpdateManyWithoutCleaningManagerNestedInput
  }

  export type CleaningManagerCreateManyInput = {
    id?: string
    userId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CleaningManagerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningManagerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionSiteCreateInput = {
    id?: string
    name: string
    description: string
    client?: string | null
    site?: string | null
    surface?: number | null
    type?: string | null
    address?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManager: CleaningManagerCreateNestedOneWithoutInterventionSitesInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutInterventionSiteInput
    cleaningPlannings?: CleaningPlanningCreateNestedManyWithoutInterventionSiteInput
  }

  export type InterventionSiteUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    client?: string | null
    site?: string | null
    surface?: number | null
    type?: string | null
    address?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManagerId: string
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutInterventionSiteInput
    cleaningPlannings?: CleaningPlanningUncheckedCreateNestedManyWithoutInterventionSiteInput
  }

  export type InterventionSiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    site?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManager?: CleaningManagerUpdateOneRequiredWithoutInterventionSitesNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutInterventionSiteNestedInput
    cleaningPlannings?: CleaningPlanningUpdateManyWithoutInterventionSiteNestedInput
  }

  export type InterventionSiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    site?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutInterventionSiteNestedInput
    cleaningPlannings?: CleaningPlanningUncheckedUpdateManyWithoutInterventionSiteNestedInput
  }

  export type InterventionSiteCreateManyInput = {
    id?: string
    name: string
    description: string
    client?: string | null
    site?: string | null
    surface?: number | null
    type?: string | null
    address?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManagerId: string
  }

  export type InterventionSiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    site?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionSiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    site?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
  }

  export type SiteCleaningSessionCreateInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    interventionSite: InterventionSiteCreateNestedOneWithoutSiteCleaningSessionsInput
    cleaningManager: CleaningManagerCreateNestedOneWithoutSiteCleaningSessionsInput
    photos?: SiteCleaningPhotoCreateNestedManyWithoutSiteCleaningSessionInput
    checklist?: SiteCleaningChecklistCreateNestedManyWithoutSiteCleaningSessionInput
    laundryManager?: LaundryManagerCreateNestedOneWithoutSiteCleaningSessionsInput
    cleaningAgent?: AgentCreateNestedOneWithoutSiteCleaningSessionsInput
  }

  export type SiteCleaningSessionUncheckedCreateInput = {
    id?: string
    interventionSiteId: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManagerId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    laundryManagerId?: string | null
    cleaningAgentId?: string | null
    photos?: SiteCleaningPhotoUncheckedCreateNestedManyWithoutSiteCleaningSessionInput
    checklist?: SiteCleaningChecklistUncheckedCreateNestedManyWithoutSiteCleaningSessionInput
  }

  export type SiteCleaningSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    interventionSite?: InterventionSiteUpdateOneRequiredWithoutSiteCleaningSessionsNestedInput
    cleaningManager?: CleaningManagerUpdateOneRequiredWithoutSiteCleaningSessionsNestedInput
    photos?: SiteCleaningPhotoUpdateManyWithoutSiteCleaningSessionNestedInput
    checklist?: SiteCleaningChecklistUpdateManyWithoutSiteCleaningSessionNestedInput
    laundryManager?: LaundryManagerUpdateOneWithoutSiteCleaningSessionsNestedInput
    cleaningAgent?: AgentUpdateOneWithoutSiteCleaningSessionsNestedInput
  }

  export type SiteCleaningSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interventionSiteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    laundryManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: SiteCleaningPhotoUncheckedUpdateManyWithoutSiteCleaningSessionNestedInput
    checklist?: SiteCleaningChecklistUncheckedUpdateManyWithoutSiteCleaningSessionNestedInput
  }

  export type SiteCleaningSessionCreateManyInput = {
    id?: string
    interventionSiteId: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManagerId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    laundryManagerId?: string | null
    cleaningAgentId?: string | null
  }

  export type SiteCleaningSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
  }

  export type SiteCleaningSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    interventionSiteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    laundryManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningAgentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LaundryManagerCreateInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutLaundryManagersInput
    products?: ProductCreateNestedManyWithoutLaundryManagerInput
    orders?: OrderCreateNestedManyWithoutLaundryManagerInput
    deliveryNotes?: DeliveryNoteCreateNestedManyWithoutLaundryManagerInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutLaundryManagerInput
  }

  export type LaundryManagerUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt: Date | string
    updatedAt: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutLaundryManagerInput
    orders?: OrderUncheckedCreateNestedManyWithoutLaundryManagerInput
    deliveryNotes?: DeliveryNoteUncheckedCreateNestedManyWithoutLaundryManagerInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutLaundryManagerInput
  }

  export type LaundryManagerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLaundryManagersNestedInput
    products?: ProductUpdateManyWithoutLaundryManagerNestedInput
    orders?: OrderUpdateManyWithoutLaundryManagerNestedInput
    deliveryNotes?: DeliveryNoteUpdateManyWithoutLaundryManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutLaundryManagerNestedInput
  }

  export type LaundryManagerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutLaundryManagerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLaundryManagerNestedInput
    deliveryNotes?: DeliveryNoteUncheckedUpdateManyWithoutLaundryManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutLaundryManagerNestedInput
  }

  export type LaundryManagerCreateManyInput = {
    id?: string
    userId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LaundryManagerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryManagerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    description: string
    price?: number | null
    stock?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    laundryManager: LaundryManagerCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    price?: number | null
    stock?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    laundryManagerId: string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    laundryManager?: LaundryManagerUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryManagerId?: StringFieldUpdateOperationsInput | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    description: string
    price?: number | null
    stock?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    laundryManagerId: string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryManagerId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderCreateInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    deliveryDate?: Date | string | null
    client?: string | null
    address?: string | null
    phone?: string | null
    total?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    laundryManager: LaundryManagerCreateNestedOneWithoutOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    deliveryNotes?: DeliveryNoteCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    deliveryDate?: Date | string | null
    client?: string | null
    address?: string | null
    phone?: string | null
    total?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    laundryManagerId: string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    deliveryNotes?: DeliveryNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryManager?: LaundryManagerUpdateOneRequiredWithoutOrdersNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    deliveryNotes?: DeliveryNoteUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryManagerId?: StringFieldUpdateOperationsInput | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    deliveryNotes?: DeliveryNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    deliveryDate?: Date | string | null
    client?: string | null
    address?: string | null
    phone?: string | null
    total?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    laundryManagerId: string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryManagerId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    property: PropertyCreateNestedOneWithoutTicketsInput
    agent?: AgentCreateNestedOneWithoutTicketsInput
    photos?: TicketPhotoCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: string | null
    propertyId: string
    agentId?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    photos?: TicketPhotoUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutTicketsNestedInput
    agent?: AgentUpdateOneWithoutTicketsNestedInput
    photos?: TicketPhotoUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: TicketPhotoUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketCreateManyInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: string | null
    propertyId: string
    agentId?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    currency?: string
    method?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    property: PropertyCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    amount: number
    currency?: string
    method?: string | null
    status?: string | null
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    amount: number
    currency?: string
    method?: string | null
    status?: string | null
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPhotoCreateInput = {
    id?: string
    url: string
    type?: string | null
    createdAt: Date | string
    property: PropertyCreateNestedOneWithoutPhotosInput
  }

  export type PropertyPhotoUncheckedCreateInput = {
    id?: string
    url: string
    type?: string | null
    propertyId: string
    createdAt: Date | string
  }

  export type PropertyPhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type PropertyPhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPhotoCreateManyInput = {
    id?: string
    url: string
    type?: string | null
    propertyId: string
    createdAt: Date | string
  }

  export type PropertyPhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningPhotoCreateInput = {
    id?: string
    url: string
    type?: string | null
    createdAt: Date | string
    cleaningSession: CleaningSessionCreateNestedOneWithoutPhotosInput
  }

  export type CleaningPhotoUncheckedCreateInput = {
    id?: string
    url: string
    type?: string | null
    cleaningSessionId: string
    createdAt: Date | string
  }

  export type CleaningPhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningSession?: CleaningSessionUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type CleaningPhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningSessionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningPhotoCreateManyInput = {
    id?: string
    url: string
    type?: string | null
    cleaningSessionId: string
    createdAt: Date | string
  }

  export type CleaningPhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningPhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningSessionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenancePhotoCreateInput = {
    id?: string
    url: string
    type?: string | null
    createdAt: Date | string
    maintenanceSession: MaintenanceSessionCreateNestedOneWithoutPhotosInput
  }

  export type MaintenancePhotoUncheckedCreateInput = {
    id?: string
    url: string
    type?: string | null
    maintenanceSessionId: string
    createdAt: Date | string
  }

  export type MaintenancePhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceSession?: MaintenanceSessionUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type MaintenancePhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenancePhotoCreateManyInput = {
    id?: string
    url: string
    type?: string | null
    maintenanceSessionId: string
    createdAt: Date | string
  }

  export type MaintenancePhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenancePhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCleaningPhotoCreateInput = {
    id?: string
    url: string
    type?: string | null
    createdAt: Date | string
    siteCleaningSession: SiteCleaningSessionCreateNestedOneWithoutPhotosInput
  }

  export type SiteCleaningPhotoUncheckedCreateInput = {
    id?: string
    url: string
    type?: string | null
    siteCleaningSessionId: string
    createdAt: Date | string
  }

  export type SiteCleaningPhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    siteCleaningSession?: SiteCleaningSessionUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type SiteCleaningPhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    siteCleaningSessionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCleaningPhotoCreateManyInput = {
    id?: string
    url: string
    type?: string | null
    siteCleaningSessionId: string
    createdAt: Date | string
  }

  export type SiteCleaningPhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCleaningPhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    siteCleaningSessionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketPhotoCreateInput = {
    id?: string
    url: string
    createdAt: Date | string
    ticket: TicketCreateNestedOneWithoutPhotosInput
  }

  export type TicketPhotoUncheckedCreateInput = {
    id?: string
    url: string
    ticketId: string
    createdAt: Date | string
  }

  export type TicketPhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type TicketPhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketPhotoCreateManyInput = {
    id?: string
    url: string
    ticketId: string
    createdAt: Date | string
  }

  export type TicketPhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketPhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningChecklistCreateInput = {
    id?: string
    item: string
    completed?: boolean
    createdAt: Date | string
    updatedAt: Date | string
    cleaningSession: CleaningSessionCreateNestedOneWithoutChecklistInput
  }

  export type CleaningChecklistUncheckedCreateInput = {
    id?: string
    item: string
    completed?: boolean
    cleaningSessionId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CleaningChecklistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningSession?: CleaningSessionUpdateOneRequiredWithoutChecklistNestedInput
  }

  export type CleaningChecklistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    cleaningSessionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningChecklistCreateManyInput = {
    id?: string
    item: string
    completed?: boolean
    cleaningSessionId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CleaningChecklistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningChecklistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    cleaningSessionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCleaningChecklistCreateInput = {
    id?: string
    item: string
    completed?: boolean
    createdAt: Date | string
    updatedAt: Date | string
    siteCleaningSession: SiteCleaningSessionCreateNestedOneWithoutChecklistInput
  }

  export type SiteCleaningChecklistUncheckedCreateInput = {
    id?: string
    item: string
    completed?: boolean
    siteCleaningSessionId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SiteCleaningChecklistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    siteCleaningSession?: SiteCleaningSessionUpdateOneRequiredWithoutChecklistNestedInput
  }

  export type SiteCleaningChecklistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    siteCleaningSessionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCleaningChecklistCreateManyInput = {
    id?: string
    item: string
    completed?: boolean
    siteCleaningSessionId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SiteCleaningChecklistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCleaningChecklistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    siteCleaningSessionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningPlanningCreateInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    interventionSite: InterventionSiteCreateNestedOneWithoutCleaningPlanningsInput
    cleaningManager: CleaningManagerCreateNestedOneWithoutCleaningPlanningsInput
    agent?: AgentCreateNestedOneWithoutCleaningPlanningsInput
  }

  export type CleaningPlanningUncheckedCreateInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    interventionSiteId: string
    cleaningManagerId: string
    agentId?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CleaningPlanningUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventionSite?: InterventionSiteUpdateOneRequiredWithoutCleaningPlanningsNestedInput
    cleaningManager?: CleaningManagerUpdateOneRequiredWithoutCleaningPlanningsNestedInput
    agent?: AgentUpdateOneWithoutCleaningPlanningsNestedInput
  }

  export type CleaningPlanningUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    interventionSiteId?: StringFieldUpdateOperationsInput | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningPlanningCreateManyInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    interventionSiteId: string
    cleaningManagerId: string
    agentId?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CleaningPlanningUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningPlanningUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    interventionSiteId?: StringFieldUpdateOperationsInput | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    id?: string
    quantity: number
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    order: OrderCreateNestedOneWithoutOrderItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    quantity: number
    price?: number | null
    orderId: string
    productId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyInput = {
    id?: string
    quantity: number
    price?: number | null
    orderId: string
    productId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryNoteCreateInput = {
    id?: string
    number: string
    date: Date | string
    createdAt: Date | string
    updatedAt: Date | string
    order: OrderCreateNestedOneWithoutDeliveryNotesInput
    laundryManager: LaundryManagerCreateNestedOneWithoutDeliveryNotesInput
  }

  export type DeliveryNoteUncheckedCreateInput = {
    id?: string
    number: string
    date: Date | string
    orderId: string
    laundryManagerId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type DeliveryNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutDeliveryNotesNestedInput
    laundryManager?: LaundryManagerUpdateOneRequiredWithoutDeliveryNotesNestedInput
  }

  export type DeliveryNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    laundryManagerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryNoteCreateManyInput = {
    id?: string
    number: string
    date: Date | string
    orderId: string
    laundryManagerId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type DeliveryNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    laundryManagerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type?: string | null
    read?: boolean
    createdAt: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    message: string
    type?: string | null
    userId: string
    read?: boolean
    createdAt: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    message: string
    type?: string | null
    userId: string
    read?: boolean
    createdAt: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    description: string
    users?: ServiceUserCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    users?: ServiceUserUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    users?: ServiceUserUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    users?: ServiceUserUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    description: string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceUserCreateInput = {
    id?: string
    name: string
    status?: $Enums.ServiceUserStatus
    user: UserCreateNestedOneWithoutServiceUsersInput
    service: ServiceCreateNestedOneWithoutUsersInput
  }

  export type ServiceUserUncheckedCreateInput = {
    id?: string
    name: string
    status?: $Enums.ServiceUserStatus
    serviceId: string
    userId: string
  }

  export type ServiceUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceUserStatusFieldUpdateOperationsInput | $Enums.ServiceUserStatus
    user?: UserUpdateOneRequiredWithoutServiceUsersNestedInput
    service?: ServiceUpdateOneRequiredWithoutUsersNestedInput
  }

  export type ServiceUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceUserStatusFieldUpdateOperationsInput | $Enums.ServiceUserStatus
    serviceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceUserCreateManyInput = {
    id?: string
    name: string
    status?: $Enums.ServiceUserStatus
    serviceId: string
    userId: string
  }

  export type ServiceUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceUserStatusFieldUpdateOperationsInput | $Enums.ServiceUserStatus
  }

  export type ServiceUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceUserStatusFieldUpdateOperationsInput | $Enums.ServiceUserStatus
    serviceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ConciergerieManagerListRelationFilter = {
    every?: ConciergerieManagerWhereInput
    some?: ConciergerieManagerWhereInput
    none?: ConciergerieManagerWhereInput
  }

  export type CleaningManagerListRelationFilter = {
    every?: CleaningManagerWhereInput
    some?: CleaningManagerWhereInput
    none?: CleaningManagerWhereInput
  }

  export type LaundryManagerListRelationFilter = {
    every?: LaundryManagerWhereInput
    some?: LaundryManagerWhereInput
    none?: LaundryManagerWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ServiceUserListRelationFilter = {
    every?: ServiceUserWhereInput
    some?: ServiceUserWhereInput
    none?: ServiceUserWhereInput
  }

  export type AgentListRelationFilter = {
    every?: AgentWhereInput
    some?: AgentWhereInput
    none?: AgentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConciergerieManagerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CleaningManagerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaundryManagerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type PropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConciergerieManagerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConciergerieManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConciergerieManagerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConciergerieManagerNullableScalarRelationFilter = {
    is?: ConciergerieManagerWhereInput | null
    isNot?: ConciergerieManagerWhereInput | null
  }

  export type AgentNullableScalarRelationFilter = {
    is?: AgentWhereInput | null
    isNot?: AgentWhereInput | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conciergerieManagerId?: SortOrder
    agentId?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conciergerieManagerId?: SortOrder
    agentId?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conciergerieManagerId?: SortOrder
    agentId?: SortOrder
  }

  export type EnumPropertyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusFilter<$PrismaModel> | $Enums.PropertyStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ConciergerieManagerScalarRelationFilter = {
    is?: ConciergerieManagerWhereInput
    isNot?: ConciergerieManagerWhereInput
  }

  export type CleaningSessionListRelationFilter = {
    every?: CleaningSessionWhereInput
    some?: CleaningSessionWhereInput
    none?: CleaningSessionWhereInput
  }

  export type MaintenanceSessionListRelationFilter = {
    every?: MaintenanceSessionWhereInput
    some?: MaintenanceSessionWhereInput
    none?: MaintenanceSessionWhereInput
  }

  export type ReservationListRelationFilter = {
    every?: ReservationWhereInput
    some?: ReservationWhereInput
    none?: ReservationWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type PropertyPhotoListRelationFilter = {
    every?: PropertyPhotoWhereInput
    some?: PropertyPhotoWhereInput
    none?: PropertyPhotoWhereInput
  }

  export type CleaningSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenanceSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    location?: SortOrder
    surface?: SortOrder
    numberOfRooms?: SortOrder
    numberOfBathrooms?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conciergerieManagerId?: SortOrder
  }

  export type PropertyAvgOrderByAggregateInput = {
    surface?: SortOrder
    numberOfRooms?: SortOrder
    numberOfBathrooms?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    location?: SortOrder
    surface?: SortOrder
    numberOfRooms?: SortOrder
    numberOfBathrooms?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conciergerieManagerId?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    location?: SortOrder
    surface?: SortOrder
    numberOfRooms?: SortOrder
    numberOfBathrooms?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conciergerieManagerId?: SortOrder
  }

  export type PropertySumOrderByAggregateInput = {
    surface?: SortOrder
    numberOfRooms?: SortOrder
    numberOfBathrooms?: SortOrder
  }

  export type EnumPropertyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel> | $Enums.PropertyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyStatusFilter<$PrismaModel>
    _max?: NestedEnumPropertyStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PropertyScalarRelationFilter = {
    is?: PropertyWhereInput
    isNot?: PropertyWhereInput
  }

  export type ReservationCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    client?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReservationMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    client?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReservationMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    client?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAgentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentTypeFilter<$PrismaModel> | $Enums.AgentType
  }

  export type CleaningPlanningListRelationFilter = {
    every?: CleaningPlanningWhereInput
    some?: CleaningPlanningWhereInput
    none?: CleaningPlanningWhereInput
  }

  export type SiteCleaningSessionListRelationFilter = {
    every?: SiteCleaningSessionWhereInput
    some?: SiteCleaningSessionWhereInput
    none?: SiteCleaningSessionWhereInput
  }

  export type CleaningManagerNullableScalarRelationFilter = {
    is?: CleaningManagerWhereInput | null
    isNot?: CleaningManagerWhereInput | null
  }

  export type CleaningPlanningOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteCleaningSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    conciergerieManagerId?: SortOrder
    userId?: SortOrder
    cleaningManagerId?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    conciergerieManagerId?: SortOrder
    userId?: SortOrder
    cleaningManagerId?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    conciergerieManagerId?: SortOrder
    userId?: SortOrder
    cleaningManagerId?: SortOrder
  }

  export type EnumAgentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AgentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentTypeFilter<$PrismaModel>
    _max?: NestedEnumAgentTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type MaintenanceScalarRelationFilter = {
    is?: MaintenanceWhereInput
    isNot?: MaintenanceWhereInput
  }

  export type AgentScalarRelationFilter = {
    is?: AgentWhereInput
    isNot?: AgentWhereInput
  }

  export type MaintenancePhotoListRelationFilter = {
    every?: MaintenancePhotoWhereInput
    some?: MaintenancePhotoWhereInput
    none?: MaintenancePhotoWhereInput
  }

  export type MaintenancePhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenanceSessionCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maintenanceId?: SortOrder
    agentId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
  }

  export type MaintenanceSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maintenanceId?: SortOrder
    agentId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
  }

  export type MaintenanceSessionMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maintenanceId?: SortOrder
    agentId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type MaintenanceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningScalarRelationFilter = {
    is?: CleaningWhereInput
    isNot?: CleaningWhereInput
  }

  export type CleaningPhotoListRelationFilter = {
    every?: CleaningPhotoWhereInput
    some?: CleaningPhotoWhereInput
    none?: CleaningPhotoWhereInput
  }

  export type CleaningChecklistListRelationFilter = {
    every?: CleaningChecklistWhereInput
    some?: CleaningChecklistWhereInput
    none?: CleaningChecklistWhereInput
  }

  export type CleaningPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CleaningChecklistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CleaningSessionCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningId?: SortOrder
    agentId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
  }

  export type CleaningSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type CleaningSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningId?: SortOrder
    agentId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
  }

  export type CleaningSessionMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningId?: SortOrder
    agentId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
  }

  export type CleaningSessionSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type CleaningCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterventionSiteListRelationFilter = {
    every?: InterventionSiteWhereInput
    some?: InterventionSiteWhereInput
    none?: InterventionSiteWhereInput
  }

  export type InterventionSiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CleaningManagerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningManagerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningManagerScalarRelationFilter = {
    is?: CleaningManagerWhereInput
    isNot?: CleaningManagerWhereInput
  }

  export type InterventionSiteCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    client?: SortOrder
    site?: SortOrder
    surface?: SortOrder
    type?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningManagerId?: SortOrder
  }

  export type InterventionSiteAvgOrderByAggregateInput = {
    surface?: SortOrder
  }

  export type InterventionSiteMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    client?: SortOrder
    site?: SortOrder
    surface?: SortOrder
    type?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningManagerId?: SortOrder
  }

  export type InterventionSiteMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    client?: SortOrder
    site?: SortOrder
    surface?: SortOrder
    type?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningManagerId?: SortOrder
  }

  export type InterventionSiteSumOrderByAggregateInput = {
    surface?: SortOrder
  }

  export type EnumInterventionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionStatus | EnumInterventionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionStatusFilter<$PrismaModel> | $Enums.InterventionStatus
  }

  export type InterventionSiteScalarRelationFilter = {
    is?: InterventionSiteWhereInput
    isNot?: InterventionSiteWhereInput
  }

  export type SiteCleaningPhotoListRelationFilter = {
    every?: SiteCleaningPhotoWhereInput
    some?: SiteCleaningPhotoWhereInput
    none?: SiteCleaningPhotoWhereInput
  }

  export type SiteCleaningChecklistListRelationFilter = {
    every?: SiteCleaningChecklistWhereInput
    some?: SiteCleaningChecklistWhereInput
    none?: SiteCleaningChecklistWhereInput
  }

  export type LaundryManagerNullableScalarRelationFilter = {
    is?: LaundryManagerWhereInput | null
    isNot?: LaundryManagerWhereInput | null
  }

  export type SiteCleaningPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteCleaningChecklistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteCleaningSessionCountOrderByAggregateInput = {
    id?: SortOrder
    interventionSiteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningManagerId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    laundryManagerId?: SortOrder
    cleaningAgentId?: SortOrder
  }

  export type SiteCleaningSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type SiteCleaningSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    interventionSiteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningManagerId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    laundryManagerId?: SortOrder
    cleaningAgentId?: SortOrder
  }

  export type SiteCleaningSessionMinOrderByAggregateInput = {
    id?: SortOrder
    interventionSiteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cleaningManagerId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    laundryManagerId?: SortOrder
    cleaningAgentId?: SortOrder
  }

  export type SiteCleaningSessionSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumInterventionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionStatus | EnumInterventionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionStatusWithAggregatesFilter<$PrismaModel> | $Enums.InterventionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterventionStatusFilter<$PrismaModel>
    _max?: NestedEnumInterventionStatusFilter<$PrismaModel>
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type DeliveryNoteListRelationFilter = {
    every?: DeliveryNoteWhereInput
    some?: DeliveryNoteWhereInput
    none?: DeliveryNoteWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaundryManagerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryManagerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type LaundryManagerScalarRelationFilter = {
    is?: LaundryManagerWhereInput
    isNot?: LaundryManagerWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryManagerId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryManagerId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryManagerId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    receivedDate?: SortOrder
    deliveryDate?: SortOrder
    client?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryManagerId?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    total?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    receivedDate?: SortOrder
    deliveryDate?: SortOrder
    client?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryManagerId?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    receivedDate?: SortOrder
    deliveryDate?: SortOrder
    client?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryManagerId?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    total?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type TicketPhotoListRelationFilter = {
    every?: TicketPhotoWhereInput
    some?: TicketPhotoWhereInput
    none?: TicketPhotoWhereInput
  }

  export type TicketPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    propertyId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    propertyId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    propertyId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type PropertyPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type CleaningSessionScalarRelationFilter = {
    is?: CleaningSessionWhereInput
    isNot?: CleaningSessionWhereInput
  }

  export type CleaningPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    cleaningSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type CleaningPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    cleaningSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type CleaningPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    cleaningSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type MaintenanceSessionScalarRelationFilter = {
    is?: MaintenanceSessionWhereInput
    isNot?: MaintenanceSessionWhereInput
  }

  export type MaintenancePhotoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    maintenanceSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type MaintenancePhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    maintenanceSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type MaintenancePhotoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    maintenanceSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type SiteCleaningSessionScalarRelationFilter = {
    is?: SiteCleaningSessionWhereInput
    isNot?: SiteCleaningSessionWhereInput
  }

  export type SiteCleaningPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    siteCleaningSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type SiteCleaningPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    siteCleaningSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type SiteCleaningPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    siteCleaningSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketScalarRelationFilter = {
    is?: TicketWhereInput
    isNot?: TicketWhereInput
  }

  export type TicketPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    ticketId?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    ticketId?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    ticketId?: SortOrder
    createdAt?: SortOrder
  }

  export type CleaningChecklistCountOrderByAggregateInput = {
    id?: SortOrder
    item?: SortOrder
    completed?: SortOrder
    cleaningSessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningChecklistMaxOrderByAggregateInput = {
    id?: SortOrder
    item?: SortOrder
    completed?: SortOrder
    cleaningSessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningChecklistMinOrderByAggregateInput = {
    id?: SortOrder
    item?: SortOrder
    completed?: SortOrder
    cleaningSessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteCleaningChecklistCountOrderByAggregateInput = {
    id?: SortOrder
    item?: SortOrder
    completed?: SortOrder
    siteCleaningSessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteCleaningChecklistMaxOrderByAggregateInput = {
    id?: SortOrder
    item?: SortOrder
    completed?: SortOrder
    siteCleaningSessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteCleaningChecklistMinOrderByAggregateInput = {
    id?: SortOrder
    item?: SortOrder
    completed?: SortOrder
    siteCleaningSessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningPlanningCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    interventionSiteId?: SortOrder
    cleaningManagerId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningPlanningMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    interventionSiteId?: SortOrder
    cleaningManagerId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningPlanningMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    interventionSiteId?: SortOrder
    cleaningManagerId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DeliveryNoteCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    orderId?: SortOrder
    laundryManagerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    orderId?: SortOrder
    laundryManagerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryNoteMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    orderId?: SortOrder
    laundryManagerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type EnumServiceUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceUserStatus | EnumServiceUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceUserStatus[] | ListEnumServiceUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceUserStatus[] | ListEnumServiceUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceUserStatusFilter<$PrismaModel> | $Enums.ServiceUserStatus
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type ServiceUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
  }

  export type ServiceUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
  }

  export type ServiceUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
  }

  export type EnumServiceUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceUserStatus | EnumServiceUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceUserStatus[] | ListEnumServiceUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceUserStatus[] | ListEnumServiceUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceUserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceUserStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceUserStatusFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ConciergerieManagerCreateNestedManyWithoutUserInput = {
    create?: XOR<ConciergerieManagerCreateWithoutUserInput, ConciergerieManagerUncheckedCreateWithoutUserInput> | ConciergerieManagerCreateWithoutUserInput[] | ConciergerieManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConciergerieManagerCreateOrConnectWithoutUserInput | ConciergerieManagerCreateOrConnectWithoutUserInput[]
    createMany?: ConciergerieManagerCreateManyUserInputEnvelope
    connect?: ConciergerieManagerWhereUniqueInput | ConciergerieManagerWhereUniqueInput[]
  }

  export type CleaningManagerCreateNestedManyWithoutUserInput = {
    create?: XOR<CleaningManagerCreateWithoutUserInput, CleaningManagerUncheckedCreateWithoutUserInput> | CleaningManagerCreateWithoutUserInput[] | CleaningManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CleaningManagerCreateOrConnectWithoutUserInput | CleaningManagerCreateOrConnectWithoutUserInput[]
    createMany?: CleaningManagerCreateManyUserInputEnvelope
    connect?: CleaningManagerWhereUniqueInput | CleaningManagerWhereUniqueInput[]
  }

  export type LaundryManagerCreateNestedManyWithoutUserInput = {
    create?: XOR<LaundryManagerCreateWithoutUserInput, LaundryManagerUncheckedCreateWithoutUserInput> | LaundryManagerCreateWithoutUserInput[] | LaundryManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LaundryManagerCreateOrConnectWithoutUserInput | LaundryManagerCreateOrConnectWithoutUserInput[]
    createMany?: LaundryManagerCreateManyUserInputEnvelope
    connect?: LaundryManagerWhereUniqueInput | LaundryManagerWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ServiceUserCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceUserCreateWithoutUserInput, ServiceUserUncheckedCreateWithoutUserInput> | ServiceUserCreateWithoutUserInput[] | ServiceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceUserCreateOrConnectWithoutUserInput | ServiceUserCreateOrConnectWithoutUserInput[]
    createMany?: ServiceUserCreateManyUserInputEnvelope
    connect?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
  }

  export type AgentCreateNestedManyWithoutUserInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput> | AgentCreateWithoutUserInput[] | AgentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput | AgentCreateOrConnectWithoutUserInput[]
    createMany?: AgentCreateManyUserInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ConciergerieManagerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConciergerieManagerCreateWithoutUserInput, ConciergerieManagerUncheckedCreateWithoutUserInput> | ConciergerieManagerCreateWithoutUserInput[] | ConciergerieManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConciergerieManagerCreateOrConnectWithoutUserInput | ConciergerieManagerCreateOrConnectWithoutUserInput[]
    createMany?: ConciergerieManagerCreateManyUserInputEnvelope
    connect?: ConciergerieManagerWhereUniqueInput | ConciergerieManagerWhereUniqueInput[]
  }

  export type CleaningManagerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CleaningManagerCreateWithoutUserInput, CleaningManagerUncheckedCreateWithoutUserInput> | CleaningManagerCreateWithoutUserInput[] | CleaningManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CleaningManagerCreateOrConnectWithoutUserInput | CleaningManagerCreateOrConnectWithoutUserInput[]
    createMany?: CleaningManagerCreateManyUserInputEnvelope
    connect?: CleaningManagerWhereUniqueInput | CleaningManagerWhereUniqueInput[]
  }

  export type LaundryManagerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LaundryManagerCreateWithoutUserInput, LaundryManagerUncheckedCreateWithoutUserInput> | LaundryManagerCreateWithoutUserInput[] | LaundryManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LaundryManagerCreateOrConnectWithoutUserInput | LaundryManagerCreateOrConnectWithoutUserInput[]
    createMany?: LaundryManagerCreateManyUserInputEnvelope
    connect?: LaundryManagerWhereUniqueInput | LaundryManagerWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ServiceUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceUserCreateWithoutUserInput, ServiceUserUncheckedCreateWithoutUserInput> | ServiceUserCreateWithoutUserInput[] | ServiceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceUserCreateOrConnectWithoutUserInput | ServiceUserCreateOrConnectWithoutUserInput[]
    createMany?: ServiceUserCreateManyUserInputEnvelope
    connect?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput> | AgentCreateWithoutUserInput[] | AgentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput | AgentCreateOrConnectWithoutUserInput[]
    createMany?: AgentCreateManyUserInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ConciergerieManagerUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConciergerieManagerCreateWithoutUserInput, ConciergerieManagerUncheckedCreateWithoutUserInput> | ConciergerieManagerCreateWithoutUserInput[] | ConciergerieManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConciergerieManagerCreateOrConnectWithoutUserInput | ConciergerieManagerCreateOrConnectWithoutUserInput[]
    upsert?: ConciergerieManagerUpsertWithWhereUniqueWithoutUserInput | ConciergerieManagerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConciergerieManagerCreateManyUserInputEnvelope
    set?: ConciergerieManagerWhereUniqueInput | ConciergerieManagerWhereUniqueInput[]
    disconnect?: ConciergerieManagerWhereUniqueInput | ConciergerieManagerWhereUniqueInput[]
    delete?: ConciergerieManagerWhereUniqueInput | ConciergerieManagerWhereUniqueInput[]
    connect?: ConciergerieManagerWhereUniqueInput | ConciergerieManagerWhereUniqueInput[]
    update?: ConciergerieManagerUpdateWithWhereUniqueWithoutUserInput | ConciergerieManagerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConciergerieManagerUpdateManyWithWhereWithoutUserInput | ConciergerieManagerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConciergerieManagerScalarWhereInput | ConciergerieManagerScalarWhereInput[]
  }

  export type CleaningManagerUpdateManyWithoutUserNestedInput = {
    create?: XOR<CleaningManagerCreateWithoutUserInput, CleaningManagerUncheckedCreateWithoutUserInput> | CleaningManagerCreateWithoutUserInput[] | CleaningManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CleaningManagerCreateOrConnectWithoutUserInput | CleaningManagerCreateOrConnectWithoutUserInput[]
    upsert?: CleaningManagerUpsertWithWhereUniqueWithoutUserInput | CleaningManagerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CleaningManagerCreateManyUserInputEnvelope
    set?: CleaningManagerWhereUniqueInput | CleaningManagerWhereUniqueInput[]
    disconnect?: CleaningManagerWhereUniqueInput | CleaningManagerWhereUniqueInput[]
    delete?: CleaningManagerWhereUniqueInput | CleaningManagerWhereUniqueInput[]
    connect?: CleaningManagerWhereUniqueInput | CleaningManagerWhereUniqueInput[]
    update?: CleaningManagerUpdateWithWhereUniqueWithoutUserInput | CleaningManagerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CleaningManagerUpdateManyWithWhereWithoutUserInput | CleaningManagerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CleaningManagerScalarWhereInput | CleaningManagerScalarWhereInput[]
  }

  export type LaundryManagerUpdateManyWithoutUserNestedInput = {
    create?: XOR<LaundryManagerCreateWithoutUserInput, LaundryManagerUncheckedCreateWithoutUserInput> | LaundryManagerCreateWithoutUserInput[] | LaundryManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LaundryManagerCreateOrConnectWithoutUserInput | LaundryManagerCreateOrConnectWithoutUserInput[]
    upsert?: LaundryManagerUpsertWithWhereUniqueWithoutUserInput | LaundryManagerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LaundryManagerCreateManyUserInputEnvelope
    set?: LaundryManagerWhereUniqueInput | LaundryManagerWhereUniqueInput[]
    disconnect?: LaundryManagerWhereUniqueInput | LaundryManagerWhereUniqueInput[]
    delete?: LaundryManagerWhereUniqueInput | LaundryManagerWhereUniqueInput[]
    connect?: LaundryManagerWhereUniqueInput | LaundryManagerWhereUniqueInput[]
    update?: LaundryManagerUpdateWithWhereUniqueWithoutUserInput | LaundryManagerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LaundryManagerUpdateManyWithWhereWithoutUserInput | LaundryManagerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LaundryManagerScalarWhereInput | LaundryManagerScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ServiceUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceUserCreateWithoutUserInput, ServiceUserUncheckedCreateWithoutUserInput> | ServiceUserCreateWithoutUserInput[] | ServiceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceUserCreateOrConnectWithoutUserInput | ServiceUserCreateOrConnectWithoutUserInput[]
    upsert?: ServiceUserUpsertWithWhereUniqueWithoutUserInput | ServiceUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceUserCreateManyUserInputEnvelope
    set?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
    disconnect?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
    delete?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
    connect?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
    update?: ServiceUserUpdateWithWhereUniqueWithoutUserInput | ServiceUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceUserUpdateManyWithWhereWithoutUserInput | ServiceUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceUserScalarWhereInput | ServiceUserScalarWhereInput[]
  }

  export type AgentUpdateManyWithoutUserNestedInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput> | AgentCreateWithoutUserInput[] | AgentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput | AgentCreateOrConnectWithoutUserInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutUserInput | AgentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AgentCreateManyUserInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutUserInput | AgentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutUserInput | AgentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ConciergerieManagerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConciergerieManagerCreateWithoutUserInput, ConciergerieManagerUncheckedCreateWithoutUserInput> | ConciergerieManagerCreateWithoutUserInput[] | ConciergerieManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConciergerieManagerCreateOrConnectWithoutUserInput | ConciergerieManagerCreateOrConnectWithoutUserInput[]
    upsert?: ConciergerieManagerUpsertWithWhereUniqueWithoutUserInput | ConciergerieManagerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConciergerieManagerCreateManyUserInputEnvelope
    set?: ConciergerieManagerWhereUniqueInput | ConciergerieManagerWhereUniqueInput[]
    disconnect?: ConciergerieManagerWhereUniqueInput | ConciergerieManagerWhereUniqueInput[]
    delete?: ConciergerieManagerWhereUniqueInput | ConciergerieManagerWhereUniqueInput[]
    connect?: ConciergerieManagerWhereUniqueInput | ConciergerieManagerWhereUniqueInput[]
    update?: ConciergerieManagerUpdateWithWhereUniqueWithoutUserInput | ConciergerieManagerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConciergerieManagerUpdateManyWithWhereWithoutUserInput | ConciergerieManagerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConciergerieManagerScalarWhereInput | ConciergerieManagerScalarWhereInput[]
  }

  export type CleaningManagerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CleaningManagerCreateWithoutUserInput, CleaningManagerUncheckedCreateWithoutUserInput> | CleaningManagerCreateWithoutUserInput[] | CleaningManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CleaningManagerCreateOrConnectWithoutUserInput | CleaningManagerCreateOrConnectWithoutUserInput[]
    upsert?: CleaningManagerUpsertWithWhereUniqueWithoutUserInput | CleaningManagerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CleaningManagerCreateManyUserInputEnvelope
    set?: CleaningManagerWhereUniqueInput | CleaningManagerWhereUniqueInput[]
    disconnect?: CleaningManagerWhereUniqueInput | CleaningManagerWhereUniqueInput[]
    delete?: CleaningManagerWhereUniqueInput | CleaningManagerWhereUniqueInput[]
    connect?: CleaningManagerWhereUniqueInput | CleaningManagerWhereUniqueInput[]
    update?: CleaningManagerUpdateWithWhereUniqueWithoutUserInput | CleaningManagerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CleaningManagerUpdateManyWithWhereWithoutUserInput | CleaningManagerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CleaningManagerScalarWhereInput | CleaningManagerScalarWhereInput[]
  }

  export type LaundryManagerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LaundryManagerCreateWithoutUserInput, LaundryManagerUncheckedCreateWithoutUserInput> | LaundryManagerCreateWithoutUserInput[] | LaundryManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LaundryManagerCreateOrConnectWithoutUserInput | LaundryManagerCreateOrConnectWithoutUserInput[]
    upsert?: LaundryManagerUpsertWithWhereUniqueWithoutUserInput | LaundryManagerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LaundryManagerCreateManyUserInputEnvelope
    set?: LaundryManagerWhereUniqueInput | LaundryManagerWhereUniqueInput[]
    disconnect?: LaundryManagerWhereUniqueInput | LaundryManagerWhereUniqueInput[]
    delete?: LaundryManagerWhereUniqueInput | LaundryManagerWhereUniqueInput[]
    connect?: LaundryManagerWhereUniqueInput | LaundryManagerWhereUniqueInput[]
    update?: LaundryManagerUpdateWithWhereUniqueWithoutUserInput | LaundryManagerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LaundryManagerUpdateManyWithWhereWithoutUserInput | LaundryManagerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LaundryManagerScalarWhereInput | LaundryManagerScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ServiceUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceUserCreateWithoutUserInput, ServiceUserUncheckedCreateWithoutUserInput> | ServiceUserCreateWithoutUserInput[] | ServiceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceUserCreateOrConnectWithoutUserInput | ServiceUserCreateOrConnectWithoutUserInput[]
    upsert?: ServiceUserUpsertWithWhereUniqueWithoutUserInput | ServiceUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceUserCreateManyUserInputEnvelope
    set?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
    disconnect?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
    delete?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
    connect?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
    update?: ServiceUserUpdateWithWhereUniqueWithoutUserInput | ServiceUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceUserUpdateManyWithWhereWithoutUserInput | ServiceUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceUserScalarWhereInput | ServiceUserScalarWhereInput[]
  }

  export type AgentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput> | AgentCreateWithoutUserInput[] | AgentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput | AgentCreateOrConnectWithoutUserInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutUserInput | AgentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AgentCreateManyUserInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutUserInput | AgentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutUserInput | AgentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutConciergerieManagersInput = {
    create?: XOR<UserCreateWithoutConciergerieManagersInput, UserUncheckedCreateWithoutConciergerieManagersInput>
    connectOrCreate?: UserCreateOrConnectWithoutConciergerieManagersInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyCreateNestedManyWithoutConciergerieManagerInput = {
    create?: XOR<PropertyCreateWithoutConciergerieManagerInput, PropertyUncheckedCreateWithoutConciergerieManagerInput> | PropertyCreateWithoutConciergerieManagerInput[] | PropertyUncheckedCreateWithoutConciergerieManagerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutConciergerieManagerInput | PropertyCreateOrConnectWithoutConciergerieManagerInput[]
    createMany?: PropertyCreateManyConciergerieManagerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type AgentCreateNestedManyWithoutConciergerieManagerInput = {
    create?: XOR<AgentCreateWithoutConciergerieManagerInput, AgentUncheckedCreateWithoutConciergerieManagerInput> | AgentCreateWithoutConciergerieManagerInput[] | AgentUncheckedCreateWithoutConciergerieManagerInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutConciergerieManagerInput | AgentCreateOrConnectWithoutConciergerieManagerInput[]
    createMany?: AgentCreateManyConciergerieManagerInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutConciergerieManagerInput = {
    create?: XOR<TaskCreateWithoutConciergerieManagerInput, TaskUncheckedCreateWithoutConciergerieManagerInput> | TaskCreateWithoutConciergerieManagerInput[] | TaskUncheckedCreateWithoutConciergerieManagerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutConciergerieManagerInput | TaskCreateOrConnectWithoutConciergerieManagerInput[]
    createMany?: TaskCreateManyConciergerieManagerInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutConciergerieManagerInput = {
    create?: XOR<PropertyCreateWithoutConciergerieManagerInput, PropertyUncheckedCreateWithoutConciergerieManagerInput> | PropertyCreateWithoutConciergerieManagerInput[] | PropertyUncheckedCreateWithoutConciergerieManagerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutConciergerieManagerInput | PropertyCreateOrConnectWithoutConciergerieManagerInput[]
    createMany?: PropertyCreateManyConciergerieManagerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedManyWithoutConciergerieManagerInput = {
    create?: XOR<AgentCreateWithoutConciergerieManagerInput, AgentUncheckedCreateWithoutConciergerieManagerInput> | AgentCreateWithoutConciergerieManagerInput[] | AgentUncheckedCreateWithoutConciergerieManagerInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutConciergerieManagerInput | AgentCreateOrConnectWithoutConciergerieManagerInput[]
    createMany?: AgentCreateManyConciergerieManagerInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutConciergerieManagerInput = {
    create?: XOR<TaskCreateWithoutConciergerieManagerInput, TaskUncheckedCreateWithoutConciergerieManagerInput> | TaskCreateWithoutConciergerieManagerInput[] | TaskUncheckedCreateWithoutConciergerieManagerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutConciergerieManagerInput | TaskCreateOrConnectWithoutConciergerieManagerInput[]
    createMany?: TaskCreateManyConciergerieManagerInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutConciergerieManagersNestedInput = {
    create?: XOR<UserCreateWithoutConciergerieManagersInput, UserUncheckedCreateWithoutConciergerieManagersInput>
    connectOrCreate?: UserCreateOrConnectWithoutConciergerieManagersInput
    upsert?: UserUpsertWithoutConciergerieManagersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConciergerieManagersInput, UserUpdateWithoutConciergerieManagersInput>, UserUncheckedUpdateWithoutConciergerieManagersInput>
  }

  export type PropertyUpdateManyWithoutConciergerieManagerNestedInput = {
    create?: XOR<PropertyCreateWithoutConciergerieManagerInput, PropertyUncheckedCreateWithoutConciergerieManagerInput> | PropertyCreateWithoutConciergerieManagerInput[] | PropertyUncheckedCreateWithoutConciergerieManagerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutConciergerieManagerInput | PropertyCreateOrConnectWithoutConciergerieManagerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutConciergerieManagerInput | PropertyUpsertWithWhereUniqueWithoutConciergerieManagerInput[]
    createMany?: PropertyCreateManyConciergerieManagerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutConciergerieManagerInput | PropertyUpdateWithWhereUniqueWithoutConciergerieManagerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutConciergerieManagerInput | PropertyUpdateManyWithWhereWithoutConciergerieManagerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type AgentUpdateManyWithoutConciergerieManagerNestedInput = {
    create?: XOR<AgentCreateWithoutConciergerieManagerInput, AgentUncheckedCreateWithoutConciergerieManagerInput> | AgentCreateWithoutConciergerieManagerInput[] | AgentUncheckedCreateWithoutConciergerieManagerInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutConciergerieManagerInput | AgentCreateOrConnectWithoutConciergerieManagerInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutConciergerieManagerInput | AgentUpsertWithWhereUniqueWithoutConciergerieManagerInput[]
    createMany?: AgentCreateManyConciergerieManagerInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutConciergerieManagerInput | AgentUpdateWithWhereUniqueWithoutConciergerieManagerInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutConciergerieManagerInput | AgentUpdateManyWithWhereWithoutConciergerieManagerInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutConciergerieManagerNestedInput = {
    create?: XOR<TaskCreateWithoutConciergerieManagerInput, TaskUncheckedCreateWithoutConciergerieManagerInput> | TaskCreateWithoutConciergerieManagerInput[] | TaskUncheckedCreateWithoutConciergerieManagerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutConciergerieManagerInput | TaskCreateOrConnectWithoutConciergerieManagerInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutConciergerieManagerInput | TaskUpsertWithWhereUniqueWithoutConciergerieManagerInput[]
    createMany?: TaskCreateManyConciergerieManagerInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutConciergerieManagerInput | TaskUpdateWithWhereUniqueWithoutConciergerieManagerInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutConciergerieManagerInput | TaskUpdateManyWithWhereWithoutConciergerieManagerInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutConciergerieManagerNestedInput = {
    create?: XOR<PropertyCreateWithoutConciergerieManagerInput, PropertyUncheckedCreateWithoutConciergerieManagerInput> | PropertyCreateWithoutConciergerieManagerInput[] | PropertyUncheckedCreateWithoutConciergerieManagerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutConciergerieManagerInput | PropertyCreateOrConnectWithoutConciergerieManagerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutConciergerieManagerInput | PropertyUpsertWithWhereUniqueWithoutConciergerieManagerInput[]
    createMany?: PropertyCreateManyConciergerieManagerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutConciergerieManagerInput | PropertyUpdateWithWhereUniqueWithoutConciergerieManagerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutConciergerieManagerInput | PropertyUpdateManyWithWhereWithoutConciergerieManagerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type AgentUncheckedUpdateManyWithoutConciergerieManagerNestedInput = {
    create?: XOR<AgentCreateWithoutConciergerieManagerInput, AgentUncheckedCreateWithoutConciergerieManagerInput> | AgentCreateWithoutConciergerieManagerInput[] | AgentUncheckedCreateWithoutConciergerieManagerInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutConciergerieManagerInput | AgentCreateOrConnectWithoutConciergerieManagerInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutConciergerieManagerInput | AgentUpsertWithWhereUniqueWithoutConciergerieManagerInput[]
    createMany?: AgentCreateManyConciergerieManagerInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutConciergerieManagerInput | AgentUpdateWithWhereUniqueWithoutConciergerieManagerInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutConciergerieManagerInput | AgentUpdateManyWithWhereWithoutConciergerieManagerInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutConciergerieManagerNestedInput = {
    create?: XOR<TaskCreateWithoutConciergerieManagerInput, TaskUncheckedCreateWithoutConciergerieManagerInput> | TaskCreateWithoutConciergerieManagerInput[] | TaskUncheckedCreateWithoutConciergerieManagerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutConciergerieManagerInput | TaskCreateOrConnectWithoutConciergerieManagerInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutConciergerieManagerInput | TaskUpsertWithWhereUniqueWithoutConciergerieManagerInput[]
    createMany?: TaskCreateManyConciergerieManagerInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutConciergerieManagerInput | TaskUpdateWithWhereUniqueWithoutConciergerieManagerInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutConciergerieManagerInput | TaskUpdateManyWithWhereWithoutConciergerieManagerInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ConciergerieManagerCreateNestedOneWithoutTasksInput = {
    create?: XOR<ConciergerieManagerCreateWithoutTasksInput, ConciergerieManagerUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ConciergerieManagerCreateOrConnectWithoutTasksInput
    connect?: ConciergerieManagerWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutTasksInput = {
    create?: XOR<AgentCreateWithoutTasksInput, AgentUncheckedCreateWithoutTasksInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTasksInput
    connect?: AgentWhereUniqueInput
  }

  export type ConciergerieManagerUpdateOneWithoutTasksNestedInput = {
    create?: XOR<ConciergerieManagerCreateWithoutTasksInput, ConciergerieManagerUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ConciergerieManagerCreateOrConnectWithoutTasksInput
    upsert?: ConciergerieManagerUpsertWithoutTasksInput
    disconnect?: ConciergerieManagerWhereInput | boolean
    delete?: ConciergerieManagerWhereInput | boolean
    connect?: ConciergerieManagerWhereUniqueInput
    update?: XOR<XOR<ConciergerieManagerUpdateToOneWithWhereWithoutTasksInput, ConciergerieManagerUpdateWithoutTasksInput>, ConciergerieManagerUncheckedUpdateWithoutTasksInput>
  }

  export type AgentUpdateOneWithoutTasksNestedInput = {
    create?: XOR<AgentCreateWithoutTasksInput, AgentUncheckedCreateWithoutTasksInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTasksInput
    upsert?: AgentUpsertWithoutTasksInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutTasksInput, AgentUpdateWithoutTasksInput>, AgentUncheckedUpdateWithoutTasksInput>
  }

  export type ConciergerieManagerCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<ConciergerieManagerCreateWithoutPropertiesInput, ConciergerieManagerUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: ConciergerieManagerCreateOrConnectWithoutPropertiesInput
    connect?: ConciergerieManagerWhereUniqueInput
  }

  export type CleaningSessionCreateNestedManyWithoutPropertyInput = {
    create?: XOR<CleaningSessionCreateWithoutPropertyInput, CleaningSessionUncheckedCreateWithoutPropertyInput> | CleaningSessionCreateWithoutPropertyInput[] | CleaningSessionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutPropertyInput | CleaningSessionCreateOrConnectWithoutPropertyInput[]
    createMany?: CleaningSessionCreateManyPropertyInputEnvelope
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
  }

  export type MaintenanceSessionCreateNestedManyWithoutPropertyInput = {
    create?: XOR<MaintenanceSessionCreateWithoutPropertyInput, MaintenanceSessionUncheckedCreateWithoutPropertyInput> | MaintenanceSessionCreateWithoutPropertyInput[] | MaintenanceSessionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutPropertyInput | MaintenanceSessionCreateOrConnectWithoutPropertyInput[]
    createMany?: MaintenanceSessionCreateManyPropertyInputEnvelope
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ReservationCreateWithoutPropertyInput, ReservationUncheckedCreateWithoutPropertyInput> | ReservationCreateWithoutPropertyInput[] | ReservationUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPropertyInput | ReservationCreateOrConnectWithoutPropertyInput[]
    createMany?: ReservationCreateManyPropertyInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PaymentCreateWithoutPropertyInput, PaymentUncheckedCreateWithoutPropertyInput> | PaymentCreateWithoutPropertyInput[] | PaymentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPropertyInput | PaymentCreateOrConnectWithoutPropertyInput[]
    createMany?: PaymentCreateManyPropertyInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutPropertyInput = {
    create?: XOR<TicketCreateWithoutPropertyInput, TicketUncheckedCreateWithoutPropertyInput> | TicketCreateWithoutPropertyInput[] | TicketUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutPropertyInput | TicketCreateOrConnectWithoutPropertyInput[]
    createMany?: TicketCreateManyPropertyInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type PropertyPhotoCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyPhotoCreateWithoutPropertyInput, PropertyPhotoUncheckedCreateWithoutPropertyInput> | PropertyPhotoCreateWithoutPropertyInput[] | PropertyPhotoUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyPhotoCreateOrConnectWithoutPropertyInput | PropertyPhotoCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyPhotoCreateManyPropertyInputEnvelope
    connect?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
  }

  export type CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<CleaningSessionCreateWithoutPropertyInput, CleaningSessionUncheckedCreateWithoutPropertyInput> | CleaningSessionCreateWithoutPropertyInput[] | CleaningSessionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutPropertyInput | CleaningSessionCreateOrConnectWithoutPropertyInput[]
    createMany?: CleaningSessionCreateManyPropertyInputEnvelope
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
  }

  export type MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<MaintenanceSessionCreateWithoutPropertyInput, MaintenanceSessionUncheckedCreateWithoutPropertyInput> | MaintenanceSessionCreateWithoutPropertyInput[] | MaintenanceSessionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutPropertyInput | MaintenanceSessionCreateOrConnectWithoutPropertyInput[]
    createMany?: MaintenanceSessionCreateManyPropertyInputEnvelope
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ReservationCreateWithoutPropertyInput, ReservationUncheckedCreateWithoutPropertyInput> | ReservationCreateWithoutPropertyInput[] | ReservationUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPropertyInput | ReservationCreateOrConnectWithoutPropertyInput[]
    createMany?: ReservationCreateManyPropertyInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PaymentCreateWithoutPropertyInput, PaymentUncheckedCreateWithoutPropertyInput> | PaymentCreateWithoutPropertyInput[] | PaymentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPropertyInput | PaymentCreateOrConnectWithoutPropertyInput[]
    createMany?: PaymentCreateManyPropertyInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<TicketCreateWithoutPropertyInput, TicketUncheckedCreateWithoutPropertyInput> | TicketCreateWithoutPropertyInput[] | TicketUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutPropertyInput | TicketCreateOrConnectWithoutPropertyInput[]
    createMany?: TicketCreateManyPropertyInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyPhotoCreateWithoutPropertyInput, PropertyPhotoUncheckedCreateWithoutPropertyInput> | PropertyPhotoCreateWithoutPropertyInput[] | PropertyPhotoUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyPhotoCreateOrConnectWithoutPropertyInput | PropertyPhotoCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyPhotoCreateManyPropertyInputEnvelope
    connect?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
  }

  export type EnumPropertyStatusFieldUpdateOperationsInput = {
    set?: $Enums.PropertyStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ConciergerieManagerUpdateOneRequiredWithoutPropertiesNestedInput = {
    create?: XOR<ConciergerieManagerCreateWithoutPropertiesInput, ConciergerieManagerUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: ConciergerieManagerCreateOrConnectWithoutPropertiesInput
    upsert?: ConciergerieManagerUpsertWithoutPropertiesInput
    connect?: ConciergerieManagerWhereUniqueInput
    update?: XOR<XOR<ConciergerieManagerUpdateToOneWithWhereWithoutPropertiesInput, ConciergerieManagerUpdateWithoutPropertiesInput>, ConciergerieManagerUncheckedUpdateWithoutPropertiesInput>
  }

  export type CleaningSessionUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<CleaningSessionCreateWithoutPropertyInput, CleaningSessionUncheckedCreateWithoutPropertyInput> | CleaningSessionCreateWithoutPropertyInput[] | CleaningSessionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutPropertyInput | CleaningSessionCreateOrConnectWithoutPropertyInput[]
    upsert?: CleaningSessionUpsertWithWhereUniqueWithoutPropertyInput | CleaningSessionUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: CleaningSessionCreateManyPropertyInputEnvelope
    set?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    disconnect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    delete?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    update?: CleaningSessionUpdateWithWhereUniqueWithoutPropertyInput | CleaningSessionUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: CleaningSessionUpdateManyWithWhereWithoutPropertyInput | CleaningSessionUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: CleaningSessionScalarWhereInput | CleaningSessionScalarWhereInput[]
  }

  export type MaintenanceSessionUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<MaintenanceSessionCreateWithoutPropertyInput, MaintenanceSessionUncheckedCreateWithoutPropertyInput> | MaintenanceSessionCreateWithoutPropertyInput[] | MaintenanceSessionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutPropertyInput | MaintenanceSessionCreateOrConnectWithoutPropertyInput[]
    upsert?: MaintenanceSessionUpsertWithWhereUniqueWithoutPropertyInput | MaintenanceSessionUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: MaintenanceSessionCreateManyPropertyInputEnvelope
    set?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    disconnect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    delete?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    update?: MaintenanceSessionUpdateWithWhereUniqueWithoutPropertyInput | MaintenanceSessionUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: MaintenanceSessionUpdateManyWithWhereWithoutPropertyInput | MaintenanceSessionUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: MaintenanceSessionScalarWhereInput | MaintenanceSessionScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ReservationCreateWithoutPropertyInput, ReservationUncheckedCreateWithoutPropertyInput> | ReservationCreateWithoutPropertyInput[] | ReservationUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPropertyInput | ReservationCreateOrConnectWithoutPropertyInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutPropertyInput | ReservationUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ReservationCreateManyPropertyInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutPropertyInput | ReservationUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutPropertyInput | ReservationUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PaymentCreateWithoutPropertyInput, PaymentUncheckedCreateWithoutPropertyInput> | PaymentCreateWithoutPropertyInput[] | PaymentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPropertyInput | PaymentCreateOrConnectWithoutPropertyInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPropertyInput | PaymentUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PaymentCreateManyPropertyInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPropertyInput | PaymentUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPropertyInput | PaymentUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<TicketCreateWithoutPropertyInput, TicketUncheckedCreateWithoutPropertyInput> | TicketCreateWithoutPropertyInput[] | TicketUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutPropertyInput | TicketCreateOrConnectWithoutPropertyInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutPropertyInput | TicketUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: TicketCreateManyPropertyInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutPropertyInput | TicketUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutPropertyInput | TicketUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type PropertyPhotoUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyPhotoCreateWithoutPropertyInput, PropertyPhotoUncheckedCreateWithoutPropertyInput> | PropertyPhotoCreateWithoutPropertyInput[] | PropertyPhotoUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyPhotoCreateOrConnectWithoutPropertyInput | PropertyPhotoCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyPhotoUpsertWithWhereUniqueWithoutPropertyInput | PropertyPhotoUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyPhotoCreateManyPropertyInputEnvelope
    set?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
    disconnect?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
    delete?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
    connect?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
    update?: PropertyPhotoUpdateWithWhereUniqueWithoutPropertyInput | PropertyPhotoUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyPhotoUpdateManyWithWhereWithoutPropertyInput | PropertyPhotoUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyPhotoScalarWhereInput | PropertyPhotoScalarWhereInput[]
  }

  export type CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<CleaningSessionCreateWithoutPropertyInput, CleaningSessionUncheckedCreateWithoutPropertyInput> | CleaningSessionCreateWithoutPropertyInput[] | CleaningSessionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutPropertyInput | CleaningSessionCreateOrConnectWithoutPropertyInput[]
    upsert?: CleaningSessionUpsertWithWhereUniqueWithoutPropertyInput | CleaningSessionUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: CleaningSessionCreateManyPropertyInputEnvelope
    set?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    disconnect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    delete?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    update?: CleaningSessionUpdateWithWhereUniqueWithoutPropertyInput | CleaningSessionUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: CleaningSessionUpdateManyWithWhereWithoutPropertyInput | CleaningSessionUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: CleaningSessionScalarWhereInput | CleaningSessionScalarWhereInput[]
  }

  export type MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<MaintenanceSessionCreateWithoutPropertyInput, MaintenanceSessionUncheckedCreateWithoutPropertyInput> | MaintenanceSessionCreateWithoutPropertyInput[] | MaintenanceSessionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutPropertyInput | MaintenanceSessionCreateOrConnectWithoutPropertyInput[]
    upsert?: MaintenanceSessionUpsertWithWhereUniqueWithoutPropertyInput | MaintenanceSessionUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: MaintenanceSessionCreateManyPropertyInputEnvelope
    set?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    disconnect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    delete?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    update?: MaintenanceSessionUpdateWithWhereUniqueWithoutPropertyInput | MaintenanceSessionUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: MaintenanceSessionUpdateManyWithWhereWithoutPropertyInput | MaintenanceSessionUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: MaintenanceSessionScalarWhereInput | MaintenanceSessionScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ReservationCreateWithoutPropertyInput, ReservationUncheckedCreateWithoutPropertyInput> | ReservationCreateWithoutPropertyInput[] | ReservationUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPropertyInput | ReservationCreateOrConnectWithoutPropertyInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutPropertyInput | ReservationUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ReservationCreateManyPropertyInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutPropertyInput | ReservationUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutPropertyInput | ReservationUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PaymentCreateWithoutPropertyInput, PaymentUncheckedCreateWithoutPropertyInput> | PaymentCreateWithoutPropertyInput[] | PaymentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPropertyInput | PaymentCreateOrConnectWithoutPropertyInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPropertyInput | PaymentUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PaymentCreateManyPropertyInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPropertyInput | PaymentUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPropertyInput | PaymentUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<TicketCreateWithoutPropertyInput, TicketUncheckedCreateWithoutPropertyInput> | TicketCreateWithoutPropertyInput[] | TicketUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutPropertyInput | TicketCreateOrConnectWithoutPropertyInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutPropertyInput | TicketUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: TicketCreateManyPropertyInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutPropertyInput | TicketUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutPropertyInput | TicketUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyPhotoCreateWithoutPropertyInput, PropertyPhotoUncheckedCreateWithoutPropertyInput> | PropertyPhotoCreateWithoutPropertyInput[] | PropertyPhotoUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyPhotoCreateOrConnectWithoutPropertyInput | PropertyPhotoCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyPhotoUpsertWithWhereUniqueWithoutPropertyInput | PropertyPhotoUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyPhotoCreateManyPropertyInputEnvelope
    set?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
    disconnect?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
    delete?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
    connect?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
    update?: PropertyPhotoUpdateWithWhereUniqueWithoutPropertyInput | PropertyPhotoUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyPhotoUpdateManyWithWhereWithoutPropertyInput | PropertyPhotoUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyPhotoScalarWhereInput | PropertyPhotoScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutReservationsInput = {
    create?: XOR<PropertyCreateWithoutReservationsInput, PropertyUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutReservationsInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<PropertyCreateWithoutReservationsInput, PropertyUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutReservationsInput
    upsert?: PropertyUpsertWithoutReservationsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutReservationsInput, PropertyUpdateWithoutReservationsInput>, PropertyUncheckedUpdateWithoutReservationsInput>
  }

  export type MaintenanceSessionCreateNestedManyWithoutAgentInput = {
    create?: XOR<MaintenanceSessionCreateWithoutAgentInput, MaintenanceSessionUncheckedCreateWithoutAgentInput> | MaintenanceSessionCreateWithoutAgentInput[] | MaintenanceSessionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutAgentInput | MaintenanceSessionCreateOrConnectWithoutAgentInput[]
    createMany?: MaintenanceSessionCreateManyAgentInputEnvelope
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
  }

  export type CleaningSessionCreateNestedManyWithoutAgentInput = {
    create?: XOR<CleaningSessionCreateWithoutAgentInput, CleaningSessionUncheckedCreateWithoutAgentInput> | CleaningSessionCreateWithoutAgentInput[] | CleaningSessionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutAgentInput | CleaningSessionCreateOrConnectWithoutAgentInput[]
    createMany?: CleaningSessionCreateManyAgentInputEnvelope
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
  }

  export type ConciergerieManagerCreateNestedOneWithoutAgentsInput = {
    create?: XOR<ConciergerieManagerCreateWithoutAgentsInput, ConciergerieManagerUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: ConciergerieManagerCreateOrConnectWithoutAgentsInput
    connect?: ConciergerieManagerWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutAgentInput = {
    create?: XOR<TaskCreateWithoutAgentInput, TaskUncheckedCreateWithoutAgentInput> | TaskCreateWithoutAgentInput[] | TaskUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAgentInput | TaskCreateOrConnectWithoutAgentInput[]
    createMany?: TaskCreateManyAgentInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutAgentInput = {
    create?: XOR<TicketCreateWithoutAgentInput, TicketUncheckedCreateWithoutAgentInput> | TicketCreateWithoutAgentInput[] | TicketUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAgentInput | TicketCreateOrConnectWithoutAgentInput[]
    createMany?: TicketCreateManyAgentInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type CleaningPlanningCreateNestedManyWithoutAgentInput = {
    create?: XOR<CleaningPlanningCreateWithoutAgentInput, CleaningPlanningUncheckedCreateWithoutAgentInput> | CleaningPlanningCreateWithoutAgentInput[] | CleaningPlanningUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: CleaningPlanningCreateOrConnectWithoutAgentInput | CleaningPlanningCreateOrConnectWithoutAgentInput[]
    createMany?: CleaningPlanningCreateManyAgentInputEnvelope
    connect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutAgentInput = {
    create?: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentInput
    connect?: UserWhereUniqueInput
  }

  export type SiteCleaningSessionCreateNestedManyWithoutCleaningAgentInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutCleaningAgentInput, SiteCleaningSessionUncheckedCreateWithoutCleaningAgentInput> | SiteCleaningSessionCreateWithoutCleaningAgentInput[] | SiteCleaningSessionUncheckedCreateWithoutCleaningAgentInput[]
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutCleaningAgentInput | SiteCleaningSessionCreateOrConnectWithoutCleaningAgentInput[]
    createMany?: SiteCleaningSessionCreateManyCleaningAgentInputEnvelope
    connect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
  }

  export type CleaningManagerCreateNestedOneWithoutCleaningAgentsInput = {
    create?: XOR<CleaningManagerCreateWithoutCleaningAgentsInput, CleaningManagerUncheckedCreateWithoutCleaningAgentsInput>
    connectOrCreate?: CleaningManagerCreateOrConnectWithoutCleaningAgentsInput
    connect?: CleaningManagerWhereUniqueInput
  }

  export type MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<MaintenanceSessionCreateWithoutAgentInput, MaintenanceSessionUncheckedCreateWithoutAgentInput> | MaintenanceSessionCreateWithoutAgentInput[] | MaintenanceSessionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutAgentInput | MaintenanceSessionCreateOrConnectWithoutAgentInput[]
    createMany?: MaintenanceSessionCreateManyAgentInputEnvelope
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
  }

  export type CleaningSessionUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<CleaningSessionCreateWithoutAgentInput, CleaningSessionUncheckedCreateWithoutAgentInput> | CleaningSessionCreateWithoutAgentInput[] | CleaningSessionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutAgentInput | CleaningSessionCreateOrConnectWithoutAgentInput[]
    createMany?: CleaningSessionCreateManyAgentInputEnvelope
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<TaskCreateWithoutAgentInput, TaskUncheckedCreateWithoutAgentInput> | TaskCreateWithoutAgentInput[] | TaskUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAgentInput | TaskCreateOrConnectWithoutAgentInput[]
    createMany?: TaskCreateManyAgentInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<TicketCreateWithoutAgentInput, TicketUncheckedCreateWithoutAgentInput> | TicketCreateWithoutAgentInput[] | TicketUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAgentInput | TicketCreateOrConnectWithoutAgentInput[]
    createMany?: TicketCreateManyAgentInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type CleaningPlanningUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<CleaningPlanningCreateWithoutAgentInput, CleaningPlanningUncheckedCreateWithoutAgentInput> | CleaningPlanningCreateWithoutAgentInput[] | CleaningPlanningUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: CleaningPlanningCreateOrConnectWithoutAgentInput | CleaningPlanningCreateOrConnectWithoutAgentInput[]
    createMany?: CleaningPlanningCreateManyAgentInputEnvelope
    connect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
  }

  export type SiteCleaningSessionUncheckedCreateNestedManyWithoutCleaningAgentInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutCleaningAgentInput, SiteCleaningSessionUncheckedCreateWithoutCleaningAgentInput> | SiteCleaningSessionCreateWithoutCleaningAgentInput[] | SiteCleaningSessionUncheckedCreateWithoutCleaningAgentInput[]
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutCleaningAgentInput | SiteCleaningSessionCreateOrConnectWithoutCleaningAgentInput[]
    createMany?: SiteCleaningSessionCreateManyCleaningAgentInputEnvelope
    connect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
  }

  export type EnumAgentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AgentType
  }

  export type MaintenanceSessionUpdateManyWithoutAgentNestedInput = {
    create?: XOR<MaintenanceSessionCreateWithoutAgentInput, MaintenanceSessionUncheckedCreateWithoutAgentInput> | MaintenanceSessionCreateWithoutAgentInput[] | MaintenanceSessionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutAgentInput | MaintenanceSessionCreateOrConnectWithoutAgentInput[]
    upsert?: MaintenanceSessionUpsertWithWhereUniqueWithoutAgentInput | MaintenanceSessionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: MaintenanceSessionCreateManyAgentInputEnvelope
    set?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    disconnect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    delete?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    update?: MaintenanceSessionUpdateWithWhereUniqueWithoutAgentInput | MaintenanceSessionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: MaintenanceSessionUpdateManyWithWhereWithoutAgentInput | MaintenanceSessionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: MaintenanceSessionScalarWhereInput | MaintenanceSessionScalarWhereInput[]
  }

  export type CleaningSessionUpdateManyWithoutAgentNestedInput = {
    create?: XOR<CleaningSessionCreateWithoutAgentInput, CleaningSessionUncheckedCreateWithoutAgentInput> | CleaningSessionCreateWithoutAgentInput[] | CleaningSessionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutAgentInput | CleaningSessionCreateOrConnectWithoutAgentInput[]
    upsert?: CleaningSessionUpsertWithWhereUniqueWithoutAgentInput | CleaningSessionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: CleaningSessionCreateManyAgentInputEnvelope
    set?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    disconnect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    delete?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    update?: CleaningSessionUpdateWithWhereUniqueWithoutAgentInput | CleaningSessionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: CleaningSessionUpdateManyWithWhereWithoutAgentInput | CleaningSessionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: CleaningSessionScalarWhereInput | CleaningSessionScalarWhereInput[]
  }

  export type ConciergerieManagerUpdateOneRequiredWithoutAgentsNestedInput = {
    create?: XOR<ConciergerieManagerCreateWithoutAgentsInput, ConciergerieManagerUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: ConciergerieManagerCreateOrConnectWithoutAgentsInput
    upsert?: ConciergerieManagerUpsertWithoutAgentsInput
    connect?: ConciergerieManagerWhereUniqueInput
    update?: XOR<XOR<ConciergerieManagerUpdateToOneWithWhereWithoutAgentsInput, ConciergerieManagerUpdateWithoutAgentsInput>, ConciergerieManagerUncheckedUpdateWithoutAgentsInput>
  }

  export type TaskUpdateManyWithoutAgentNestedInput = {
    create?: XOR<TaskCreateWithoutAgentInput, TaskUncheckedCreateWithoutAgentInput> | TaskCreateWithoutAgentInput[] | TaskUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAgentInput | TaskCreateOrConnectWithoutAgentInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAgentInput | TaskUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: TaskCreateManyAgentInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAgentInput | TaskUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAgentInput | TaskUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutAgentNestedInput = {
    create?: XOR<TicketCreateWithoutAgentInput, TicketUncheckedCreateWithoutAgentInput> | TicketCreateWithoutAgentInput[] | TicketUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAgentInput | TicketCreateOrConnectWithoutAgentInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAgentInput | TicketUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: TicketCreateManyAgentInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAgentInput | TicketUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAgentInput | TicketUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CleaningPlanningUpdateManyWithoutAgentNestedInput = {
    create?: XOR<CleaningPlanningCreateWithoutAgentInput, CleaningPlanningUncheckedCreateWithoutAgentInput> | CleaningPlanningCreateWithoutAgentInput[] | CleaningPlanningUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: CleaningPlanningCreateOrConnectWithoutAgentInput | CleaningPlanningCreateOrConnectWithoutAgentInput[]
    upsert?: CleaningPlanningUpsertWithWhereUniqueWithoutAgentInput | CleaningPlanningUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: CleaningPlanningCreateManyAgentInputEnvelope
    set?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    disconnect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    delete?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    connect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    update?: CleaningPlanningUpdateWithWhereUniqueWithoutAgentInput | CleaningPlanningUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: CleaningPlanningUpdateManyWithWhereWithoutAgentInput | CleaningPlanningUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: CleaningPlanningScalarWhereInput | CleaningPlanningScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutAgentNestedInput = {
    create?: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentInput
    upsert?: UserUpsertWithoutAgentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgentInput, UserUpdateWithoutAgentInput>, UserUncheckedUpdateWithoutAgentInput>
  }

  export type SiteCleaningSessionUpdateManyWithoutCleaningAgentNestedInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutCleaningAgentInput, SiteCleaningSessionUncheckedCreateWithoutCleaningAgentInput> | SiteCleaningSessionCreateWithoutCleaningAgentInput[] | SiteCleaningSessionUncheckedCreateWithoutCleaningAgentInput[]
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutCleaningAgentInput | SiteCleaningSessionCreateOrConnectWithoutCleaningAgentInput[]
    upsert?: SiteCleaningSessionUpsertWithWhereUniqueWithoutCleaningAgentInput | SiteCleaningSessionUpsertWithWhereUniqueWithoutCleaningAgentInput[]
    createMany?: SiteCleaningSessionCreateManyCleaningAgentInputEnvelope
    set?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    disconnect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    delete?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    connect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    update?: SiteCleaningSessionUpdateWithWhereUniqueWithoutCleaningAgentInput | SiteCleaningSessionUpdateWithWhereUniqueWithoutCleaningAgentInput[]
    updateMany?: SiteCleaningSessionUpdateManyWithWhereWithoutCleaningAgentInput | SiteCleaningSessionUpdateManyWithWhereWithoutCleaningAgentInput[]
    deleteMany?: SiteCleaningSessionScalarWhereInput | SiteCleaningSessionScalarWhereInput[]
  }

  export type CleaningManagerUpdateOneWithoutCleaningAgentsNestedInput = {
    create?: XOR<CleaningManagerCreateWithoutCleaningAgentsInput, CleaningManagerUncheckedCreateWithoutCleaningAgentsInput>
    connectOrCreate?: CleaningManagerCreateOrConnectWithoutCleaningAgentsInput
    upsert?: CleaningManagerUpsertWithoutCleaningAgentsInput
    disconnect?: CleaningManagerWhereInput | boolean
    delete?: CleaningManagerWhereInput | boolean
    connect?: CleaningManagerWhereUniqueInput
    update?: XOR<XOR<CleaningManagerUpdateToOneWithWhereWithoutCleaningAgentsInput, CleaningManagerUpdateWithoutCleaningAgentsInput>, CleaningManagerUncheckedUpdateWithoutCleaningAgentsInput>
  }

  export type MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<MaintenanceSessionCreateWithoutAgentInput, MaintenanceSessionUncheckedCreateWithoutAgentInput> | MaintenanceSessionCreateWithoutAgentInput[] | MaintenanceSessionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutAgentInput | MaintenanceSessionCreateOrConnectWithoutAgentInput[]
    upsert?: MaintenanceSessionUpsertWithWhereUniqueWithoutAgentInput | MaintenanceSessionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: MaintenanceSessionCreateManyAgentInputEnvelope
    set?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    disconnect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    delete?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    update?: MaintenanceSessionUpdateWithWhereUniqueWithoutAgentInput | MaintenanceSessionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: MaintenanceSessionUpdateManyWithWhereWithoutAgentInput | MaintenanceSessionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: MaintenanceSessionScalarWhereInput | MaintenanceSessionScalarWhereInput[]
  }

  export type CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<CleaningSessionCreateWithoutAgentInput, CleaningSessionUncheckedCreateWithoutAgentInput> | CleaningSessionCreateWithoutAgentInput[] | CleaningSessionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutAgentInput | CleaningSessionCreateOrConnectWithoutAgentInput[]
    upsert?: CleaningSessionUpsertWithWhereUniqueWithoutAgentInput | CleaningSessionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: CleaningSessionCreateManyAgentInputEnvelope
    set?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    disconnect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    delete?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    update?: CleaningSessionUpdateWithWhereUniqueWithoutAgentInput | CleaningSessionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: CleaningSessionUpdateManyWithWhereWithoutAgentInput | CleaningSessionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: CleaningSessionScalarWhereInput | CleaningSessionScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<TaskCreateWithoutAgentInput, TaskUncheckedCreateWithoutAgentInput> | TaskCreateWithoutAgentInput[] | TaskUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAgentInput | TaskCreateOrConnectWithoutAgentInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAgentInput | TaskUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: TaskCreateManyAgentInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAgentInput | TaskUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAgentInput | TaskUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<TicketCreateWithoutAgentInput, TicketUncheckedCreateWithoutAgentInput> | TicketCreateWithoutAgentInput[] | TicketUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAgentInput | TicketCreateOrConnectWithoutAgentInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAgentInput | TicketUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: TicketCreateManyAgentInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAgentInput | TicketUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAgentInput | TicketUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CleaningPlanningUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<CleaningPlanningCreateWithoutAgentInput, CleaningPlanningUncheckedCreateWithoutAgentInput> | CleaningPlanningCreateWithoutAgentInput[] | CleaningPlanningUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: CleaningPlanningCreateOrConnectWithoutAgentInput | CleaningPlanningCreateOrConnectWithoutAgentInput[]
    upsert?: CleaningPlanningUpsertWithWhereUniqueWithoutAgentInput | CleaningPlanningUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: CleaningPlanningCreateManyAgentInputEnvelope
    set?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    disconnect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    delete?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    connect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    update?: CleaningPlanningUpdateWithWhereUniqueWithoutAgentInput | CleaningPlanningUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: CleaningPlanningUpdateManyWithWhereWithoutAgentInput | CleaningPlanningUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: CleaningPlanningScalarWhereInput | CleaningPlanningScalarWhereInput[]
  }

  export type SiteCleaningSessionUncheckedUpdateManyWithoutCleaningAgentNestedInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutCleaningAgentInput, SiteCleaningSessionUncheckedCreateWithoutCleaningAgentInput> | SiteCleaningSessionCreateWithoutCleaningAgentInput[] | SiteCleaningSessionUncheckedCreateWithoutCleaningAgentInput[]
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutCleaningAgentInput | SiteCleaningSessionCreateOrConnectWithoutCleaningAgentInput[]
    upsert?: SiteCleaningSessionUpsertWithWhereUniqueWithoutCleaningAgentInput | SiteCleaningSessionUpsertWithWhereUniqueWithoutCleaningAgentInput[]
    createMany?: SiteCleaningSessionCreateManyCleaningAgentInputEnvelope
    set?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    disconnect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    delete?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    connect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    update?: SiteCleaningSessionUpdateWithWhereUniqueWithoutCleaningAgentInput | SiteCleaningSessionUpdateWithWhereUniqueWithoutCleaningAgentInput[]
    updateMany?: SiteCleaningSessionUpdateManyWithWhereWithoutCleaningAgentInput | SiteCleaningSessionUpdateManyWithWhereWithoutCleaningAgentInput[]
    deleteMany?: SiteCleaningSessionScalarWhereInput | SiteCleaningSessionScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutMaintenanceSessionsInput = {
    create?: XOR<PropertyCreateWithoutMaintenanceSessionsInput, PropertyUncheckedCreateWithoutMaintenanceSessionsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutMaintenanceSessionsInput
    connect?: PropertyWhereUniqueInput
  }

  export type MaintenanceCreateNestedOneWithoutSessionMaintenancesInput = {
    create?: XOR<MaintenanceCreateWithoutSessionMaintenancesInput, MaintenanceUncheckedCreateWithoutSessionMaintenancesInput>
    connectOrCreate?: MaintenanceCreateOrConnectWithoutSessionMaintenancesInput
    connect?: MaintenanceWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutMaintenanceSessionsInput = {
    create?: XOR<AgentCreateWithoutMaintenanceSessionsInput, AgentUncheckedCreateWithoutMaintenanceSessionsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMaintenanceSessionsInput
    connect?: AgentWhereUniqueInput
  }

  export type MaintenancePhotoCreateNestedManyWithoutMaintenanceSessionInput = {
    create?: XOR<MaintenancePhotoCreateWithoutMaintenanceSessionInput, MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput> | MaintenancePhotoCreateWithoutMaintenanceSessionInput[] | MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput[]
    connectOrCreate?: MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput | MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput[]
    createMany?: MaintenancePhotoCreateManyMaintenanceSessionInputEnvelope
    connect?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
  }

  export type MaintenancePhotoUncheckedCreateNestedManyWithoutMaintenanceSessionInput = {
    create?: XOR<MaintenancePhotoCreateWithoutMaintenanceSessionInput, MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput> | MaintenancePhotoCreateWithoutMaintenanceSessionInput[] | MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput[]
    connectOrCreate?: MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput | MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput[]
    createMany?: MaintenancePhotoCreateManyMaintenanceSessionInputEnvelope
    connect?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PropertyUpdateOneRequiredWithoutMaintenanceSessionsNestedInput = {
    create?: XOR<PropertyCreateWithoutMaintenanceSessionsInput, PropertyUncheckedCreateWithoutMaintenanceSessionsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutMaintenanceSessionsInput
    upsert?: PropertyUpsertWithoutMaintenanceSessionsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutMaintenanceSessionsInput, PropertyUpdateWithoutMaintenanceSessionsInput>, PropertyUncheckedUpdateWithoutMaintenanceSessionsInput>
  }

  export type MaintenanceUpdateOneRequiredWithoutSessionMaintenancesNestedInput = {
    create?: XOR<MaintenanceCreateWithoutSessionMaintenancesInput, MaintenanceUncheckedCreateWithoutSessionMaintenancesInput>
    connectOrCreate?: MaintenanceCreateOrConnectWithoutSessionMaintenancesInput
    upsert?: MaintenanceUpsertWithoutSessionMaintenancesInput
    connect?: MaintenanceWhereUniqueInput
    update?: XOR<XOR<MaintenanceUpdateToOneWithWhereWithoutSessionMaintenancesInput, MaintenanceUpdateWithoutSessionMaintenancesInput>, MaintenanceUncheckedUpdateWithoutSessionMaintenancesInput>
  }

  export type AgentUpdateOneRequiredWithoutMaintenanceSessionsNestedInput = {
    create?: XOR<AgentCreateWithoutMaintenanceSessionsInput, AgentUncheckedCreateWithoutMaintenanceSessionsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMaintenanceSessionsInput
    upsert?: AgentUpsertWithoutMaintenanceSessionsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutMaintenanceSessionsInput, AgentUpdateWithoutMaintenanceSessionsInput>, AgentUncheckedUpdateWithoutMaintenanceSessionsInput>
  }

  export type MaintenancePhotoUpdateManyWithoutMaintenanceSessionNestedInput = {
    create?: XOR<MaintenancePhotoCreateWithoutMaintenanceSessionInput, MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput> | MaintenancePhotoCreateWithoutMaintenanceSessionInput[] | MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput[]
    connectOrCreate?: MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput | MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput[]
    upsert?: MaintenancePhotoUpsertWithWhereUniqueWithoutMaintenanceSessionInput | MaintenancePhotoUpsertWithWhereUniqueWithoutMaintenanceSessionInput[]
    createMany?: MaintenancePhotoCreateManyMaintenanceSessionInputEnvelope
    set?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
    disconnect?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
    delete?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
    connect?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
    update?: MaintenancePhotoUpdateWithWhereUniqueWithoutMaintenanceSessionInput | MaintenancePhotoUpdateWithWhereUniqueWithoutMaintenanceSessionInput[]
    updateMany?: MaintenancePhotoUpdateManyWithWhereWithoutMaintenanceSessionInput | MaintenancePhotoUpdateManyWithWhereWithoutMaintenanceSessionInput[]
    deleteMany?: MaintenancePhotoScalarWhereInput | MaintenancePhotoScalarWhereInput[]
  }

  export type MaintenancePhotoUncheckedUpdateManyWithoutMaintenanceSessionNestedInput = {
    create?: XOR<MaintenancePhotoCreateWithoutMaintenanceSessionInput, MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput> | MaintenancePhotoCreateWithoutMaintenanceSessionInput[] | MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput[]
    connectOrCreate?: MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput | MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput[]
    upsert?: MaintenancePhotoUpsertWithWhereUniqueWithoutMaintenanceSessionInput | MaintenancePhotoUpsertWithWhereUniqueWithoutMaintenanceSessionInput[]
    createMany?: MaintenancePhotoCreateManyMaintenanceSessionInputEnvelope
    set?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
    disconnect?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
    delete?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
    connect?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
    update?: MaintenancePhotoUpdateWithWhereUniqueWithoutMaintenanceSessionInput | MaintenancePhotoUpdateWithWhereUniqueWithoutMaintenanceSessionInput[]
    updateMany?: MaintenancePhotoUpdateManyWithWhereWithoutMaintenanceSessionInput | MaintenancePhotoUpdateManyWithWhereWithoutMaintenanceSessionInput[]
    deleteMany?: MaintenancePhotoScalarWhereInput | MaintenancePhotoScalarWhereInput[]
  }

  export type MaintenanceSessionCreateNestedManyWithoutMaintenanceInput = {
    create?: XOR<MaintenanceSessionCreateWithoutMaintenanceInput, MaintenanceSessionUncheckedCreateWithoutMaintenanceInput> | MaintenanceSessionCreateWithoutMaintenanceInput[] | MaintenanceSessionUncheckedCreateWithoutMaintenanceInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutMaintenanceInput | MaintenanceSessionCreateOrConnectWithoutMaintenanceInput[]
    createMany?: MaintenanceSessionCreateManyMaintenanceInputEnvelope
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
  }

  export type MaintenanceSessionUncheckedCreateNestedManyWithoutMaintenanceInput = {
    create?: XOR<MaintenanceSessionCreateWithoutMaintenanceInput, MaintenanceSessionUncheckedCreateWithoutMaintenanceInput> | MaintenanceSessionCreateWithoutMaintenanceInput[] | MaintenanceSessionUncheckedCreateWithoutMaintenanceInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutMaintenanceInput | MaintenanceSessionCreateOrConnectWithoutMaintenanceInput[]
    createMany?: MaintenanceSessionCreateManyMaintenanceInputEnvelope
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
  }

  export type MaintenanceSessionUpdateManyWithoutMaintenanceNestedInput = {
    create?: XOR<MaintenanceSessionCreateWithoutMaintenanceInput, MaintenanceSessionUncheckedCreateWithoutMaintenanceInput> | MaintenanceSessionCreateWithoutMaintenanceInput[] | MaintenanceSessionUncheckedCreateWithoutMaintenanceInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutMaintenanceInput | MaintenanceSessionCreateOrConnectWithoutMaintenanceInput[]
    upsert?: MaintenanceSessionUpsertWithWhereUniqueWithoutMaintenanceInput | MaintenanceSessionUpsertWithWhereUniqueWithoutMaintenanceInput[]
    createMany?: MaintenanceSessionCreateManyMaintenanceInputEnvelope
    set?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    disconnect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    delete?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    update?: MaintenanceSessionUpdateWithWhereUniqueWithoutMaintenanceInput | MaintenanceSessionUpdateWithWhereUniqueWithoutMaintenanceInput[]
    updateMany?: MaintenanceSessionUpdateManyWithWhereWithoutMaintenanceInput | MaintenanceSessionUpdateManyWithWhereWithoutMaintenanceInput[]
    deleteMany?: MaintenanceSessionScalarWhereInput | MaintenanceSessionScalarWhereInput[]
  }

  export type MaintenanceSessionUncheckedUpdateManyWithoutMaintenanceNestedInput = {
    create?: XOR<MaintenanceSessionCreateWithoutMaintenanceInput, MaintenanceSessionUncheckedCreateWithoutMaintenanceInput> | MaintenanceSessionCreateWithoutMaintenanceInput[] | MaintenanceSessionUncheckedCreateWithoutMaintenanceInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutMaintenanceInput | MaintenanceSessionCreateOrConnectWithoutMaintenanceInput[]
    upsert?: MaintenanceSessionUpsertWithWhereUniqueWithoutMaintenanceInput | MaintenanceSessionUpsertWithWhereUniqueWithoutMaintenanceInput[]
    createMany?: MaintenanceSessionCreateManyMaintenanceInputEnvelope
    set?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    disconnect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    delete?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    update?: MaintenanceSessionUpdateWithWhereUniqueWithoutMaintenanceInput | MaintenanceSessionUpdateWithWhereUniqueWithoutMaintenanceInput[]
    updateMany?: MaintenanceSessionUpdateManyWithWhereWithoutMaintenanceInput | MaintenanceSessionUpdateManyWithWhereWithoutMaintenanceInput[]
    deleteMany?: MaintenanceSessionScalarWhereInput | MaintenanceSessionScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutCleaningSessionsInput = {
    create?: XOR<PropertyCreateWithoutCleaningSessionsInput, PropertyUncheckedCreateWithoutCleaningSessionsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutCleaningSessionsInput
    connect?: PropertyWhereUniqueInput
  }

  export type CleaningCreateNestedOneWithoutCleaningSessionsInput = {
    create?: XOR<CleaningCreateWithoutCleaningSessionsInput, CleaningUncheckedCreateWithoutCleaningSessionsInput>
    connectOrCreate?: CleaningCreateOrConnectWithoutCleaningSessionsInput
    connect?: CleaningWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutCleaningSessionsInput = {
    create?: XOR<AgentCreateWithoutCleaningSessionsInput, AgentUncheckedCreateWithoutCleaningSessionsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutCleaningSessionsInput
    connect?: AgentWhereUniqueInput
  }

  export type CleaningPhotoCreateNestedManyWithoutCleaningSessionInput = {
    create?: XOR<CleaningPhotoCreateWithoutCleaningSessionInput, CleaningPhotoUncheckedCreateWithoutCleaningSessionInput> | CleaningPhotoCreateWithoutCleaningSessionInput[] | CleaningPhotoUncheckedCreateWithoutCleaningSessionInput[]
    connectOrCreate?: CleaningPhotoCreateOrConnectWithoutCleaningSessionInput | CleaningPhotoCreateOrConnectWithoutCleaningSessionInput[]
    createMany?: CleaningPhotoCreateManyCleaningSessionInputEnvelope
    connect?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
  }

  export type CleaningChecklistCreateNestedManyWithoutCleaningSessionInput = {
    create?: XOR<CleaningChecklistCreateWithoutCleaningSessionInput, CleaningChecklistUncheckedCreateWithoutCleaningSessionInput> | CleaningChecklistCreateWithoutCleaningSessionInput[] | CleaningChecklistUncheckedCreateWithoutCleaningSessionInput[]
    connectOrCreate?: CleaningChecklistCreateOrConnectWithoutCleaningSessionInput | CleaningChecklistCreateOrConnectWithoutCleaningSessionInput[]
    createMany?: CleaningChecklistCreateManyCleaningSessionInputEnvelope
    connect?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
  }

  export type CleaningPhotoUncheckedCreateNestedManyWithoutCleaningSessionInput = {
    create?: XOR<CleaningPhotoCreateWithoutCleaningSessionInput, CleaningPhotoUncheckedCreateWithoutCleaningSessionInput> | CleaningPhotoCreateWithoutCleaningSessionInput[] | CleaningPhotoUncheckedCreateWithoutCleaningSessionInput[]
    connectOrCreate?: CleaningPhotoCreateOrConnectWithoutCleaningSessionInput | CleaningPhotoCreateOrConnectWithoutCleaningSessionInput[]
    createMany?: CleaningPhotoCreateManyCleaningSessionInputEnvelope
    connect?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
  }

  export type CleaningChecklistUncheckedCreateNestedManyWithoutCleaningSessionInput = {
    create?: XOR<CleaningChecklistCreateWithoutCleaningSessionInput, CleaningChecklistUncheckedCreateWithoutCleaningSessionInput> | CleaningChecklistCreateWithoutCleaningSessionInput[] | CleaningChecklistUncheckedCreateWithoutCleaningSessionInput[]
    connectOrCreate?: CleaningChecklistCreateOrConnectWithoutCleaningSessionInput | CleaningChecklistCreateOrConnectWithoutCleaningSessionInput[]
    createMany?: CleaningChecklistCreateManyCleaningSessionInputEnvelope
    connect?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
  }

  export type PropertyUpdateOneRequiredWithoutCleaningSessionsNestedInput = {
    create?: XOR<PropertyCreateWithoutCleaningSessionsInput, PropertyUncheckedCreateWithoutCleaningSessionsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutCleaningSessionsInput
    upsert?: PropertyUpsertWithoutCleaningSessionsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutCleaningSessionsInput, PropertyUpdateWithoutCleaningSessionsInput>, PropertyUncheckedUpdateWithoutCleaningSessionsInput>
  }

  export type CleaningUpdateOneRequiredWithoutCleaningSessionsNestedInput = {
    create?: XOR<CleaningCreateWithoutCleaningSessionsInput, CleaningUncheckedCreateWithoutCleaningSessionsInput>
    connectOrCreate?: CleaningCreateOrConnectWithoutCleaningSessionsInput
    upsert?: CleaningUpsertWithoutCleaningSessionsInput
    connect?: CleaningWhereUniqueInput
    update?: XOR<XOR<CleaningUpdateToOneWithWhereWithoutCleaningSessionsInput, CleaningUpdateWithoutCleaningSessionsInput>, CleaningUncheckedUpdateWithoutCleaningSessionsInput>
  }

  export type AgentUpdateOneRequiredWithoutCleaningSessionsNestedInput = {
    create?: XOR<AgentCreateWithoutCleaningSessionsInput, AgentUncheckedCreateWithoutCleaningSessionsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutCleaningSessionsInput
    upsert?: AgentUpsertWithoutCleaningSessionsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutCleaningSessionsInput, AgentUpdateWithoutCleaningSessionsInput>, AgentUncheckedUpdateWithoutCleaningSessionsInput>
  }

  export type CleaningPhotoUpdateManyWithoutCleaningSessionNestedInput = {
    create?: XOR<CleaningPhotoCreateWithoutCleaningSessionInput, CleaningPhotoUncheckedCreateWithoutCleaningSessionInput> | CleaningPhotoCreateWithoutCleaningSessionInput[] | CleaningPhotoUncheckedCreateWithoutCleaningSessionInput[]
    connectOrCreate?: CleaningPhotoCreateOrConnectWithoutCleaningSessionInput | CleaningPhotoCreateOrConnectWithoutCleaningSessionInput[]
    upsert?: CleaningPhotoUpsertWithWhereUniqueWithoutCleaningSessionInput | CleaningPhotoUpsertWithWhereUniqueWithoutCleaningSessionInput[]
    createMany?: CleaningPhotoCreateManyCleaningSessionInputEnvelope
    set?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
    disconnect?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
    delete?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
    connect?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
    update?: CleaningPhotoUpdateWithWhereUniqueWithoutCleaningSessionInput | CleaningPhotoUpdateWithWhereUniqueWithoutCleaningSessionInput[]
    updateMany?: CleaningPhotoUpdateManyWithWhereWithoutCleaningSessionInput | CleaningPhotoUpdateManyWithWhereWithoutCleaningSessionInput[]
    deleteMany?: CleaningPhotoScalarWhereInput | CleaningPhotoScalarWhereInput[]
  }

  export type CleaningChecklistUpdateManyWithoutCleaningSessionNestedInput = {
    create?: XOR<CleaningChecklistCreateWithoutCleaningSessionInput, CleaningChecklistUncheckedCreateWithoutCleaningSessionInput> | CleaningChecklistCreateWithoutCleaningSessionInput[] | CleaningChecklistUncheckedCreateWithoutCleaningSessionInput[]
    connectOrCreate?: CleaningChecklistCreateOrConnectWithoutCleaningSessionInput | CleaningChecklistCreateOrConnectWithoutCleaningSessionInput[]
    upsert?: CleaningChecklistUpsertWithWhereUniqueWithoutCleaningSessionInput | CleaningChecklistUpsertWithWhereUniqueWithoutCleaningSessionInput[]
    createMany?: CleaningChecklistCreateManyCleaningSessionInputEnvelope
    set?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
    disconnect?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
    delete?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
    connect?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
    update?: CleaningChecklistUpdateWithWhereUniqueWithoutCleaningSessionInput | CleaningChecklistUpdateWithWhereUniqueWithoutCleaningSessionInput[]
    updateMany?: CleaningChecklistUpdateManyWithWhereWithoutCleaningSessionInput | CleaningChecklistUpdateManyWithWhereWithoutCleaningSessionInput[]
    deleteMany?: CleaningChecklistScalarWhereInput | CleaningChecklistScalarWhereInput[]
  }

  export type CleaningPhotoUncheckedUpdateManyWithoutCleaningSessionNestedInput = {
    create?: XOR<CleaningPhotoCreateWithoutCleaningSessionInput, CleaningPhotoUncheckedCreateWithoutCleaningSessionInput> | CleaningPhotoCreateWithoutCleaningSessionInput[] | CleaningPhotoUncheckedCreateWithoutCleaningSessionInput[]
    connectOrCreate?: CleaningPhotoCreateOrConnectWithoutCleaningSessionInput | CleaningPhotoCreateOrConnectWithoutCleaningSessionInput[]
    upsert?: CleaningPhotoUpsertWithWhereUniqueWithoutCleaningSessionInput | CleaningPhotoUpsertWithWhereUniqueWithoutCleaningSessionInput[]
    createMany?: CleaningPhotoCreateManyCleaningSessionInputEnvelope
    set?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
    disconnect?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
    delete?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
    connect?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
    update?: CleaningPhotoUpdateWithWhereUniqueWithoutCleaningSessionInput | CleaningPhotoUpdateWithWhereUniqueWithoutCleaningSessionInput[]
    updateMany?: CleaningPhotoUpdateManyWithWhereWithoutCleaningSessionInput | CleaningPhotoUpdateManyWithWhereWithoutCleaningSessionInput[]
    deleteMany?: CleaningPhotoScalarWhereInput | CleaningPhotoScalarWhereInput[]
  }

  export type CleaningChecklistUncheckedUpdateManyWithoutCleaningSessionNestedInput = {
    create?: XOR<CleaningChecklistCreateWithoutCleaningSessionInput, CleaningChecklistUncheckedCreateWithoutCleaningSessionInput> | CleaningChecklistCreateWithoutCleaningSessionInput[] | CleaningChecklistUncheckedCreateWithoutCleaningSessionInput[]
    connectOrCreate?: CleaningChecklistCreateOrConnectWithoutCleaningSessionInput | CleaningChecklistCreateOrConnectWithoutCleaningSessionInput[]
    upsert?: CleaningChecklistUpsertWithWhereUniqueWithoutCleaningSessionInput | CleaningChecklistUpsertWithWhereUniqueWithoutCleaningSessionInput[]
    createMany?: CleaningChecklistCreateManyCleaningSessionInputEnvelope
    set?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
    disconnect?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
    delete?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
    connect?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
    update?: CleaningChecklistUpdateWithWhereUniqueWithoutCleaningSessionInput | CleaningChecklistUpdateWithWhereUniqueWithoutCleaningSessionInput[]
    updateMany?: CleaningChecklistUpdateManyWithWhereWithoutCleaningSessionInput | CleaningChecklistUpdateManyWithWhereWithoutCleaningSessionInput[]
    deleteMany?: CleaningChecklistScalarWhereInput | CleaningChecklistScalarWhereInput[]
  }

  export type CleaningSessionCreateNestedManyWithoutCleaningInput = {
    create?: XOR<CleaningSessionCreateWithoutCleaningInput, CleaningSessionUncheckedCreateWithoutCleaningInput> | CleaningSessionCreateWithoutCleaningInput[] | CleaningSessionUncheckedCreateWithoutCleaningInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutCleaningInput | CleaningSessionCreateOrConnectWithoutCleaningInput[]
    createMany?: CleaningSessionCreateManyCleaningInputEnvelope
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
  }

  export type CleaningSessionUncheckedCreateNestedManyWithoutCleaningInput = {
    create?: XOR<CleaningSessionCreateWithoutCleaningInput, CleaningSessionUncheckedCreateWithoutCleaningInput> | CleaningSessionCreateWithoutCleaningInput[] | CleaningSessionUncheckedCreateWithoutCleaningInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutCleaningInput | CleaningSessionCreateOrConnectWithoutCleaningInput[]
    createMany?: CleaningSessionCreateManyCleaningInputEnvelope
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
  }

  export type CleaningSessionUpdateManyWithoutCleaningNestedInput = {
    create?: XOR<CleaningSessionCreateWithoutCleaningInput, CleaningSessionUncheckedCreateWithoutCleaningInput> | CleaningSessionCreateWithoutCleaningInput[] | CleaningSessionUncheckedCreateWithoutCleaningInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutCleaningInput | CleaningSessionCreateOrConnectWithoutCleaningInput[]
    upsert?: CleaningSessionUpsertWithWhereUniqueWithoutCleaningInput | CleaningSessionUpsertWithWhereUniqueWithoutCleaningInput[]
    createMany?: CleaningSessionCreateManyCleaningInputEnvelope
    set?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    disconnect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    delete?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    update?: CleaningSessionUpdateWithWhereUniqueWithoutCleaningInput | CleaningSessionUpdateWithWhereUniqueWithoutCleaningInput[]
    updateMany?: CleaningSessionUpdateManyWithWhereWithoutCleaningInput | CleaningSessionUpdateManyWithWhereWithoutCleaningInput[]
    deleteMany?: CleaningSessionScalarWhereInput | CleaningSessionScalarWhereInput[]
  }

  export type CleaningSessionUncheckedUpdateManyWithoutCleaningNestedInput = {
    create?: XOR<CleaningSessionCreateWithoutCleaningInput, CleaningSessionUncheckedCreateWithoutCleaningInput> | CleaningSessionCreateWithoutCleaningInput[] | CleaningSessionUncheckedCreateWithoutCleaningInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutCleaningInput | CleaningSessionCreateOrConnectWithoutCleaningInput[]
    upsert?: CleaningSessionUpsertWithWhereUniqueWithoutCleaningInput | CleaningSessionUpsertWithWhereUniqueWithoutCleaningInput[]
    createMany?: CleaningSessionCreateManyCleaningInputEnvelope
    set?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    disconnect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    delete?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    update?: CleaningSessionUpdateWithWhereUniqueWithoutCleaningInput | CleaningSessionUpdateWithWhereUniqueWithoutCleaningInput[]
    updateMany?: CleaningSessionUpdateManyWithWhereWithoutCleaningInput | CleaningSessionUpdateManyWithWhereWithoutCleaningInput[]
    deleteMany?: CleaningSessionScalarWhereInput | CleaningSessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCleaningManagersInput = {
    create?: XOR<UserCreateWithoutCleaningManagersInput, UserUncheckedCreateWithoutCleaningManagersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCleaningManagersInput
    connect?: UserWhereUniqueInput
  }

  export type InterventionSiteCreateNestedManyWithoutCleaningManagerInput = {
    create?: XOR<InterventionSiteCreateWithoutCleaningManagerInput, InterventionSiteUncheckedCreateWithoutCleaningManagerInput> | InterventionSiteCreateWithoutCleaningManagerInput[] | InterventionSiteUncheckedCreateWithoutCleaningManagerInput[]
    connectOrCreate?: InterventionSiteCreateOrConnectWithoutCleaningManagerInput | InterventionSiteCreateOrConnectWithoutCleaningManagerInput[]
    createMany?: InterventionSiteCreateManyCleaningManagerInputEnvelope
    connect?: InterventionSiteWhereUniqueInput | InterventionSiteWhereUniqueInput[]
  }

  export type SiteCleaningSessionCreateNestedManyWithoutCleaningManagerInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutCleaningManagerInput, SiteCleaningSessionUncheckedCreateWithoutCleaningManagerInput> | SiteCleaningSessionCreateWithoutCleaningManagerInput[] | SiteCleaningSessionUncheckedCreateWithoutCleaningManagerInput[]
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutCleaningManagerInput | SiteCleaningSessionCreateOrConnectWithoutCleaningManagerInput[]
    createMany?: SiteCleaningSessionCreateManyCleaningManagerInputEnvelope
    connect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
  }

  export type AgentCreateNestedManyWithoutCleaningManagerInput = {
    create?: XOR<AgentCreateWithoutCleaningManagerInput, AgentUncheckedCreateWithoutCleaningManagerInput> | AgentCreateWithoutCleaningManagerInput[] | AgentUncheckedCreateWithoutCleaningManagerInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutCleaningManagerInput | AgentCreateOrConnectWithoutCleaningManagerInput[]
    createMany?: AgentCreateManyCleaningManagerInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type CleaningPlanningCreateNestedManyWithoutCleaningManagerInput = {
    create?: XOR<CleaningPlanningCreateWithoutCleaningManagerInput, CleaningPlanningUncheckedCreateWithoutCleaningManagerInput> | CleaningPlanningCreateWithoutCleaningManagerInput[] | CleaningPlanningUncheckedCreateWithoutCleaningManagerInput[]
    connectOrCreate?: CleaningPlanningCreateOrConnectWithoutCleaningManagerInput | CleaningPlanningCreateOrConnectWithoutCleaningManagerInput[]
    createMany?: CleaningPlanningCreateManyCleaningManagerInputEnvelope
    connect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
  }

  export type InterventionSiteUncheckedCreateNestedManyWithoutCleaningManagerInput = {
    create?: XOR<InterventionSiteCreateWithoutCleaningManagerInput, InterventionSiteUncheckedCreateWithoutCleaningManagerInput> | InterventionSiteCreateWithoutCleaningManagerInput[] | InterventionSiteUncheckedCreateWithoutCleaningManagerInput[]
    connectOrCreate?: InterventionSiteCreateOrConnectWithoutCleaningManagerInput | InterventionSiteCreateOrConnectWithoutCleaningManagerInput[]
    createMany?: InterventionSiteCreateManyCleaningManagerInputEnvelope
    connect?: InterventionSiteWhereUniqueInput | InterventionSiteWhereUniqueInput[]
  }

  export type SiteCleaningSessionUncheckedCreateNestedManyWithoutCleaningManagerInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutCleaningManagerInput, SiteCleaningSessionUncheckedCreateWithoutCleaningManagerInput> | SiteCleaningSessionCreateWithoutCleaningManagerInput[] | SiteCleaningSessionUncheckedCreateWithoutCleaningManagerInput[]
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutCleaningManagerInput | SiteCleaningSessionCreateOrConnectWithoutCleaningManagerInput[]
    createMany?: SiteCleaningSessionCreateManyCleaningManagerInputEnvelope
    connect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedManyWithoutCleaningManagerInput = {
    create?: XOR<AgentCreateWithoutCleaningManagerInput, AgentUncheckedCreateWithoutCleaningManagerInput> | AgentCreateWithoutCleaningManagerInput[] | AgentUncheckedCreateWithoutCleaningManagerInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutCleaningManagerInput | AgentCreateOrConnectWithoutCleaningManagerInput[]
    createMany?: AgentCreateManyCleaningManagerInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type CleaningPlanningUncheckedCreateNestedManyWithoutCleaningManagerInput = {
    create?: XOR<CleaningPlanningCreateWithoutCleaningManagerInput, CleaningPlanningUncheckedCreateWithoutCleaningManagerInput> | CleaningPlanningCreateWithoutCleaningManagerInput[] | CleaningPlanningUncheckedCreateWithoutCleaningManagerInput[]
    connectOrCreate?: CleaningPlanningCreateOrConnectWithoutCleaningManagerInput | CleaningPlanningCreateOrConnectWithoutCleaningManagerInput[]
    createMany?: CleaningPlanningCreateManyCleaningManagerInputEnvelope
    connect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCleaningManagersNestedInput = {
    create?: XOR<UserCreateWithoutCleaningManagersInput, UserUncheckedCreateWithoutCleaningManagersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCleaningManagersInput
    upsert?: UserUpsertWithoutCleaningManagersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCleaningManagersInput, UserUpdateWithoutCleaningManagersInput>, UserUncheckedUpdateWithoutCleaningManagersInput>
  }

  export type InterventionSiteUpdateManyWithoutCleaningManagerNestedInput = {
    create?: XOR<InterventionSiteCreateWithoutCleaningManagerInput, InterventionSiteUncheckedCreateWithoutCleaningManagerInput> | InterventionSiteCreateWithoutCleaningManagerInput[] | InterventionSiteUncheckedCreateWithoutCleaningManagerInput[]
    connectOrCreate?: InterventionSiteCreateOrConnectWithoutCleaningManagerInput | InterventionSiteCreateOrConnectWithoutCleaningManagerInput[]
    upsert?: InterventionSiteUpsertWithWhereUniqueWithoutCleaningManagerInput | InterventionSiteUpsertWithWhereUniqueWithoutCleaningManagerInput[]
    createMany?: InterventionSiteCreateManyCleaningManagerInputEnvelope
    set?: InterventionSiteWhereUniqueInput | InterventionSiteWhereUniqueInput[]
    disconnect?: InterventionSiteWhereUniqueInput | InterventionSiteWhereUniqueInput[]
    delete?: InterventionSiteWhereUniqueInput | InterventionSiteWhereUniqueInput[]
    connect?: InterventionSiteWhereUniqueInput | InterventionSiteWhereUniqueInput[]
    update?: InterventionSiteUpdateWithWhereUniqueWithoutCleaningManagerInput | InterventionSiteUpdateWithWhereUniqueWithoutCleaningManagerInput[]
    updateMany?: InterventionSiteUpdateManyWithWhereWithoutCleaningManagerInput | InterventionSiteUpdateManyWithWhereWithoutCleaningManagerInput[]
    deleteMany?: InterventionSiteScalarWhereInput | InterventionSiteScalarWhereInput[]
  }

  export type SiteCleaningSessionUpdateManyWithoutCleaningManagerNestedInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutCleaningManagerInput, SiteCleaningSessionUncheckedCreateWithoutCleaningManagerInput> | SiteCleaningSessionCreateWithoutCleaningManagerInput[] | SiteCleaningSessionUncheckedCreateWithoutCleaningManagerInput[]
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutCleaningManagerInput | SiteCleaningSessionCreateOrConnectWithoutCleaningManagerInput[]
    upsert?: SiteCleaningSessionUpsertWithWhereUniqueWithoutCleaningManagerInput | SiteCleaningSessionUpsertWithWhereUniqueWithoutCleaningManagerInput[]
    createMany?: SiteCleaningSessionCreateManyCleaningManagerInputEnvelope
    set?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    disconnect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    delete?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    connect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    update?: SiteCleaningSessionUpdateWithWhereUniqueWithoutCleaningManagerInput | SiteCleaningSessionUpdateWithWhereUniqueWithoutCleaningManagerInput[]
    updateMany?: SiteCleaningSessionUpdateManyWithWhereWithoutCleaningManagerInput | SiteCleaningSessionUpdateManyWithWhereWithoutCleaningManagerInput[]
    deleteMany?: SiteCleaningSessionScalarWhereInput | SiteCleaningSessionScalarWhereInput[]
  }

  export type AgentUpdateManyWithoutCleaningManagerNestedInput = {
    create?: XOR<AgentCreateWithoutCleaningManagerInput, AgentUncheckedCreateWithoutCleaningManagerInput> | AgentCreateWithoutCleaningManagerInput[] | AgentUncheckedCreateWithoutCleaningManagerInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutCleaningManagerInput | AgentCreateOrConnectWithoutCleaningManagerInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutCleaningManagerInput | AgentUpsertWithWhereUniqueWithoutCleaningManagerInput[]
    createMany?: AgentCreateManyCleaningManagerInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutCleaningManagerInput | AgentUpdateWithWhereUniqueWithoutCleaningManagerInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutCleaningManagerInput | AgentUpdateManyWithWhereWithoutCleaningManagerInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type CleaningPlanningUpdateManyWithoutCleaningManagerNestedInput = {
    create?: XOR<CleaningPlanningCreateWithoutCleaningManagerInput, CleaningPlanningUncheckedCreateWithoutCleaningManagerInput> | CleaningPlanningCreateWithoutCleaningManagerInput[] | CleaningPlanningUncheckedCreateWithoutCleaningManagerInput[]
    connectOrCreate?: CleaningPlanningCreateOrConnectWithoutCleaningManagerInput | CleaningPlanningCreateOrConnectWithoutCleaningManagerInput[]
    upsert?: CleaningPlanningUpsertWithWhereUniqueWithoutCleaningManagerInput | CleaningPlanningUpsertWithWhereUniqueWithoutCleaningManagerInput[]
    createMany?: CleaningPlanningCreateManyCleaningManagerInputEnvelope
    set?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    disconnect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    delete?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    connect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    update?: CleaningPlanningUpdateWithWhereUniqueWithoutCleaningManagerInput | CleaningPlanningUpdateWithWhereUniqueWithoutCleaningManagerInput[]
    updateMany?: CleaningPlanningUpdateManyWithWhereWithoutCleaningManagerInput | CleaningPlanningUpdateManyWithWhereWithoutCleaningManagerInput[]
    deleteMany?: CleaningPlanningScalarWhereInput | CleaningPlanningScalarWhereInput[]
  }

  export type InterventionSiteUncheckedUpdateManyWithoutCleaningManagerNestedInput = {
    create?: XOR<InterventionSiteCreateWithoutCleaningManagerInput, InterventionSiteUncheckedCreateWithoutCleaningManagerInput> | InterventionSiteCreateWithoutCleaningManagerInput[] | InterventionSiteUncheckedCreateWithoutCleaningManagerInput[]
    connectOrCreate?: InterventionSiteCreateOrConnectWithoutCleaningManagerInput | InterventionSiteCreateOrConnectWithoutCleaningManagerInput[]
    upsert?: InterventionSiteUpsertWithWhereUniqueWithoutCleaningManagerInput | InterventionSiteUpsertWithWhereUniqueWithoutCleaningManagerInput[]
    createMany?: InterventionSiteCreateManyCleaningManagerInputEnvelope
    set?: InterventionSiteWhereUniqueInput | InterventionSiteWhereUniqueInput[]
    disconnect?: InterventionSiteWhereUniqueInput | InterventionSiteWhereUniqueInput[]
    delete?: InterventionSiteWhereUniqueInput | InterventionSiteWhereUniqueInput[]
    connect?: InterventionSiteWhereUniqueInput | InterventionSiteWhereUniqueInput[]
    update?: InterventionSiteUpdateWithWhereUniqueWithoutCleaningManagerInput | InterventionSiteUpdateWithWhereUniqueWithoutCleaningManagerInput[]
    updateMany?: InterventionSiteUpdateManyWithWhereWithoutCleaningManagerInput | InterventionSiteUpdateManyWithWhereWithoutCleaningManagerInput[]
    deleteMany?: InterventionSiteScalarWhereInput | InterventionSiteScalarWhereInput[]
  }

  export type SiteCleaningSessionUncheckedUpdateManyWithoutCleaningManagerNestedInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutCleaningManagerInput, SiteCleaningSessionUncheckedCreateWithoutCleaningManagerInput> | SiteCleaningSessionCreateWithoutCleaningManagerInput[] | SiteCleaningSessionUncheckedCreateWithoutCleaningManagerInput[]
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutCleaningManagerInput | SiteCleaningSessionCreateOrConnectWithoutCleaningManagerInput[]
    upsert?: SiteCleaningSessionUpsertWithWhereUniqueWithoutCleaningManagerInput | SiteCleaningSessionUpsertWithWhereUniqueWithoutCleaningManagerInput[]
    createMany?: SiteCleaningSessionCreateManyCleaningManagerInputEnvelope
    set?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    disconnect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    delete?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    connect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    update?: SiteCleaningSessionUpdateWithWhereUniqueWithoutCleaningManagerInput | SiteCleaningSessionUpdateWithWhereUniqueWithoutCleaningManagerInput[]
    updateMany?: SiteCleaningSessionUpdateManyWithWhereWithoutCleaningManagerInput | SiteCleaningSessionUpdateManyWithWhereWithoutCleaningManagerInput[]
    deleteMany?: SiteCleaningSessionScalarWhereInput | SiteCleaningSessionScalarWhereInput[]
  }

  export type AgentUncheckedUpdateManyWithoutCleaningManagerNestedInput = {
    create?: XOR<AgentCreateWithoutCleaningManagerInput, AgentUncheckedCreateWithoutCleaningManagerInput> | AgentCreateWithoutCleaningManagerInput[] | AgentUncheckedCreateWithoutCleaningManagerInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutCleaningManagerInput | AgentCreateOrConnectWithoutCleaningManagerInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutCleaningManagerInput | AgentUpsertWithWhereUniqueWithoutCleaningManagerInput[]
    createMany?: AgentCreateManyCleaningManagerInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutCleaningManagerInput | AgentUpdateWithWhereUniqueWithoutCleaningManagerInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutCleaningManagerInput | AgentUpdateManyWithWhereWithoutCleaningManagerInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type CleaningPlanningUncheckedUpdateManyWithoutCleaningManagerNestedInput = {
    create?: XOR<CleaningPlanningCreateWithoutCleaningManagerInput, CleaningPlanningUncheckedCreateWithoutCleaningManagerInput> | CleaningPlanningCreateWithoutCleaningManagerInput[] | CleaningPlanningUncheckedCreateWithoutCleaningManagerInput[]
    connectOrCreate?: CleaningPlanningCreateOrConnectWithoutCleaningManagerInput | CleaningPlanningCreateOrConnectWithoutCleaningManagerInput[]
    upsert?: CleaningPlanningUpsertWithWhereUniqueWithoutCleaningManagerInput | CleaningPlanningUpsertWithWhereUniqueWithoutCleaningManagerInput[]
    createMany?: CleaningPlanningCreateManyCleaningManagerInputEnvelope
    set?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    disconnect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    delete?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    connect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    update?: CleaningPlanningUpdateWithWhereUniqueWithoutCleaningManagerInput | CleaningPlanningUpdateWithWhereUniqueWithoutCleaningManagerInput[]
    updateMany?: CleaningPlanningUpdateManyWithWhereWithoutCleaningManagerInput | CleaningPlanningUpdateManyWithWhereWithoutCleaningManagerInput[]
    deleteMany?: CleaningPlanningScalarWhereInput | CleaningPlanningScalarWhereInput[]
  }

  export type CleaningManagerCreateNestedOneWithoutInterventionSitesInput = {
    create?: XOR<CleaningManagerCreateWithoutInterventionSitesInput, CleaningManagerUncheckedCreateWithoutInterventionSitesInput>
    connectOrCreate?: CleaningManagerCreateOrConnectWithoutInterventionSitesInput
    connect?: CleaningManagerWhereUniqueInput
  }

  export type SiteCleaningSessionCreateNestedManyWithoutInterventionSiteInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutInterventionSiteInput, SiteCleaningSessionUncheckedCreateWithoutInterventionSiteInput> | SiteCleaningSessionCreateWithoutInterventionSiteInput[] | SiteCleaningSessionUncheckedCreateWithoutInterventionSiteInput[]
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutInterventionSiteInput | SiteCleaningSessionCreateOrConnectWithoutInterventionSiteInput[]
    createMany?: SiteCleaningSessionCreateManyInterventionSiteInputEnvelope
    connect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
  }

  export type CleaningPlanningCreateNestedManyWithoutInterventionSiteInput = {
    create?: XOR<CleaningPlanningCreateWithoutInterventionSiteInput, CleaningPlanningUncheckedCreateWithoutInterventionSiteInput> | CleaningPlanningCreateWithoutInterventionSiteInput[] | CleaningPlanningUncheckedCreateWithoutInterventionSiteInput[]
    connectOrCreate?: CleaningPlanningCreateOrConnectWithoutInterventionSiteInput | CleaningPlanningCreateOrConnectWithoutInterventionSiteInput[]
    createMany?: CleaningPlanningCreateManyInterventionSiteInputEnvelope
    connect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
  }

  export type SiteCleaningSessionUncheckedCreateNestedManyWithoutInterventionSiteInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutInterventionSiteInput, SiteCleaningSessionUncheckedCreateWithoutInterventionSiteInput> | SiteCleaningSessionCreateWithoutInterventionSiteInput[] | SiteCleaningSessionUncheckedCreateWithoutInterventionSiteInput[]
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutInterventionSiteInput | SiteCleaningSessionCreateOrConnectWithoutInterventionSiteInput[]
    createMany?: SiteCleaningSessionCreateManyInterventionSiteInputEnvelope
    connect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
  }

  export type CleaningPlanningUncheckedCreateNestedManyWithoutInterventionSiteInput = {
    create?: XOR<CleaningPlanningCreateWithoutInterventionSiteInput, CleaningPlanningUncheckedCreateWithoutInterventionSiteInput> | CleaningPlanningCreateWithoutInterventionSiteInput[] | CleaningPlanningUncheckedCreateWithoutInterventionSiteInput[]
    connectOrCreate?: CleaningPlanningCreateOrConnectWithoutInterventionSiteInput | CleaningPlanningCreateOrConnectWithoutInterventionSiteInput[]
    createMany?: CleaningPlanningCreateManyInterventionSiteInputEnvelope
    connect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
  }

  export type CleaningManagerUpdateOneRequiredWithoutInterventionSitesNestedInput = {
    create?: XOR<CleaningManagerCreateWithoutInterventionSitesInput, CleaningManagerUncheckedCreateWithoutInterventionSitesInput>
    connectOrCreate?: CleaningManagerCreateOrConnectWithoutInterventionSitesInput
    upsert?: CleaningManagerUpsertWithoutInterventionSitesInput
    connect?: CleaningManagerWhereUniqueInput
    update?: XOR<XOR<CleaningManagerUpdateToOneWithWhereWithoutInterventionSitesInput, CleaningManagerUpdateWithoutInterventionSitesInput>, CleaningManagerUncheckedUpdateWithoutInterventionSitesInput>
  }

  export type SiteCleaningSessionUpdateManyWithoutInterventionSiteNestedInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutInterventionSiteInput, SiteCleaningSessionUncheckedCreateWithoutInterventionSiteInput> | SiteCleaningSessionCreateWithoutInterventionSiteInput[] | SiteCleaningSessionUncheckedCreateWithoutInterventionSiteInput[]
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutInterventionSiteInput | SiteCleaningSessionCreateOrConnectWithoutInterventionSiteInput[]
    upsert?: SiteCleaningSessionUpsertWithWhereUniqueWithoutInterventionSiteInput | SiteCleaningSessionUpsertWithWhereUniqueWithoutInterventionSiteInput[]
    createMany?: SiteCleaningSessionCreateManyInterventionSiteInputEnvelope
    set?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    disconnect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    delete?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    connect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    update?: SiteCleaningSessionUpdateWithWhereUniqueWithoutInterventionSiteInput | SiteCleaningSessionUpdateWithWhereUniqueWithoutInterventionSiteInput[]
    updateMany?: SiteCleaningSessionUpdateManyWithWhereWithoutInterventionSiteInput | SiteCleaningSessionUpdateManyWithWhereWithoutInterventionSiteInput[]
    deleteMany?: SiteCleaningSessionScalarWhereInput | SiteCleaningSessionScalarWhereInput[]
  }

  export type CleaningPlanningUpdateManyWithoutInterventionSiteNestedInput = {
    create?: XOR<CleaningPlanningCreateWithoutInterventionSiteInput, CleaningPlanningUncheckedCreateWithoutInterventionSiteInput> | CleaningPlanningCreateWithoutInterventionSiteInput[] | CleaningPlanningUncheckedCreateWithoutInterventionSiteInput[]
    connectOrCreate?: CleaningPlanningCreateOrConnectWithoutInterventionSiteInput | CleaningPlanningCreateOrConnectWithoutInterventionSiteInput[]
    upsert?: CleaningPlanningUpsertWithWhereUniqueWithoutInterventionSiteInput | CleaningPlanningUpsertWithWhereUniqueWithoutInterventionSiteInput[]
    createMany?: CleaningPlanningCreateManyInterventionSiteInputEnvelope
    set?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    disconnect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    delete?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    connect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    update?: CleaningPlanningUpdateWithWhereUniqueWithoutInterventionSiteInput | CleaningPlanningUpdateWithWhereUniqueWithoutInterventionSiteInput[]
    updateMany?: CleaningPlanningUpdateManyWithWhereWithoutInterventionSiteInput | CleaningPlanningUpdateManyWithWhereWithoutInterventionSiteInput[]
    deleteMany?: CleaningPlanningScalarWhereInput | CleaningPlanningScalarWhereInput[]
  }

  export type SiteCleaningSessionUncheckedUpdateManyWithoutInterventionSiteNestedInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutInterventionSiteInput, SiteCleaningSessionUncheckedCreateWithoutInterventionSiteInput> | SiteCleaningSessionCreateWithoutInterventionSiteInput[] | SiteCleaningSessionUncheckedCreateWithoutInterventionSiteInput[]
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutInterventionSiteInput | SiteCleaningSessionCreateOrConnectWithoutInterventionSiteInput[]
    upsert?: SiteCleaningSessionUpsertWithWhereUniqueWithoutInterventionSiteInput | SiteCleaningSessionUpsertWithWhereUniqueWithoutInterventionSiteInput[]
    createMany?: SiteCleaningSessionCreateManyInterventionSiteInputEnvelope
    set?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    disconnect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    delete?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    connect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    update?: SiteCleaningSessionUpdateWithWhereUniqueWithoutInterventionSiteInput | SiteCleaningSessionUpdateWithWhereUniqueWithoutInterventionSiteInput[]
    updateMany?: SiteCleaningSessionUpdateManyWithWhereWithoutInterventionSiteInput | SiteCleaningSessionUpdateManyWithWhereWithoutInterventionSiteInput[]
    deleteMany?: SiteCleaningSessionScalarWhereInput | SiteCleaningSessionScalarWhereInput[]
  }

  export type CleaningPlanningUncheckedUpdateManyWithoutInterventionSiteNestedInput = {
    create?: XOR<CleaningPlanningCreateWithoutInterventionSiteInput, CleaningPlanningUncheckedCreateWithoutInterventionSiteInput> | CleaningPlanningCreateWithoutInterventionSiteInput[] | CleaningPlanningUncheckedCreateWithoutInterventionSiteInput[]
    connectOrCreate?: CleaningPlanningCreateOrConnectWithoutInterventionSiteInput | CleaningPlanningCreateOrConnectWithoutInterventionSiteInput[]
    upsert?: CleaningPlanningUpsertWithWhereUniqueWithoutInterventionSiteInput | CleaningPlanningUpsertWithWhereUniqueWithoutInterventionSiteInput[]
    createMany?: CleaningPlanningCreateManyInterventionSiteInputEnvelope
    set?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    disconnect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    delete?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    connect?: CleaningPlanningWhereUniqueInput | CleaningPlanningWhereUniqueInput[]
    update?: CleaningPlanningUpdateWithWhereUniqueWithoutInterventionSiteInput | CleaningPlanningUpdateWithWhereUniqueWithoutInterventionSiteInput[]
    updateMany?: CleaningPlanningUpdateManyWithWhereWithoutInterventionSiteInput | CleaningPlanningUpdateManyWithWhereWithoutInterventionSiteInput[]
    deleteMany?: CleaningPlanningScalarWhereInput | CleaningPlanningScalarWhereInput[]
  }

  export type InterventionSiteCreateNestedOneWithoutSiteCleaningSessionsInput = {
    create?: XOR<InterventionSiteCreateWithoutSiteCleaningSessionsInput, InterventionSiteUncheckedCreateWithoutSiteCleaningSessionsInput>
    connectOrCreate?: InterventionSiteCreateOrConnectWithoutSiteCleaningSessionsInput
    connect?: InterventionSiteWhereUniqueInput
  }

  export type CleaningManagerCreateNestedOneWithoutSiteCleaningSessionsInput = {
    create?: XOR<CleaningManagerCreateWithoutSiteCleaningSessionsInput, CleaningManagerUncheckedCreateWithoutSiteCleaningSessionsInput>
    connectOrCreate?: CleaningManagerCreateOrConnectWithoutSiteCleaningSessionsInput
    connect?: CleaningManagerWhereUniqueInput
  }

  export type SiteCleaningPhotoCreateNestedManyWithoutSiteCleaningSessionInput = {
    create?: XOR<SiteCleaningPhotoCreateWithoutSiteCleaningSessionInput, SiteCleaningPhotoUncheckedCreateWithoutSiteCleaningSessionInput> | SiteCleaningPhotoCreateWithoutSiteCleaningSessionInput[] | SiteCleaningPhotoUncheckedCreateWithoutSiteCleaningSessionInput[]
    connectOrCreate?: SiteCleaningPhotoCreateOrConnectWithoutSiteCleaningSessionInput | SiteCleaningPhotoCreateOrConnectWithoutSiteCleaningSessionInput[]
    createMany?: SiteCleaningPhotoCreateManySiteCleaningSessionInputEnvelope
    connect?: SiteCleaningPhotoWhereUniqueInput | SiteCleaningPhotoWhereUniqueInput[]
  }

  export type SiteCleaningChecklistCreateNestedManyWithoutSiteCleaningSessionInput = {
    create?: XOR<SiteCleaningChecklistCreateWithoutSiteCleaningSessionInput, SiteCleaningChecklistUncheckedCreateWithoutSiteCleaningSessionInput> | SiteCleaningChecklistCreateWithoutSiteCleaningSessionInput[] | SiteCleaningChecklistUncheckedCreateWithoutSiteCleaningSessionInput[]
    connectOrCreate?: SiteCleaningChecklistCreateOrConnectWithoutSiteCleaningSessionInput | SiteCleaningChecklistCreateOrConnectWithoutSiteCleaningSessionInput[]
    createMany?: SiteCleaningChecklistCreateManySiteCleaningSessionInputEnvelope
    connect?: SiteCleaningChecklistWhereUniqueInput | SiteCleaningChecklistWhereUniqueInput[]
  }

  export type LaundryManagerCreateNestedOneWithoutSiteCleaningSessionsInput = {
    create?: XOR<LaundryManagerCreateWithoutSiteCleaningSessionsInput, LaundryManagerUncheckedCreateWithoutSiteCleaningSessionsInput>
    connectOrCreate?: LaundryManagerCreateOrConnectWithoutSiteCleaningSessionsInput
    connect?: LaundryManagerWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutSiteCleaningSessionsInput = {
    create?: XOR<AgentCreateWithoutSiteCleaningSessionsInput, AgentUncheckedCreateWithoutSiteCleaningSessionsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutSiteCleaningSessionsInput
    connect?: AgentWhereUniqueInput
  }

  export type SiteCleaningPhotoUncheckedCreateNestedManyWithoutSiteCleaningSessionInput = {
    create?: XOR<SiteCleaningPhotoCreateWithoutSiteCleaningSessionInput, SiteCleaningPhotoUncheckedCreateWithoutSiteCleaningSessionInput> | SiteCleaningPhotoCreateWithoutSiteCleaningSessionInput[] | SiteCleaningPhotoUncheckedCreateWithoutSiteCleaningSessionInput[]
    connectOrCreate?: SiteCleaningPhotoCreateOrConnectWithoutSiteCleaningSessionInput | SiteCleaningPhotoCreateOrConnectWithoutSiteCleaningSessionInput[]
    createMany?: SiteCleaningPhotoCreateManySiteCleaningSessionInputEnvelope
    connect?: SiteCleaningPhotoWhereUniqueInput | SiteCleaningPhotoWhereUniqueInput[]
  }

  export type SiteCleaningChecklistUncheckedCreateNestedManyWithoutSiteCleaningSessionInput = {
    create?: XOR<SiteCleaningChecklistCreateWithoutSiteCleaningSessionInput, SiteCleaningChecklistUncheckedCreateWithoutSiteCleaningSessionInput> | SiteCleaningChecklistCreateWithoutSiteCleaningSessionInput[] | SiteCleaningChecklistUncheckedCreateWithoutSiteCleaningSessionInput[]
    connectOrCreate?: SiteCleaningChecklistCreateOrConnectWithoutSiteCleaningSessionInput | SiteCleaningChecklistCreateOrConnectWithoutSiteCleaningSessionInput[]
    createMany?: SiteCleaningChecklistCreateManySiteCleaningSessionInputEnvelope
    connect?: SiteCleaningChecklistWhereUniqueInput | SiteCleaningChecklistWhereUniqueInput[]
  }

  export type EnumInterventionStatusFieldUpdateOperationsInput = {
    set?: $Enums.InterventionStatus
  }

  export type InterventionSiteUpdateOneRequiredWithoutSiteCleaningSessionsNestedInput = {
    create?: XOR<InterventionSiteCreateWithoutSiteCleaningSessionsInput, InterventionSiteUncheckedCreateWithoutSiteCleaningSessionsInput>
    connectOrCreate?: InterventionSiteCreateOrConnectWithoutSiteCleaningSessionsInput
    upsert?: InterventionSiteUpsertWithoutSiteCleaningSessionsInput
    connect?: InterventionSiteWhereUniqueInput
    update?: XOR<XOR<InterventionSiteUpdateToOneWithWhereWithoutSiteCleaningSessionsInput, InterventionSiteUpdateWithoutSiteCleaningSessionsInput>, InterventionSiteUncheckedUpdateWithoutSiteCleaningSessionsInput>
  }

  export type CleaningManagerUpdateOneRequiredWithoutSiteCleaningSessionsNestedInput = {
    create?: XOR<CleaningManagerCreateWithoutSiteCleaningSessionsInput, CleaningManagerUncheckedCreateWithoutSiteCleaningSessionsInput>
    connectOrCreate?: CleaningManagerCreateOrConnectWithoutSiteCleaningSessionsInput
    upsert?: CleaningManagerUpsertWithoutSiteCleaningSessionsInput
    connect?: CleaningManagerWhereUniqueInput
    update?: XOR<XOR<CleaningManagerUpdateToOneWithWhereWithoutSiteCleaningSessionsInput, CleaningManagerUpdateWithoutSiteCleaningSessionsInput>, CleaningManagerUncheckedUpdateWithoutSiteCleaningSessionsInput>
  }

  export type SiteCleaningPhotoUpdateManyWithoutSiteCleaningSessionNestedInput = {
    create?: XOR<SiteCleaningPhotoCreateWithoutSiteCleaningSessionInput, SiteCleaningPhotoUncheckedCreateWithoutSiteCleaningSessionInput> | SiteCleaningPhotoCreateWithoutSiteCleaningSessionInput[] | SiteCleaningPhotoUncheckedCreateWithoutSiteCleaningSessionInput[]
    connectOrCreate?: SiteCleaningPhotoCreateOrConnectWithoutSiteCleaningSessionInput | SiteCleaningPhotoCreateOrConnectWithoutSiteCleaningSessionInput[]
    upsert?: SiteCleaningPhotoUpsertWithWhereUniqueWithoutSiteCleaningSessionInput | SiteCleaningPhotoUpsertWithWhereUniqueWithoutSiteCleaningSessionInput[]
    createMany?: SiteCleaningPhotoCreateManySiteCleaningSessionInputEnvelope
    set?: SiteCleaningPhotoWhereUniqueInput | SiteCleaningPhotoWhereUniqueInput[]
    disconnect?: SiteCleaningPhotoWhereUniqueInput | SiteCleaningPhotoWhereUniqueInput[]
    delete?: SiteCleaningPhotoWhereUniqueInput | SiteCleaningPhotoWhereUniqueInput[]
    connect?: SiteCleaningPhotoWhereUniqueInput | SiteCleaningPhotoWhereUniqueInput[]
    update?: SiteCleaningPhotoUpdateWithWhereUniqueWithoutSiteCleaningSessionInput | SiteCleaningPhotoUpdateWithWhereUniqueWithoutSiteCleaningSessionInput[]
    updateMany?: SiteCleaningPhotoUpdateManyWithWhereWithoutSiteCleaningSessionInput | SiteCleaningPhotoUpdateManyWithWhereWithoutSiteCleaningSessionInput[]
    deleteMany?: SiteCleaningPhotoScalarWhereInput | SiteCleaningPhotoScalarWhereInput[]
  }

  export type SiteCleaningChecklistUpdateManyWithoutSiteCleaningSessionNestedInput = {
    create?: XOR<SiteCleaningChecklistCreateWithoutSiteCleaningSessionInput, SiteCleaningChecklistUncheckedCreateWithoutSiteCleaningSessionInput> | SiteCleaningChecklistCreateWithoutSiteCleaningSessionInput[] | SiteCleaningChecklistUncheckedCreateWithoutSiteCleaningSessionInput[]
    connectOrCreate?: SiteCleaningChecklistCreateOrConnectWithoutSiteCleaningSessionInput | SiteCleaningChecklistCreateOrConnectWithoutSiteCleaningSessionInput[]
    upsert?: SiteCleaningChecklistUpsertWithWhereUniqueWithoutSiteCleaningSessionInput | SiteCleaningChecklistUpsertWithWhereUniqueWithoutSiteCleaningSessionInput[]
    createMany?: SiteCleaningChecklistCreateManySiteCleaningSessionInputEnvelope
    set?: SiteCleaningChecklistWhereUniqueInput | SiteCleaningChecklistWhereUniqueInput[]
    disconnect?: SiteCleaningChecklistWhereUniqueInput | SiteCleaningChecklistWhereUniqueInput[]
    delete?: SiteCleaningChecklistWhereUniqueInput | SiteCleaningChecklistWhereUniqueInput[]
    connect?: SiteCleaningChecklistWhereUniqueInput | SiteCleaningChecklistWhereUniqueInput[]
    update?: SiteCleaningChecklistUpdateWithWhereUniqueWithoutSiteCleaningSessionInput | SiteCleaningChecklistUpdateWithWhereUniqueWithoutSiteCleaningSessionInput[]
    updateMany?: SiteCleaningChecklistUpdateManyWithWhereWithoutSiteCleaningSessionInput | SiteCleaningChecklistUpdateManyWithWhereWithoutSiteCleaningSessionInput[]
    deleteMany?: SiteCleaningChecklistScalarWhereInput | SiteCleaningChecklistScalarWhereInput[]
  }

  export type LaundryManagerUpdateOneWithoutSiteCleaningSessionsNestedInput = {
    create?: XOR<LaundryManagerCreateWithoutSiteCleaningSessionsInput, LaundryManagerUncheckedCreateWithoutSiteCleaningSessionsInput>
    connectOrCreate?: LaundryManagerCreateOrConnectWithoutSiteCleaningSessionsInput
    upsert?: LaundryManagerUpsertWithoutSiteCleaningSessionsInput
    disconnect?: LaundryManagerWhereInput | boolean
    delete?: LaundryManagerWhereInput | boolean
    connect?: LaundryManagerWhereUniqueInput
    update?: XOR<XOR<LaundryManagerUpdateToOneWithWhereWithoutSiteCleaningSessionsInput, LaundryManagerUpdateWithoutSiteCleaningSessionsInput>, LaundryManagerUncheckedUpdateWithoutSiteCleaningSessionsInput>
  }

  export type AgentUpdateOneWithoutSiteCleaningSessionsNestedInput = {
    create?: XOR<AgentCreateWithoutSiteCleaningSessionsInput, AgentUncheckedCreateWithoutSiteCleaningSessionsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutSiteCleaningSessionsInput
    upsert?: AgentUpsertWithoutSiteCleaningSessionsInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutSiteCleaningSessionsInput, AgentUpdateWithoutSiteCleaningSessionsInput>, AgentUncheckedUpdateWithoutSiteCleaningSessionsInput>
  }

  export type SiteCleaningPhotoUncheckedUpdateManyWithoutSiteCleaningSessionNestedInput = {
    create?: XOR<SiteCleaningPhotoCreateWithoutSiteCleaningSessionInput, SiteCleaningPhotoUncheckedCreateWithoutSiteCleaningSessionInput> | SiteCleaningPhotoCreateWithoutSiteCleaningSessionInput[] | SiteCleaningPhotoUncheckedCreateWithoutSiteCleaningSessionInput[]
    connectOrCreate?: SiteCleaningPhotoCreateOrConnectWithoutSiteCleaningSessionInput | SiteCleaningPhotoCreateOrConnectWithoutSiteCleaningSessionInput[]
    upsert?: SiteCleaningPhotoUpsertWithWhereUniqueWithoutSiteCleaningSessionInput | SiteCleaningPhotoUpsertWithWhereUniqueWithoutSiteCleaningSessionInput[]
    createMany?: SiteCleaningPhotoCreateManySiteCleaningSessionInputEnvelope
    set?: SiteCleaningPhotoWhereUniqueInput | SiteCleaningPhotoWhereUniqueInput[]
    disconnect?: SiteCleaningPhotoWhereUniqueInput | SiteCleaningPhotoWhereUniqueInput[]
    delete?: SiteCleaningPhotoWhereUniqueInput | SiteCleaningPhotoWhereUniqueInput[]
    connect?: SiteCleaningPhotoWhereUniqueInput | SiteCleaningPhotoWhereUniqueInput[]
    update?: SiteCleaningPhotoUpdateWithWhereUniqueWithoutSiteCleaningSessionInput | SiteCleaningPhotoUpdateWithWhereUniqueWithoutSiteCleaningSessionInput[]
    updateMany?: SiteCleaningPhotoUpdateManyWithWhereWithoutSiteCleaningSessionInput | SiteCleaningPhotoUpdateManyWithWhereWithoutSiteCleaningSessionInput[]
    deleteMany?: SiteCleaningPhotoScalarWhereInput | SiteCleaningPhotoScalarWhereInput[]
  }

  export type SiteCleaningChecklistUncheckedUpdateManyWithoutSiteCleaningSessionNestedInput = {
    create?: XOR<SiteCleaningChecklistCreateWithoutSiteCleaningSessionInput, SiteCleaningChecklistUncheckedCreateWithoutSiteCleaningSessionInput> | SiteCleaningChecklistCreateWithoutSiteCleaningSessionInput[] | SiteCleaningChecklistUncheckedCreateWithoutSiteCleaningSessionInput[]
    connectOrCreate?: SiteCleaningChecklistCreateOrConnectWithoutSiteCleaningSessionInput | SiteCleaningChecklistCreateOrConnectWithoutSiteCleaningSessionInput[]
    upsert?: SiteCleaningChecklistUpsertWithWhereUniqueWithoutSiteCleaningSessionInput | SiteCleaningChecklistUpsertWithWhereUniqueWithoutSiteCleaningSessionInput[]
    createMany?: SiteCleaningChecklistCreateManySiteCleaningSessionInputEnvelope
    set?: SiteCleaningChecklistWhereUniqueInput | SiteCleaningChecklistWhereUniqueInput[]
    disconnect?: SiteCleaningChecklistWhereUniqueInput | SiteCleaningChecklistWhereUniqueInput[]
    delete?: SiteCleaningChecklistWhereUniqueInput | SiteCleaningChecklistWhereUniqueInput[]
    connect?: SiteCleaningChecklistWhereUniqueInput | SiteCleaningChecklistWhereUniqueInput[]
    update?: SiteCleaningChecklistUpdateWithWhereUniqueWithoutSiteCleaningSessionInput | SiteCleaningChecklistUpdateWithWhereUniqueWithoutSiteCleaningSessionInput[]
    updateMany?: SiteCleaningChecklistUpdateManyWithWhereWithoutSiteCleaningSessionInput | SiteCleaningChecklistUpdateManyWithWhereWithoutSiteCleaningSessionInput[]
    deleteMany?: SiteCleaningChecklistScalarWhereInput | SiteCleaningChecklistScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLaundryManagersInput = {
    create?: XOR<UserCreateWithoutLaundryManagersInput, UserUncheckedCreateWithoutLaundryManagersInput>
    connectOrCreate?: UserCreateOrConnectWithoutLaundryManagersInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutLaundryManagerInput = {
    create?: XOR<ProductCreateWithoutLaundryManagerInput, ProductUncheckedCreateWithoutLaundryManagerInput> | ProductCreateWithoutLaundryManagerInput[] | ProductUncheckedCreateWithoutLaundryManagerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutLaundryManagerInput | ProductCreateOrConnectWithoutLaundryManagerInput[]
    createMany?: ProductCreateManyLaundryManagerInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutLaundryManagerInput = {
    create?: XOR<OrderCreateWithoutLaundryManagerInput, OrderUncheckedCreateWithoutLaundryManagerInput> | OrderCreateWithoutLaundryManagerInput[] | OrderUncheckedCreateWithoutLaundryManagerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLaundryManagerInput | OrderCreateOrConnectWithoutLaundryManagerInput[]
    createMany?: OrderCreateManyLaundryManagerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type DeliveryNoteCreateNestedManyWithoutLaundryManagerInput = {
    create?: XOR<DeliveryNoteCreateWithoutLaundryManagerInput, DeliveryNoteUncheckedCreateWithoutLaundryManagerInput> | DeliveryNoteCreateWithoutLaundryManagerInput[] | DeliveryNoteUncheckedCreateWithoutLaundryManagerInput[]
    connectOrCreate?: DeliveryNoteCreateOrConnectWithoutLaundryManagerInput | DeliveryNoteCreateOrConnectWithoutLaundryManagerInput[]
    createMany?: DeliveryNoteCreateManyLaundryManagerInputEnvelope
    connect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
  }

  export type SiteCleaningSessionCreateNestedManyWithoutLaundryManagerInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutLaundryManagerInput, SiteCleaningSessionUncheckedCreateWithoutLaundryManagerInput> | SiteCleaningSessionCreateWithoutLaundryManagerInput[] | SiteCleaningSessionUncheckedCreateWithoutLaundryManagerInput[]
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutLaundryManagerInput | SiteCleaningSessionCreateOrConnectWithoutLaundryManagerInput[]
    createMany?: SiteCleaningSessionCreateManyLaundryManagerInputEnvelope
    connect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutLaundryManagerInput = {
    create?: XOR<ProductCreateWithoutLaundryManagerInput, ProductUncheckedCreateWithoutLaundryManagerInput> | ProductCreateWithoutLaundryManagerInput[] | ProductUncheckedCreateWithoutLaundryManagerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutLaundryManagerInput | ProductCreateOrConnectWithoutLaundryManagerInput[]
    createMany?: ProductCreateManyLaundryManagerInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutLaundryManagerInput = {
    create?: XOR<OrderCreateWithoutLaundryManagerInput, OrderUncheckedCreateWithoutLaundryManagerInput> | OrderCreateWithoutLaundryManagerInput[] | OrderUncheckedCreateWithoutLaundryManagerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLaundryManagerInput | OrderCreateOrConnectWithoutLaundryManagerInput[]
    createMany?: OrderCreateManyLaundryManagerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type DeliveryNoteUncheckedCreateNestedManyWithoutLaundryManagerInput = {
    create?: XOR<DeliveryNoteCreateWithoutLaundryManagerInput, DeliveryNoteUncheckedCreateWithoutLaundryManagerInput> | DeliveryNoteCreateWithoutLaundryManagerInput[] | DeliveryNoteUncheckedCreateWithoutLaundryManagerInput[]
    connectOrCreate?: DeliveryNoteCreateOrConnectWithoutLaundryManagerInput | DeliveryNoteCreateOrConnectWithoutLaundryManagerInput[]
    createMany?: DeliveryNoteCreateManyLaundryManagerInputEnvelope
    connect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
  }

  export type SiteCleaningSessionUncheckedCreateNestedManyWithoutLaundryManagerInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutLaundryManagerInput, SiteCleaningSessionUncheckedCreateWithoutLaundryManagerInput> | SiteCleaningSessionCreateWithoutLaundryManagerInput[] | SiteCleaningSessionUncheckedCreateWithoutLaundryManagerInput[]
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutLaundryManagerInput | SiteCleaningSessionCreateOrConnectWithoutLaundryManagerInput[]
    createMany?: SiteCleaningSessionCreateManyLaundryManagerInputEnvelope
    connect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutLaundryManagersNestedInput = {
    create?: XOR<UserCreateWithoutLaundryManagersInput, UserUncheckedCreateWithoutLaundryManagersInput>
    connectOrCreate?: UserCreateOrConnectWithoutLaundryManagersInput
    upsert?: UserUpsertWithoutLaundryManagersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLaundryManagersInput, UserUpdateWithoutLaundryManagersInput>, UserUncheckedUpdateWithoutLaundryManagersInput>
  }

  export type ProductUpdateManyWithoutLaundryManagerNestedInput = {
    create?: XOR<ProductCreateWithoutLaundryManagerInput, ProductUncheckedCreateWithoutLaundryManagerInput> | ProductCreateWithoutLaundryManagerInput[] | ProductUncheckedCreateWithoutLaundryManagerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutLaundryManagerInput | ProductCreateOrConnectWithoutLaundryManagerInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutLaundryManagerInput | ProductUpsertWithWhereUniqueWithoutLaundryManagerInput[]
    createMany?: ProductCreateManyLaundryManagerInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutLaundryManagerInput | ProductUpdateWithWhereUniqueWithoutLaundryManagerInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutLaundryManagerInput | ProductUpdateManyWithWhereWithoutLaundryManagerInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutLaundryManagerNestedInput = {
    create?: XOR<OrderCreateWithoutLaundryManagerInput, OrderUncheckedCreateWithoutLaundryManagerInput> | OrderCreateWithoutLaundryManagerInput[] | OrderUncheckedCreateWithoutLaundryManagerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLaundryManagerInput | OrderCreateOrConnectWithoutLaundryManagerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutLaundryManagerInput | OrderUpsertWithWhereUniqueWithoutLaundryManagerInput[]
    createMany?: OrderCreateManyLaundryManagerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutLaundryManagerInput | OrderUpdateWithWhereUniqueWithoutLaundryManagerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutLaundryManagerInput | OrderUpdateManyWithWhereWithoutLaundryManagerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type DeliveryNoteUpdateManyWithoutLaundryManagerNestedInput = {
    create?: XOR<DeliveryNoteCreateWithoutLaundryManagerInput, DeliveryNoteUncheckedCreateWithoutLaundryManagerInput> | DeliveryNoteCreateWithoutLaundryManagerInput[] | DeliveryNoteUncheckedCreateWithoutLaundryManagerInput[]
    connectOrCreate?: DeliveryNoteCreateOrConnectWithoutLaundryManagerInput | DeliveryNoteCreateOrConnectWithoutLaundryManagerInput[]
    upsert?: DeliveryNoteUpsertWithWhereUniqueWithoutLaundryManagerInput | DeliveryNoteUpsertWithWhereUniqueWithoutLaundryManagerInput[]
    createMany?: DeliveryNoteCreateManyLaundryManagerInputEnvelope
    set?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    disconnect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    delete?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    connect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    update?: DeliveryNoteUpdateWithWhereUniqueWithoutLaundryManagerInput | DeliveryNoteUpdateWithWhereUniqueWithoutLaundryManagerInput[]
    updateMany?: DeliveryNoteUpdateManyWithWhereWithoutLaundryManagerInput | DeliveryNoteUpdateManyWithWhereWithoutLaundryManagerInput[]
    deleteMany?: DeliveryNoteScalarWhereInput | DeliveryNoteScalarWhereInput[]
  }

  export type SiteCleaningSessionUpdateManyWithoutLaundryManagerNestedInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutLaundryManagerInput, SiteCleaningSessionUncheckedCreateWithoutLaundryManagerInput> | SiteCleaningSessionCreateWithoutLaundryManagerInput[] | SiteCleaningSessionUncheckedCreateWithoutLaundryManagerInput[]
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutLaundryManagerInput | SiteCleaningSessionCreateOrConnectWithoutLaundryManagerInput[]
    upsert?: SiteCleaningSessionUpsertWithWhereUniqueWithoutLaundryManagerInput | SiteCleaningSessionUpsertWithWhereUniqueWithoutLaundryManagerInput[]
    createMany?: SiteCleaningSessionCreateManyLaundryManagerInputEnvelope
    set?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    disconnect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    delete?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    connect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    update?: SiteCleaningSessionUpdateWithWhereUniqueWithoutLaundryManagerInput | SiteCleaningSessionUpdateWithWhereUniqueWithoutLaundryManagerInput[]
    updateMany?: SiteCleaningSessionUpdateManyWithWhereWithoutLaundryManagerInput | SiteCleaningSessionUpdateManyWithWhereWithoutLaundryManagerInput[]
    deleteMany?: SiteCleaningSessionScalarWhereInput | SiteCleaningSessionScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutLaundryManagerNestedInput = {
    create?: XOR<ProductCreateWithoutLaundryManagerInput, ProductUncheckedCreateWithoutLaundryManagerInput> | ProductCreateWithoutLaundryManagerInput[] | ProductUncheckedCreateWithoutLaundryManagerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutLaundryManagerInput | ProductCreateOrConnectWithoutLaundryManagerInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutLaundryManagerInput | ProductUpsertWithWhereUniqueWithoutLaundryManagerInput[]
    createMany?: ProductCreateManyLaundryManagerInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutLaundryManagerInput | ProductUpdateWithWhereUniqueWithoutLaundryManagerInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutLaundryManagerInput | ProductUpdateManyWithWhereWithoutLaundryManagerInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutLaundryManagerNestedInput = {
    create?: XOR<OrderCreateWithoutLaundryManagerInput, OrderUncheckedCreateWithoutLaundryManagerInput> | OrderCreateWithoutLaundryManagerInput[] | OrderUncheckedCreateWithoutLaundryManagerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLaundryManagerInput | OrderCreateOrConnectWithoutLaundryManagerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutLaundryManagerInput | OrderUpsertWithWhereUniqueWithoutLaundryManagerInput[]
    createMany?: OrderCreateManyLaundryManagerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutLaundryManagerInput | OrderUpdateWithWhereUniqueWithoutLaundryManagerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutLaundryManagerInput | OrderUpdateManyWithWhereWithoutLaundryManagerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type DeliveryNoteUncheckedUpdateManyWithoutLaundryManagerNestedInput = {
    create?: XOR<DeliveryNoteCreateWithoutLaundryManagerInput, DeliveryNoteUncheckedCreateWithoutLaundryManagerInput> | DeliveryNoteCreateWithoutLaundryManagerInput[] | DeliveryNoteUncheckedCreateWithoutLaundryManagerInput[]
    connectOrCreate?: DeliveryNoteCreateOrConnectWithoutLaundryManagerInput | DeliveryNoteCreateOrConnectWithoutLaundryManagerInput[]
    upsert?: DeliveryNoteUpsertWithWhereUniqueWithoutLaundryManagerInput | DeliveryNoteUpsertWithWhereUniqueWithoutLaundryManagerInput[]
    createMany?: DeliveryNoteCreateManyLaundryManagerInputEnvelope
    set?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    disconnect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    delete?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    connect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    update?: DeliveryNoteUpdateWithWhereUniqueWithoutLaundryManagerInput | DeliveryNoteUpdateWithWhereUniqueWithoutLaundryManagerInput[]
    updateMany?: DeliveryNoteUpdateManyWithWhereWithoutLaundryManagerInput | DeliveryNoteUpdateManyWithWhereWithoutLaundryManagerInput[]
    deleteMany?: DeliveryNoteScalarWhereInput | DeliveryNoteScalarWhereInput[]
  }

  export type SiteCleaningSessionUncheckedUpdateManyWithoutLaundryManagerNestedInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutLaundryManagerInput, SiteCleaningSessionUncheckedCreateWithoutLaundryManagerInput> | SiteCleaningSessionCreateWithoutLaundryManagerInput[] | SiteCleaningSessionUncheckedCreateWithoutLaundryManagerInput[]
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutLaundryManagerInput | SiteCleaningSessionCreateOrConnectWithoutLaundryManagerInput[]
    upsert?: SiteCleaningSessionUpsertWithWhereUniqueWithoutLaundryManagerInput | SiteCleaningSessionUpsertWithWhereUniqueWithoutLaundryManagerInput[]
    createMany?: SiteCleaningSessionCreateManyLaundryManagerInputEnvelope
    set?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    disconnect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    delete?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    connect?: SiteCleaningSessionWhereUniqueInput | SiteCleaningSessionWhereUniqueInput[]
    update?: SiteCleaningSessionUpdateWithWhereUniqueWithoutLaundryManagerInput | SiteCleaningSessionUpdateWithWhereUniqueWithoutLaundryManagerInput[]
    updateMany?: SiteCleaningSessionUpdateManyWithWhereWithoutLaundryManagerInput | SiteCleaningSessionUpdateManyWithWhereWithoutLaundryManagerInput[]
    deleteMany?: SiteCleaningSessionScalarWhereInput | SiteCleaningSessionScalarWhereInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type LaundryManagerCreateNestedOneWithoutProductsInput = {
    create?: XOR<LaundryManagerCreateWithoutProductsInput, LaundryManagerUncheckedCreateWithoutProductsInput>
    connectOrCreate?: LaundryManagerCreateOrConnectWithoutProductsInput
    connect?: LaundryManagerWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type LaundryManagerUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<LaundryManagerCreateWithoutProductsInput, LaundryManagerUncheckedCreateWithoutProductsInput>
    connectOrCreate?: LaundryManagerCreateOrConnectWithoutProductsInput
    upsert?: LaundryManagerUpsertWithoutProductsInput
    connect?: LaundryManagerWhereUniqueInput
    update?: XOR<XOR<LaundryManagerUpdateToOneWithWhereWithoutProductsInput, LaundryManagerUpdateWithoutProductsInput>, LaundryManagerUncheckedUpdateWithoutProductsInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type LaundryManagerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<LaundryManagerCreateWithoutOrdersInput, LaundryManagerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: LaundryManagerCreateOrConnectWithoutOrdersInput
    connect?: LaundryManagerWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type DeliveryNoteCreateNestedManyWithoutOrderInput = {
    create?: XOR<DeliveryNoteCreateWithoutOrderInput, DeliveryNoteUncheckedCreateWithoutOrderInput> | DeliveryNoteCreateWithoutOrderInput[] | DeliveryNoteUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryNoteCreateOrConnectWithoutOrderInput | DeliveryNoteCreateOrConnectWithoutOrderInput[]
    createMany?: DeliveryNoteCreateManyOrderInputEnvelope
    connect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type DeliveryNoteUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<DeliveryNoteCreateWithoutOrderInput, DeliveryNoteUncheckedCreateWithoutOrderInput> | DeliveryNoteCreateWithoutOrderInput[] | DeliveryNoteUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryNoteCreateOrConnectWithoutOrderInput | DeliveryNoteCreateOrConnectWithoutOrderInput[]
    createMany?: DeliveryNoteCreateManyOrderInputEnvelope
    connect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type LaundryManagerUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<LaundryManagerCreateWithoutOrdersInput, LaundryManagerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: LaundryManagerCreateOrConnectWithoutOrdersInput
    upsert?: LaundryManagerUpsertWithoutOrdersInput
    connect?: LaundryManagerWhereUniqueInput
    update?: XOR<XOR<LaundryManagerUpdateToOneWithWhereWithoutOrdersInput, LaundryManagerUpdateWithoutOrdersInput>, LaundryManagerUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type DeliveryNoteUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DeliveryNoteCreateWithoutOrderInput, DeliveryNoteUncheckedCreateWithoutOrderInput> | DeliveryNoteCreateWithoutOrderInput[] | DeliveryNoteUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryNoteCreateOrConnectWithoutOrderInput | DeliveryNoteCreateOrConnectWithoutOrderInput[]
    upsert?: DeliveryNoteUpsertWithWhereUniqueWithoutOrderInput | DeliveryNoteUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DeliveryNoteCreateManyOrderInputEnvelope
    set?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    disconnect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    delete?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    connect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    update?: DeliveryNoteUpdateWithWhereUniqueWithoutOrderInput | DeliveryNoteUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DeliveryNoteUpdateManyWithWhereWithoutOrderInput | DeliveryNoteUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DeliveryNoteScalarWhereInput | DeliveryNoteScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type DeliveryNoteUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DeliveryNoteCreateWithoutOrderInput, DeliveryNoteUncheckedCreateWithoutOrderInput> | DeliveryNoteCreateWithoutOrderInput[] | DeliveryNoteUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryNoteCreateOrConnectWithoutOrderInput | DeliveryNoteCreateOrConnectWithoutOrderInput[]
    upsert?: DeliveryNoteUpsertWithWhereUniqueWithoutOrderInput | DeliveryNoteUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DeliveryNoteCreateManyOrderInputEnvelope
    set?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    disconnect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    delete?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    connect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    update?: DeliveryNoteUpdateWithWhereUniqueWithoutOrderInput | DeliveryNoteUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DeliveryNoteUpdateManyWithWhereWithoutOrderInput | DeliveryNoteUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DeliveryNoteScalarWhereInput | DeliveryNoteScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutTicketsInput = {
    create?: XOR<PropertyCreateWithoutTicketsInput, PropertyUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutTicketsInput
    connect?: PropertyWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutTicketsInput = {
    create?: XOR<AgentCreateWithoutTicketsInput, AgentUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTicketsInput
    connect?: AgentWhereUniqueInput
  }

  export type TicketPhotoCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketPhotoCreateWithoutTicketInput, TicketPhotoUncheckedCreateWithoutTicketInput> | TicketPhotoCreateWithoutTicketInput[] | TicketPhotoUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketPhotoCreateOrConnectWithoutTicketInput | TicketPhotoCreateOrConnectWithoutTicketInput[]
    createMany?: TicketPhotoCreateManyTicketInputEnvelope
    connect?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
  }

  export type TicketPhotoUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketPhotoCreateWithoutTicketInput, TicketPhotoUncheckedCreateWithoutTicketInput> | TicketPhotoCreateWithoutTicketInput[] | TicketPhotoUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketPhotoCreateOrConnectWithoutTicketInput | TicketPhotoCreateOrConnectWithoutTicketInput[]
    createMany?: TicketPhotoCreateManyTicketInputEnvelope
    connect?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type PropertyUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<PropertyCreateWithoutTicketsInput, PropertyUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutTicketsInput
    upsert?: PropertyUpsertWithoutTicketsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutTicketsInput, PropertyUpdateWithoutTicketsInput>, PropertyUncheckedUpdateWithoutTicketsInput>
  }

  export type AgentUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<AgentCreateWithoutTicketsInput, AgentUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTicketsInput
    upsert?: AgentUpsertWithoutTicketsInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutTicketsInput, AgentUpdateWithoutTicketsInput>, AgentUncheckedUpdateWithoutTicketsInput>
  }

  export type TicketPhotoUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketPhotoCreateWithoutTicketInput, TicketPhotoUncheckedCreateWithoutTicketInput> | TicketPhotoCreateWithoutTicketInput[] | TicketPhotoUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketPhotoCreateOrConnectWithoutTicketInput | TicketPhotoCreateOrConnectWithoutTicketInput[]
    upsert?: TicketPhotoUpsertWithWhereUniqueWithoutTicketInput | TicketPhotoUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketPhotoCreateManyTicketInputEnvelope
    set?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
    disconnect?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
    delete?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
    connect?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
    update?: TicketPhotoUpdateWithWhereUniqueWithoutTicketInput | TicketPhotoUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketPhotoUpdateManyWithWhereWithoutTicketInput | TicketPhotoUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketPhotoScalarWhereInput | TicketPhotoScalarWhereInput[]
  }

  export type TicketPhotoUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketPhotoCreateWithoutTicketInput, TicketPhotoUncheckedCreateWithoutTicketInput> | TicketPhotoCreateWithoutTicketInput[] | TicketPhotoUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketPhotoCreateOrConnectWithoutTicketInput | TicketPhotoCreateOrConnectWithoutTicketInput[]
    upsert?: TicketPhotoUpsertWithWhereUniqueWithoutTicketInput | TicketPhotoUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketPhotoCreateManyTicketInputEnvelope
    set?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
    disconnect?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
    delete?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
    connect?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
    update?: TicketPhotoUpdateWithWhereUniqueWithoutTicketInput | TicketPhotoUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketPhotoUpdateManyWithWhereWithoutTicketInput | TicketPhotoUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketPhotoScalarWhereInput | TicketPhotoScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<PropertyCreateWithoutPaymentsInput, PropertyUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPaymentsInput
    connect?: PropertyWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PropertyUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<PropertyCreateWithoutPaymentsInput, PropertyUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPaymentsInput
    upsert?: PropertyUpsertWithoutPaymentsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPaymentsInput, PropertyUpdateWithoutPaymentsInput>, PropertyUncheckedUpdateWithoutPaymentsInput>
  }

  export type PropertyCreateNestedOneWithoutPhotosInput = {
    create?: XOR<PropertyCreateWithoutPhotosInput, PropertyUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPhotosInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<PropertyCreateWithoutPhotosInput, PropertyUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPhotosInput
    upsert?: PropertyUpsertWithoutPhotosInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPhotosInput, PropertyUpdateWithoutPhotosInput>, PropertyUncheckedUpdateWithoutPhotosInput>
  }

  export type CleaningSessionCreateNestedOneWithoutPhotosInput = {
    create?: XOR<CleaningSessionCreateWithoutPhotosInput, CleaningSessionUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutPhotosInput
    connect?: CleaningSessionWhereUniqueInput
  }

  export type CleaningSessionUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<CleaningSessionCreateWithoutPhotosInput, CleaningSessionUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutPhotosInput
    upsert?: CleaningSessionUpsertWithoutPhotosInput
    connect?: CleaningSessionWhereUniqueInput
    update?: XOR<XOR<CleaningSessionUpdateToOneWithWhereWithoutPhotosInput, CleaningSessionUpdateWithoutPhotosInput>, CleaningSessionUncheckedUpdateWithoutPhotosInput>
  }

  export type MaintenanceSessionCreateNestedOneWithoutPhotosInput = {
    create?: XOR<MaintenanceSessionCreateWithoutPhotosInput, MaintenanceSessionUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutPhotosInput
    connect?: MaintenanceSessionWhereUniqueInput
  }

  export type MaintenanceSessionUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<MaintenanceSessionCreateWithoutPhotosInput, MaintenanceSessionUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutPhotosInput
    upsert?: MaintenanceSessionUpsertWithoutPhotosInput
    connect?: MaintenanceSessionWhereUniqueInput
    update?: XOR<XOR<MaintenanceSessionUpdateToOneWithWhereWithoutPhotosInput, MaintenanceSessionUpdateWithoutPhotosInput>, MaintenanceSessionUncheckedUpdateWithoutPhotosInput>
  }

  export type SiteCleaningSessionCreateNestedOneWithoutPhotosInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutPhotosInput, SiteCleaningSessionUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutPhotosInput
    connect?: SiteCleaningSessionWhereUniqueInput
  }

  export type SiteCleaningSessionUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutPhotosInput, SiteCleaningSessionUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutPhotosInput
    upsert?: SiteCleaningSessionUpsertWithoutPhotosInput
    connect?: SiteCleaningSessionWhereUniqueInput
    update?: XOR<XOR<SiteCleaningSessionUpdateToOneWithWhereWithoutPhotosInput, SiteCleaningSessionUpdateWithoutPhotosInput>, SiteCleaningSessionUncheckedUpdateWithoutPhotosInput>
  }

  export type TicketCreateNestedOneWithoutPhotosInput = {
    create?: XOR<TicketCreateWithoutPhotosInput, TicketUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: TicketCreateOrConnectWithoutPhotosInput
    connect?: TicketWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<TicketCreateWithoutPhotosInput, TicketUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: TicketCreateOrConnectWithoutPhotosInput
    upsert?: TicketUpsertWithoutPhotosInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutPhotosInput, TicketUpdateWithoutPhotosInput>, TicketUncheckedUpdateWithoutPhotosInput>
  }

  export type CleaningSessionCreateNestedOneWithoutChecklistInput = {
    create?: XOR<CleaningSessionCreateWithoutChecklistInput, CleaningSessionUncheckedCreateWithoutChecklistInput>
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutChecklistInput
    connect?: CleaningSessionWhereUniqueInput
  }

  export type CleaningSessionUpdateOneRequiredWithoutChecklistNestedInput = {
    create?: XOR<CleaningSessionCreateWithoutChecklistInput, CleaningSessionUncheckedCreateWithoutChecklistInput>
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutChecklistInput
    upsert?: CleaningSessionUpsertWithoutChecklistInput
    connect?: CleaningSessionWhereUniqueInput
    update?: XOR<XOR<CleaningSessionUpdateToOneWithWhereWithoutChecklistInput, CleaningSessionUpdateWithoutChecklistInput>, CleaningSessionUncheckedUpdateWithoutChecklistInput>
  }

  export type SiteCleaningSessionCreateNestedOneWithoutChecklistInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutChecklistInput, SiteCleaningSessionUncheckedCreateWithoutChecklistInput>
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutChecklistInput
    connect?: SiteCleaningSessionWhereUniqueInput
  }

  export type SiteCleaningSessionUpdateOneRequiredWithoutChecklistNestedInput = {
    create?: XOR<SiteCleaningSessionCreateWithoutChecklistInput, SiteCleaningSessionUncheckedCreateWithoutChecklistInput>
    connectOrCreate?: SiteCleaningSessionCreateOrConnectWithoutChecklistInput
    upsert?: SiteCleaningSessionUpsertWithoutChecklistInput
    connect?: SiteCleaningSessionWhereUniqueInput
    update?: XOR<XOR<SiteCleaningSessionUpdateToOneWithWhereWithoutChecklistInput, SiteCleaningSessionUpdateWithoutChecklistInput>, SiteCleaningSessionUncheckedUpdateWithoutChecklistInput>
  }

  export type InterventionSiteCreateNestedOneWithoutCleaningPlanningsInput = {
    create?: XOR<InterventionSiteCreateWithoutCleaningPlanningsInput, InterventionSiteUncheckedCreateWithoutCleaningPlanningsInput>
    connectOrCreate?: InterventionSiteCreateOrConnectWithoutCleaningPlanningsInput
    connect?: InterventionSiteWhereUniqueInput
  }

  export type CleaningManagerCreateNestedOneWithoutCleaningPlanningsInput = {
    create?: XOR<CleaningManagerCreateWithoutCleaningPlanningsInput, CleaningManagerUncheckedCreateWithoutCleaningPlanningsInput>
    connectOrCreate?: CleaningManagerCreateOrConnectWithoutCleaningPlanningsInput
    connect?: CleaningManagerWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutCleaningPlanningsInput = {
    create?: XOR<AgentCreateWithoutCleaningPlanningsInput, AgentUncheckedCreateWithoutCleaningPlanningsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutCleaningPlanningsInput
    connect?: AgentWhereUniqueInput
  }

  export type InterventionSiteUpdateOneRequiredWithoutCleaningPlanningsNestedInput = {
    create?: XOR<InterventionSiteCreateWithoutCleaningPlanningsInput, InterventionSiteUncheckedCreateWithoutCleaningPlanningsInput>
    connectOrCreate?: InterventionSiteCreateOrConnectWithoutCleaningPlanningsInput
    upsert?: InterventionSiteUpsertWithoutCleaningPlanningsInput
    connect?: InterventionSiteWhereUniqueInput
    update?: XOR<XOR<InterventionSiteUpdateToOneWithWhereWithoutCleaningPlanningsInput, InterventionSiteUpdateWithoutCleaningPlanningsInput>, InterventionSiteUncheckedUpdateWithoutCleaningPlanningsInput>
  }

  export type CleaningManagerUpdateOneRequiredWithoutCleaningPlanningsNestedInput = {
    create?: XOR<CleaningManagerCreateWithoutCleaningPlanningsInput, CleaningManagerUncheckedCreateWithoutCleaningPlanningsInput>
    connectOrCreate?: CleaningManagerCreateOrConnectWithoutCleaningPlanningsInput
    upsert?: CleaningManagerUpsertWithoutCleaningPlanningsInput
    connect?: CleaningManagerWhereUniqueInput
    update?: XOR<XOR<CleaningManagerUpdateToOneWithWhereWithoutCleaningPlanningsInput, CleaningManagerUpdateWithoutCleaningPlanningsInput>, CleaningManagerUncheckedUpdateWithoutCleaningPlanningsInput>
  }

  export type AgentUpdateOneWithoutCleaningPlanningsNestedInput = {
    create?: XOR<AgentCreateWithoutCleaningPlanningsInput, AgentUncheckedCreateWithoutCleaningPlanningsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutCleaningPlanningsInput
    upsert?: AgentUpsertWithoutCleaningPlanningsInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutCleaningPlanningsInput, AgentUpdateWithoutCleaningPlanningsInput>, AgentUncheckedUpdateWithoutCleaningPlanningsInput>
  }

  export type OrderCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    upsert?: OrderUpsertWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderItemsInput, OrderUpdateWithoutOrderItemsInput>, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderCreateNestedOneWithoutDeliveryNotesInput = {
    create?: XOR<OrderCreateWithoutDeliveryNotesInput, OrderUncheckedCreateWithoutDeliveryNotesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryNotesInput
    connect?: OrderWhereUniqueInput
  }

  export type LaundryManagerCreateNestedOneWithoutDeliveryNotesInput = {
    create?: XOR<LaundryManagerCreateWithoutDeliveryNotesInput, LaundryManagerUncheckedCreateWithoutDeliveryNotesInput>
    connectOrCreate?: LaundryManagerCreateOrConnectWithoutDeliveryNotesInput
    connect?: LaundryManagerWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutDeliveryNotesNestedInput = {
    create?: XOR<OrderCreateWithoutDeliveryNotesInput, OrderUncheckedCreateWithoutDeliveryNotesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryNotesInput
    upsert?: OrderUpsertWithoutDeliveryNotesInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutDeliveryNotesInput, OrderUpdateWithoutDeliveryNotesInput>, OrderUncheckedUpdateWithoutDeliveryNotesInput>
  }

  export type LaundryManagerUpdateOneRequiredWithoutDeliveryNotesNestedInput = {
    create?: XOR<LaundryManagerCreateWithoutDeliveryNotesInput, LaundryManagerUncheckedCreateWithoutDeliveryNotesInput>
    connectOrCreate?: LaundryManagerCreateOrConnectWithoutDeliveryNotesInput
    upsert?: LaundryManagerUpsertWithoutDeliveryNotesInput
    connect?: LaundryManagerWhereUniqueInput
    update?: XOR<XOR<LaundryManagerUpdateToOneWithWhereWithoutDeliveryNotesInput, LaundryManagerUpdateWithoutDeliveryNotesInput>, LaundryManagerUncheckedUpdateWithoutDeliveryNotesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type ServiceUserCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceUserCreateWithoutServiceInput, ServiceUserUncheckedCreateWithoutServiceInput> | ServiceUserCreateWithoutServiceInput[] | ServiceUserUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceUserCreateOrConnectWithoutServiceInput | ServiceUserCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceUserCreateManyServiceInputEnvelope
    connect?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
  }

  export type ServiceUserUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceUserCreateWithoutServiceInput, ServiceUserUncheckedCreateWithoutServiceInput> | ServiceUserCreateWithoutServiceInput[] | ServiceUserUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceUserCreateOrConnectWithoutServiceInput | ServiceUserCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceUserCreateManyServiceInputEnvelope
    connect?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
  }

  export type ServiceUserUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceUserCreateWithoutServiceInput, ServiceUserUncheckedCreateWithoutServiceInput> | ServiceUserCreateWithoutServiceInput[] | ServiceUserUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceUserCreateOrConnectWithoutServiceInput | ServiceUserCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceUserUpsertWithWhereUniqueWithoutServiceInput | ServiceUserUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceUserCreateManyServiceInputEnvelope
    set?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
    disconnect?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
    delete?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
    connect?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
    update?: ServiceUserUpdateWithWhereUniqueWithoutServiceInput | ServiceUserUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceUserUpdateManyWithWhereWithoutServiceInput | ServiceUserUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceUserScalarWhereInput | ServiceUserScalarWhereInput[]
  }

  export type ServiceUserUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceUserCreateWithoutServiceInput, ServiceUserUncheckedCreateWithoutServiceInput> | ServiceUserCreateWithoutServiceInput[] | ServiceUserUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceUserCreateOrConnectWithoutServiceInput | ServiceUserCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceUserUpsertWithWhereUniqueWithoutServiceInput | ServiceUserUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceUserCreateManyServiceInputEnvelope
    set?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
    disconnect?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
    delete?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
    connect?: ServiceUserWhereUniqueInput | ServiceUserWhereUniqueInput[]
    update?: ServiceUserUpdateWithWhereUniqueWithoutServiceInput | ServiceUserUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceUserUpdateManyWithWhereWithoutServiceInput | ServiceUserUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceUserScalarWhereInput | ServiceUserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutServiceUsersInput = {
    create?: XOR<UserCreateWithoutServiceUsersInput, UserUncheckedCreateWithoutServiceUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceUsersInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutUsersInput = {
    create?: XOR<ServiceCreateWithoutUsersInput, ServiceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutUsersInput
    connect?: ServiceWhereUniqueInput
  }

  export type EnumServiceUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.ServiceUserStatus
  }

  export type UserUpdateOneRequiredWithoutServiceUsersNestedInput = {
    create?: XOR<UserCreateWithoutServiceUsersInput, UserUncheckedCreateWithoutServiceUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceUsersInput
    upsert?: UserUpsertWithoutServiceUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServiceUsersInput, UserUpdateWithoutServiceUsersInput>, UserUncheckedUpdateWithoutServiceUsersInput>
  }

  export type ServiceUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<ServiceCreateWithoutUsersInput, ServiceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutUsersInput
    upsert?: ServiceUpsertWithoutUsersInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutUsersInput, ServiceUpdateWithoutUsersInput>, ServiceUncheckedUpdateWithoutUsersInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumPropertyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusFilter<$PrismaModel> | $Enums.PropertyStatus
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel> | $Enums.PropertyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyStatusFilter<$PrismaModel>
    _max?: NestedEnumPropertyStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumAgentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentTypeFilter<$PrismaModel> | $Enums.AgentType
  }

  export type NestedEnumAgentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AgentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentTypeFilter<$PrismaModel>
    _max?: NestedEnumAgentTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumInterventionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionStatus | EnumInterventionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionStatusFilter<$PrismaModel> | $Enums.InterventionStatus
  }

  export type NestedEnumInterventionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionStatus | EnumInterventionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionStatusWithAggregatesFilter<$PrismaModel> | $Enums.InterventionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterventionStatusFilter<$PrismaModel>
    _max?: NestedEnumInterventionStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumServiceUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceUserStatus | EnumServiceUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceUserStatus[] | ListEnumServiceUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceUserStatus[] | ListEnumServiceUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceUserStatusFilter<$PrismaModel> | $Enums.ServiceUserStatus
  }

  export type NestedEnumServiceUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceUserStatus | EnumServiceUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceUserStatus[] | ListEnumServiceUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceUserStatus[] | ListEnumServiceUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceUserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceUserStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceUserStatusFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConciergerieManagerCreateWithoutUserInput = {
    id?: string
    name: string
    createdAt: Date | string
    updatedAt: Date | string
    properties?: PropertyCreateNestedManyWithoutConciergerieManagerInput
    agents?: AgentCreateNestedManyWithoutConciergerieManagerInput
    tasks?: TaskCreateNestedManyWithoutConciergerieManagerInput
  }

  export type ConciergerieManagerUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    createdAt: Date | string
    updatedAt: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutConciergerieManagerInput
    agents?: AgentUncheckedCreateNestedManyWithoutConciergerieManagerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutConciergerieManagerInput
  }

  export type ConciergerieManagerCreateOrConnectWithoutUserInput = {
    where: ConciergerieManagerWhereUniqueInput
    create: XOR<ConciergerieManagerCreateWithoutUserInput, ConciergerieManagerUncheckedCreateWithoutUserInput>
  }

  export type ConciergerieManagerCreateManyUserInputEnvelope = {
    data: ConciergerieManagerCreateManyUserInput | ConciergerieManagerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CleaningManagerCreateWithoutUserInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    interventionSites?: InterventionSiteCreateNestedManyWithoutCleaningManagerInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutCleaningManagerInput
    cleaningAgents?: AgentCreateNestedManyWithoutCleaningManagerInput
    cleaningPlannings?: CleaningPlanningCreateNestedManyWithoutCleaningManagerInput
  }

  export type CleaningManagerUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    interventionSites?: InterventionSiteUncheckedCreateNestedManyWithoutCleaningManagerInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutCleaningManagerInput
    cleaningAgents?: AgentUncheckedCreateNestedManyWithoutCleaningManagerInput
    cleaningPlannings?: CleaningPlanningUncheckedCreateNestedManyWithoutCleaningManagerInput
  }

  export type CleaningManagerCreateOrConnectWithoutUserInput = {
    where: CleaningManagerWhereUniqueInput
    create: XOR<CleaningManagerCreateWithoutUserInput, CleaningManagerUncheckedCreateWithoutUserInput>
  }

  export type CleaningManagerCreateManyUserInputEnvelope = {
    data: CleaningManagerCreateManyUserInput | CleaningManagerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LaundryManagerCreateWithoutUserInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    products?: ProductCreateNestedManyWithoutLaundryManagerInput
    orders?: OrderCreateNestedManyWithoutLaundryManagerInput
    deliveryNotes?: DeliveryNoteCreateNestedManyWithoutLaundryManagerInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutLaundryManagerInput
  }

  export type LaundryManagerUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutLaundryManagerInput
    orders?: OrderUncheckedCreateNestedManyWithoutLaundryManagerInput
    deliveryNotes?: DeliveryNoteUncheckedCreateNestedManyWithoutLaundryManagerInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutLaundryManagerInput
  }

  export type LaundryManagerCreateOrConnectWithoutUserInput = {
    where: LaundryManagerWhereUniqueInput
    create: XOR<LaundryManagerCreateWithoutUserInput, LaundryManagerUncheckedCreateWithoutUserInput>
  }

  export type LaundryManagerCreateManyUserInputEnvelope = {
    data: LaundryManagerCreateManyUserInput | LaundryManagerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type?: string | null
    read?: boolean
    createdAt: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type?: string | null
    read?: boolean
    createdAt: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUserCreateWithoutUserInput = {
    id?: string
    name: string
    status?: $Enums.ServiceUserStatus
    service: ServiceCreateNestedOneWithoutUsersInput
  }

  export type ServiceUserUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    status?: $Enums.ServiceUserStatus
    serviceId: string
  }

  export type ServiceUserCreateOrConnectWithoutUserInput = {
    where: ServiceUserWhereUniqueInput
    create: XOR<ServiceUserCreateWithoutUserInput, ServiceUserUncheckedCreateWithoutUserInput>
  }

  export type ServiceUserCreateManyUserInputEnvelope = {
    data: ServiceUserCreateManyUserInput | ServiceUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AgentCreateWithoutUserInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutAgentInput
    conciergerieManager: ConciergerieManagerCreateNestedOneWithoutAgentsInput
    tasks?: TaskCreateNestedManyWithoutAgentInput
    tickets?: TicketCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningCreateNestedManyWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutCleaningAgentInput
    cleaningManager?: CleaningManagerCreateNestedOneWithoutCleaningAgentsInput
  }

  export type AgentUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    conciergerieManagerId: string
    cleaningManagerId?: string | null
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutAgentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAgentInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningUncheckedCreateNestedManyWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutCleaningAgentInput
  }

  export type AgentCreateOrConnectWithoutUserInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
  }

  export type AgentCreateManyUserInputEnvelope = {
    data: AgentCreateManyUserInput | AgentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type ConciergerieManagerUpsertWithWhereUniqueWithoutUserInput = {
    where: ConciergerieManagerWhereUniqueInput
    update: XOR<ConciergerieManagerUpdateWithoutUserInput, ConciergerieManagerUncheckedUpdateWithoutUserInput>
    create: XOR<ConciergerieManagerCreateWithoutUserInput, ConciergerieManagerUncheckedCreateWithoutUserInput>
  }

  export type ConciergerieManagerUpdateWithWhereUniqueWithoutUserInput = {
    where: ConciergerieManagerWhereUniqueInput
    data: XOR<ConciergerieManagerUpdateWithoutUserInput, ConciergerieManagerUncheckedUpdateWithoutUserInput>
  }

  export type ConciergerieManagerUpdateManyWithWhereWithoutUserInput = {
    where: ConciergerieManagerScalarWhereInput
    data: XOR<ConciergerieManagerUpdateManyMutationInput, ConciergerieManagerUncheckedUpdateManyWithoutUserInput>
  }

  export type ConciergerieManagerScalarWhereInput = {
    AND?: ConciergerieManagerScalarWhereInput | ConciergerieManagerScalarWhereInput[]
    OR?: ConciergerieManagerScalarWhereInput[]
    NOT?: ConciergerieManagerScalarWhereInput | ConciergerieManagerScalarWhereInput[]
    id?: StringFilter<"ConciergerieManager"> | string
    name?: StringFilter<"ConciergerieManager"> | string
    userId?: StringFilter<"ConciergerieManager"> | string
    createdAt?: DateTimeFilter<"ConciergerieManager"> | Date | string
    updatedAt?: DateTimeFilter<"ConciergerieManager"> | Date | string
  }

  export type CleaningManagerUpsertWithWhereUniqueWithoutUserInput = {
    where: CleaningManagerWhereUniqueInput
    update: XOR<CleaningManagerUpdateWithoutUserInput, CleaningManagerUncheckedUpdateWithoutUserInput>
    create: XOR<CleaningManagerCreateWithoutUserInput, CleaningManagerUncheckedCreateWithoutUserInput>
  }

  export type CleaningManagerUpdateWithWhereUniqueWithoutUserInput = {
    where: CleaningManagerWhereUniqueInput
    data: XOR<CleaningManagerUpdateWithoutUserInput, CleaningManagerUncheckedUpdateWithoutUserInput>
  }

  export type CleaningManagerUpdateManyWithWhereWithoutUserInput = {
    where: CleaningManagerScalarWhereInput
    data: XOR<CleaningManagerUpdateManyMutationInput, CleaningManagerUncheckedUpdateManyWithoutUserInput>
  }

  export type CleaningManagerScalarWhereInput = {
    AND?: CleaningManagerScalarWhereInput | CleaningManagerScalarWhereInput[]
    OR?: CleaningManagerScalarWhereInput[]
    NOT?: CleaningManagerScalarWhereInput | CleaningManagerScalarWhereInput[]
    id?: StringFilter<"CleaningManager"> | string
    userId?: StringFilter<"CleaningManager"> | string
    createdAt?: DateTimeFilter<"CleaningManager"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningManager"> | Date | string
  }

  export type LaundryManagerUpsertWithWhereUniqueWithoutUserInput = {
    where: LaundryManagerWhereUniqueInput
    update: XOR<LaundryManagerUpdateWithoutUserInput, LaundryManagerUncheckedUpdateWithoutUserInput>
    create: XOR<LaundryManagerCreateWithoutUserInput, LaundryManagerUncheckedCreateWithoutUserInput>
  }

  export type LaundryManagerUpdateWithWhereUniqueWithoutUserInput = {
    where: LaundryManagerWhereUniqueInput
    data: XOR<LaundryManagerUpdateWithoutUserInput, LaundryManagerUncheckedUpdateWithoutUserInput>
  }

  export type LaundryManagerUpdateManyWithWhereWithoutUserInput = {
    where: LaundryManagerScalarWhereInput
    data: XOR<LaundryManagerUpdateManyMutationInput, LaundryManagerUncheckedUpdateManyWithoutUserInput>
  }

  export type LaundryManagerScalarWhereInput = {
    AND?: LaundryManagerScalarWhereInput | LaundryManagerScalarWhereInput[]
    OR?: LaundryManagerScalarWhereInput[]
    NOT?: LaundryManagerScalarWhereInput | LaundryManagerScalarWhereInput[]
    id?: StringFilter<"LaundryManager"> | string
    userId?: StringFilter<"LaundryManager"> | string
    createdAt?: DateTimeFilter<"LaundryManager"> | Date | string
    updatedAt?: DateTimeFilter<"LaundryManager"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringNullableFilter<"Notification"> | string | null
    userId?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ServiceUserUpsertWithWhereUniqueWithoutUserInput = {
    where: ServiceUserWhereUniqueInput
    update: XOR<ServiceUserUpdateWithoutUserInput, ServiceUserUncheckedUpdateWithoutUserInput>
    create: XOR<ServiceUserCreateWithoutUserInput, ServiceUserUncheckedCreateWithoutUserInput>
  }

  export type ServiceUserUpdateWithWhereUniqueWithoutUserInput = {
    where: ServiceUserWhereUniqueInput
    data: XOR<ServiceUserUpdateWithoutUserInput, ServiceUserUncheckedUpdateWithoutUserInput>
  }

  export type ServiceUserUpdateManyWithWhereWithoutUserInput = {
    where: ServiceUserScalarWhereInput
    data: XOR<ServiceUserUpdateManyMutationInput, ServiceUserUncheckedUpdateManyWithoutUserInput>
  }

  export type ServiceUserScalarWhereInput = {
    AND?: ServiceUserScalarWhereInput | ServiceUserScalarWhereInput[]
    OR?: ServiceUserScalarWhereInput[]
    NOT?: ServiceUserScalarWhereInput | ServiceUserScalarWhereInput[]
    id?: StringFilter<"ServiceUser"> | string
    name?: StringFilter<"ServiceUser"> | string
    status?: EnumServiceUserStatusFilter<"ServiceUser"> | $Enums.ServiceUserStatus
    serviceId?: StringFilter<"ServiceUser"> | string
    userId?: StringFilter<"ServiceUser"> | string
  }

  export type AgentUpsertWithWhereUniqueWithoutUserInput = {
    where: AgentWhereUniqueInput
    update: XOR<AgentUpdateWithoutUserInput, AgentUncheckedUpdateWithoutUserInput>
    create: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
  }

  export type AgentUpdateWithWhereUniqueWithoutUserInput = {
    where: AgentWhereUniqueInput
    data: XOR<AgentUpdateWithoutUserInput, AgentUncheckedUpdateWithoutUserInput>
  }

  export type AgentUpdateManyWithWhereWithoutUserInput = {
    where: AgentScalarWhereInput
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyWithoutUserInput>
  }

  export type AgentScalarWhereInput = {
    AND?: AgentScalarWhereInput | AgentScalarWhereInput[]
    OR?: AgentScalarWhereInput[]
    NOT?: AgentScalarWhereInput | AgentScalarWhereInput[]
    id?: StringFilter<"Agent"> | string
    name?: StringFilter<"Agent"> | string
    description?: StringFilter<"Agent"> | string
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    type?: EnumAgentTypeFilter<"Agent"> | $Enums.AgentType
    conciergerieManagerId?: StringFilter<"Agent"> | string
    userId?: StringFilter<"Agent"> | string
    cleaningManagerId?: StringNullableFilter<"Agent"> | string | null
  }

  export type UserCreateWithoutConciergerieManagersInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    cleaningManagers?: CleaningManagerCreateNestedManyWithoutUserInput
    laundryManagers?: LaundryManagerCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    serviceUsers?: ServiceUserCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConciergerieManagersInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    cleaningManagers?: CleaningManagerUncheckedCreateNestedManyWithoutUserInput
    laundryManagers?: LaundryManagerUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    serviceUsers?: ServiceUserUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConciergerieManagersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConciergerieManagersInput, UserUncheckedCreateWithoutConciergerieManagersInput>
  }

  export type PropertyCreateWithoutConciergerieManagerInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutPropertyInput
    reservations?: ReservationCreateNestedManyWithoutPropertyInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    tickets?: TicketCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutConciergerieManagerInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutConciergerieManagerInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutConciergerieManagerInput, PropertyUncheckedCreateWithoutConciergerieManagerInput>
  }

  export type PropertyCreateManyConciergerieManagerInputEnvelope = {
    data: PropertyCreateManyConciergerieManagerInput | PropertyCreateManyConciergerieManagerInput[]
    skipDuplicates?: boolean
  }

  export type AgentCreateWithoutConciergerieManagerInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutAgentInput
    tasks?: TaskCreateNestedManyWithoutAgentInput
    tickets?: TicketCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningCreateNestedManyWithoutAgentInput
    user: UserCreateNestedOneWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutCleaningAgentInput
    cleaningManager?: CleaningManagerCreateNestedOneWithoutCleaningAgentsInput
  }

  export type AgentUncheckedCreateWithoutConciergerieManagerInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    userId: string
    cleaningManagerId?: string | null
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutAgentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAgentInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningUncheckedCreateNestedManyWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutCleaningAgentInput
  }

  export type AgentCreateOrConnectWithoutConciergerieManagerInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutConciergerieManagerInput, AgentUncheckedCreateWithoutConciergerieManagerInput>
  }

  export type AgentCreateManyConciergerieManagerInputEnvelope = {
    data: AgentCreateManyConciergerieManagerInput | AgentCreateManyConciergerieManagerInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutConciergerieManagerInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    agent?: AgentCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutConciergerieManagerInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    agentId?: string | null
  }

  export type TaskCreateOrConnectWithoutConciergerieManagerInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutConciergerieManagerInput, TaskUncheckedCreateWithoutConciergerieManagerInput>
  }

  export type TaskCreateManyConciergerieManagerInputEnvelope = {
    data: TaskCreateManyConciergerieManagerInput | TaskCreateManyConciergerieManagerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutConciergerieManagersInput = {
    update: XOR<UserUpdateWithoutConciergerieManagersInput, UserUncheckedUpdateWithoutConciergerieManagersInput>
    create: XOR<UserCreateWithoutConciergerieManagersInput, UserUncheckedCreateWithoutConciergerieManagersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConciergerieManagersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConciergerieManagersInput, UserUncheckedUpdateWithoutConciergerieManagersInput>
  }

  export type UserUpdateWithoutConciergerieManagersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    cleaningManagers?: CleaningManagerUpdateManyWithoutUserNestedInput
    laundryManagers?: LaundryManagerUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    serviceUsers?: ServiceUserUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConciergerieManagersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    cleaningManagers?: CleaningManagerUncheckedUpdateManyWithoutUserNestedInput
    laundryManagers?: LaundryManagerUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    serviceUsers?: ServiceUserUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PropertyUpsertWithWhereUniqueWithoutConciergerieManagerInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutConciergerieManagerInput, PropertyUncheckedUpdateWithoutConciergerieManagerInput>
    create: XOR<PropertyCreateWithoutConciergerieManagerInput, PropertyUncheckedCreateWithoutConciergerieManagerInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutConciergerieManagerInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutConciergerieManagerInput, PropertyUncheckedUpdateWithoutConciergerieManagerInput>
  }

  export type PropertyUpdateManyWithWhereWithoutConciergerieManagerInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutConciergerieManagerInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    OR?: PropertyScalarWhereInput[]
    NOT?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    id?: StringFilter<"Property"> | string
    name?: StringFilter<"Property"> | string
    description?: StringFilter<"Property"> | string
    status?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    location?: StringNullableFilter<"Property"> | string | null
    surface?: FloatNullableFilter<"Property"> | number | null
    numberOfRooms?: IntNullableFilter<"Property"> | number | null
    numberOfBathrooms?: IntNullableFilter<"Property"> | number | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    conciergerieManagerId?: StringFilter<"Property"> | string
  }

  export type AgentUpsertWithWhereUniqueWithoutConciergerieManagerInput = {
    where: AgentWhereUniqueInput
    update: XOR<AgentUpdateWithoutConciergerieManagerInput, AgentUncheckedUpdateWithoutConciergerieManagerInput>
    create: XOR<AgentCreateWithoutConciergerieManagerInput, AgentUncheckedCreateWithoutConciergerieManagerInput>
  }

  export type AgentUpdateWithWhereUniqueWithoutConciergerieManagerInput = {
    where: AgentWhereUniqueInput
    data: XOR<AgentUpdateWithoutConciergerieManagerInput, AgentUncheckedUpdateWithoutConciergerieManagerInput>
  }

  export type AgentUpdateManyWithWhereWithoutConciergerieManagerInput = {
    where: AgentScalarWhereInput
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyWithoutConciergerieManagerInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutConciergerieManagerInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutConciergerieManagerInput, TaskUncheckedUpdateWithoutConciergerieManagerInput>
    create: XOR<TaskCreateWithoutConciergerieManagerInput, TaskUncheckedCreateWithoutConciergerieManagerInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutConciergerieManagerInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutConciergerieManagerInput, TaskUncheckedUpdateWithoutConciergerieManagerInput>
  }

  export type TaskUpdateManyWithWhereWithoutConciergerieManagerInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutConciergerieManagerInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    name?: StringFilter<"Task"> | string
    description?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    conciergerieManagerId?: StringNullableFilter<"Task"> | string | null
    agentId?: StringNullableFilter<"Task"> | string | null
  }

  export type ConciergerieManagerCreateWithoutTasksInput = {
    id?: string
    name: string
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutConciergerieManagersInput
    properties?: PropertyCreateNestedManyWithoutConciergerieManagerInput
    agents?: AgentCreateNestedManyWithoutConciergerieManagerInput
  }

  export type ConciergerieManagerUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    userId: string
    createdAt: Date | string
    updatedAt: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutConciergerieManagerInput
    agents?: AgentUncheckedCreateNestedManyWithoutConciergerieManagerInput
  }

  export type ConciergerieManagerCreateOrConnectWithoutTasksInput = {
    where: ConciergerieManagerWhereUniqueInput
    create: XOR<ConciergerieManagerCreateWithoutTasksInput, ConciergerieManagerUncheckedCreateWithoutTasksInput>
  }

  export type AgentCreateWithoutTasksInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutAgentInput
    conciergerieManager: ConciergerieManagerCreateNestedOneWithoutAgentsInput
    tickets?: TicketCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningCreateNestedManyWithoutAgentInput
    user: UserCreateNestedOneWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutCleaningAgentInput
    cleaningManager?: CleaningManagerCreateNestedOneWithoutCleaningAgentsInput
  }

  export type AgentUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    conciergerieManagerId: string
    userId: string
    cleaningManagerId?: string | null
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutAgentInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningUncheckedCreateNestedManyWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutCleaningAgentInput
  }

  export type AgentCreateOrConnectWithoutTasksInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutTasksInput, AgentUncheckedCreateWithoutTasksInput>
  }

  export type ConciergerieManagerUpsertWithoutTasksInput = {
    update: XOR<ConciergerieManagerUpdateWithoutTasksInput, ConciergerieManagerUncheckedUpdateWithoutTasksInput>
    create: XOR<ConciergerieManagerCreateWithoutTasksInput, ConciergerieManagerUncheckedCreateWithoutTasksInput>
    where?: ConciergerieManagerWhereInput
  }

  export type ConciergerieManagerUpdateToOneWithWhereWithoutTasksInput = {
    where?: ConciergerieManagerWhereInput
    data: XOR<ConciergerieManagerUpdateWithoutTasksInput, ConciergerieManagerUncheckedUpdateWithoutTasksInput>
  }

  export type ConciergerieManagerUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConciergerieManagersNestedInput
    properties?: PropertyUpdateManyWithoutConciergerieManagerNestedInput
    agents?: AgentUpdateManyWithoutConciergerieManagerNestedInput
  }

  export type ConciergerieManagerUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutConciergerieManagerNestedInput
    agents?: AgentUncheckedUpdateManyWithoutConciergerieManagerNestedInput
  }

  export type AgentUpsertWithoutTasksInput = {
    update: XOR<AgentUpdateWithoutTasksInput, AgentUncheckedUpdateWithoutTasksInput>
    create: XOR<AgentCreateWithoutTasksInput, AgentUncheckedCreateWithoutTasksInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutTasksInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutTasksInput, AgentUncheckedUpdateWithoutTasksInput>
  }

  export type AgentUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutAgentNestedInput
    conciergerieManager?: ConciergerieManagerUpdateOneRequiredWithoutAgentsNestedInput
    tickets?: TicketUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUpdateManyWithoutAgentNestedInput
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutCleaningAgentNestedInput
    cleaningManager?: CleaningManagerUpdateOneWithoutCleaningAgentsNestedInput
  }

  export type AgentUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cleaningManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUncheckedUpdateManyWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutCleaningAgentNestedInput
  }

  export type ConciergerieManagerCreateWithoutPropertiesInput = {
    id?: string
    name: string
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutConciergerieManagersInput
    agents?: AgentCreateNestedManyWithoutConciergerieManagerInput
    tasks?: TaskCreateNestedManyWithoutConciergerieManagerInput
  }

  export type ConciergerieManagerUncheckedCreateWithoutPropertiesInput = {
    id?: string
    name: string
    userId: string
    createdAt: Date | string
    updatedAt: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutConciergerieManagerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutConciergerieManagerInput
  }

  export type ConciergerieManagerCreateOrConnectWithoutPropertiesInput = {
    where: ConciergerieManagerWhereUniqueInput
    create: XOR<ConciergerieManagerCreateWithoutPropertiesInput, ConciergerieManagerUncheckedCreateWithoutPropertiesInput>
  }

  export type CleaningSessionCreateWithoutPropertyInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    cleaning: CleaningCreateNestedOneWithoutCleaningSessionsInput
    agent: AgentCreateNestedOneWithoutCleaningSessionsInput
    photos?: CleaningPhotoCreateNestedManyWithoutCleaningSessionInput
    checklist?: CleaningChecklistCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionUncheckedCreateWithoutPropertyInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningId: string
    agentId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    photos?: CleaningPhotoUncheckedCreateNestedManyWithoutCleaningSessionInput
    checklist?: CleaningChecklistUncheckedCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionCreateOrConnectWithoutPropertyInput = {
    where: CleaningSessionWhereUniqueInput
    create: XOR<CleaningSessionCreateWithoutPropertyInput, CleaningSessionUncheckedCreateWithoutPropertyInput>
  }

  export type CleaningSessionCreateManyPropertyInputEnvelope = {
    data: CleaningSessionCreateManyPropertyInput | CleaningSessionCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceSessionCreateWithoutPropertyInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    notes?: string | null
    maintenance: MaintenanceCreateNestedOneWithoutSessionMaintenancesInput
    agent: AgentCreateNestedOneWithoutMaintenanceSessionsInput
    photos?: MaintenancePhotoCreateNestedManyWithoutMaintenanceSessionInput
  }

  export type MaintenanceSessionUncheckedCreateWithoutPropertyInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    maintenanceId: string
    agentId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    notes?: string | null
    photos?: MaintenancePhotoUncheckedCreateNestedManyWithoutMaintenanceSessionInput
  }

  export type MaintenanceSessionCreateOrConnectWithoutPropertyInput = {
    where: MaintenanceSessionWhereUniqueInput
    create: XOR<MaintenanceSessionCreateWithoutPropertyInput, MaintenanceSessionUncheckedCreateWithoutPropertyInput>
  }

  export type MaintenanceSessionCreateManyPropertyInputEnvelope = {
    data: MaintenanceSessionCreateManyPropertyInput | MaintenanceSessionCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutPropertyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    client?: string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ReservationUncheckedCreateWithoutPropertyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    client?: string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ReservationCreateOrConnectWithoutPropertyInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutPropertyInput, ReservationUncheckedCreateWithoutPropertyInput>
  }

  export type ReservationCreateManyPropertyInputEnvelope = {
    data: ReservationCreateManyPropertyInput | ReservationCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutPropertyInput = {
    id?: string
    amount: number
    currency?: string
    method?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PaymentUncheckedCreateWithoutPropertyInput = {
    id?: string
    amount: number
    currency?: string
    method?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PaymentCreateOrConnectWithoutPropertyInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPropertyInput, PaymentUncheckedCreateWithoutPropertyInput>
  }

  export type PaymentCreateManyPropertyInputEnvelope = {
    data: PaymentCreateManyPropertyInput | PaymentCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutPropertyInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    agent?: AgentCreateNestedOneWithoutTicketsInput
    photos?: TicketPhotoCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutPropertyInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: string | null
    agentId?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    photos?: TicketPhotoUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutPropertyInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutPropertyInput, TicketUncheckedCreateWithoutPropertyInput>
  }

  export type TicketCreateManyPropertyInputEnvelope = {
    data: TicketCreateManyPropertyInput | TicketCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyPhotoCreateWithoutPropertyInput = {
    id?: string
    url: string
    type?: string | null
    createdAt: Date | string
  }

  export type PropertyPhotoUncheckedCreateWithoutPropertyInput = {
    id?: string
    url: string
    type?: string | null
    createdAt: Date | string
  }

  export type PropertyPhotoCreateOrConnectWithoutPropertyInput = {
    where: PropertyPhotoWhereUniqueInput
    create: XOR<PropertyPhotoCreateWithoutPropertyInput, PropertyPhotoUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyPhotoCreateManyPropertyInputEnvelope = {
    data: PropertyPhotoCreateManyPropertyInput | PropertyPhotoCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type ConciergerieManagerUpsertWithoutPropertiesInput = {
    update: XOR<ConciergerieManagerUpdateWithoutPropertiesInput, ConciergerieManagerUncheckedUpdateWithoutPropertiesInput>
    create: XOR<ConciergerieManagerCreateWithoutPropertiesInput, ConciergerieManagerUncheckedCreateWithoutPropertiesInput>
    where?: ConciergerieManagerWhereInput
  }

  export type ConciergerieManagerUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: ConciergerieManagerWhereInput
    data: XOR<ConciergerieManagerUpdateWithoutPropertiesInput, ConciergerieManagerUncheckedUpdateWithoutPropertiesInput>
  }

  export type ConciergerieManagerUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConciergerieManagersNestedInput
    agents?: AgentUpdateManyWithoutConciergerieManagerNestedInput
    tasks?: TaskUpdateManyWithoutConciergerieManagerNestedInput
  }

  export type ConciergerieManagerUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutConciergerieManagerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutConciergerieManagerNestedInput
  }

  export type CleaningSessionUpsertWithWhereUniqueWithoutPropertyInput = {
    where: CleaningSessionWhereUniqueInput
    update: XOR<CleaningSessionUpdateWithoutPropertyInput, CleaningSessionUncheckedUpdateWithoutPropertyInput>
    create: XOR<CleaningSessionCreateWithoutPropertyInput, CleaningSessionUncheckedCreateWithoutPropertyInput>
  }

  export type CleaningSessionUpdateWithWhereUniqueWithoutPropertyInput = {
    where: CleaningSessionWhereUniqueInput
    data: XOR<CleaningSessionUpdateWithoutPropertyInput, CleaningSessionUncheckedUpdateWithoutPropertyInput>
  }

  export type CleaningSessionUpdateManyWithWhereWithoutPropertyInput = {
    where: CleaningSessionScalarWhereInput
    data: XOR<CleaningSessionUpdateManyMutationInput, CleaningSessionUncheckedUpdateManyWithoutPropertyInput>
  }

  export type CleaningSessionScalarWhereInput = {
    AND?: CleaningSessionScalarWhereInput | CleaningSessionScalarWhereInput[]
    OR?: CleaningSessionScalarWhereInput[]
    NOT?: CleaningSessionScalarWhereInput | CleaningSessionScalarWhereInput[]
    id?: StringFilter<"CleaningSession"> | string
    propertyId?: StringFilter<"CleaningSession"> | string
    createdAt?: DateTimeFilter<"CleaningSession"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningSession"> | Date | string
    cleaningId?: StringFilter<"CleaningSession"> | string
    agentId?: StringFilter<"CleaningSession"> | string
    startDate?: DateTimeNullableFilter<"CleaningSession"> | Date | string | null
    endDate?: DateTimeNullableFilter<"CleaningSession"> | Date | string | null
    duration?: IntNullableFilter<"CleaningSession"> | number | null
    notes?: StringNullableFilter<"CleaningSession"> | string | null
  }

  export type MaintenanceSessionUpsertWithWhereUniqueWithoutPropertyInput = {
    where: MaintenanceSessionWhereUniqueInput
    update: XOR<MaintenanceSessionUpdateWithoutPropertyInput, MaintenanceSessionUncheckedUpdateWithoutPropertyInput>
    create: XOR<MaintenanceSessionCreateWithoutPropertyInput, MaintenanceSessionUncheckedCreateWithoutPropertyInput>
  }

  export type MaintenanceSessionUpdateWithWhereUniqueWithoutPropertyInput = {
    where: MaintenanceSessionWhereUniqueInput
    data: XOR<MaintenanceSessionUpdateWithoutPropertyInput, MaintenanceSessionUncheckedUpdateWithoutPropertyInput>
  }

  export type MaintenanceSessionUpdateManyWithWhereWithoutPropertyInput = {
    where: MaintenanceSessionScalarWhereInput
    data: XOR<MaintenanceSessionUpdateManyMutationInput, MaintenanceSessionUncheckedUpdateManyWithoutPropertyInput>
  }

  export type MaintenanceSessionScalarWhereInput = {
    AND?: MaintenanceSessionScalarWhereInput | MaintenanceSessionScalarWhereInput[]
    OR?: MaintenanceSessionScalarWhereInput[]
    NOT?: MaintenanceSessionScalarWhereInput | MaintenanceSessionScalarWhereInput[]
    id?: StringFilter<"MaintenanceSession"> | string
    propertyId?: StringFilter<"MaintenanceSession"> | string
    createdAt?: DateTimeFilter<"MaintenanceSession"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceSession"> | Date | string
    maintenanceId?: StringFilter<"MaintenanceSession"> | string
    agentId?: StringFilter<"MaintenanceSession"> | string
    startDate?: DateTimeNullableFilter<"MaintenanceSession"> | Date | string | null
    endDate?: DateTimeNullableFilter<"MaintenanceSession"> | Date | string | null
    notes?: StringNullableFilter<"MaintenanceSession"> | string | null
  }

  export type ReservationUpsertWithWhereUniqueWithoutPropertyInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutPropertyInput, ReservationUncheckedUpdateWithoutPropertyInput>
    create: XOR<ReservationCreateWithoutPropertyInput, ReservationUncheckedCreateWithoutPropertyInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutPropertyInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutPropertyInput, ReservationUncheckedUpdateWithoutPropertyInput>
  }

  export type ReservationUpdateManyWithWhereWithoutPropertyInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutPropertyInput>
  }

  export type ReservationScalarWhereInput = {
    AND?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    OR?: ReservationScalarWhereInput[]
    NOT?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    id?: StringFilter<"Reservation"> | string
    propertyId?: StringFilter<"Reservation"> | string
    startDate?: DateTimeFilter<"Reservation"> | Date | string
    endDate?: DateTimeFilter<"Reservation"> | Date | string
    client?: StringNullableFilter<"Reservation"> | string | null
    notes?: StringNullableFilter<"Reservation"> | string | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutPropertyInput, PaymentUncheckedUpdateWithoutPropertyInput>
    create: XOR<PaymentCreateWithoutPropertyInput, PaymentUncheckedCreateWithoutPropertyInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutPropertyInput, PaymentUncheckedUpdateWithoutPropertyInput>
  }

  export type PaymentUpdateManyWithWhereWithoutPropertyInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    method?: StringNullableFilter<"Payment"> | string | null
    status?: StringNullableFilter<"Payment"> | string | null
    propertyId?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutPropertyInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutPropertyInput, TicketUncheckedUpdateWithoutPropertyInput>
    create: XOR<TicketCreateWithoutPropertyInput, TicketUncheckedCreateWithoutPropertyInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutPropertyInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutPropertyInput, TicketUncheckedUpdateWithoutPropertyInput>
  }

  export type TicketUpdateManyWithWhereWithoutPropertyInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutPropertyInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: StringFilter<"Ticket"> | string
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: StringNullableFilter<"Ticket"> | string | null
    propertyId?: StringFilter<"Ticket"> | string
    agentId?: StringNullableFilter<"Ticket"> | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
  }

  export type PropertyPhotoUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyPhotoWhereUniqueInput
    update: XOR<PropertyPhotoUpdateWithoutPropertyInput, PropertyPhotoUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyPhotoCreateWithoutPropertyInput, PropertyPhotoUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyPhotoUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyPhotoWhereUniqueInput
    data: XOR<PropertyPhotoUpdateWithoutPropertyInput, PropertyPhotoUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyPhotoUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyPhotoScalarWhereInput
    data: XOR<PropertyPhotoUpdateManyMutationInput, PropertyPhotoUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyPhotoScalarWhereInput = {
    AND?: PropertyPhotoScalarWhereInput | PropertyPhotoScalarWhereInput[]
    OR?: PropertyPhotoScalarWhereInput[]
    NOT?: PropertyPhotoScalarWhereInput | PropertyPhotoScalarWhereInput[]
    id?: StringFilter<"PropertyPhoto"> | string
    url?: StringFilter<"PropertyPhoto"> | string
    type?: StringNullableFilter<"PropertyPhoto"> | string | null
    propertyId?: StringFilter<"PropertyPhoto"> | string
    createdAt?: DateTimeFilter<"PropertyPhoto"> | Date | string
  }

  export type PropertyCreateWithoutReservationsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManager: ConciergerieManagerCreateNestedOneWithoutPropertiesInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutPropertyInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    tickets?: TicketCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutReservationsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManagerId: string
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutReservationsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutReservationsInput, PropertyUncheckedCreateWithoutReservationsInput>
  }

  export type PropertyUpsertWithoutReservationsInput = {
    update: XOR<PropertyUpdateWithoutReservationsInput, PropertyUncheckedUpdateWithoutReservationsInput>
    create: XOR<PropertyCreateWithoutReservationsInput, PropertyUncheckedCreateWithoutReservationsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutReservationsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutReservationsInput, PropertyUncheckedUpdateWithoutReservationsInput>
  }

  export type PropertyUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManager?: ConciergerieManagerUpdateOneRequiredWithoutPropertiesNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type MaintenanceSessionCreateWithoutAgentInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    notes?: string | null
    property: PropertyCreateNestedOneWithoutMaintenanceSessionsInput
    maintenance: MaintenanceCreateNestedOneWithoutSessionMaintenancesInput
    photos?: MaintenancePhotoCreateNestedManyWithoutMaintenanceSessionInput
  }

  export type MaintenanceSessionUncheckedCreateWithoutAgentInput = {
    id?: string
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
    maintenanceId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    notes?: string | null
    photos?: MaintenancePhotoUncheckedCreateNestedManyWithoutMaintenanceSessionInput
  }

  export type MaintenanceSessionCreateOrConnectWithoutAgentInput = {
    where: MaintenanceSessionWhereUniqueInput
    create: XOR<MaintenanceSessionCreateWithoutAgentInput, MaintenanceSessionUncheckedCreateWithoutAgentInput>
  }

  export type MaintenanceSessionCreateManyAgentInputEnvelope = {
    data: MaintenanceSessionCreateManyAgentInput | MaintenanceSessionCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type CleaningSessionCreateWithoutAgentInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    property: PropertyCreateNestedOneWithoutCleaningSessionsInput
    cleaning: CleaningCreateNestedOneWithoutCleaningSessionsInput
    photos?: CleaningPhotoCreateNestedManyWithoutCleaningSessionInput
    checklist?: CleaningChecklistCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionUncheckedCreateWithoutAgentInput = {
    id?: string
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    photos?: CleaningPhotoUncheckedCreateNestedManyWithoutCleaningSessionInput
    checklist?: CleaningChecklistUncheckedCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionCreateOrConnectWithoutAgentInput = {
    where: CleaningSessionWhereUniqueInput
    create: XOR<CleaningSessionCreateWithoutAgentInput, CleaningSessionUncheckedCreateWithoutAgentInput>
  }

  export type CleaningSessionCreateManyAgentInputEnvelope = {
    data: CleaningSessionCreateManyAgentInput | CleaningSessionCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type ConciergerieManagerCreateWithoutAgentsInput = {
    id?: string
    name: string
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutConciergerieManagersInput
    properties?: PropertyCreateNestedManyWithoutConciergerieManagerInput
    tasks?: TaskCreateNestedManyWithoutConciergerieManagerInput
  }

  export type ConciergerieManagerUncheckedCreateWithoutAgentsInput = {
    id?: string
    name: string
    userId: string
    createdAt: Date | string
    updatedAt: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutConciergerieManagerInput
    tasks?: TaskUncheckedCreateNestedManyWithoutConciergerieManagerInput
  }

  export type ConciergerieManagerCreateOrConnectWithoutAgentsInput = {
    where: ConciergerieManagerWhereUniqueInput
    create: XOR<ConciergerieManagerCreateWithoutAgentsInput, ConciergerieManagerUncheckedCreateWithoutAgentsInput>
  }

  export type TaskCreateWithoutAgentInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManager?: ConciergerieManagerCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutAgentInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManagerId?: string | null
  }

  export type TaskCreateOrConnectWithoutAgentInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAgentInput, TaskUncheckedCreateWithoutAgentInput>
  }

  export type TaskCreateManyAgentInputEnvelope = {
    data: TaskCreateManyAgentInput | TaskCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutAgentInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    property: PropertyCreateNestedOneWithoutTicketsInput
    photos?: TicketPhotoCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutAgentInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: string | null
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
    photos?: TicketPhotoUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutAgentInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAgentInput, TicketUncheckedCreateWithoutAgentInput>
  }

  export type TicketCreateManyAgentInputEnvelope = {
    data: TicketCreateManyAgentInput | TicketCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type CleaningPlanningCreateWithoutAgentInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    interventionSite: InterventionSiteCreateNestedOneWithoutCleaningPlanningsInput
    cleaningManager: CleaningManagerCreateNestedOneWithoutCleaningPlanningsInput
  }

  export type CleaningPlanningUncheckedCreateWithoutAgentInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    interventionSiteId: string
    cleaningManagerId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CleaningPlanningCreateOrConnectWithoutAgentInput = {
    where: CleaningPlanningWhereUniqueInput
    create: XOR<CleaningPlanningCreateWithoutAgentInput, CleaningPlanningUncheckedCreateWithoutAgentInput>
  }

  export type CleaningPlanningCreateManyAgentInputEnvelope = {
    data: CleaningPlanningCreateManyAgentInput | CleaningPlanningCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutAgentInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    conciergerieManagers?: ConciergerieManagerCreateNestedManyWithoutUserInput
    cleaningManagers?: CleaningManagerCreateNestedManyWithoutUserInput
    laundryManagers?: LaundryManagerCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    serviceUsers?: ServiceUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgentInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    conciergerieManagers?: ConciergerieManagerUncheckedCreateNestedManyWithoutUserInput
    cleaningManagers?: CleaningManagerUncheckedCreateNestedManyWithoutUserInput
    laundryManagers?: LaundryManagerUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    serviceUsers?: ServiceUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
  }

  export type SiteCleaningSessionCreateWithoutCleaningAgentInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    interventionSite: InterventionSiteCreateNestedOneWithoutSiteCleaningSessionsInput
    cleaningManager: CleaningManagerCreateNestedOneWithoutSiteCleaningSessionsInput
    photos?: SiteCleaningPhotoCreateNestedManyWithoutSiteCleaningSessionInput
    checklist?: SiteCleaningChecklistCreateNestedManyWithoutSiteCleaningSessionInput
    laundryManager?: LaundryManagerCreateNestedOneWithoutSiteCleaningSessionsInput
  }

  export type SiteCleaningSessionUncheckedCreateWithoutCleaningAgentInput = {
    id?: string
    interventionSiteId: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManagerId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    laundryManagerId?: string | null
    photos?: SiteCleaningPhotoUncheckedCreateNestedManyWithoutSiteCleaningSessionInput
    checklist?: SiteCleaningChecklistUncheckedCreateNestedManyWithoutSiteCleaningSessionInput
  }

  export type SiteCleaningSessionCreateOrConnectWithoutCleaningAgentInput = {
    where: SiteCleaningSessionWhereUniqueInput
    create: XOR<SiteCleaningSessionCreateWithoutCleaningAgentInput, SiteCleaningSessionUncheckedCreateWithoutCleaningAgentInput>
  }

  export type SiteCleaningSessionCreateManyCleaningAgentInputEnvelope = {
    data: SiteCleaningSessionCreateManyCleaningAgentInput | SiteCleaningSessionCreateManyCleaningAgentInput[]
    skipDuplicates?: boolean
  }

  export type CleaningManagerCreateWithoutCleaningAgentsInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutCleaningManagersInput
    interventionSites?: InterventionSiteCreateNestedManyWithoutCleaningManagerInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutCleaningManagerInput
    cleaningPlannings?: CleaningPlanningCreateNestedManyWithoutCleaningManagerInput
  }

  export type CleaningManagerUncheckedCreateWithoutCleaningAgentsInput = {
    id?: string
    userId: string
    createdAt: Date | string
    updatedAt: Date | string
    interventionSites?: InterventionSiteUncheckedCreateNestedManyWithoutCleaningManagerInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutCleaningManagerInput
    cleaningPlannings?: CleaningPlanningUncheckedCreateNestedManyWithoutCleaningManagerInput
  }

  export type CleaningManagerCreateOrConnectWithoutCleaningAgentsInput = {
    where: CleaningManagerWhereUniqueInput
    create: XOR<CleaningManagerCreateWithoutCleaningAgentsInput, CleaningManagerUncheckedCreateWithoutCleaningAgentsInput>
  }

  export type MaintenanceSessionUpsertWithWhereUniqueWithoutAgentInput = {
    where: MaintenanceSessionWhereUniqueInput
    update: XOR<MaintenanceSessionUpdateWithoutAgentInput, MaintenanceSessionUncheckedUpdateWithoutAgentInput>
    create: XOR<MaintenanceSessionCreateWithoutAgentInput, MaintenanceSessionUncheckedCreateWithoutAgentInput>
  }

  export type MaintenanceSessionUpdateWithWhereUniqueWithoutAgentInput = {
    where: MaintenanceSessionWhereUniqueInput
    data: XOR<MaintenanceSessionUpdateWithoutAgentInput, MaintenanceSessionUncheckedUpdateWithoutAgentInput>
  }

  export type MaintenanceSessionUpdateManyWithWhereWithoutAgentInput = {
    where: MaintenanceSessionScalarWhereInput
    data: XOR<MaintenanceSessionUpdateManyMutationInput, MaintenanceSessionUncheckedUpdateManyWithoutAgentInput>
  }

  export type CleaningSessionUpsertWithWhereUniqueWithoutAgentInput = {
    where: CleaningSessionWhereUniqueInput
    update: XOR<CleaningSessionUpdateWithoutAgentInput, CleaningSessionUncheckedUpdateWithoutAgentInput>
    create: XOR<CleaningSessionCreateWithoutAgentInput, CleaningSessionUncheckedCreateWithoutAgentInput>
  }

  export type CleaningSessionUpdateWithWhereUniqueWithoutAgentInput = {
    where: CleaningSessionWhereUniqueInput
    data: XOR<CleaningSessionUpdateWithoutAgentInput, CleaningSessionUncheckedUpdateWithoutAgentInput>
  }

  export type CleaningSessionUpdateManyWithWhereWithoutAgentInput = {
    where: CleaningSessionScalarWhereInput
    data: XOR<CleaningSessionUpdateManyMutationInput, CleaningSessionUncheckedUpdateManyWithoutAgentInput>
  }

  export type ConciergerieManagerUpsertWithoutAgentsInput = {
    update: XOR<ConciergerieManagerUpdateWithoutAgentsInput, ConciergerieManagerUncheckedUpdateWithoutAgentsInput>
    create: XOR<ConciergerieManagerCreateWithoutAgentsInput, ConciergerieManagerUncheckedCreateWithoutAgentsInput>
    where?: ConciergerieManagerWhereInput
  }

  export type ConciergerieManagerUpdateToOneWithWhereWithoutAgentsInput = {
    where?: ConciergerieManagerWhereInput
    data: XOR<ConciergerieManagerUpdateWithoutAgentsInput, ConciergerieManagerUncheckedUpdateWithoutAgentsInput>
  }

  export type ConciergerieManagerUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConciergerieManagersNestedInput
    properties?: PropertyUpdateManyWithoutConciergerieManagerNestedInput
    tasks?: TaskUpdateManyWithoutConciergerieManagerNestedInput
  }

  export type ConciergerieManagerUncheckedUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutConciergerieManagerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutConciergerieManagerNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutAgentInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutAgentInput, TaskUncheckedUpdateWithoutAgentInput>
    create: XOR<TaskCreateWithoutAgentInput, TaskUncheckedCreateWithoutAgentInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutAgentInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutAgentInput, TaskUncheckedUpdateWithoutAgentInput>
  }

  export type TaskUpdateManyWithWhereWithoutAgentInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutAgentInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutAgentInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutAgentInput, TicketUncheckedUpdateWithoutAgentInput>
    create: XOR<TicketCreateWithoutAgentInput, TicketUncheckedCreateWithoutAgentInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutAgentInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutAgentInput, TicketUncheckedUpdateWithoutAgentInput>
  }

  export type TicketUpdateManyWithWhereWithoutAgentInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutAgentInput>
  }

  export type CleaningPlanningUpsertWithWhereUniqueWithoutAgentInput = {
    where: CleaningPlanningWhereUniqueInput
    update: XOR<CleaningPlanningUpdateWithoutAgentInput, CleaningPlanningUncheckedUpdateWithoutAgentInput>
    create: XOR<CleaningPlanningCreateWithoutAgentInput, CleaningPlanningUncheckedCreateWithoutAgentInput>
  }

  export type CleaningPlanningUpdateWithWhereUniqueWithoutAgentInput = {
    where: CleaningPlanningWhereUniqueInput
    data: XOR<CleaningPlanningUpdateWithoutAgentInput, CleaningPlanningUncheckedUpdateWithoutAgentInput>
  }

  export type CleaningPlanningUpdateManyWithWhereWithoutAgentInput = {
    where: CleaningPlanningScalarWhereInput
    data: XOR<CleaningPlanningUpdateManyMutationInput, CleaningPlanningUncheckedUpdateManyWithoutAgentInput>
  }

  export type CleaningPlanningScalarWhereInput = {
    AND?: CleaningPlanningScalarWhereInput | CleaningPlanningScalarWhereInput[]
    OR?: CleaningPlanningScalarWhereInput[]
    NOT?: CleaningPlanningScalarWhereInput | CleaningPlanningScalarWhereInput[]
    id?: StringFilter<"CleaningPlanning"> | string
    date?: DateTimeFilter<"CleaningPlanning"> | Date | string
    startTime?: StringNullableFilter<"CleaningPlanning"> | string | null
    endTime?: StringNullableFilter<"CleaningPlanning"> | string | null
    interventionSiteId?: StringFilter<"CleaningPlanning"> | string
    cleaningManagerId?: StringFilter<"CleaningPlanning"> | string
    agentId?: StringNullableFilter<"CleaningPlanning"> | string | null
    createdAt?: DateTimeFilter<"CleaningPlanning"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningPlanning"> | Date | string
  }

  export type UserUpsertWithoutAgentInput = {
    update: XOR<UserUpdateWithoutAgentInput, UserUncheckedUpdateWithoutAgentInput>
    create: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgentInput, UserUncheckedUpdateWithoutAgentInput>
  }

  export type UserUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    conciergerieManagers?: ConciergerieManagerUpdateManyWithoutUserNestedInput
    cleaningManagers?: CleaningManagerUpdateManyWithoutUserNestedInput
    laundryManagers?: LaundryManagerUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    serviceUsers?: ServiceUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    conciergerieManagers?: ConciergerieManagerUncheckedUpdateManyWithoutUserNestedInput
    cleaningManagers?: CleaningManagerUncheckedUpdateManyWithoutUserNestedInput
    laundryManagers?: LaundryManagerUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    serviceUsers?: ServiceUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SiteCleaningSessionUpsertWithWhereUniqueWithoutCleaningAgentInput = {
    where: SiteCleaningSessionWhereUniqueInput
    update: XOR<SiteCleaningSessionUpdateWithoutCleaningAgentInput, SiteCleaningSessionUncheckedUpdateWithoutCleaningAgentInput>
    create: XOR<SiteCleaningSessionCreateWithoutCleaningAgentInput, SiteCleaningSessionUncheckedCreateWithoutCleaningAgentInput>
  }

  export type SiteCleaningSessionUpdateWithWhereUniqueWithoutCleaningAgentInput = {
    where: SiteCleaningSessionWhereUniqueInput
    data: XOR<SiteCleaningSessionUpdateWithoutCleaningAgentInput, SiteCleaningSessionUncheckedUpdateWithoutCleaningAgentInput>
  }

  export type SiteCleaningSessionUpdateManyWithWhereWithoutCleaningAgentInput = {
    where: SiteCleaningSessionScalarWhereInput
    data: XOR<SiteCleaningSessionUpdateManyMutationInput, SiteCleaningSessionUncheckedUpdateManyWithoutCleaningAgentInput>
  }

  export type SiteCleaningSessionScalarWhereInput = {
    AND?: SiteCleaningSessionScalarWhereInput | SiteCleaningSessionScalarWhereInput[]
    OR?: SiteCleaningSessionScalarWhereInput[]
    NOT?: SiteCleaningSessionScalarWhereInput | SiteCleaningSessionScalarWhereInput[]
    id?: StringFilter<"SiteCleaningSession"> | string
    interventionSiteId?: StringFilter<"SiteCleaningSession"> | string
    createdAt?: DateTimeFilter<"SiteCleaningSession"> | Date | string
    updatedAt?: DateTimeFilter<"SiteCleaningSession"> | Date | string
    cleaningManagerId?: StringFilter<"SiteCleaningSession"> | string
    startDate?: DateTimeNullableFilter<"SiteCleaningSession"> | Date | string | null
    endDate?: DateTimeNullableFilter<"SiteCleaningSession"> | Date | string | null
    duration?: IntNullableFilter<"SiteCleaningSession"> | number | null
    notes?: StringNullableFilter<"SiteCleaningSession"> | string | null
    status?: EnumInterventionStatusFilter<"SiteCleaningSession"> | $Enums.InterventionStatus
    laundryManagerId?: StringNullableFilter<"SiteCleaningSession"> | string | null
    cleaningAgentId?: StringNullableFilter<"SiteCleaningSession"> | string | null
  }

  export type CleaningManagerUpsertWithoutCleaningAgentsInput = {
    update: XOR<CleaningManagerUpdateWithoutCleaningAgentsInput, CleaningManagerUncheckedUpdateWithoutCleaningAgentsInput>
    create: XOR<CleaningManagerCreateWithoutCleaningAgentsInput, CleaningManagerUncheckedCreateWithoutCleaningAgentsInput>
    where?: CleaningManagerWhereInput
  }

  export type CleaningManagerUpdateToOneWithWhereWithoutCleaningAgentsInput = {
    where?: CleaningManagerWhereInput
    data: XOR<CleaningManagerUpdateWithoutCleaningAgentsInput, CleaningManagerUncheckedUpdateWithoutCleaningAgentsInput>
  }

  export type CleaningManagerUpdateWithoutCleaningAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCleaningManagersNestedInput
    interventionSites?: InterventionSiteUpdateManyWithoutCleaningManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutCleaningManagerNestedInput
    cleaningPlannings?: CleaningPlanningUpdateManyWithoutCleaningManagerNestedInput
  }

  export type CleaningManagerUncheckedUpdateWithoutCleaningAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventionSites?: InterventionSiteUncheckedUpdateManyWithoutCleaningManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutCleaningManagerNestedInput
    cleaningPlannings?: CleaningPlanningUncheckedUpdateManyWithoutCleaningManagerNestedInput
  }

  export type PropertyCreateWithoutMaintenanceSessionsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManager: ConciergerieManagerCreateNestedOneWithoutPropertiesInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutPropertyInput
    reservations?: ReservationCreateNestedManyWithoutPropertyInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    tickets?: TicketCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutMaintenanceSessionsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManagerId: string
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutMaintenanceSessionsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutMaintenanceSessionsInput, PropertyUncheckedCreateWithoutMaintenanceSessionsInput>
  }

  export type MaintenanceCreateWithoutSessionMaintenancesInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type MaintenanceUncheckedCreateWithoutSessionMaintenancesInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type MaintenanceCreateOrConnectWithoutSessionMaintenancesInput = {
    where: MaintenanceWhereUniqueInput
    create: XOR<MaintenanceCreateWithoutSessionMaintenancesInput, MaintenanceUncheckedCreateWithoutSessionMaintenancesInput>
  }

  export type AgentCreateWithoutMaintenanceSessionsInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutAgentInput
    conciergerieManager: ConciergerieManagerCreateNestedOneWithoutAgentsInput
    tasks?: TaskCreateNestedManyWithoutAgentInput
    tickets?: TicketCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningCreateNestedManyWithoutAgentInput
    user: UserCreateNestedOneWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutCleaningAgentInput
    cleaningManager?: CleaningManagerCreateNestedOneWithoutCleaningAgentsInput
  }

  export type AgentUncheckedCreateWithoutMaintenanceSessionsInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    conciergerieManagerId: string
    userId: string
    cleaningManagerId?: string | null
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutAgentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAgentInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningUncheckedCreateNestedManyWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutCleaningAgentInput
  }

  export type AgentCreateOrConnectWithoutMaintenanceSessionsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutMaintenanceSessionsInput, AgentUncheckedCreateWithoutMaintenanceSessionsInput>
  }

  export type MaintenancePhotoCreateWithoutMaintenanceSessionInput = {
    id?: string
    url: string
    type?: string | null
    createdAt: Date | string
  }

  export type MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput = {
    id?: string
    url: string
    type?: string | null
    createdAt: Date | string
  }

  export type MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput = {
    where: MaintenancePhotoWhereUniqueInput
    create: XOR<MaintenancePhotoCreateWithoutMaintenanceSessionInput, MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput>
  }

  export type MaintenancePhotoCreateManyMaintenanceSessionInputEnvelope = {
    data: MaintenancePhotoCreateManyMaintenanceSessionInput | MaintenancePhotoCreateManyMaintenanceSessionInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithoutMaintenanceSessionsInput = {
    update: XOR<PropertyUpdateWithoutMaintenanceSessionsInput, PropertyUncheckedUpdateWithoutMaintenanceSessionsInput>
    create: XOR<PropertyCreateWithoutMaintenanceSessionsInput, PropertyUncheckedCreateWithoutMaintenanceSessionsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutMaintenanceSessionsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutMaintenanceSessionsInput, PropertyUncheckedUpdateWithoutMaintenanceSessionsInput>
  }

  export type PropertyUpdateWithoutMaintenanceSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManager?: ConciergerieManagerUpdateOneRequiredWithoutPropertiesNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutMaintenanceSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type MaintenanceUpsertWithoutSessionMaintenancesInput = {
    update: XOR<MaintenanceUpdateWithoutSessionMaintenancesInput, MaintenanceUncheckedUpdateWithoutSessionMaintenancesInput>
    create: XOR<MaintenanceCreateWithoutSessionMaintenancesInput, MaintenanceUncheckedCreateWithoutSessionMaintenancesInput>
    where?: MaintenanceWhereInput
  }

  export type MaintenanceUpdateToOneWithWhereWithoutSessionMaintenancesInput = {
    where?: MaintenanceWhereInput
    data: XOR<MaintenanceUpdateWithoutSessionMaintenancesInput, MaintenanceUncheckedUpdateWithoutSessionMaintenancesInput>
  }

  export type MaintenanceUpdateWithoutSessionMaintenancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceUncheckedUpdateWithoutSessionMaintenancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUpsertWithoutMaintenanceSessionsInput = {
    update: XOR<AgentUpdateWithoutMaintenanceSessionsInput, AgentUncheckedUpdateWithoutMaintenanceSessionsInput>
    create: XOR<AgentCreateWithoutMaintenanceSessionsInput, AgentUncheckedCreateWithoutMaintenanceSessionsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutMaintenanceSessionsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutMaintenanceSessionsInput, AgentUncheckedUpdateWithoutMaintenanceSessionsInput>
  }

  export type AgentUpdateWithoutMaintenanceSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    cleaningSessions?: CleaningSessionUpdateManyWithoutAgentNestedInput
    conciergerieManager?: ConciergerieManagerUpdateOneRequiredWithoutAgentsNestedInput
    tasks?: TaskUpdateManyWithoutAgentNestedInput
    tickets?: TicketUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUpdateManyWithoutAgentNestedInput
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutCleaningAgentNestedInput
    cleaningManager?: CleaningManagerUpdateOneWithoutCleaningAgentsNestedInput
  }

  export type AgentUncheckedUpdateWithoutMaintenanceSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cleaningManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUncheckedUpdateManyWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutCleaningAgentNestedInput
  }

  export type MaintenancePhotoUpsertWithWhereUniqueWithoutMaintenanceSessionInput = {
    where: MaintenancePhotoWhereUniqueInput
    update: XOR<MaintenancePhotoUpdateWithoutMaintenanceSessionInput, MaintenancePhotoUncheckedUpdateWithoutMaintenanceSessionInput>
    create: XOR<MaintenancePhotoCreateWithoutMaintenanceSessionInput, MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput>
  }

  export type MaintenancePhotoUpdateWithWhereUniqueWithoutMaintenanceSessionInput = {
    where: MaintenancePhotoWhereUniqueInput
    data: XOR<MaintenancePhotoUpdateWithoutMaintenanceSessionInput, MaintenancePhotoUncheckedUpdateWithoutMaintenanceSessionInput>
  }

  export type MaintenancePhotoUpdateManyWithWhereWithoutMaintenanceSessionInput = {
    where: MaintenancePhotoScalarWhereInput
    data: XOR<MaintenancePhotoUpdateManyMutationInput, MaintenancePhotoUncheckedUpdateManyWithoutMaintenanceSessionInput>
  }

  export type MaintenancePhotoScalarWhereInput = {
    AND?: MaintenancePhotoScalarWhereInput | MaintenancePhotoScalarWhereInput[]
    OR?: MaintenancePhotoScalarWhereInput[]
    NOT?: MaintenancePhotoScalarWhereInput | MaintenancePhotoScalarWhereInput[]
    id?: StringFilter<"MaintenancePhoto"> | string
    url?: StringFilter<"MaintenancePhoto"> | string
    type?: StringNullableFilter<"MaintenancePhoto"> | string | null
    maintenanceSessionId?: StringFilter<"MaintenancePhoto"> | string
    createdAt?: DateTimeFilter<"MaintenancePhoto"> | Date | string
  }

  export type MaintenanceSessionCreateWithoutMaintenanceInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    notes?: string | null
    property: PropertyCreateNestedOneWithoutMaintenanceSessionsInput
    agent: AgentCreateNestedOneWithoutMaintenanceSessionsInput
    photos?: MaintenancePhotoCreateNestedManyWithoutMaintenanceSessionInput
  }

  export type MaintenanceSessionUncheckedCreateWithoutMaintenanceInput = {
    id?: string
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
    agentId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    notes?: string | null
    photos?: MaintenancePhotoUncheckedCreateNestedManyWithoutMaintenanceSessionInput
  }

  export type MaintenanceSessionCreateOrConnectWithoutMaintenanceInput = {
    where: MaintenanceSessionWhereUniqueInput
    create: XOR<MaintenanceSessionCreateWithoutMaintenanceInput, MaintenanceSessionUncheckedCreateWithoutMaintenanceInput>
  }

  export type MaintenanceSessionCreateManyMaintenanceInputEnvelope = {
    data: MaintenanceSessionCreateManyMaintenanceInput | MaintenanceSessionCreateManyMaintenanceInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceSessionUpsertWithWhereUniqueWithoutMaintenanceInput = {
    where: MaintenanceSessionWhereUniqueInput
    update: XOR<MaintenanceSessionUpdateWithoutMaintenanceInput, MaintenanceSessionUncheckedUpdateWithoutMaintenanceInput>
    create: XOR<MaintenanceSessionCreateWithoutMaintenanceInput, MaintenanceSessionUncheckedCreateWithoutMaintenanceInput>
  }

  export type MaintenanceSessionUpdateWithWhereUniqueWithoutMaintenanceInput = {
    where: MaintenanceSessionWhereUniqueInput
    data: XOR<MaintenanceSessionUpdateWithoutMaintenanceInput, MaintenanceSessionUncheckedUpdateWithoutMaintenanceInput>
  }

  export type MaintenanceSessionUpdateManyWithWhereWithoutMaintenanceInput = {
    where: MaintenanceSessionScalarWhereInput
    data: XOR<MaintenanceSessionUpdateManyMutationInput, MaintenanceSessionUncheckedUpdateManyWithoutMaintenanceInput>
  }

  export type PropertyCreateWithoutCleaningSessionsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManager: ConciergerieManagerCreateNestedOneWithoutPropertiesInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutPropertyInput
    reservations?: ReservationCreateNestedManyWithoutPropertyInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    tickets?: TicketCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutCleaningSessionsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManagerId: string
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutCleaningSessionsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutCleaningSessionsInput, PropertyUncheckedCreateWithoutCleaningSessionsInput>
  }

  export type CleaningCreateWithoutCleaningSessionsInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CleaningUncheckedCreateWithoutCleaningSessionsInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CleaningCreateOrConnectWithoutCleaningSessionsInput = {
    where: CleaningWhereUniqueInput
    create: XOR<CleaningCreateWithoutCleaningSessionsInput, CleaningUncheckedCreateWithoutCleaningSessionsInput>
  }

  export type AgentCreateWithoutCleaningSessionsInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutAgentInput
    conciergerieManager: ConciergerieManagerCreateNestedOneWithoutAgentsInput
    tasks?: TaskCreateNestedManyWithoutAgentInput
    tickets?: TicketCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningCreateNestedManyWithoutAgentInput
    user: UserCreateNestedOneWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutCleaningAgentInput
    cleaningManager?: CleaningManagerCreateNestedOneWithoutCleaningAgentsInput
  }

  export type AgentUncheckedCreateWithoutCleaningSessionsInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    conciergerieManagerId: string
    userId: string
    cleaningManagerId?: string | null
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAgentInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningUncheckedCreateNestedManyWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutCleaningAgentInput
  }

  export type AgentCreateOrConnectWithoutCleaningSessionsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutCleaningSessionsInput, AgentUncheckedCreateWithoutCleaningSessionsInput>
  }

  export type CleaningPhotoCreateWithoutCleaningSessionInput = {
    id?: string
    url: string
    type?: string | null
    createdAt: Date | string
  }

  export type CleaningPhotoUncheckedCreateWithoutCleaningSessionInput = {
    id?: string
    url: string
    type?: string | null
    createdAt: Date | string
  }

  export type CleaningPhotoCreateOrConnectWithoutCleaningSessionInput = {
    where: CleaningPhotoWhereUniqueInput
    create: XOR<CleaningPhotoCreateWithoutCleaningSessionInput, CleaningPhotoUncheckedCreateWithoutCleaningSessionInput>
  }

  export type CleaningPhotoCreateManyCleaningSessionInputEnvelope = {
    data: CleaningPhotoCreateManyCleaningSessionInput | CleaningPhotoCreateManyCleaningSessionInput[]
    skipDuplicates?: boolean
  }

  export type CleaningChecklistCreateWithoutCleaningSessionInput = {
    id?: string
    item: string
    completed?: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CleaningChecklistUncheckedCreateWithoutCleaningSessionInput = {
    id?: string
    item: string
    completed?: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CleaningChecklistCreateOrConnectWithoutCleaningSessionInput = {
    where: CleaningChecklistWhereUniqueInput
    create: XOR<CleaningChecklistCreateWithoutCleaningSessionInput, CleaningChecklistUncheckedCreateWithoutCleaningSessionInput>
  }

  export type CleaningChecklistCreateManyCleaningSessionInputEnvelope = {
    data: CleaningChecklistCreateManyCleaningSessionInput | CleaningChecklistCreateManyCleaningSessionInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithoutCleaningSessionsInput = {
    update: XOR<PropertyUpdateWithoutCleaningSessionsInput, PropertyUncheckedUpdateWithoutCleaningSessionsInput>
    create: XOR<PropertyCreateWithoutCleaningSessionsInput, PropertyUncheckedCreateWithoutCleaningSessionsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutCleaningSessionsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutCleaningSessionsInput, PropertyUncheckedUpdateWithoutCleaningSessionsInput>
  }

  export type PropertyUpdateWithoutCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManager?: ConciergerieManagerUpdateOneRequiredWithoutPropertiesNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type CleaningUpsertWithoutCleaningSessionsInput = {
    update: XOR<CleaningUpdateWithoutCleaningSessionsInput, CleaningUncheckedUpdateWithoutCleaningSessionsInput>
    create: XOR<CleaningCreateWithoutCleaningSessionsInput, CleaningUncheckedCreateWithoutCleaningSessionsInput>
    where?: CleaningWhereInput
  }

  export type CleaningUpdateToOneWithWhereWithoutCleaningSessionsInput = {
    where?: CleaningWhereInput
    data: XOR<CleaningUpdateWithoutCleaningSessionsInput, CleaningUncheckedUpdateWithoutCleaningSessionsInput>
  }

  export type CleaningUpdateWithoutCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningUncheckedUpdateWithoutCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUpsertWithoutCleaningSessionsInput = {
    update: XOR<AgentUpdateWithoutCleaningSessionsInput, AgentUncheckedUpdateWithoutCleaningSessionsInput>
    create: XOR<AgentCreateWithoutCleaningSessionsInput, AgentUncheckedCreateWithoutCleaningSessionsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutCleaningSessionsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutCleaningSessionsInput, AgentUncheckedUpdateWithoutCleaningSessionsInput>
  }

  export type AgentUpdateWithoutCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutAgentNestedInput
    conciergerieManager?: ConciergerieManagerUpdateOneRequiredWithoutAgentsNestedInput
    tasks?: TaskUpdateManyWithoutAgentNestedInput
    tickets?: TicketUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUpdateManyWithoutAgentNestedInput
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutCleaningAgentNestedInput
    cleaningManager?: CleaningManagerUpdateOneWithoutCleaningAgentsNestedInput
  }

  export type AgentUncheckedUpdateWithoutCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cleaningManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUncheckedUpdateManyWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutCleaningAgentNestedInput
  }

  export type CleaningPhotoUpsertWithWhereUniqueWithoutCleaningSessionInput = {
    where: CleaningPhotoWhereUniqueInput
    update: XOR<CleaningPhotoUpdateWithoutCleaningSessionInput, CleaningPhotoUncheckedUpdateWithoutCleaningSessionInput>
    create: XOR<CleaningPhotoCreateWithoutCleaningSessionInput, CleaningPhotoUncheckedCreateWithoutCleaningSessionInput>
  }

  export type CleaningPhotoUpdateWithWhereUniqueWithoutCleaningSessionInput = {
    where: CleaningPhotoWhereUniqueInput
    data: XOR<CleaningPhotoUpdateWithoutCleaningSessionInput, CleaningPhotoUncheckedUpdateWithoutCleaningSessionInput>
  }

  export type CleaningPhotoUpdateManyWithWhereWithoutCleaningSessionInput = {
    where: CleaningPhotoScalarWhereInput
    data: XOR<CleaningPhotoUpdateManyMutationInput, CleaningPhotoUncheckedUpdateManyWithoutCleaningSessionInput>
  }

  export type CleaningPhotoScalarWhereInput = {
    AND?: CleaningPhotoScalarWhereInput | CleaningPhotoScalarWhereInput[]
    OR?: CleaningPhotoScalarWhereInput[]
    NOT?: CleaningPhotoScalarWhereInput | CleaningPhotoScalarWhereInput[]
    id?: StringFilter<"CleaningPhoto"> | string
    url?: StringFilter<"CleaningPhoto"> | string
    type?: StringNullableFilter<"CleaningPhoto"> | string | null
    cleaningSessionId?: StringFilter<"CleaningPhoto"> | string
    createdAt?: DateTimeFilter<"CleaningPhoto"> | Date | string
  }

  export type CleaningChecklistUpsertWithWhereUniqueWithoutCleaningSessionInput = {
    where: CleaningChecklistWhereUniqueInput
    update: XOR<CleaningChecklistUpdateWithoutCleaningSessionInput, CleaningChecklistUncheckedUpdateWithoutCleaningSessionInput>
    create: XOR<CleaningChecklistCreateWithoutCleaningSessionInput, CleaningChecklistUncheckedCreateWithoutCleaningSessionInput>
  }

  export type CleaningChecklistUpdateWithWhereUniqueWithoutCleaningSessionInput = {
    where: CleaningChecklistWhereUniqueInput
    data: XOR<CleaningChecklistUpdateWithoutCleaningSessionInput, CleaningChecklistUncheckedUpdateWithoutCleaningSessionInput>
  }

  export type CleaningChecklistUpdateManyWithWhereWithoutCleaningSessionInput = {
    where: CleaningChecklistScalarWhereInput
    data: XOR<CleaningChecklistUpdateManyMutationInput, CleaningChecklistUncheckedUpdateManyWithoutCleaningSessionInput>
  }

  export type CleaningChecklistScalarWhereInput = {
    AND?: CleaningChecklistScalarWhereInput | CleaningChecklistScalarWhereInput[]
    OR?: CleaningChecklistScalarWhereInput[]
    NOT?: CleaningChecklistScalarWhereInput | CleaningChecklistScalarWhereInput[]
    id?: StringFilter<"CleaningChecklist"> | string
    item?: StringFilter<"CleaningChecklist"> | string
    completed?: BoolFilter<"CleaningChecklist"> | boolean
    cleaningSessionId?: StringFilter<"CleaningChecklist"> | string
    createdAt?: DateTimeFilter<"CleaningChecklist"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningChecklist"> | Date | string
  }

  export type CleaningSessionCreateWithoutCleaningInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    property: PropertyCreateNestedOneWithoutCleaningSessionsInput
    agent: AgentCreateNestedOneWithoutCleaningSessionsInput
    photos?: CleaningPhotoCreateNestedManyWithoutCleaningSessionInput
    checklist?: CleaningChecklistCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionUncheckedCreateWithoutCleaningInput = {
    id?: string
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
    agentId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    photos?: CleaningPhotoUncheckedCreateNestedManyWithoutCleaningSessionInput
    checklist?: CleaningChecklistUncheckedCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionCreateOrConnectWithoutCleaningInput = {
    where: CleaningSessionWhereUniqueInput
    create: XOR<CleaningSessionCreateWithoutCleaningInput, CleaningSessionUncheckedCreateWithoutCleaningInput>
  }

  export type CleaningSessionCreateManyCleaningInputEnvelope = {
    data: CleaningSessionCreateManyCleaningInput | CleaningSessionCreateManyCleaningInput[]
    skipDuplicates?: boolean
  }

  export type CleaningSessionUpsertWithWhereUniqueWithoutCleaningInput = {
    where: CleaningSessionWhereUniqueInput
    update: XOR<CleaningSessionUpdateWithoutCleaningInput, CleaningSessionUncheckedUpdateWithoutCleaningInput>
    create: XOR<CleaningSessionCreateWithoutCleaningInput, CleaningSessionUncheckedCreateWithoutCleaningInput>
  }

  export type CleaningSessionUpdateWithWhereUniqueWithoutCleaningInput = {
    where: CleaningSessionWhereUniqueInput
    data: XOR<CleaningSessionUpdateWithoutCleaningInput, CleaningSessionUncheckedUpdateWithoutCleaningInput>
  }

  export type CleaningSessionUpdateManyWithWhereWithoutCleaningInput = {
    where: CleaningSessionScalarWhereInput
    data: XOR<CleaningSessionUpdateManyMutationInput, CleaningSessionUncheckedUpdateManyWithoutCleaningInput>
  }

  export type UserCreateWithoutCleaningManagersInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    conciergerieManagers?: ConciergerieManagerCreateNestedManyWithoutUserInput
    laundryManagers?: LaundryManagerCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    serviceUsers?: ServiceUserCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCleaningManagersInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    conciergerieManagers?: ConciergerieManagerUncheckedCreateNestedManyWithoutUserInput
    laundryManagers?: LaundryManagerUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    serviceUsers?: ServiceUserUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCleaningManagersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCleaningManagersInput, UserUncheckedCreateWithoutCleaningManagersInput>
  }

  export type InterventionSiteCreateWithoutCleaningManagerInput = {
    id?: string
    name: string
    description: string
    client?: string | null
    site?: string | null
    surface?: number | null
    type?: string | null
    address?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutInterventionSiteInput
    cleaningPlannings?: CleaningPlanningCreateNestedManyWithoutInterventionSiteInput
  }

  export type InterventionSiteUncheckedCreateWithoutCleaningManagerInput = {
    id?: string
    name: string
    description: string
    client?: string | null
    site?: string | null
    surface?: number | null
    type?: string | null
    address?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutInterventionSiteInput
    cleaningPlannings?: CleaningPlanningUncheckedCreateNestedManyWithoutInterventionSiteInput
  }

  export type InterventionSiteCreateOrConnectWithoutCleaningManagerInput = {
    where: InterventionSiteWhereUniqueInput
    create: XOR<InterventionSiteCreateWithoutCleaningManagerInput, InterventionSiteUncheckedCreateWithoutCleaningManagerInput>
  }

  export type InterventionSiteCreateManyCleaningManagerInputEnvelope = {
    data: InterventionSiteCreateManyCleaningManagerInput | InterventionSiteCreateManyCleaningManagerInput[]
    skipDuplicates?: boolean
  }

  export type SiteCleaningSessionCreateWithoutCleaningManagerInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    interventionSite: InterventionSiteCreateNestedOneWithoutSiteCleaningSessionsInput
    photos?: SiteCleaningPhotoCreateNestedManyWithoutSiteCleaningSessionInput
    checklist?: SiteCleaningChecklistCreateNestedManyWithoutSiteCleaningSessionInput
    laundryManager?: LaundryManagerCreateNestedOneWithoutSiteCleaningSessionsInput
    cleaningAgent?: AgentCreateNestedOneWithoutSiteCleaningSessionsInput
  }

  export type SiteCleaningSessionUncheckedCreateWithoutCleaningManagerInput = {
    id?: string
    interventionSiteId: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    laundryManagerId?: string | null
    cleaningAgentId?: string | null
    photos?: SiteCleaningPhotoUncheckedCreateNestedManyWithoutSiteCleaningSessionInput
    checklist?: SiteCleaningChecklistUncheckedCreateNestedManyWithoutSiteCleaningSessionInput
  }

  export type SiteCleaningSessionCreateOrConnectWithoutCleaningManagerInput = {
    where: SiteCleaningSessionWhereUniqueInput
    create: XOR<SiteCleaningSessionCreateWithoutCleaningManagerInput, SiteCleaningSessionUncheckedCreateWithoutCleaningManagerInput>
  }

  export type SiteCleaningSessionCreateManyCleaningManagerInputEnvelope = {
    data: SiteCleaningSessionCreateManyCleaningManagerInput | SiteCleaningSessionCreateManyCleaningManagerInput[]
    skipDuplicates?: boolean
  }

  export type AgentCreateWithoutCleaningManagerInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutAgentInput
    conciergerieManager: ConciergerieManagerCreateNestedOneWithoutAgentsInput
    tasks?: TaskCreateNestedManyWithoutAgentInput
    tickets?: TicketCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningCreateNestedManyWithoutAgentInput
    user: UserCreateNestedOneWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutCleaningAgentInput
  }

  export type AgentUncheckedCreateWithoutCleaningManagerInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    conciergerieManagerId: string
    userId: string
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutAgentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAgentInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningUncheckedCreateNestedManyWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutCleaningAgentInput
  }

  export type AgentCreateOrConnectWithoutCleaningManagerInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutCleaningManagerInput, AgentUncheckedCreateWithoutCleaningManagerInput>
  }

  export type AgentCreateManyCleaningManagerInputEnvelope = {
    data: AgentCreateManyCleaningManagerInput | AgentCreateManyCleaningManagerInput[]
    skipDuplicates?: boolean
  }

  export type CleaningPlanningCreateWithoutCleaningManagerInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    interventionSite: InterventionSiteCreateNestedOneWithoutCleaningPlanningsInput
    agent?: AgentCreateNestedOneWithoutCleaningPlanningsInput
  }

  export type CleaningPlanningUncheckedCreateWithoutCleaningManagerInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    interventionSiteId: string
    agentId?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CleaningPlanningCreateOrConnectWithoutCleaningManagerInput = {
    where: CleaningPlanningWhereUniqueInput
    create: XOR<CleaningPlanningCreateWithoutCleaningManagerInput, CleaningPlanningUncheckedCreateWithoutCleaningManagerInput>
  }

  export type CleaningPlanningCreateManyCleaningManagerInputEnvelope = {
    data: CleaningPlanningCreateManyCleaningManagerInput | CleaningPlanningCreateManyCleaningManagerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCleaningManagersInput = {
    update: XOR<UserUpdateWithoutCleaningManagersInput, UserUncheckedUpdateWithoutCleaningManagersInput>
    create: XOR<UserCreateWithoutCleaningManagersInput, UserUncheckedCreateWithoutCleaningManagersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCleaningManagersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCleaningManagersInput, UserUncheckedUpdateWithoutCleaningManagersInput>
  }

  export type UserUpdateWithoutCleaningManagersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    conciergerieManagers?: ConciergerieManagerUpdateManyWithoutUserNestedInput
    laundryManagers?: LaundryManagerUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    serviceUsers?: ServiceUserUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCleaningManagersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    conciergerieManagers?: ConciergerieManagerUncheckedUpdateManyWithoutUserNestedInput
    laundryManagers?: LaundryManagerUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    serviceUsers?: ServiceUserUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InterventionSiteUpsertWithWhereUniqueWithoutCleaningManagerInput = {
    where: InterventionSiteWhereUniqueInput
    update: XOR<InterventionSiteUpdateWithoutCleaningManagerInput, InterventionSiteUncheckedUpdateWithoutCleaningManagerInput>
    create: XOR<InterventionSiteCreateWithoutCleaningManagerInput, InterventionSiteUncheckedCreateWithoutCleaningManagerInput>
  }

  export type InterventionSiteUpdateWithWhereUniqueWithoutCleaningManagerInput = {
    where: InterventionSiteWhereUniqueInput
    data: XOR<InterventionSiteUpdateWithoutCleaningManagerInput, InterventionSiteUncheckedUpdateWithoutCleaningManagerInput>
  }

  export type InterventionSiteUpdateManyWithWhereWithoutCleaningManagerInput = {
    where: InterventionSiteScalarWhereInput
    data: XOR<InterventionSiteUpdateManyMutationInput, InterventionSiteUncheckedUpdateManyWithoutCleaningManagerInput>
  }

  export type InterventionSiteScalarWhereInput = {
    AND?: InterventionSiteScalarWhereInput | InterventionSiteScalarWhereInput[]
    OR?: InterventionSiteScalarWhereInput[]
    NOT?: InterventionSiteScalarWhereInput | InterventionSiteScalarWhereInput[]
    id?: StringFilter<"InterventionSite"> | string
    name?: StringFilter<"InterventionSite"> | string
    description?: StringFilter<"InterventionSite"> | string
    client?: StringNullableFilter<"InterventionSite"> | string | null
    site?: StringNullableFilter<"InterventionSite"> | string | null
    surface?: FloatNullableFilter<"InterventionSite"> | number | null
    type?: StringNullableFilter<"InterventionSite"> | string | null
    address?: StringNullableFilter<"InterventionSite"> | string | null
    createdAt?: DateTimeFilter<"InterventionSite"> | Date | string
    updatedAt?: DateTimeFilter<"InterventionSite"> | Date | string
    cleaningManagerId?: StringFilter<"InterventionSite"> | string
  }

  export type SiteCleaningSessionUpsertWithWhereUniqueWithoutCleaningManagerInput = {
    where: SiteCleaningSessionWhereUniqueInput
    update: XOR<SiteCleaningSessionUpdateWithoutCleaningManagerInput, SiteCleaningSessionUncheckedUpdateWithoutCleaningManagerInput>
    create: XOR<SiteCleaningSessionCreateWithoutCleaningManagerInput, SiteCleaningSessionUncheckedCreateWithoutCleaningManagerInput>
  }

  export type SiteCleaningSessionUpdateWithWhereUniqueWithoutCleaningManagerInput = {
    where: SiteCleaningSessionWhereUniqueInput
    data: XOR<SiteCleaningSessionUpdateWithoutCleaningManagerInput, SiteCleaningSessionUncheckedUpdateWithoutCleaningManagerInput>
  }

  export type SiteCleaningSessionUpdateManyWithWhereWithoutCleaningManagerInput = {
    where: SiteCleaningSessionScalarWhereInput
    data: XOR<SiteCleaningSessionUpdateManyMutationInput, SiteCleaningSessionUncheckedUpdateManyWithoutCleaningManagerInput>
  }

  export type AgentUpsertWithWhereUniqueWithoutCleaningManagerInput = {
    where: AgentWhereUniqueInput
    update: XOR<AgentUpdateWithoutCleaningManagerInput, AgentUncheckedUpdateWithoutCleaningManagerInput>
    create: XOR<AgentCreateWithoutCleaningManagerInput, AgentUncheckedCreateWithoutCleaningManagerInput>
  }

  export type AgentUpdateWithWhereUniqueWithoutCleaningManagerInput = {
    where: AgentWhereUniqueInput
    data: XOR<AgentUpdateWithoutCleaningManagerInput, AgentUncheckedUpdateWithoutCleaningManagerInput>
  }

  export type AgentUpdateManyWithWhereWithoutCleaningManagerInput = {
    where: AgentScalarWhereInput
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyWithoutCleaningManagerInput>
  }

  export type CleaningPlanningUpsertWithWhereUniqueWithoutCleaningManagerInput = {
    where: CleaningPlanningWhereUniqueInput
    update: XOR<CleaningPlanningUpdateWithoutCleaningManagerInput, CleaningPlanningUncheckedUpdateWithoutCleaningManagerInput>
    create: XOR<CleaningPlanningCreateWithoutCleaningManagerInput, CleaningPlanningUncheckedCreateWithoutCleaningManagerInput>
  }

  export type CleaningPlanningUpdateWithWhereUniqueWithoutCleaningManagerInput = {
    where: CleaningPlanningWhereUniqueInput
    data: XOR<CleaningPlanningUpdateWithoutCleaningManagerInput, CleaningPlanningUncheckedUpdateWithoutCleaningManagerInput>
  }

  export type CleaningPlanningUpdateManyWithWhereWithoutCleaningManagerInput = {
    where: CleaningPlanningScalarWhereInput
    data: XOR<CleaningPlanningUpdateManyMutationInput, CleaningPlanningUncheckedUpdateManyWithoutCleaningManagerInput>
  }

  export type CleaningManagerCreateWithoutInterventionSitesInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutCleaningManagersInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutCleaningManagerInput
    cleaningAgents?: AgentCreateNestedManyWithoutCleaningManagerInput
    cleaningPlannings?: CleaningPlanningCreateNestedManyWithoutCleaningManagerInput
  }

  export type CleaningManagerUncheckedCreateWithoutInterventionSitesInput = {
    id?: string
    userId: string
    createdAt: Date | string
    updatedAt: Date | string
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutCleaningManagerInput
    cleaningAgents?: AgentUncheckedCreateNestedManyWithoutCleaningManagerInput
    cleaningPlannings?: CleaningPlanningUncheckedCreateNestedManyWithoutCleaningManagerInput
  }

  export type CleaningManagerCreateOrConnectWithoutInterventionSitesInput = {
    where: CleaningManagerWhereUniqueInput
    create: XOR<CleaningManagerCreateWithoutInterventionSitesInput, CleaningManagerUncheckedCreateWithoutInterventionSitesInput>
  }

  export type SiteCleaningSessionCreateWithoutInterventionSiteInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    cleaningManager: CleaningManagerCreateNestedOneWithoutSiteCleaningSessionsInput
    photos?: SiteCleaningPhotoCreateNestedManyWithoutSiteCleaningSessionInput
    checklist?: SiteCleaningChecklistCreateNestedManyWithoutSiteCleaningSessionInput
    laundryManager?: LaundryManagerCreateNestedOneWithoutSiteCleaningSessionsInput
    cleaningAgent?: AgentCreateNestedOneWithoutSiteCleaningSessionsInput
  }

  export type SiteCleaningSessionUncheckedCreateWithoutInterventionSiteInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManagerId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    laundryManagerId?: string | null
    cleaningAgentId?: string | null
    photos?: SiteCleaningPhotoUncheckedCreateNestedManyWithoutSiteCleaningSessionInput
    checklist?: SiteCleaningChecklistUncheckedCreateNestedManyWithoutSiteCleaningSessionInput
  }

  export type SiteCleaningSessionCreateOrConnectWithoutInterventionSiteInput = {
    where: SiteCleaningSessionWhereUniqueInput
    create: XOR<SiteCleaningSessionCreateWithoutInterventionSiteInput, SiteCleaningSessionUncheckedCreateWithoutInterventionSiteInput>
  }

  export type SiteCleaningSessionCreateManyInterventionSiteInputEnvelope = {
    data: SiteCleaningSessionCreateManyInterventionSiteInput | SiteCleaningSessionCreateManyInterventionSiteInput[]
    skipDuplicates?: boolean
  }

  export type CleaningPlanningCreateWithoutInterventionSiteInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManager: CleaningManagerCreateNestedOneWithoutCleaningPlanningsInput
    agent?: AgentCreateNestedOneWithoutCleaningPlanningsInput
  }

  export type CleaningPlanningUncheckedCreateWithoutInterventionSiteInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    cleaningManagerId: string
    agentId?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CleaningPlanningCreateOrConnectWithoutInterventionSiteInput = {
    where: CleaningPlanningWhereUniqueInput
    create: XOR<CleaningPlanningCreateWithoutInterventionSiteInput, CleaningPlanningUncheckedCreateWithoutInterventionSiteInput>
  }

  export type CleaningPlanningCreateManyInterventionSiteInputEnvelope = {
    data: CleaningPlanningCreateManyInterventionSiteInput | CleaningPlanningCreateManyInterventionSiteInput[]
    skipDuplicates?: boolean
  }

  export type CleaningManagerUpsertWithoutInterventionSitesInput = {
    update: XOR<CleaningManagerUpdateWithoutInterventionSitesInput, CleaningManagerUncheckedUpdateWithoutInterventionSitesInput>
    create: XOR<CleaningManagerCreateWithoutInterventionSitesInput, CleaningManagerUncheckedCreateWithoutInterventionSitesInput>
    where?: CleaningManagerWhereInput
  }

  export type CleaningManagerUpdateToOneWithWhereWithoutInterventionSitesInput = {
    where?: CleaningManagerWhereInput
    data: XOR<CleaningManagerUpdateWithoutInterventionSitesInput, CleaningManagerUncheckedUpdateWithoutInterventionSitesInput>
  }

  export type CleaningManagerUpdateWithoutInterventionSitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCleaningManagersNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutCleaningManagerNestedInput
    cleaningAgents?: AgentUpdateManyWithoutCleaningManagerNestedInput
    cleaningPlannings?: CleaningPlanningUpdateManyWithoutCleaningManagerNestedInput
  }

  export type CleaningManagerUncheckedUpdateWithoutInterventionSitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutCleaningManagerNestedInput
    cleaningAgents?: AgentUncheckedUpdateManyWithoutCleaningManagerNestedInput
    cleaningPlannings?: CleaningPlanningUncheckedUpdateManyWithoutCleaningManagerNestedInput
  }

  export type SiteCleaningSessionUpsertWithWhereUniqueWithoutInterventionSiteInput = {
    where: SiteCleaningSessionWhereUniqueInput
    update: XOR<SiteCleaningSessionUpdateWithoutInterventionSiteInput, SiteCleaningSessionUncheckedUpdateWithoutInterventionSiteInput>
    create: XOR<SiteCleaningSessionCreateWithoutInterventionSiteInput, SiteCleaningSessionUncheckedCreateWithoutInterventionSiteInput>
  }

  export type SiteCleaningSessionUpdateWithWhereUniqueWithoutInterventionSiteInput = {
    where: SiteCleaningSessionWhereUniqueInput
    data: XOR<SiteCleaningSessionUpdateWithoutInterventionSiteInput, SiteCleaningSessionUncheckedUpdateWithoutInterventionSiteInput>
  }

  export type SiteCleaningSessionUpdateManyWithWhereWithoutInterventionSiteInput = {
    where: SiteCleaningSessionScalarWhereInput
    data: XOR<SiteCleaningSessionUpdateManyMutationInput, SiteCleaningSessionUncheckedUpdateManyWithoutInterventionSiteInput>
  }

  export type CleaningPlanningUpsertWithWhereUniqueWithoutInterventionSiteInput = {
    where: CleaningPlanningWhereUniqueInput
    update: XOR<CleaningPlanningUpdateWithoutInterventionSiteInput, CleaningPlanningUncheckedUpdateWithoutInterventionSiteInput>
    create: XOR<CleaningPlanningCreateWithoutInterventionSiteInput, CleaningPlanningUncheckedCreateWithoutInterventionSiteInput>
  }

  export type CleaningPlanningUpdateWithWhereUniqueWithoutInterventionSiteInput = {
    where: CleaningPlanningWhereUniqueInput
    data: XOR<CleaningPlanningUpdateWithoutInterventionSiteInput, CleaningPlanningUncheckedUpdateWithoutInterventionSiteInput>
  }

  export type CleaningPlanningUpdateManyWithWhereWithoutInterventionSiteInput = {
    where: CleaningPlanningScalarWhereInput
    data: XOR<CleaningPlanningUpdateManyMutationInput, CleaningPlanningUncheckedUpdateManyWithoutInterventionSiteInput>
  }

  export type InterventionSiteCreateWithoutSiteCleaningSessionsInput = {
    id?: string
    name: string
    description: string
    client?: string | null
    site?: string | null
    surface?: number | null
    type?: string | null
    address?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManager: CleaningManagerCreateNestedOneWithoutInterventionSitesInput
    cleaningPlannings?: CleaningPlanningCreateNestedManyWithoutInterventionSiteInput
  }

  export type InterventionSiteUncheckedCreateWithoutSiteCleaningSessionsInput = {
    id?: string
    name: string
    description: string
    client?: string | null
    site?: string | null
    surface?: number | null
    type?: string | null
    address?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManagerId: string
    cleaningPlannings?: CleaningPlanningUncheckedCreateNestedManyWithoutInterventionSiteInput
  }

  export type InterventionSiteCreateOrConnectWithoutSiteCleaningSessionsInput = {
    where: InterventionSiteWhereUniqueInput
    create: XOR<InterventionSiteCreateWithoutSiteCleaningSessionsInput, InterventionSiteUncheckedCreateWithoutSiteCleaningSessionsInput>
  }

  export type CleaningManagerCreateWithoutSiteCleaningSessionsInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutCleaningManagersInput
    interventionSites?: InterventionSiteCreateNestedManyWithoutCleaningManagerInput
    cleaningAgents?: AgentCreateNestedManyWithoutCleaningManagerInput
    cleaningPlannings?: CleaningPlanningCreateNestedManyWithoutCleaningManagerInput
  }

  export type CleaningManagerUncheckedCreateWithoutSiteCleaningSessionsInput = {
    id?: string
    userId: string
    createdAt: Date | string
    updatedAt: Date | string
    interventionSites?: InterventionSiteUncheckedCreateNestedManyWithoutCleaningManagerInput
    cleaningAgents?: AgentUncheckedCreateNestedManyWithoutCleaningManagerInput
    cleaningPlannings?: CleaningPlanningUncheckedCreateNestedManyWithoutCleaningManagerInput
  }

  export type CleaningManagerCreateOrConnectWithoutSiteCleaningSessionsInput = {
    where: CleaningManagerWhereUniqueInput
    create: XOR<CleaningManagerCreateWithoutSiteCleaningSessionsInput, CleaningManagerUncheckedCreateWithoutSiteCleaningSessionsInput>
  }

  export type SiteCleaningPhotoCreateWithoutSiteCleaningSessionInput = {
    id?: string
    url: string
    type?: string | null
    createdAt: Date | string
  }

  export type SiteCleaningPhotoUncheckedCreateWithoutSiteCleaningSessionInput = {
    id?: string
    url: string
    type?: string | null
    createdAt: Date | string
  }

  export type SiteCleaningPhotoCreateOrConnectWithoutSiteCleaningSessionInput = {
    where: SiteCleaningPhotoWhereUniqueInput
    create: XOR<SiteCleaningPhotoCreateWithoutSiteCleaningSessionInput, SiteCleaningPhotoUncheckedCreateWithoutSiteCleaningSessionInput>
  }

  export type SiteCleaningPhotoCreateManySiteCleaningSessionInputEnvelope = {
    data: SiteCleaningPhotoCreateManySiteCleaningSessionInput | SiteCleaningPhotoCreateManySiteCleaningSessionInput[]
    skipDuplicates?: boolean
  }

  export type SiteCleaningChecklistCreateWithoutSiteCleaningSessionInput = {
    id?: string
    item: string
    completed?: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SiteCleaningChecklistUncheckedCreateWithoutSiteCleaningSessionInput = {
    id?: string
    item: string
    completed?: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SiteCleaningChecklistCreateOrConnectWithoutSiteCleaningSessionInput = {
    where: SiteCleaningChecklistWhereUniqueInput
    create: XOR<SiteCleaningChecklistCreateWithoutSiteCleaningSessionInput, SiteCleaningChecklistUncheckedCreateWithoutSiteCleaningSessionInput>
  }

  export type SiteCleaningChecklistCreateManySiteCleaningSessionInputEnvelope = {
    data: SiteCleaningChecklistCreateManySiteCleaningSessionInput | SiteCleaningChecklistCreateManySiteCleaningSessionInput[]
    skipDuplicates?: boolean
  }

  export type LaundryManagerCreateWithoutSiteCleaningSessionsInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutLaundryManagersInput
    products?: ProductCreateNestedManyWithoutLaundryManagerInput
    orders?: OrderCreateNestedManyWithoutLaundryManagerInput
    deliveryNotes?: DeliveryNoteCreateNestedManyWithoutLaundryManagerInput
  }

  export type LaundryManagerUncheckedCreateWithoutSiteCleaningSessionsInput = {
    id?: string
    userId: string
    createdAt: Date | string
    updatedAt: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutLaundryManagerInput
    orders?: OrderUncheckedCreateNestedManyWithoutLaundryManagerInput
    deliveryNotes?: DeliveryNoteUncheckedCreateNestedManyWithoutLaundryManagerInput
  }

  export type LaundryManagerCreateOrConnectWithoutSiteCleaningSessionsInput = {
    where: LaundryManagerWhereUniqueInput
    create: XOR<LaundryManagerCreateWithoutSiteCleaningSessionsInput, LaundryManagerUncheckedCreateWithoutSiteCleaningSessionsInput>
  }

  export type AgentCreateWithoutSiteCleaningSessionsInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutAgentInput
    conciergerieManager: ConciergerieManagerCreateNestedOneWithoutAgentsInput
    tasks?: TaskCreateNestedManyWithoutAgentInput
    tickets?: TicketCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningCreateNestedManyWithoutAgentInput
    user: UserCreateNestedOneWithoutAgentInput
    cleaningManager?: CleaningManagerCreateNestedOneWithoutCleaningAgentsInput
  }

  export type AgentUncheckedCreateWithoutSiteCleaningSessionsInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    conciergerieManagerId: string
    userId: string
    cleaningManagerId?: string | null
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutAgentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAgentInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutSiteCleaningSessionsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutSiteCleaningSessionsInput, AgentUncheckedCreateWithoutSiteCleaningSessionsInput>
  }

  export type InterventionSiteUpsertWithoutSiteCleaningSessionsInput = {
    update: XOR<InterventionSiteUpdateWithoutSiteCleaningSessionsInput, InterventionSiteUncheckedUpdateWithoutSiteCleaningSessionsInput>
    create: XOR<InterventionSiteCreateWithoutSiteCleaningSessionsInput, InterventionSiteUncheckedCreateWithoutSiteCleaningSessionsInput>
    where?: InterventionSiteWhereInput
  }

  export type InterventionSiteUpdateToOneWithWhereWithoutSiteCleaningSessionsInput = {
    where?: InterventionSiteWhereInput
    data: XOR<InterventionSiteUpdateWithoutSiteCleaningSessionsInput, InterventionSiteUncheckedUpdateWithoutSiteCleaningSessionsInput>
  }

  export type InterventionSiteUpdateWithoutSiteCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    site?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManager?: CleaningManagerUpdateOneRequiredWithoutInterventionSitesNestedInput
    cleaningPlannings?: CleaningPlanningUpdateManyWithoutInterventionSiteNestedInput
  }

  export type InterventionSiteUncheckedUpdateWithoutSiteCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    site?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    cleaningPlannings?: CleaningPlanningUncheckedUpdateManyWithoutInterventionSiteNestedInput
  }

  export type CleaningManagerUpsertWithoutSiteCleaningSessionsInput = {
    update: XOR<CleaningManagerUpdateWithoutSiteCleaningSessionsInput, CleaningManagerUncheckedUpdateWithoutSiteCleaningSessionsInput>
    create: XOR<CleaningManagerCreateWithoutSiteCleaningSessionsInput, CleaningManagerUncheckedCreateWithoutSiteCleaningSessionsInput>
    where?: CleaningManagerWhereInput
  }

  export type CleaningManagerUpdateToOneWithWhereWithoutSiteCleaningSessionsInput = {
    where?: CleaningManagerWhereInput
    data: XOR<CleaningManagerUpdateWithoutSiteCleaningSessionsInput, CleaningManagerUncheckedUpdateWithoutSiteCleaningSessionsInput>
  }

  export type CleaningManagerUpdateWithoutSiteCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCleaningManagersNestedInput
    interventionSites?: InterventionSiteUpdateManyWithoutCleaningManagerNestedInput
    cleaningAgents?: AgentUpdateManyWithoutCleaningManagerNestedInput
    cleaningPlannings?: CleaningPlanningUpdateManyWithoutCleaningManagerNestedInput
  }

  export type CleaningManagerUncheckedUpdateWithoutSiteCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventionSites?: InterventionSiteUncheckedUpdateManyWithoutCleaningManagerNestedInput
    cleaningAgents?: AgentUncheckedUpdateManyWithoutCleaningManagerNestedInput
    cleaningPlannings?: CleaningPlanningUncheckedUpdateManyWithoutCleaningManagerNestedInput
  }

  export type SiteCleaningPhotoUpsertWithWhereUniqueWithoutSiteCleaningSessionInput = {
    where: SiteCleaningPhotoWhereUniqueInput
    update: XOR<SiteCleaningPhotoUpdateWithoutSiteCleaningSessionInput, SiteCleaningPhotoUncheckedUpdateWithoutSiteCleaningSessionInput>
    create: XOR<SiteCleaningPhotoCreateWithoutSiteCleaningSessionInput, SiteCleaningPhotoUncheckedCreateWithoutSiteCleaningSessionInput>
  }

  export type SiteCleaningPhotoUpdateWithWhereUniqueWithoutSiteCleaningSessionInput = {
    where: SiteCleaningPhotoWhereUniqueInput
    data: XOR<SiteCleaningPhotoUpdateWithoutSiteCleaningSessionInput, SiteCleaningPhotoUncheckedUpdateWithoutSiteCleaningSessionInput>
  }

  export type SiteCleaningPhotoUpdateManyWithWhereWithoutSiteCleaningSessionInput = {
    where: SiteCleaningPhotoScalarWhereInput
    data: XOR<SiteCleaningPhotoUpdateManyMutationInput, SiteCleaningPhotoUncheckedUpdateManyWithoutSiteCleaningSessionInput>
  }

  export type SiteCleaningPhotoScalarWhereInput = {
    AND?: SiteCleaningPhotoScalarWhereInput | SiteCleaningPhotoScalarWhereInput[]
    OR?: SiteCleaningPhotoScalarWhereInput[]
    NOT?: SiteCleaningPhotoScalarWhereInput | SiteCleaningPhotoScalarWhereInput[]
    id?: StringFilter<"SiteCleaningPhoto"> | string
    url?: StringFilter<"SiteCleaningPhoto"> | string
    type?: StringNullableFilter<"SiteCleaningPhoto"> | string | null
    siteCleaningSessionId?: StringFilter<"SiteCleaningPhoto"> | string
    createdAt?: DateTimeFilter<"SiteCleaningPhoto"> | Date | string
  }

  export type SiteCleaningChecklistUpsertWithWhereUniqueWithoutSiteCleaningSessionInput = {
    where: SiteCleaningChecklistWhereUniqueInput
    update: XOR<SiteCleaningChecklistUpdateWithoutSiteCleaningSessionInput, SiteCleaningChecklistUncheckedUpdateWithoutSiteCleaningSessionInput>
    create: XOR<SiteCleaningChecklistCreateWithoutSiteCleaningSessionInput, SiteCleaningChecklistUncheckedCreateWithoutSiteCleaningSessionInput>
  }

  export type SiteCleaningChecklistUpdateWithWhereUniqueWithoutSiteCleaningSessionInput = {
    where: SiteCleaningChecklistWhereUniqueInput
    data: XOR<SiteCleaningChecklistUpdateWithoutSiteCleaningSessionInput, SiteCleaningChecklistUncheckedUpdateWithoutSiteCleaningSessionInput>
  }

  export type SiteCleaningChecklistUpdateManyWithWhereWithoutSiteCleaningSessionInput = {
    where: SiteCleaningChecklistScalarWhereInput
    data: XOR<SiteCleaningChecklistUpdateManyMutationInput, SiteCleaningChecklistUncheckedUpdateManyWithoutSiteCleaningSessionInput>
  }

  export type SiteCleaningChecklistScalarWhereInput = {
    AND?: SiteCleaningChecklistScalarWhereInput | SiteCleaningChecklistScalarWhereInput[]
    OR?: SiteCleaningChecklistScalarWhereInput[]
    NOT?: SiteCleaningChecklistScalarWhereInput | SiteCleaningChecklistScalarWhereInput[]
    id?: StringFilter<"SiteCleaningChecklist"> | string
    item?: StringFilter<"SiteCleaningChecklist"> | string
    completed?: BoolFilter<"SiteCleaningChecklist"> | boolean
    siteCleaningSessionId?: StringFilter<"SiteCleaningChecklist"> | string
    createdAt?: DateTimeFilter<"SiteCleaningChecklist"> | Date | string
    updatedAt?: DateTimeFilter<"SiteCleaningChecklist"> | Date | string
  }

  export type LaundryManagerUpsertWithoutSiteCleaningSessionsInput = {
    update: XOR<LaundryManagerUpdateWithoutSiteCleaningSessionsInput, LaundryManagerUncheckedUpdateWithoutSiteCleaningSessionsInput>
    create: XOR<LaundryManagerCreateWithoutSiteCleaningSessionsInput, LaundryManagerUncheckedCreateWithoutSiteCleaningSessionsInput>
    where?: LaundryManagerWhereInput
  }

  export type LaundryManagerUpdateToOneWithWhereWithoutSiteCleaningSessionsInput = {
    where?: LaundryManagerWhereInput
    data: XOR<LaundryManagerUpdateWithoutSiteCleaningSessionsInput, LaundryManagerUncheckedUpdateWithoutSiteCleaningSessionsInput>
  }

  export type LaundryManagerUpdateWithoutSiteCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLaundryManagersNestedInput
    products?: ProductUpdateManyWithoutLaundryManagerNestedInput
    orders?: OrderUpdateManyWithoutLaundryManagerNestedInput
    deliveryNotes?: DeliveryNoteUpdateManyWithoutLaundryManagerNestedInput
  }

  export type LaundryManagerUncheckedUpdateWithoutSiteCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutLaundryManagerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLaundryManagerNestedInput
    deliveryNotes?: DeliveryNoteUncheckedUpdateManyWithoutLaundryManagerNestedInput
  }

  export type AgentUpsertWithoutSiteCleaningSessionsInput = {
    update: XOR<AgentUpdateWithoutSiteCleaningSessionsInput, AgentUncheckedUpdateWithoutSiteCleaningSessionsInput>
    create: XOR<AgentCreateWithoutSiteCleaningSessionsInput, AgentUncheckedCreateWithoutSiteCleaningSessionsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutSiteCleaningSessionsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutSiteCleaningSessionsInput, AgentUncheckedUpdateWithoutSiteCleaningSessionsInput>
  }

  export type AgentUpdateWithoutSiteCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutAgentNestedInput
    conciergerieManager?: ConciergerieManagerUpdateOneRequiredWithoutAgentsNestedInput
    tasks?: TaskUpdateManyWithoutAgentNestedInput
    tickets?: TicketUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUpdateManyWithoutAgentNestedInput
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    cleaningManager?: CleaningManagerUpdateOneWithoutCleaningAgentsNestedInput
  }

  export type AgentUncheckedUpdateWithoutSiteCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cleaningManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type UserCreateWithoutLaundryManagersInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    conciergerieManagers?: ConciergerieManagerCreateNestedManyWithoutUserInput
    cleaningManagers?: CleaningManagerCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    serviceUsers?: ServiceUserCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLaundryManagersInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    conciergerieManagers?: ConciergerieManagerUncheckedCreateNestedManyWithoutUserInput
    cleaningManagers?: CleaningManagerUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    serviceUsers?: ServiceUserUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLaundryManagersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLaundryManagersInput, UserUncheckedCreateWithoutLaundryManagersInput>
  }

  export type ProductCreateWithoutLaundryManagerInput = {
    id?: string
    name: string
    description: string
    price?: number | null
    stock?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutLaundryManagerInput = {
    id?: string
    name: string
    description: string
    price?: number | null
    stock?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutLaundryManagerInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutLaundryManagerInput, ProductUncheckedCreateWithoutLaundryManagerInput>
  }

  export type ProductCreateManyLaundryManagerInputEnvelope = {
    data: ProductCreateManyLaundryManagerInput | ProductCreateManyLaundryManagerInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutLaundryManagerInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    deliveryDate?: Date | string | null
    client?: string | null
    address?: string | null
    phone?: string | null
    total?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    deliveryNotes?: DeliveryNoteCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutLaundryManagerInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    deliveryDate?: Date | string | null
    client?: string | null
    address?: string | null
    phone?: string | null
    total?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    deliveryNotes?: DeliveryNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutLaundryManagerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutLaundryManagerInput, OrderUncheckedCreateWithoutLaundryManagerInput>
  }

  export type OrderCreateManyLaundryManagerInputEnvelope = {
    data: OrderCreateManyLaundryManagerInput | OrderCreateManyLaundryManagerInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryNoteCreateWithoutLaundryManagerInput = {
    id?: string
    number: string
    date: Date | string
    createdAt: Date | string
    updatedAt: Date | string
    order: OrderCreateNestedOneWithoutDeliveryNotesInput
  }

  export type DeliveryNoteUncheckedCreateWithoutLaundryManagerInput = {
    id?: string
    number: string
    date: Date | string
    orderId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type DeliveryNoteCreateOrConnectWithoutLaundryManagerInput = {
    where: DeliveryNoteWhereUniqueInput
    create: XOR<DeliveryNoteCreateWithoutLaundryManagerInput, DeliveryNoteUncheckedCreateWithoutLaundryManagerInput>
  }

  export type DeliveryNoteCreateManyLaundryManagerInputEnvelope = {
    data: DeliveryNoteCreateManyLaundryManagerInput | DeliveryNoteCreateManyLaundryManagerInput[]
    skipDuplicates?: boolean
  }

  export type SiteCleaningSessionCreateWithoutLaundryManagerInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    interventionSite: InterventionSiteCreateNestedOneWithoutSiteCleaningSessionsInput
    cleaningManager: CleaningManagerCreateNestedOneWithoutSiteCleaningSessionsInput
    photos?: SiteCleaningPhotoCreateNestedManyWithoutSiteCleaningSessionInput
    checklist?: SiteCleaningChecklistCreateNestedManyWithoutSiteCleaningSessionInput
    cleaningAgent?: AgentCreateNestedOneWithoutSiteCleaningSessionsInput
  }

  export type SiteCleaningSessionUncheckedCreateWithoutLaundryManagerInput = {
    id?: string
    interventionSiteId: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManagerId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    cleaningAgentId?: string | null
    photos?: SiteCleaningPhotoUncheckedCreateNestedManyWithoutSiteCleaningSessionInput
    checklist?: SiteCleaningChecklistUncheckedCreateNestedManyWithoutSiteCleaningSessionInput
  }

  export type SiteCleaningSessionCreateOrConnectWithoutLaundryManagerInput = {
    where: SiteCleaningSessionWhereUniqueInput
    create: XOR<SiteCleaningSessionCreateWithoutLaundryManagerInput, SiteCleaningSessionUncheckedCreateWithoutLaundryManagerInput>
  }

  export type SiteCleaningSessionCreateManyLaundryManagerInputEnvelope = {
    data: SiteCleaningSessionCreateManyLaundryManagerInput | SiteCleaningSessionCreateManyLaundryManagerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLaundryManagersInput = {
    update: XOR<UserUpdateWithoutLaundryManagersInput, UserUncheckedUpdateWithoutLaundryManagersInput>
    create: XOR<UserCreateWithoutLaundryManagersInput, UserUncheckedCreateWithoutLaundryManagersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLaundryManagersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLaundryManagersInput, UserUncheckedUpdateWithoutLaundryManagersInput>
  }

  export type UserUpdateWithoutLaundryManagersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    conciergerieManagers?: ConciergerieManagerUpdateManyWithoutUserNestedInput
    cleaningManagers?: CleaningManagerUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    serviceUsers?: ServiceUserUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLaundryManagersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    conciergerieManagers?: ConciergerieManagerUncheckedUpdateManyWithoutUserNestedInput
    cleaningManagers?: CleaningManagerUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    serviceUsers?: ServiceUserUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutLaundryManagerInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutLaundryManagerInput, ProductUncheckedUpdateWithoutLaundryManagerInput>
    create: XOR<ProductCreateWithoutLaundryManagerInput, ProductUncheckedCreateWithoutLaundryManagerInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutLaundryManagerInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutLaundryManagerInput, ProductUncheckedUpdateWithoutLaundryManagerInput>
  }

  export type ProductUpdateManyWithWhereWithoutLaundryManagerInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutLaundryManagerInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    price?: FloatNullableFilter<"Product"> | number | null
    stock?: IntNullableFilter<"Product"> | number | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    laundryManagerId?: StringFilter<"Product"> | string
  }

  export type OrderUpsertWithWhereUniqueWithoutLaundryManagerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutLaundryManagerInput, OrderUncheckedUpdateWithoutLaundryManagerInput>
    create: XOR<OrderCreateWithoutLaundryManagerInput, OrderUncheckedCreateWithoutLaundryManagerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutLaundryManagerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutLaundryManagerInput, OrderUncheckedUpdateWithoutLaundryManagerInput>
  }

  export type OrderUpdateManyWithWhereWithoutLaundryManagerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutLaundryManagerInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    name?: StringFilter<"Order"> | string
    description?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    receivedDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveryDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    client?: StringNullableFilter<"Order"> | string | null
    address?: StringNullableFilter<"Order"> | string | null
    phone?: StringNullableFilter<"Order"> | string | null
    total?: FloatNullableFilter<"Order"> | number | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    laundryManagerId?: StringFilter<"Order"> | string
  }

  export type DeliveryNoteUpsertWithWhereUniqueWithoutLaundryManagerInput = {
    where: DeliveryNoteWhereUniqueInput
    update: XOR<DeliveryNoteUpdateWithoutLaundryManagerInput, DeliveryNoteUncheckedUpdateWithoutLaundryManagerInput>
    create: XOR<DeliveryNoteCreateWithoutLaundryManagerInput, DeliveryNoteUncheckedCreateWithoutLaundryManagerInput>
  }

  export type DeliveryNoteUpdateWithWhereUniqueWithoutLaundryManagerInput = {
    where: DeliveryNoteWhereUniqueInput
    data: XOR<DeliveryNoteUpdateWithoutLaundryManagerInput, DeliveryNoteUncheckedUpdateWithoutLaundryManagerInput>
  }

  export type DeliveryNoteUpdateManyWithWhereWithoutLaundryManagerInput = {
    where: DeliveryNoteScalarWhereInput
    data: XOR<DeliveryNoteUpdateManyMutationInput, DeliveryNoteUncheckedUpdateManyWithoutLaundryManagerInput>
  }

  export type DeliveryNoteScalarWhereInput = {
    AND?: DeliveryNoteScalarWhereInput | DeliveryNoteScalarWhereInput[]
    OR?: DeliveryNoteScalarWhereInput[]
    NOT?: DeliveryNoteScalarWhereInput | DeliveryNoteScalarWhereInput[]
    id?: StringFilter<"DeliveryNote"> | string
    number?: StringFilter<"DeliveryNote"> | string
    date?: DateTimeFilter<"DeliveryNote"> | Date | string
    orderId?: StringFilter<"DeliveryNote"> | string
    laundryManagerId?: StringFilter<"DeliveryNote"> | string
    createdAt?: DateTimeFilter<"DeliveryNote"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryNote"> | Date | string
  }

  export type SiteCleaningSessionUpsertWithWhereUniqueWithoutLaundryManagerInput = {
    where: SiteCleaningSessionWhereUniqueInput
    update: XOR<SiteCleaningSessionUpdateWithoutLaundryManagerInput, SiteCleaningSessionUncheckedUpdateWithoutLaundryManagerInput>
    create: XOR<SiteCleaningSessionCreateWithoutLaundryManagerInput, SiteCleaningSessionUncheckedCreateWithoutLaundryManagerInput>
  }

  export type SiteCleaningSessionUpdateWithWhereUniqueWithoutLaundryManagerInput = {
    where: SiteCleaningSessionWhereUniqueInput
    data: XOR<SiteCleaningSessionUpdateWithoutLaundryManagerInput, SiteCleaningSessionUncheckedUpdateWithoutLaundryManagerInput>
  }

  export type SiteCleaningSessionUpdateManyWithWhereWithoutLaundryManagerInput = {
    where: SiteCleaningSessionScalarWhereInput
    data: XOR<SiteCleaningSessionUpdateManyMutationInput, SiteCleaningSessionUncheckedUpdateManyWithoutLaundryManagerInput>
  }

  export type OrderItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    order: OrderCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    quantity: number
    price?: number | null
    orderId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type LaundryManagerCreateWithoutProductsInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutLaundryManagersInput
    orders?: OrderCreateNestedManyWithoutLaundryManagerInput
    deliveryNotes?: DeliveryNoteCreateNestedManyWithoutLaundryManagerInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutLaundryManagerInput
  }

  export type LaundryManagerUncheckedCreateWithoutProductsInput = {
    id?: string
    userId: string
    createdAt: Date | string
    updatedAt: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutLaundryManagerInput
    deliveryNotes?: DeliveryNoteUncheckedCreateNestedManyWithoutLaundryManagerInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutLaundryManagerInput
  }

  export type LaundryManagerCreateOrConnectWithoutProductsInput = {
    where: LaundryManagerWhereUniqueInput
    create: XOR<LaundryManagerCreateWithoutProductsInput, LaundryManagerUncheckedCreateWithoutProductsInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatNullableFilter<"OrderItem"> | number | null
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
  }

  export type LaundryManagerUpsertWithoutProductsInput = {
    update: XOR<LaundryManagerUpdateWithoutProductsInput, LaundryManagerUncheckedUpdateWithoutProductsInput>
    create: XOR<LaundryManagerCreateWithoutProductsInput, LaundryManagerUncheckedCreateWithoutProductsInput>
    where?: LaundryManagerWhereInput
  }

  export type LaundryManagerUpdateToOneWithWhereWithoutProductsInput = {
    where?: LaundryManagerWhereInput
    data: XOR<LaundryManagerUpdateWithoutProductsInput, LaundryManagerUncheckedUpdateWithoutProductsInput>
  }

  export type LaundryManagerUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLaundryManagersNestedInput
    orders?: OrderUpdateManyWithoutLaundryManagerNestedInput
    deliveryNotes?: DeliveryNoteUpdateManyWithoutLaundryManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutLaundryManagerNestedInput
  }

  export type LaundryManagerUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutLaundryManagerNestedInput
    deliveryNotes?: DeliveryNoteUncheckedUpdateManyWithoutLaundryManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutLaundryManagerNestedInput
  }

  export type LaundryManagerCreateWithoutOrdersInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutLaundryManagersInput
    products?: ProductCreateNestedManyWithoutLaundryManagerInput
    deliveryNotes?: DeliveryNoteCreateNestedManyWithoutLaundryManagerInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutLaundryManagerInput
  }

  export type LaundryManagerUncheckedCreateWithoutOrdersInput = {
    id?: string
    userId: string
    createdAt: Date | string
    updatedAt: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutLaundryManagerInput
    deliveryNotes?: DeliveryNoteUncheckedCreateNestedManyWithoutLaundryManagerInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutLaundryManagerInput
  }

  export type LaundryManagerCreateOrConnectWithoutOrdersInput = {
    where: LaundryManagerWhereUniqueInput
    create: XOR<LaundryManagerCreateWithoutOrdersInput, LaundryManagerUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    quantity: number
    price?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    quantity: number
    price?: number | null
    productId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryNoteCreateWithoutOrderInput = {
    id?: string
    number: string
    date: Date | string
    createdAt: Date | string
    updatedAt: Date | string
    laundryManager: LaundryManagerCreateNestedOneWithoutDeliveryNotesInput
  }

  export type DeliveryNoteUncheckedCreateWithoutOrderInput = {
    id?: string
    number: string
    date: Date | string
    laundryManagerId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type DeliveryNoteCreateOrConnectWithoutOrderInput = {
    where: DeliveryNoteWhereUniqueInput
    create: XOR<DeliveryNoteCreateWithoutOrderInput, DeliveryNoteUncheckedCreateWithoutOrderInput>
  }

  export type DeliveryNoteCreateManyOrderInputEnvelope = {
    data: DeliveryNoteCreateManyOrderInput | DeliveryNoteCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type LaundryManagerUpsertWithoutOrdersInput = {
    update: XOR<LaundryManagerUpdateWithoutOrdersInput, LaundryManagerUncheckedUpdateWithoutOrdersInput>
    create: XOR<LaundryManagerCreateWithoutOrdersInput, LaundryManagerUncheckedCreateWithoutOrdersInput>
    where?: LaundryManagerWhereInput
  }

  export type LaundryManagerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: LaundryManagerWhereInput
    data: XOR<LaundryManagerUpdateWithoutOrdersInput, LaundryManagerUncheckedUpdateWithoutOrdersInput>
  }

  export type LaundryManagerUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLaundryManagersNestedInput
    products?: ProductUpdateManyWithoutLaundryManagerNestedInput
    deliveryNotes?: DeliveryNoteUpdateManyWithoutLaundryManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutLaundryManagerNestedInput
  }

  export type LaundryManagerUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutLaundryManagerNestedInput
    deliveryNotes?: DeliveryNoteUncheckedUpdateManyWithoutLaundryManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutLaundryManagerNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type DeliveryNoteUpsertWithWhereUniqueWithoutOrderInput = {
    where: DeliveryNoteWhereUniqueInput
    update: XOR<DeliveryNoteUpdateWithoutOrderInput, DeliveryNoteUncheckedUpdateWithoutOrderInput>
    create: XOR<DeliveryNoteCreateWithoutOrderInput, DeliveryNoteUncheckedCreateWithoutOrderInput>
  }

  export type DeliveryNoteUpdateWithWhereUniqueWithoutOrderInput = {
    where: DeliveryNoteWhereUniqueInput
    data: XOR<DeliveryNoteUpdateWithoutOrderInput, DeliveryNoteUncheckedUpdateWithoutOrderInput>
  }

  export type DeliveryNoteUpdateManyWithWhereWithoutOrderInput = {
    where: DeliveryNoteScalarWhereInput
    data: XOR<DeliveryNoteUpdateManyMutationInput, DeliveryNoteUncheckedUpdateManyWithoutOrderInput>
  }

  export type PropertyCreateWithoutTicketsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManager: ConciergerieManagerCreateNestedOneWithoutPropertiesInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutPropertyInput
    reservations?: ReservationCreateNestedManyWithoutPropertyInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutTicketsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManagerId: string
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutTicketsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutTicketsInput, PropertyUncheckedCreateWithoutTicketsInput>
  }

  export type AgentCreateWithoutTicketsInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutAgentInput
    conciergerieManager: ConciergerieManagerCreateNestedOneWithoutAgentsInput
    tasks?: TaskCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningCreateNestedManyWithoutAgentInput
    user: UserCreateNestedOneWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutCleaningAgentInput
    cleaningManager?: CleaningManagerCreateNestedOneWithoutCleaningAgentsInput
  }

  export type AgentUncheckedCreateWithoutTicketsInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    conciergerieManagerId: string
    userId: string
    cleaningManagerId?: string | null
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutAgentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAgentInput
    cleaningPlannings?: CleaningPlanningUncheckedCreateNestedManyWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutCleaningAgentInput
  }

  export type AgentCreateOrConnectWithoutTicketsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutTicketsInput, AgentUncheckedCreateWithoutTicketsInput>
  }

  export type TicketPhotoCreateWithoutTicketInput = {
    id?: string
    url: string
    createdAt: Date | string
  }

  export type TicketPhotoUncheckedCreateWithoutTicketInput = {
    id?: string
    url: string
    createdAt: Date | string
  }

  export type TicketPhotoCreateOrConnectWithoutTicketInput = {
    where: TicketPhotoWhereUniqueInput
    create: XOR<TicketPhotoCreateWithoutTicketInput, TicketPhotoUncheckedCreateWithoutTicketInput>
  }

  export type TicketPhotoCreateManyTicketInputEnvelope = {
    data: TicketPhotoCreateManyTicketInput | TicketPhotoCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithoutTicketsInput = {
    update: XOR<PropertyUpdateWithoutTicketsInput, PropertyUncheckedUpdateWithoutTicketsInput>
    create: XOR<PropertyCreateWithoutTicketsInput, PropertyUncheckedCreateWithoutTicketsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutTicketsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutTicketsInput, PropertyUncheckedUpdateWithoutTicketsInput>
  }

  export type PropertyUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManager?: ConciergerieManagerUpdateOneRequiredWithoutPropertiesNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type AgentUpsertWithoutTicketsInput = {
    update: XOR<AgentUpdateWithoutTicketsInput, AgentUncheckedUpdateWithoutTicketsInput>
    create: XOR<AgentCreateWithoutTicketsInput, AgentUncheckedCreateWithoutTicketsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutTicketsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutTicketsInput, AgentUncheckedUpdateWithoutTicketsInput>
  }

  export type AgentUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutAgentNestedInput
    conciergerieManager?: ConciergerieManagerUpdateOneRequiredWithoutAgentsNestedInput
    tasks?: TaskUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUpdateManyWithoutAgentNestedInput
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutCleaningAgentNestedInput
    cleaningManager?: CleaningManagerUpdateOneWithoutCleaningAgentsNestedInput
  }

  export type AgentUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cleaningManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUncheckedUpdateManyWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutCleaningAgentNestedInput
  }

  export type TicketPhotoUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketPhotoWhereUniqueInput
    update: XOR<TicketPhotoUpdateWithoutTicketInput, TicketPhotoUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketPhotoCreateWithoutTicketInput, TicketPhotoUncheckedCreateWithoutTicketInput>
  }

  export type TicketPhotoUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketPhotoWhereUniqueInput
    data: XOR<TicketPhotoUpdateWithoutTicketInput, TicketPhotoUncheckedUpdateWithoutTicketInput>
  }

  export type TicketPhotoUpdateManyWithWhereWithoutTicketInput = {
    where: TicketPhotoScalarWhereInput
    data: XOR<TicketPhotoUpdateManyMutationInput, TicketPhotoUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketPhotoScalarWhereInput = {
    AND?: TicketPhotoScalarWhereInput | TicketPhotoScalarWhereInput[]
    OR?: TicketPhotoScalarWhereInput[]
    NOT?: TicketPhotoScalarWhereInput | TicketPhotoScalarWhereInput[]
    id?: StringFilter<"TicketPhoto"> | string
    url?: StringFilter<"TicketPhoto"> | string
    ticketId?: StringFilter<"TicketPhoto"> | string
    createdAt?: DateTimeFilter<"TicketPhoto"> | Date | string
  }

  export type PropertyCreateWithoutPaymentsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManager: ConciergerieManagerCreateNestedOneWithoutPropertiesInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutPropertyInput
    reservations?: ReservationCreateNestedManyWithoutPropertyInput
    tickets?: TicketCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManagerId: string
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPropertyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPaymentsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPaymentsInput, PropertyUncheckedCreateWithoutPaymentsInput>
  }

  export type PropertyUpsertWithoutPaymentsInput = {
    update: XOR<PropertyUpdateWithoutPaymentsInput, PropertyUncheckedUpdateWithoutPaymentsInput>
    create: XOR<PropertyCreateWithoutPaymentsInput, PropertyUncheckedCreateWithoutPaymentsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPaymentsInput, PropertyUncheckedUpdateWithoutPaymentsInput>
  }

  export type PropertyUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManager?: ConciergerieManagerUpdateOneRequiredWithoutPropertiesNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutPhotosInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManager: ConciergerieManagerCreateNestedOneWithoutPropertiesInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutPropertyInput
    reservations?: ReservationCreateNestedManyWithoutPropertyInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    tickets?: TicketCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPhotosInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManagerId: string
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPhotosInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPhotosInput, PropertyUncheckedCreateWithoutPhotosInput>
  }

  export type PropertyUpsertWithoutPhotosInput = {
    update: XOR<PropertyUpdateWithoutPhotosInput, PropertyUncheckedUpdateWithoutPhotosInput>
    create: XOR<PropertyCreateWithoutPhotosInput, PropertyUncheckedCreateWithoutPhotosInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPhotosInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPhotosInput, PropertyUncheckedUpdateWithoutPhotosInput>
  }

  export type PropertyUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManager?: ConciergerieManagerUpdateOneRequiredWithoutPropertiesNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type CleaningSessionCreateWithoutPhotosInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    property: PropertyCreateNestedOneWithoutCleaningSessionsInput
    cleaning: CleaningCreateNestedOneWithoutCleaningSessionsInput
    agent: AgentCreateNestedOneWithoutCleaningSessionsInput
    checklist?: CleaningChecklistCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionUncheckedCreateWithoutPhotosInput = {
    id?: string
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningId: string
    agentId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    checklist?: CleaningChecklistUncheckedCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionCreateOrConnectWithoutPhotosInput = {
    where: CleaningSessionWhereUniqueInput
    create: XOR<CleaningSessionCreateWithoutPhotosInput, CleaningSessionUncheckedCreateWithoutPhotosInput>
  }

  export type CleaningSessionUpsertWithoutPhotosInput = {
    update: XOR<CleaningSessionUpdateWithoutPhotosInput, CleaningSessionUncheckedUpdateWithoutPhotosInput>
    create: XOR<CleaningSessionCreateWithoutPhotosInput, CleaningSessionUncheckedCreateWithoutPhotosInput>
    where?: CleaningSessionWhereInput
  }

  export type CleaningSessionUpdateToOneWithWhereWithoutPhotosInput = {
    where?: CleaningSessionWhereInput
    data: XOR<CleaningSessionUpdateWithoutPhotosInput, CleaningSessionUncheckedUpdateWithoutPhotosInput>
  }

  export type CleaningSessionUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    property?: PropertyUpdateOneRequiredWithoutCleaningSessionsNestedInput
    cleaning?: CleaningUpdateOneRequiredWithoutCleaningSessionsNestedInput
    agent?: AgentUpdateOneRequiredWithoutCleaningSessionsNestedInput
    checklist?: CleaningChecklistUpdateManyWithoutCleaningSessionNestedInput
  }

  export type CleaningSessionUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: CleaningChecklistUncheckedUpdateManyWithoutCleaningSessionNestedInput
  }

  export type MaintenanceSessionCreateWithoutPhotosInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    notes?: string | null
    property: PropertyCreateNestedOneWithoutMaintenanceSessionsInput
    maintenance: MaintenanceCreateNestedOneWithoutSessionMaintenancesInput
    agent: AgentCreateNestedOneWithoutMaintenanceSessionsInput
  }

  export type MaintenanceSessionUncheckedCreateWithoutPhotosInput = {
    id?: string
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
    maintenanceId: string
    agentId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    notes?: string | null
  }

  export type MaintenanceSessionCreateOrConnectWithoutPhotosInput = {
    where: MaintenanceSessionWhereUniqueInput
    create: XOR<MaintenanceSessionCreateWithoutPhotosInput, MaintenanceSessionUncheckedCreateWithoutPhotosInput>
  }

  export type MaintenanceSessionUpsertWithoutPhotosInput = {
    update: XOR<MaintenanceSessionUpdateWithoutPhotosInput, MaintenanceSessionUncheckedUpdateWithoutPhotosInput>
    create: XOR<MaintenanceSessionCreateWithoutPhotosInput, MaintenanceSessionUncheckedCreateWithoutPhotosInput>
    where?: MaintenanceSessionWhereInput
  }

  export type MaintenanceSessionUpdateToOneWithWhereWithoutPhotosInput = {
    where?: MaintenanceSessionWhereInput
    data: XOR<MaintenanceSessionUpdateWithoutPhotosInput, MaintenanceSessionUncheckedUpdateWithoutPhotosInput>
  }

  export type MaintenanceSessionUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    property?: PropertyUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    maintenance?: MaintenanceUpdateOneRequiredWithoutSessionMaintenancesNestedInput
    agent?: AgentUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SiteCleaningSessionCreateWithoutPhotosInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    interventionSite: InterventionSiteCreateNestedOneWithoutSiteCleaningSessionsInput
    cleaningManager: CleaningManagerCreateNestedOneWithoutSiteCleaningSessionsInput
    checklist?: SiteCleaningChecklistCreateNestedManyWithoutSiteCleaningSessionInput
    laundryManager?: LaundryManagerCreateNestedOneWithoutSiteCleaningSessionsInput
    cleaningAgent?: AgentCreateNestedOneWithoutSiteCleaningSessionsInput
  }

  export type SiteCleaningSessionUncheckedCreateWithoutPhotosInput = {
    id?: string
    interventionSiteId: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManagerId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    laundryManagerId?: string | null
    cleaningAgentId?: string | null
    checklist?: SiteCleaningChecklistUncheckedCreateNestedManyWithoutSiteCleaningSessionInput
  }

  export type SiteCleaningSessionCreateOrConnectWithoutPhotosInput = {
    where: SiteCleaningSessionWhereUniqueInput
    create: XOR<SiteCleaningSessionCreateWithoutPhotosInput, SiteCleaningSessionUncheckedCreateWithoutPhotosInput>
  }

  export type SiteCleaningSessionUpsertWithoutPhotosInput = {
    update: XOR<SiteCleaningSessionUpdateWithoutPhotosInput, SiteCleaningSessionUncheckedUpdateWithoutPhotosInput>
    create: XOR<SiteCleaningSessionCreateWithoutPhotosInput, SiteCleaningSessionUncheckedCreateWithoutPhotosInput>
    where?: SiteCleaningSessionWhereInput
  }

  export type SiteCleaningSessionUpdateToOneWithWhereWithoutPhotosInput = {
    where?: SiteCleaningSessionWhereInput
    data: XOR<SiteCleaningSessionUpdateWithoutPhotosInput, SiteCleaningSessionUncheckedUpdateWithoutPhotosInput>
  }

  export type SiteCleaningSessionUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    interventionSite?: InterventionSiteUpdateOneRequiredWithoutSiteCleaningSessionsNestedInput
    cleaningManager?: CleaningManagerUpdateOneRequiredWithoutSiteCleaningSessionsNestedInput
    checklist?: SiteCleaningChecklistUpdateManyWithoutSiteCleaningSessionNestedInput
    laundryManager?: LaundryManagerUpdateOneWithoutSiteCleaningSessionsNestedInput
    cleaningAgent?: AgentUpdateOneWithoutSiteCleaningSessionsNestedInput
  }

  export type SiteCleaningSessionUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    interventionSiteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    laundryManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    checklist?: SiteCleaningChecklistUncheckedUpdateManyWithoutSiteCleaningSessionNestedInput
  }

  export type TicketCreateWithoutPhotosInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    property: PropertyCreateNestedOneWithoutTicketsInput
    agent?: AgentCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutPhotosInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: string | null
    propertyId: string
    agentId?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TicketCreateOrConnectWithoutPhotosInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutPhotosInput, TicketUncheckedCreateWithoutPhotosInput>
  }

  export type TicketUpsertWithoutPhotosInput = {
    update: XOR<TicketUpdateWithoutPhotosInput, TicketUncheckedUpdateWithoutPhotosInput>
    create: XOR<TicketCreateWithoutPhotosInput, TicketUncheckedCreateWithoutPhotosInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutPhotosInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutPhotosInput, TicketUncheckedUpdateWithoutPhotosInput>
  }

  export type TicketUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutTicketsNestedInput
    agent?: AgentUpdateOneWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSessionCreateWithoutChecklistInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    property: PropertyCreateNestedOneWithoutCleaningSessionsInput
    cleaning: CleaningCreateNestedOneWithoutCleaningSessionsInput
    agent: AgentCreateNestedOneWithoutCleaningSessionsInput
    photos?: CleaningPhotoCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionUncheckedCreateWithoutChecklistInput = {
    id?: string
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningId: string
    agentId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    photos?: CleaningPhotoUncheckedCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionCreateOrConnectWithoutChecklistInput = {
    where: CleaningSessionWhereUniqueInput
    create: XOR<CleaningSessionCreateWithoutChecklistInput, CleaningSessionUncheckedCreateWithoutChecklistInput>
  }

  export type CleaningSessionUpsertWithoutChecklistInput = {
    update: XOR<CleaningSessionUpdateWithoutChecklistInput, CleaningSessionUncheckedUpdateWithoutChecklistInput>
    create: XOR<CleaningSessionCreateWithoutChecklistInput, CleaningSessionUncheckedCreateWithoutChecklistInput>
    where?: CleaningSessionWhereInput
  }

  export type CleaningSessionUpdateToOneWithWhereWithoutChecklistInput = {
    where?: CleaningSessionWhereInput
    data: XOR<CleaningSessionUpdateWithoutChecklistInput, CleaningSessionUncheckedUpdateWithoutChecklistInput>
  }

  export type CleaningSessionUpdateWithoutChecklistInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    property?: PropertyUpdateOneRequiredWithoutCleaningSessionsNestedInput
    cleaning?: CleaningUpdateOneRequiredWithoutCleaningSessionsNestedInput
    agent?: AgentUpdateOneRequiredWithoutCleaningSessionsNestedInput
    photos?: CleaningPhotoUpdateManyWithoutCleaningSessionNestedInput
  }

  export type CleaningSessionUncheckedUpdateWithoutChecklistInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: CleaningPhotoUncheckedUpdateManyWithoutCleaningSessionNestedInput
  }

  export type SiteCleaningSessionCreateWithoutChecklistInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    interventionSite: InterventionSiteCreateNestedOneWithoutSiteCleaningSessionsInput
    cleaningManager: CleaningManagerCreateNestedOneWithoutSiteCleaningSessionsInput
    photos?: SiteCleaningPhotoCreateNestedManyWithoutSiteCleaningSessionInput
    laundryManager?: LaundryManagerCreateNestedOneWithoutSiteCleaningSessionsInput
    cleaningAgent?: AgentCreateNestedOneWithoutSiteCleaningSessionsInput
  }

  export type SiteCleaningSessionUncheckedCreateWithoutChecklistInput = {
    id?: string
    interventionSiteId: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManagerId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    laundryManagerId?: string | null
    cleaningAgentId?: string | null
    photos?: SiteCleaningPhotoUncheckedCreateNestedManyWithoutSiteCleaningSessionInput
  }

  export type SiteCleaningSessionCreateOrConnectWithoutChecklistInput = {
    where: SiteCleaningSessionWhereUniqueInput
    create: XOR<SiteCleaningSessionCreateWithoutChecklistInput, SiteCleaningSessionUncheckedCreateWithoutChecklistInput>
  }

  export type SiteCleaningSessionUpsertWithoutChecklistInput = {
    update: XOR<SiteCleaningSessionUpdateWithoutChecklistInput, SiteCleaningSessionUncheckedUpdateWithoutChecklistInput>
    create: XOR<SiteCleaningSessionCreateWithoutChecklistInput, SiteCleaningSessionUncheckedCreateWithoutChecklistInput>
    where?: SiteCleaningSessionWhereInput
  }

  export type SiteCleaningSessionUpdateToOneWithWhereWithoutChecklistInput = {
    where?: SiteCleaningSessionWhereInput
    data: XOR<SiteCleaningSessionUpdateWithoutChecklistInput, SiteCleaningSessionUncheckedUpdateWithoutChecklistInput>
  }

  export type SiteCleaningSessionUpdateWithoutChecklistInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    interventionSite?: InterventionSiteUpdateOneRequiredWithoutSiteCleaningSessionsNestedInput
    cleaningManager?: CleaningManagerUpdateOneRequiredWithoutSiteCleaningSessionsNestedInput
    photos?: SiteCleaningPhotoUpdateManyWithoutSiteCleaningSessionNestedInput
    laundryManager?: LaundryManagerUpdateOneWithoutSiteCleaningSessionsNestedInput
    cleaningAgent?: AgentUpdateOneWithoutSiteCleaningSessionsNestedInput
  }

  export type SiteCleaningSessionUncheckedUpdateWithoutChecklistInput = {
    id?: StringFieldUpdateOperationsInput | string
    interventionSiteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    laundryManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: SiteCleaningPhotoUncheckedUpdateManyWithoutSiteCleaningSessionNestedInput
  }

  export type InterventionSiteCreateWithoutCleaningPlanningsInput = {
    id?: string
    name: string
    description: string
    client?: string | null
    site?: string | null
    surface?: number | null
    type?: string | null
    address?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManager: CleaningManagerCreateNestedOneWithoutInterventionSitesInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutInterventionSiteInput
  }

  export type InterventionSiteUncheckedCreateWithoutCleaningPlanningsInput = {
    id?: string
    name: string
    description: string
    client?: string | null
    site?: string | null
    surface?: number | null
    type?: string | null
    address?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManagerId: string
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutInterventionSiteInput
  }

  export type InterventionSiteCreateOrConnectWithoutCleaningPlanningsInput = {
    where: InterventionSiteWhereUniqueInput
    create: XOR<InterventionSiteCreateWithoutCleaningPlanningsInput, InterventionSiteUncheckedCreateWithoutCleaningPlanningsInput>
  }

  export type CleaningManagerCreateWithoutCleaningPlanningsInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutCleaningManagersInput
    interventionSites?: InterventionSiteCreateNestedManyWithoutCleaningManagerInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutCleaningManagerInput
    cleaningAgents?: AgentCreateNestedManyWithoutCleaningManagerInput
  }

  export type CleaningManagerUncheckedCreateWithoutCleaningPlanningsInput = {
    id?: string
    userId: string
    createdAt: Date | string
    updatedAt: Date | string
    interventionSites?: InterventionSiteUncheckedCreateNestedManyWithoutCleaningManagerInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutCleaningManagerInput
    cleaningAgents?: AgentUncheckedCreateNestedManyWithoutCleaningManagerInput
  }

  export type CleaningManagerCreateOrConnectWithoutCleaningPlanningsInput = {
    where: CleaningManagerWhereUniqueInput
    create: XOR<CleaningManagerCreateWithoutCleaningPlanningsInput, CleaningManagerUncheckedCreateWithoutCleaningPlanningsInput>
  }

  export type AgentCreateWithoutCleaningPlanningsInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutAgentInput
    conciergerieManager: ConciergerieManagerCreateNestedOneWithoutAgentsInput
    tasks?: TaskCreateNestedManyWithoutAgentInput
    tickets?: TicketCreateNestedManyWithoutAgentInput
    user: UserCreateNestedOneWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutCleaningAgentInput
    cleaningManager?: CleaningManagerCreateNestedOneWithoutCleaningAgentsInput
  }

  export type AgentUncheckedCreateWithoutCleaningPlanningsInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    conciergerieManagerId: string
    userId: string
    cleaningManagerId?: string | null
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutAgentInput
    tasks?: TaskUncheckedCreateNestedManyWithoutAgentInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAgentInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutCleaningAgentInput
  }

  export type AgentCreateOrConnectWithoutCleaningPlanningsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutCleaningPlanningsInput, AgentUncheckedCreateWithoutCleaningPlanningsInput>
  }

  export type InterventionSiteUpsertWithoutCleaningPlanningsInput = {
    update: XOR<InterventionSiteUpdateWithoutCleaningPlanningsInput, InterventionSiteUncheckedUpdateWithoutCleaningPlanningsInput>
    create: XOR<InterventionSiteCreateWithoutCleaningPlanningsInput, InterventionSiteUncheckedCreateWithoutCleaningPlanningsInput>
    where?: InterventionSiteWhereInput
  }

  export type InterventionSiteUpdateToOneWithWhereWithoutCleaningPlanningsInput = {
    where?: InterventionSiteWhereInput
    data: XOR<InterventionSiteUpdateWithoutCleaningPlanningsInput, InterventionSiteUncheckedUpdateWithoutCleaningPlanningsInput>
  }

  export type InterventionSiteUpdateWithoutCleaningPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    site?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManager?: CleaningManagerUpdateOneRequiredWithoutInterventionSitesNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutInterventionSiteNestedInput
  }

  export type InterventionSiteUncheckedUpdateWithoutCleaningPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    site?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutInterventionSiteNestedInput
  }

  export type CleaningManagerUpsertWithoutCleaningPlanningsInput = {
    update: XOR<CleaningManagerUpdateWithoutCleaningPlanningsInput, CleaningManagerUncheckedUpdateWithoutCleaningPlanningsInput>
    create: XOR<CleaningManagerCreateWithoutCleaningPlanningsInput, CleaningManagerUncheckedCreateWithoutCleaningPlanningsInput>
    where?: CleaningManagerWhereInput
  }

  export type CleaningManagerUpdateToOneWithWhereWithoutCleaningPlanningsInput = {
    where?: CleaningManagerWhereInput
    data: XOR<CleaningManagerUpdateWithoutCleaningPlanningsInput, CleaningManagerUncheckedUpdateWithoutCleaningPlanningsInput>
  }

  export type CleaningManagerUpdateWithoutCleaningPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCleaningManagersNestedInput
    interventionSites?: InterventionSiteUpdateManyWithoutCleaningManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutCleaningManagerNestedInput
    cleaningAgents?: AgentUpdateManyWithoutCleaningManagerNestedInput
  }

  export type CleaningManagerUncheckedUpdateWithoutCleaningPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventionSites?: InterventionSiteUncheckedUpdateManyWithoutCleaningManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutCleaningManagerNestedInput
    cleaningAgents?: AgentUncheckedUpdateManyWithoutCleaningManagerNestedInput
  }

  export type AgentUpsertWithoutCleaningPlanningsInput = {
    update: XOR<AgentUpdateWithoutCleaningPlanningsInput, AgentUncheckedUpdateWithoutCleaningPlanningsInput>
    create: XOR<AgentCreateWithoutCleaningPlanningsInput, AgentUncheckedCreateWithoutCleaningPlanningsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutCleaningPlanningsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutCleaningPlanningsInput, AgentUncheckedUpdateWithoutCleaningPlanningsInput>
  }

  export type AgentUpdateWithoutCleaningPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutAgentNestedInput
    conciergerieManager?: ConciergerieManagerUpdateOneRequiredWithoutAgentsNestedInput
    tasks?: TaskUpdateManyWithoutAgentNestedInput
    tickets?: TicketUpdateManyWithoutAgentNestedInput
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutCleaningAgentNestedInput
    cleaningManager?: CleaningManagerUpdateOneWithoutCleaningAgentsNestedInput
  }

  export type AgentUncheckedUpdateWithoutCleaningPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cleaningManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutCleaningAgentNestedInput
  }

  export type OrderCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    deliveryDate?: Date | string | null
    client?: string | null
    address?: string | null
    phone?: string | null
    total?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    laundryManager: LaundryManagerCreateNestedOneWithoutOrdersInput
    deliveryNotes?: DeliveryNoteCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    deliveryDate?: Date | string | null
    client?: string | null
    address?: string | null
    phone?: string | null
    total?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    laundryManagerId: string
    deliveryNotes?: DeliveryNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrderItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    description: string
    price?: number | null
    stock?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    laundryManager: LaundryManagerCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    description: string
    price?: number | null
    stock?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    laundryManagerId: string
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutOrderItemsInput = {
    update: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryManager?: LaundryManagerUpdateOneRequiredWithoutOrdersNestedInput
    deliveryNotes?: DeliveryNoteUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryManagerId?: StringFieldUpdateOperationsInput | string
    deliveryNotes?: DeliveryNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryManager?: LaundryManagerUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryManagerId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderCreateWithoutDeliveryNotesInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    deliveryDate?: Date | string | null
    client?: string | null
    address?: string | null
    phone?: string | null
    total?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    laundryManager: LaundryManagerCreateNestedOneWithoutOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutDeliveryNotesInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    deliveryDate?: Date | string | null
    client?: string | null
    address?: string | null
    phone?: string | null
    total?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    laundryManagerId: string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutDeliveryNotesInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutDeliveryNotesInput, OrderUncheckedCreateWithoutDeliveryNotesInput>
  }

  export type LaundryManagerCreateWithoutDeliveryNotesInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutLaundryManagersInput
    products?: ProductCreateNestedManyWithoutLaundryManagerInput
    orders?: OrderCreateNestedManyWithoutLaundryManagerInput
    siteCleaningSessions?: SiteCleaningSessionCreateNestedManyWithoutLaundryManagerInput
  }

  export type LaundryManagerUncheckedCreateWithoutDeliveryNotesInput = {
    id?: string
    userId: string
    createdAt: Date | string
    updatedAt: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutLaundryManagerInput
    orders?: OrderUncheckedCreateNestedManyWithoutLaundryManagerInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedCreateNestedManyWithoutLaundryManagerInput
  }

  export type LaundryManagerCreateOrConnectWithoutDeliveryNotesInput = {
    where: LaundryManagerWhereUniqueInput
    create: XOR<LaundryManagerCreateWithoutDeliveryNotesInput, LaundryManagerUncheckedCreateWithoutDeliveryNotesInput>
  }

  export type OrderUpsertWithoutDeliveryNotesInput = {
    update: XOR<OrderUpdateWithoutDeliveryNotesInput, OrderUncheckedUpdateWithoutDeliveryNotesInput>
    create: XOR<OrderCreateWithoutDeliveryNotesInput, OrderUncheckedCreateWithoutDeliveryNotesInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutDeliveryNotesInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutDeliveryNotesInput, OrderUncheckedUpdateWithoutDeliveryNotesInput>
  }

  export type OrderUpdateWithoutDeliveryNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryManager?: LaundryManagerUpdateOneRequiredWithoutOrdersNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutDeliveryNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryManagerId?: StringFieldUpdateOperationsInput | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LaundryManagerUpsertWithoutDeliveryNotesInput = {
    update: XOR<LaundryManagerUpdateWithoutDeliveryNotesInput, LaundryManagerUncheckedUpdateWithoutDeliveryNotesInput>
    create: XOR<LaundryManagerCreateWithoutDeliveryNotesInput, LaundryManagerUncheckedCreateWithoutDeliveryNotesInput>
    where?: LaundryManagerWhereInput
  }

  export type LaundryManagerUpdateToOneWithWhereWithoutDeliveryNotesInput = {
    where?: LaundryManagerWhereInput
    data: XOR<LaundryManagerUpdateWithoutDeliveryNotesInput, LaundryManagerUncheckedUpdateWithoutDeliveryNotesInput>
  }

  export type LaundryManagerUpdateWithoutDeliveryNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLaundryManagersNestedInput
    products?: ProductUpdateManyWithoutLaundryManagerNestedInput
    orders?: OrderUpdateManyWithoutLaundryManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutLaundryManagerNestedInput
  }

  export type LaundryManagerUncheckedUpdateWithoutDeliveryNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutLaundryManagerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLaundryManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutLaundryManagerNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    conciergerieManagers?: ConciergerieManagerCreateNestedManyWithoutUserInput
    cleaningManagers?: CleaningManagerCreateNestedManyWithoutUserInput
    laundryManagers?: LaundryManagerCreateNestedManyWithoutUserInput
    serviceUsers?: ServiceUserCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    conciergerieManagers?: ConciergerieManagerUncheckedCreateNestedManyWithoutUserInput
    cleaningManagers?: CleaningManagerUncheckedCreateNestedManyWithoutUserInput
    laundryManagers?: LaundryManagerUncheckedCreateNestedManyWithoutUserInput
    serviceUsers?: ServiceUserUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    conciergerieManagers?: ConciergerieManagerUpdateManyWithoutUserNestedInput
    cleaningManagers?: CleaningManagerUpdateManyWithoutUserNestedInput
    laundryManagers?: LaundryManagerUpdateManyWithoutUserNestedInput
    serviceUsers?: ServiceUserUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    conciergerieManagers?: ConciergerieManagerUncheckedUpdateManyWithoutUserNestedInput
    cleaningManagers?: CleaningManagerUncheckedUpdateManyWithoutUserNestedInput
    laundryManagers?: LaundryManagerUncheckedUpdateManyWithoutUserNestedInput
    serviceUsers?: ServiceUserUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceUserCreateWithoutServiceInput = {
    id?: string
    name: string
    status?: $Enums.ServiceUserStatus
    user: UserCreateNestedOneWithoutServiceUsersInput
  }

  export type ServiceUserUncheckedCreateWithoutServiceInput = {
    id?: string
    name: string
    status?: $Enums.ServiceUserStatus
    userId: string
  }

  export type ServiceUserCreateOrConnectWithoutServiceInput = {
    where: ServiceUserWhereUniqueInput
    create: XOR<ServiceUserCreateWithoutServiceInput, ServiceUserUncheckedCreateWithoutServiceInput>
  }

  export type ServiceUserCreateManyServiceInputEnvelope = {
    data: ServiceUserCreateManyServiceInput | ServiceUserCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUserUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceUserWhereUniqueInput
    update: XOR<ServiceUserUpdateWithoutServiceInput, ServiceUserUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceUserCreateWithoutServiceInput, ServiceUserUncheckedCreateWithoutServiceInput>
  }

  export type ServiceUserUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceUserWhereUniqueInput
    data: XOR<ServiceUserUpdateWithoutServiceInput, ServiceUserUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceUserUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceUserScalarWhereInput
    data: XOR<ServiceUserUpdateManyMutationInput, ServiceUserUncheckedUpdateManyWithoutServiceInput>
  }

  export type UserCreateWithoutServiceUsersInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    conciergerieManagers?: ConciergerieManagerCreateNestedManyWithoutUserInput
    cleaningManagers?: CleaningManagerCreateNestedManyWithoutUserInput
    laundryManagers?: LaundryManagerCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutServiceUsersInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    conciergerieManagers?: ConciergerieManagerUncheckedCreateNestedManyWithoutUserInput
    cleaningManagers?: CleaningManagerUncheckedCreateNestedManyWithoutUserInput
    laundryManagers?: LaundryManagerUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutServiceUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServiceUsersInput, UserUncheckedCreateWithoutServiceUsersInput>
  }

  export type ServiceCreateWithoutUsersInput = {
    id?: string
    name: string
    description: string
  }

  export type ServiceUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description: string
  }

  export type ServiceCreateOrConnectWithoutUsersInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutUsersInput, ServiceUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutServiceUsersInput = {
    update: XOR<UserUpdateWithoutServiceUsersInput, UserUncheckedUpdateWithoutServiceUsersInput>
    create: XOR<UserCreateWithoutServiceUsersInput, UserUncheckedCreateWithoutServiceUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServiceUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServiceUsersInput, UserUncheckedUpdateWithoutServiceUsersInput>
  }

  export type UserUpdateWithoutServiceUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    conciergerieManagers?: ConciergerieManagerUpdateManyWithoutUserNestedInput
    cleaningManagers?: CleaningManagerUpdateManyWithoutUserNestedInput
    laundryManagers?: LaundryManagerUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutServiceUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    conciergerieManagers?: ConciergerieManagerUncheckedUpdateManyWithoutUserNestedInput
    cleaningManagers?: CleaningManagerUncheckedUpdateManyWithoutUserNestedInput
    laundryManagers?: LaundryManagerUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceUpsertWithoutUsersInput = {
    update: XOR<ServiceUpdateWithoutUsersInput, ServiceUncheckedUpdateWithoutUsersInput>
    create: XOR<ServiceCreateWithoutUsersInput, ServiceUncheckedCreateWithoutUsersInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutUsersInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutUsersInput, ServiceUncheckedUpdateWithoutUsersInput>
  }

  export type ServiceUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    conciergerieManagers?: ConciergerieManagerCreateNestedManyWithoutUserInput
    cleaningManagers?: CleaningManagerCreateNestedManyWithoutUserInput
    laundryManagers?: LaundryManagerCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    serviceUsers?: ServiceUserCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    conciergerieManagers?: ConciergerieManagerUncheckedCreateNestedManyWithoutUserInput
    cleaningManagers?: CleaningManagerUncheckedCreateNestedManyWithoutUserInput
    laundryManagers?: LaundryManagerUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    serviceUsers?: ServiceUserUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    conciergerieManagers?: ConciergerieManagerUpdateManyWithoutUserNestedInput
    cleaningManagers?: CleaningManagerUpdateManyWithoutUserNestedInput
    laundryManagers?: LaundryManagerUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    serviceUsers?: ServiceUserUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    conciergerieManagers?: ConciergerieManagerUncheckedUpdateManyWithoutUserNestedInput
    cleaningManagers?: CleaningManagerUncheckedUpdateManyWithoutUserNestedInput
    laundryManagers?: LaundryManagerUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    serviceUsers?: ServiceUserUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    conciergerieManagers?: ConciergerieManagerCreateNestedManyWithoutUserInput
    cleaningManagers?: CleaningManagerCreateNestedManyWithoutUserInput
    laundryManagers?: LaundryManagerCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    serviceUsers?: ServiceUserCreateNestedManyWithoutUserInput
    agent?: AgentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    role?: $Enums.Role
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    conciergerieManagers?: ConciergerieManagerUncheckedCreateNestedManyWithoutUserInput
    cleaningManagers?: CleaningManagerUncheckedCreateNestedManyWithoutUserInput
    laundryManagers?: LaundryManagerUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    serviceUsers?: ServiceUserUncheckedCreateNestedManyWithoutUserInput
    agent?: AgentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    conciergerieManagers?: ConciergerieManagerUpdateManyWithoutUserNestedInput
    cleaningManagers?: CleaningManagerUpdateManyWithoutUserNestedInput
    laundryManagers?: LaundryManagerUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    serviceUsers?: ServiceUserUpdateManyWithoutUserNestedInput
    agent?: AgentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    conciergerieManagers?: ConciergerieManagerUncheckedUpdateManyWithoutUserNestedInput
    cleaningManagers?: CleaningManagerUncheckedUpdateManyWithoutUserNestedInput
    laundryManagers?: LaundryManagerUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    serviceUsers?: ServiceUserUncheckedUpdateManyWithoutUserNestedInput
    agent?: AgentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SessionCreateManyUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ConciergerieManagerCreateManyUserInput = {
    id?: string
    name: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CleaningManagerCreateManyUserInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LaundryManagerCreateManyUserInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type?: string | null
    read?: boolean
    createdAt: Date | string
  }

  export type ServiceUserCreateManyUserInput = {
    id?: string
    name: string
    status?: $Enums.ServiceUserStatus
    serviceId: string
  }

  export type AgentCreateManyUserInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    conciergerieManagerId: string
    cleaningManagerId?: string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConciergerieManagerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutConciergerieManagerNestedInput
    agents?: AgentUpdateManyWithoutConciergerieManagerNestedInput
    tasks?: TaskUpdateManyWithoutConciergerieManagerNestedInput
  }

  export type ConciergerieManagerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutConciergerieManagerNestedInput
    agents?: AgentUncheckedUpdateManyWithoutConciergerieManagerNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutConciergerieManagerNestedInput
  }

  export type ConciergerieManagerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningManagerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventionSites?: InterventionSiteUpdateManyWithoutCleaningManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutCleaningManagerNestedInput
    cleaningAgents?: AgentUpdateManyWithoutCleaningManagerNestedInput
    cleaningPlannings?: CleaningPlanningUpdateManyWithoutCleaningManagerNestedInput
  }

  export type CleaningManagerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventionSites?: InterventionSiteUncheckedUpdateManyWithoutCleaningManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutCleaningManagerNestedInput
    cleaningAgents?: AgentUncheckedUpdateManyWithoutCleaningManagerNestedInput
    cleaningPlannings?: CleaningPlanningUncheckedUpdateManyWithoutCleaningManagerNestedInput
  }

  export type CleaningManagerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryManagerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutLaundryManagerNestedInput
    orders?: OrderUpdateManyWithoutLaundryManagerNestedInput
    deliveryNotes?: DeliveryNoteUpdateManyWithoutLaundryManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutLaundryManagerNestedInput
  }

  export type LaundryManagerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutLaundryManagerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLaundryManagerNestedInput
    deliveryNotes?: DeliveryNoteUncheckedUpdateManyWithoutLaundryManagerNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutLaundryManagerNestedInput
  }

  export type LaundryManagerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceUserStatusFieldUpdateOperationsInput | $Enums.ServiceUserStatus
    service?: ServiceUpdateOneRequiredWithoutUsersNestedInput
  }

  export type ServiceUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceUserStatusFieldUpdateOperationsInput | $Enums.ServiceUserStatus
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceUserStatusFieldUpdateOperationsInput | $Enums.ServiceUserStatus
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type AgentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutAgentNestedInput
    conciergerieManager?: ConciergerieManagerUpdateOneRequiredWithoutAgentsNestedInput
    tasks?: TaskUpdateManyWithoutAgentNestedInput
    tickets?: TicketUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUpdateManyWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutCleaningAgentNestedInput
    cleaningManager?: CleaningManagerUpdateOneWithoutCleaningAgentsNestedInput
  }

  export type AgentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    cleaningManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUncheckedUpdateManyWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutCleaningAgentNestedInput
  }

  export type AgentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    cleaningManagerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyCreateManyConciergerieManagerInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    location?: string | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBathrooms?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AgentCreateManyConciergerieManagerInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    userId: string
    cleaningManagerId?: string | null
  }

  export type TaskCreateManyConciergerieManagerInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    agentId?: string | null
  }

  export type PropertyUpdateWithoutConciergerieManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningSessions?: CleaningSessionUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutConciergerieManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutConciergerieManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUpdateWithoutConciergerieManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutAgentNestedInput
    tasks?: TaskUpdateManyWithoutAgentNestedInput
    tickets?: TicketUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUpdateManyWithoutAgentNestedInput
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutCleaningAgentNestedInput
    cleaningManager?: CleaningManagerUpdateOneWithoutCleaningAgentsNestedInput
  }

  export type AgentUncheckedUpdateWithoutConciergerieManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    userId?: StringFieldUpdateOperationsInput | string
    cleaningManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUncheckedUpdateManyWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutCleaningAgentNestedInput
  }

  export type AgentUncheckedUpdateManyWithoutConciergerieManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    userId?: StringFieldUpdateOperationsInput | string
    cleaningManagerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUpdateWithoutConciergerieManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutConciergerieManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUncheckedUpdateManyWithoutConciergerieManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CleaningSessionCreateManyPropertyInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningId: string
    agentId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
  }

  export type MaintenanceSessionCreateManyPropertyInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    maintenanceId: string
    agentId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    notes?: string | null
  }

  export type ReservationCreateManyPropertyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    client?: string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PaymentCreateManyPropertyInput = {
    id?: string
    amount: number
    currency?: string
    method?: string | null
    status?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TicketCreateManyPropertyInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: string | null
    agentId?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PropertyPhotoCreateManyPropertyInput = {
    id?: string
    url: string
    type?: string | null
    createdAt: Date | string
  }

  export type CleaningSessionUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cleaning?: CleaningUpdateOneRequiredWithoutCleaningSessionsNestedInput
    agent?: AgentUpdateOneRequiredWithoutCleaningSessionsNestedInput
    photos?: CleaningPhotoUpdateManyWithoutCleaningSessionNestedInput
    checklist?: CleaningChecklistUpdateManyWithoutCleaningSessionNestedInput
  }

  export type CleaningSessionUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: CleaningPhotoUncheckedUpdateManyWithoutCleaningSessionNestedInput
    checklist?: CleaningChecklistUncheckedUpdateManyWithoutCleaningSessionNestedInput
  }

  export type CleaningSessionUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceSessionUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    maintenance?: MaintenanceUpdateOneRequiredWithoutSessionMaintenancesNestedInput
    agent?: AgentUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    photos?: MaintenancePhotoUpdateManyWithoutMaintenanceSessionNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: MaintenancePhotoUncheckedUpdateManyWithoutMaintenanceSessionNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutTicketsNestedInput
    photos?: TicketPhotoUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: TicketPhotoUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPhotoUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPhotoUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPhotoUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceSessionCreateManyAgentInput = {
    id?: string
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
    maintenanceId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    notes?: string | null
  }

  export type CleaningSessionCreateManyAgentInput = {
    id?: string
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
  }

  export type TaskCreateManyAgentInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    conciergerieManagerId?: string | null
  }

  export type TicketCreateManyAgentInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: string | null
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CleaningPlanningCreateManyAgentInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    interventionSiteId: string
    cleaningManagerId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SiteCleaningSessionCreateManyCleaningAgentInput = {
    id?: string
    interventionSiteId: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManagerId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    laundryManagerId?: string | null
  }

  export type MaintenanceSessionUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    property?: PropertyUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    maintenance?: MaintenanceUpdateOneRequiredWithoutSessionMaintenancesNestedInput
    photos?: MaintenancePhotoUpdateManyWithoutMaintenanceSessionNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: MaintenancePhotoUncheckedUpdateManyWithoutMaintenanceSessionNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CleaningSessionUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    property?: PropertyUpdateOneRequiredWithoutCleaningSessionsNestedInput
    cleaning?: CleaningUpdateOneRequiredWithoutCleaningSessionsNestedInput
    photos?: CleaningPhotoUpdateManyWithoutCleaningSessionNestedInput
    checklist?: CleaningChecklistUpdateManyWithoutCleaningSessionNestedInput
  }

  export type CleaningSessionUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: CleaningPhotoUncheckedUpdateManyWithoutCleaningSessionNestedInput
    checklist?: CleaningChecklistUncheckedUpdateManyWithoutCleaningSessionNestedInput
  }

  export type CleaningSessionUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManager?: ConciergerieManagerUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManagerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conciergerieManagerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutTicketsNestedInput
    photos?: TicketPhotoUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: TicketPhotoUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningPlanningUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventionSite?: InterventionSiteUpdateOneRequiredWithoutCleaningPlanningsNestedInput
    cleaningManager?: CleaningManagerUpdateOneRequiredWithoutCleaningPlanningsNestedInput
  }

  export type CleaningPlanningUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    interventionSiteId?: StringFieldUpdateOperationsInput | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningPlanningUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    interventionSiteId?: StringFieldUpdateOperationsInput | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCleaningSessionUpdateWithoutCleaningAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    interventionSite?: InterventionSiteUpdateOneRequiredWithoutSiteCleaningSessionsNestedInput
    cleaningManager?: CleaningManagerUpdateOneRequiredWithoutSiteCleaningSessionsNestedInput
    photos?: SiteCleaningPhotoUpdateManyWithoutSiteCleaningSessionNestedInput
    checklist?: SiteCleaningChecklistUpdateManyWithoutSiteCleaningSessionNestedInput
    laundryManager?: LaundryManagerUpdateOneWithoutSiteCleaningSessionsNestedInput
  }

  export type SiteCleaningSessionUncheckedUpdateWithoutCleaningAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    interventionSiteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    laundryManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: SiteCleaningPhotoUncheckedUpdateManyWithoutSiteCleaningSessionNestedInput
    checklist?: SiteCleaningChecklistUncheckedUpdateManyWithoutSiteCleaningSessionNestedInput
  }

  export type SiteCleaningSessionUncheckedUpdateManyWithoutCleaningAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    interventionSiteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    laundryManagerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenancePhotoCreateManyMaintenanceSessionInput = {
    id?: string
    url: string
    type?: string | null
    createdAt: Date | string
  }

  export type MaintenancePhotoUpdateWithoutMaintenanceSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenancePhotoUncheckedUpdateWithoutMaintenanceSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenancePhotoUncheckedUpdateManyWithoutMaintenanceSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceSessionCreateManyMaintenanceInput = {
    id?: string
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
    agentId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    notes?: string | null
  }

  export type MaintenanceSessionUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    property?: PropertyUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    agent?: AgentUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    photos?: MaintenancePhotoUpdateManyWithoutMaintenanceSessionNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: MaintenancePhotoUncheckedUpdateManyWithoutMaintenanceSessionNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateManyWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CleaningPhotoCreateManyCleaningSessionInput = {
    id?: string
    url: string
    type?: string | null
    createdAt: Date | string
  }

  export type CleaningChecklistCreateManyCleaningSessionInput = {
    id?: string
    item: string
    completed?: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CleaningPhotoUpdateWithoutCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningPhotoUncheckedUpdateWithoutCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningPhotoUncheckedUpdateManyWithoutCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningChecklistUpdateWithoutCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningChecklistUncheckedUpdateWithoutCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningChecklistUncheckedUpdateManyWithoutCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSessionCreateManyCleaningInput = {
    id?: string
    propertyId: string
    createdAt: Date | string
    updatedAt: Date | string
    agentId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
  }

  export type CleaningSessionUpdateWithoutCleaningInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    property?: PropertyUpdateOneRequiredWithoutCleaningSessionsNestedInput
    agent?: AgentUpdateOneRequiredWithoutCleaningSessionsNestedInput
    photos?: CleaningPhotoUpdateManyWithoutCleaningSessionNestedInput
    checklist?: CleaningChecklistUpdateManyWithoutCleaningSessionNestedInput
  }

  export type CleaningSessionUncheckedUpdateWithoutCleaningInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: CleaningPhotoUncheckedUpdateManyWithoutCleaningSessionNestedInput
    checklist?: CleaningChecklistUncheckedUpdateManyWithoutCleaningSessionNestedInput
  }

  export type CleaningSessionUncheckedUpdateManyWithoutCleaningInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InterventionSiteCreateManyCleaningManagerInput = {
    id?: string
    name: string
    description: string
    client?: string | null
    site?: string | null
    surface?: number | null
    type?: string | null
    address?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SiteCleaningSessionCreateManyCleaningManagerInput = {
    id?: string
    interventionSiteId: string
    createdAt: Date | string
    updatedAt: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    laundryManagerId?: string | null
    cleaningAgentId?: string | null
  }

  export type AgentCreateManyCleaningManagerInput = {
    id?: string
    name: string
    description: string
    createdAt: Date | string
    updatedAt: Date | string
    type?: $Enums.AgentType
    conciergerieManagerId: string
    userId: string
  }

  export type CleaningPlanningCreateManyCleaningManagerInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    interventionSiteId: string
    agentId?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type InterventionSiteUpdateWithoutCleaningManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    site?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutInterventionSiteNestedInput
    cleaningPlannings?: CleaningPlanningUpdateManyWithoutInterventionSiteNestedInput
  }

  export type InterventionSiteUncheckedUpdateWithoutCleaningManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    site?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutInterventionSiteNestedInput
    cleaningPlannings?: CleaningPlanningUncheckedUpdateManyWithoutInterventionSiteNestedInput
  }

  export type InterventionSiteUncheckedUpdateManyWithoutCleaningManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    client?: NullableStringFieldUpdateOperationsInput | string | null
    site?: NullableStringFieldUpdateOperationsInput | string | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCleaningSessionUpdateWithoutCleaningManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    interventionSite?: InterventionSiteUpdateOneRequiredWithoutSiteCleaningSessionsNestedInput
    photos?: SiteCleaningPhotoUpdateManyWithoutSiteCleaningSessionNestedInput
    checklist?: SiteCleaningChecklistUpdateManyWithoutSiteCleaningSessionNestedInput
    laundryManager?: LaundryManagerUpdateOneWithoutSiteCleaningSessionsNestedInput
    cleaningAgent?: AgentUpdateOneWithoutSiteCleaningSessionsNestedInput
  }

  export type SiteCleaningSessionUncheckedUpdateWithoutCleaningManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    interventionSiteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    laundryManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: SiteCleaningPhotoUncheckedUpdateManyWithoutSiteCleaningSessionNestedInput
    checklist?: SiteCleaningChecklistUncheckedUpdateManyWithoutSiteCleaningSessionNestedInput
  }

  export type SiteCleaningSessionUncheckedUpdateManyWithoutCleaningManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    interventionSiteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    laundryManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningAgentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentUpdateWithoutCleaningManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutAgentNestedInput
    conciergerieManager?: ConciergerieManagerUpdateOneRequiredWithoutAgentsNestedInput
    tasks?: TaskUpdateManyWithoutAgentNestedInput
    tickets?: TicketUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUpdateManyWithoutAgentNestedInput
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUpdateManyWithoutCleaningAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutCleaningManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAgentNestedInput
    cleaningPlannings?: CleaningPlanningUncheckedUpdateManyWithoutAgentNestedInput
    siteCleaningSessions?: SiteCleaningSessionUncheckedUpdateManyWithoutCleaningAgentNestedInput
  }

  export type AgentUncheckedUpdateManyWithoutCleaningManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    conciergerieManagerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CleaningPlanningUpdateWithoutCleaningManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interventionSite?: InterventionSiteUpdateOneRequiredWithoutCleaningPlanningsNestedInput
    agent?: AgentUpdateOneWithoutCleaningPlanningsNestedInput
  }

  export type CleaningPlanningUncheckedUpdateWithoutCleaningManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    interventionSiteId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningPlanningUncheckedUpdateManyWithoutCleaningManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    interventionSiteId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCleaningSessionCreateManyInterventionSiteInput = {
    id?: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManagerId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    laundryManagerId?: string | null
    cleaningAgentId?: string | null
  }

  export type CleaningPlanningCreateManyInterventionSiteInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    cleaningManagerId: string
    agentId?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SiteCleaningSessionUpdateWithoutInterventionSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    cleaningManager?: CleaningManagerUpdateOneRequiredWithoutSiteCleaningSessionsNestedInput
    photos?: SiteCleaningPhotoUpdateManyWithoutSiteCleaningSessionNestedInput
    checklist?: SiteCleaningChecklistUpdateManyWithoutSiteCleaningSessionNestedInput
    laundryManager?: LaundryManagerUpdateOneWithoutSiteCleaningSessionsNestedInput
    cleaningAgent?: AgentUpdateOneWithoutSiteCleaningSessionsNestedInput
  }

  export type SiteCleaningSessionUncheckedUpdateWithoutInterventionSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    laundryManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: SiteCleaningPhotoUncheckedUpdateManyWithoutSiteCleaningSessionNestedInput
    checklist?: SiteCleaningChecklistUncheckedUpdateManyWithoutSiteCleaningSessionNestedInput
  }

  export type SiteCleaningSessionUncheckedUpdateManyWithoutInterventionSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    laundryManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningAgentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CleaningPlanningUpdateWithoutInterventionSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManager?: CleaningManagerUpdateOneRequiredWithoutCleaningPlanningsNestedInput
    agent?: AgentUpdateOneWithoutCleaningPlanningsNestedInput
  }

  export type CleaningPlanningUncheckedUpdateWithoutInterventionSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningPlanningUncheckedUpdateManyWithoutInterventionSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCleaningPhotoCreateManySiteCleaningSessionInput = {
    id?: string
    url: string
    type?: string | null
    createdAt: Date | string
  }

  export type SiteCleaningChecklistCreateManySiteCleaningSessionInput = {
    id?: string
    item: string
    completed?: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SiteCleaningPhotoUpdateWithoutSiteCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCleaningPhotoUncheckedUpdateWithoutSiteCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCleaningPhotoUncheckedUpdateManyWithoutSiteCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCleaningChecklistUpdateWithoutSiteCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCleaningChecklistUncheckedUpdateWithoutSiteCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCleaningChecklistUncheckedUpdateManyWithoutSiteCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyLaundryManagerInput = {
    id?: string
    name: string
    description: string
    price?: number | null
    stock?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type OrderCreateManyLaundryManagerInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    deliveryDate?: Date | string | null
    client?: string | null
    address?: string | null
    phone?: string | null
    total?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type DeliveryNoteCreateManyLaundryManagerInput = {
    id?: string
    number: string
    date: Date | string
    orderId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SiteCleaningSessionCreateManyLaundryManagerInput = {
    id?: string
    interventionSiteId: string
    createdAt: Date | string
    updatedAt: Date | string
    cleaningManagerId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.InterventionStatus
    cleaningAgentId?: string | null
  }

  export type ProductUpdateWithoutLaundryManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutLaundryManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutLaundryManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutLaundryManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    deliveryNotes?: DeliveryNoteUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutLaundryManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    deliveryNotes?: DeliveryNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutLaundryManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryNoteUpdateWithoutLaundryManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutDeliveryNotesNestedInput
  }

  export type DeliveryNoteUncheckedUpdateWithoutLaundryManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryNoteUncheckedUpdateManyWithoutLaundryManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCleaningSessionUpdateWithoutLaundryManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    interventionSite?: InterventionSiteUpdateOneRequiredWithoutSiteCleaningSessionsNestedInput
    cleaningManager?: CleaningManagerUpdateOneRequiredWithoutSiteCleaningSessionsNestedInput
    photos?: SiteCleaningPhotoUpdateManyWithoutSiteCleaningSessionNestedInput
    checklist?: SiteCleaningChecklistUpdateManyWithoutSiteCleaningSessionNestedInput
    cleaningAgent?: AgentUpdateOneWithoutSiteCleaningSessionsNestedInput
  }

  export type SiteCleaningSessionUncheckedUpdateWithoutLaundryManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    interventionSiteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    cleaningAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: SiteCleaningPhotoUncheckedUpdateManyWithoutSiteCleaningSessionNestedInput
    checklist?: SiteCleaningChecklistUncheckedUpdateManyWithoutSiteCleaningSessionNestedInput
  }

  export type SiteCleaningSessionUncheckedUpdateManyWithoutLaundryManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    interventionSiteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningManagerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    cleaningAgentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyProductInput = {
    id?: string
    quantity: number
    price?: number | null
    orderId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type OrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    quantity: number
    price?: number | null
    productId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type DeliveryNoteCreateManyOrderInput = {
    id?: string
    number: string
    date: Date | string
    laundryManagerId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryNoteUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryManager?: LaundryManagerUpdateOneRequiredWithoutDeliveryNotesNestedInput
  }

  export type DeliveryNoteUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryManagerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryNoteUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryManagerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketPhotoCreateManyTicketInput = {
    id?: string
    url: string
    createdAt: Date | string
  }

  export type TicketPhotoUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketPhotoUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketPhotoUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUserCreateManyServiceInput = {
    id?: string
    name: string
    status?: $Enums.ServiceUserStatus
    userId: string
  }

  export type ServiceUserUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceUserStatusFieldUpdateOperationsInput | $Enums.ServiceUserStatus
    user?: UserUpdateOneRequiredWithoutServiceUsersNestedInput
  }

  export type ServiceUserUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceUserStatusFieldUpdateOperationsInput | $Enums.ServiceUserStatus
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceUserUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceUserStatusFieldUpdateOperationsInput | $Enums.ServiceUserStatus
    userId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}