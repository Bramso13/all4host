
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model SuperAdminProfile
 * 
 */
export type SuperAdminProfile = $Result.DefaultSelection<Prisma.$SuperAdminProfilePayload>
/**
 * Model PoleSubscription
 * 
 */
export type PoleSubscription = $Result.DefaultSelection<Prisma.$PoleSubscriptionPayload>
/**
 * Model PoleManagerProfile
 * 
 */
export type PoleManagerProfile = $Result.DefaultSelection<Prisma.$PoleManagerProfilePayload>
/**
 * Model PropertyOwnerProfile
 * 
 */
export type PropertyOwnerProfile = $Result.DefaultSelection<Prisma.$PropertyOwnerProfilePayload>
/**
 * Model LaundryClientProfile
 * 
 */
export type LaundryClientProfile = $Result.DefaultSelection<Prisma.$LaundryClientProfilePayload>
/**
 * Model AgentProfile
 * 
 */
export type AgentProfile = $Result.DefaultSelection<Prisma.$AgentProfilePayload>
/**
 * Model AgentSpecialty
 * 
 */
export type AgentSpecialty = $Result.DefaultSelection<Prisma.$AgentSpecialtyPayload>
/**
 * Model Property
 * 
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model PropertyFeature
 * 
 */
export type PropertyFeature = $Result.DefaultSelection<Prisma.$PropertyFeaturePayload>
/**
 * Model PropertyPhoto
 * 
 */
export type PropertyPhoto = $Result.DefaultSelection<Prisma.$PropertyPhotoPayload>
/**
 * Model PropertyReview
 * 
 */
export type PropertyReview = $Result.DefaultSelection<Prisma.$PropertyReviewPayload>
/**
 * Model Reservation
 * 
 */
export type Reservation = $Result.DefaultSelection<Prisma.$ReservationPayload>
/**
 * Model CleaningSession
 * 
 */
export type CleaningSession = $Result.DefaultSelection<Prisma.$CleaningSessionPayload>
/**
 * Model CleaningChecklist
 * 
 */
export type CleaningChecklist = $Result.DefaultSelection<Prisma.$CleaningChecklistPayload>
/**
 * Model CleaningPhoto
 * 
 */
export type CleaningPhoto = $Result.DefaultSelection<Prisma.$CleaningPhotoPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model TicketPhoto
 * 
 */
export type TicketPhoto = $Result.DefaultSelection<Prisma.$TicketPhotoPayload>
/**
 * Model MaintenanceSession
 * 
 */
export type MaintenanceSession = $Result.DefaultSelection<Prisma.$MaintenanceSessionPayload>
/**
 * Model MaintenanceMaterial
 * 
 */
export type MaintenanceMaterial = $Result.DefaultSelection<Prisma.$MaintenanceMaterialPayload>
/**
 * Model MaintenancePhoto
 * 
 */
export type MaintenancePhoto = $Result.DefaultSelection<Prisma.$MaintenancePhotoPayload>
/**
 * Model LaundryProduct
 * 
 */
export type LaundryProduct = $Result.DefaultSelection<Prisma.$LaundryProductPayload>
/**
 * Model LaundryOrder
 * 
 */
export type LaundryOrder = $Result.DefaultSelection<Prisma.$LaundryOrderPayload>
/**
 * Model LaundryOrderItem
 * 
 */
export type LaundryOrderItem = $Result.DefaultSelection<Prisma.$LaundryOrderItemPayload>
/**
 * Model DeliveryNote
 * 
 */
export type DeliveryNote = $Result.DefaultSelection<Prisma.$DeliveryNotePayload>
/**
 * Model TaskAssignment
 * 
 */
export type TaskAssignment = $Result.DefaultSelection<Prisma.$TaskAssignmentPayload>
/**
 * Model PropertyContract
 * 
 */
export type PropertyContract = $Result.DefaultSelection<Prisma.$PropertyContractPayload>
/**
 * Model SuperAdminInvoice
 * 
 */
export type SuperAdminInvoice = $Result.DefaultSelection<Prisma.$SuperAdminInvoicePayload>
/**
 * Model SuperAdminInvoiceItem
 * 
 */
export type SuperAdminInvoiceItem = $Result.DefaultSelection<Prisma.$SuperAdminInvoiceItemPayload>
/**
 * Model LaundryInvoice
 * 
 */
export type LaundryInvoice = $Result.DefaultSelection<Prisma.$LaundryInvoicePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  super_admin: 'super_admin',
  pole_manager: 'pole_manager',
  property_owner: 'property_owner',
  laundry_client: 'laundry_client',
  agent: 'agent'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserStatus: {
  active: 'active',
  inactive: 'inactive',
  pending: 'pending',
  suspended: 'suspended'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const PoleType: {
  conciergerie: 'conciergerie',
  cleaning: 'cleaning',
  maintenance: 'maintenance',
  laundry: 'laundry'
};

export type PoleType = (typeof PoleType)[keyof typeof PoleType]


export const PoleStatus: {
  active: 'active',
  inactive: 'inactive',
  trial: 'trial',
  expired: 'expired'
};

export type PoleStatus = (typeof PoleStatus)[keyof typeof PoleStatus]


export const AgentType: {
  cleaning: 'cleaning',
  maintenance: 'maintenance',
  laundry: 'laundry',
  concierge: 'concierge',
  multi_service: 'multi_service'
};

export type AgentType = (typeof AgentType)[keyof typeof AgentType]


export const AgentAvailability: {
  available: 'available',
  busy: 'busy',
  offline: 'offline',
  on_break: 'on_break',
  on_mission: 'on_mission'
};

export type AgentAvailability = (typeof AgentAvailability)[keyof typeof AgentAvailability]


export const PropertyStatus: {
  available: 'available',
  occupied: 'occupied',
  maintenance: 'maintenance',
  reserved: 'reserved',
  offline: 'offline'
};

export type PropertyStatus = (typeof PropertyStatus)[keyof typeof PropertyStatus]


export const ReservationStatus: {
  confirmed: 'confirmed',
  pending: 'pending',
  cancelled: 'cancelled',
  completed: 'completed',
  in_progress: 'in_progress',
  checked_in: 'checked_in',
  checked_out: 'checked_out'
};

export type ReservationStatus = (typeof ReservationStatus)[keyof typeof ReservationStatus]


export const SessionStatus: {
  planned: 'planned',
  in_progress: 'in_progress',
  completed: 'completed',
  cancelled: 'cancelled',
  paused: 'paused',
  pending_validation: 'pending_validation'
};

export type SessionStatus = (typeof SessionStatus)[keyof typeof SessionStatus]


export const TicketStatus: {
  open: 'open',
  assigned: 'assigned',
  in_progress: 'in_progress',
  resolved: 'resolved',
  closed: 'closed',
  cancelled: 'cancelled'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]


export const TicketPriority: {
  low: 'low',
  medium: 'medium',
  high: 'high',
  urgent: 'urgent',
  critical: 'critical'
};

export type TicketPriority = (typeof TicketPriority)[keyof typeof TicketPriority]


export const OrderStatus: {
  received: 'received',
  processing: 'processing',
  ready: 'ready',
  pickup_scheduled: 'pickup_scheduled',
  in_delivery: 'in_delivery',
  delivered: 'delivered',
  completed: 'completed',
  cancelled: 'cancelled',
  returned: 'returned'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const NotificationType: {
  info: 'info',
  warning: 'warning',
  error: 'error',
  success: 'success',
  task_assigned: 'task_assigned',
  status_update: 'status_update',
  payment_due: 'payment_due',
  review_request: 'review_request',
  pole_activated: 'pole_activated',
  pole_expired: 'pole_expired'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type PoleType = $Enums.PoleType

export const PoleType: typeof $Enums.PoleType

export type PoleStatus = $Enums.PoleStatus

export const PoleStatus: typeof $Enums.PoleStatus

export type AgentType = $Enums.AgentType

export const AgentType: typeof $Enums.AgentType

export type AgentAvailability = $Enums.AgentAvailability

export const AgentAvailability: typeof $Enums.AgentAvailability

export type PropertyStatus = $Enums.PropertyStatus

export const PropertyStatus: typeof $Enums.PropertyStatus

export type ReservationStatus = $Enums.ReservationStatus

export const ReservationStatus: typeof $Enums.ReservationStatus

export type SessionStatus = $Enums.SessionStatus

export const SessionStatus: typeof $Enums.SessionStatus

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

export type TicketPriority = $Enums.TicketPriority

export const TicketPriority: typeof $Enums.TicketPriority

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.superAdminProfile`: Exposes CRUD operations for the **SuperAdminProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuperAdminProfiles
    * const superAdminProfiles = await prisma.superAdminProfile.findMany()
    * ```
    */
  get superAdminProfile(): Prisma.SuperAdminProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.poleSubscription`: Exposes CRUD operations for the **PoleSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PoleSubscriptions
    * const poleSubscriptions = await prisma.poleSubscription.findMany()
    * ```
    */
  get poleSubscription(): Prisma.PoleSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.poleManagerProfile`: Exposes CRUD operations for the **PoleManagerProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PoleManagerProfiles
    * const poleManagerProfiles = await prisma.poleManagerProfile.findMany()
    * ```
    */
  get poleManagerProfile(): Prisma.PoleManagerProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyOwnerProfile`: Exposes CRUD operations for the **PropertyOwnerProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyOwnerProfiles
    * const propertyOwnerProfiles = await prisma.propertyOwnerProfile.findMany()
    * ```
    */
  get propertyOwnerProfile(): Prisma.PropertyOwnerProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.laundryClientProfile`: Exposes CRUD operations for the **LaundryClientProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaundryClientProfiles
    * const laundryClientProfiles = await prisma.laundryClientProfile.findMany()
    * ```
    */
  get laundryClientProfile(): Prisma.LaundryClientProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentProfile`: Exposes CRUD operations for the **AgentProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentProfiles
    * const agentProfiles = await prisma.agentProfile.findMany()
    * ```
    */
  get agentProfile(): Prisma.AgentProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentSpecialty`: Exposes CRUD operations for the **AgentSpecialty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentSpecialties
    * const agentSpecialties = await prisma.agentSpecialty.findMany()
    * ```
    */
  get agentSpecialty(): Prisma.AgentSpecialtyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyFeature`: Exposes CRUD operations for the **PropertyFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyFeatures
    * const propertyFeatures = await prisma.propertyFeature.findMany()
    * ```
    */
  get propertyFeature(): Prisma.PropertyFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyPhoto`: Exposes CRUD operations for the **PropertyPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyPhotos
    * const propertyPhotos = await prisma.propertyPhoto.findMany()
    * ```
    */
  get propertyPhoto(): Prisma.PropertyPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyReview`: Exposes CRUD operations for the **PropertyReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyReviews
    * const propertyReviews = await prisma.propertyReview.findMany()
    * ```
    */
  get propertyReview(): Prisma.PropertyReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **Reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservation.findMany()
    * ```
    */
  get reservation(): Prisma.ReservationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cleaningSession`: Exposes CRUD operations for the **CleaningSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CleaningSessions
    * const cleaningSessions = await prisma.cleaningSession.findMany()
    * ```
    */
  get cleaningSession(): Prisma.CleaningSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cleaningChecklist`: Exposes CRUD operations for the **CleaningChecklist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CleaningChecklists
    * const cleaningChecklists = await prisma.cleaningChecklist.findMany()
    * ```
    */
  get cleaningChecklist(): Prisma.CleaningChecklistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cleaningPhoto`: Exposes CRUD operations for the **CleaningPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CleaningPhotos
    * const cleaningPhotos = await prisma.cleaningPhoto.findMany()
    * ```
    */
  get cleaningPhoto(): Prisma.CleaningPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketPhoto`: Exposes CRUD operations for the **TicketPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketPhotos
    * const ticketPhotos = await prisma.ticketPhoto.findMany()
    * ```
    */
  get ticketPhoto(): Prisma.TicketPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenanceSession`: Exposes CRUD operations for the **MaintenanceSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceSessions
    * const maintenanceSessions = await prisma.maintenanceSession.findMany()
    * ```
    */
  get maintenanceSession(): Prisma.MaintenanceSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenanceMaterial`: Exposes CRUD operations for the **MaintenanceMaterial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceMaterials
    * const maintenanceMaterials = await prisma.maintenanceMaterial.findMany()
    * ```
    */
  get maintenanceMaterial(): Prisma.MaintenanceMaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenancePhoto`: Exposes CRUD operations for the **MaintenancePhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenancePhotos
    * const maintenancePhotos = await prisma.maintenancePhoto.findMany()
    * ```
    */
  get maintenancePhoto(): Prisma.MaintenancePhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.laundryProduct`: Exposes CRUD operations for the **LaundryProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaundryProducts
    * const laundryProducts = await prisma.laundryProduct.findMany()
    * ```
    */
  get laundryProduct(): Prisma.LaundryProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.laundryOrder`: Exposes CRUD operations for the **LaundryOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaundryOrders
    * const laundryOrders = await prisma.laundryOrder.findMany()
    * ```
    */
  get laundryOrder(): Prisma.LaundryOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.laundryOrderItem`: Exposes CRUD operations for the **LaundryOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaundryOrderItems
    * const laundryOrderItems = await prisma.laundryOrderItem.findMany()
    * ```
    */
  get laundryOrderItem(): Prisma.LaundryOrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryNote`: Exposes CRUD operations for the **DeliveryNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryNotes
    * const deliveryNotes = await prisma.deliveryNote.findMany()
    * ```
    */
  get deliveryNote(): Prisma.DeliveryNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskAssignment`: Exposes CRUD operations for the **TaskAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskAssignments
    * const taskAssignments = await prisma.taskAssignment.findMany()
    * ```
    */
  get taskAssignment(): Prisma.TaskAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyContract`: Exposes CRUD operations for the **PropertyContract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyContracts
    * const propertyContracts = await prisma.propertyContract.findMany()
    * ```
    */
  get propertyContract(): Prisma.PropertyContractDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.superAdminInvoice`: Exposes CRUD operations for the **SuperAdminInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuperAdminInvoices
    * const superAdminInvoices = await prisma.superAdminInvoice.findMany()
    * ```
    */
  get superAdminInvoice(): Prisma.SuperAdminInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.superAdminInvoiceItem`: Exposes CRUD operations for the **SuperAdminInvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuperAdminInvoiceItems
    * const superAdminInvoiceItems = await prisma.superAdminInvoiceItem.findMany()
    * ```
    */
  get superAdminInvoiceItem(): Prisma.SuperAdminInvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.laundryInvoice`: Exposes CRUD operations for the **LaundryInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaundryInvoices
    * const laundryInvoices = await prisma.laundryInvoice.findMany()
    * ```
    */
  get laundryInvoice(): Prisma.LaundryInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    SuperAdminProfile: 'SuperAdminProfile',
    PoleSubscription: 'PoleSubscription',
    PoleManagerProfile: 'PoleManagerProfile',
    PropertyOwnerProfile: 'PropertyOwnerProfile',
    LaundryClientProfile: 'LaundryClientProfile',
    AgentProfile: 'AgentProfile',
    AgentSpecialty: 'AgentSpecialty',
    Property: 'Property',
    PropertyFeature: 'PropertyFeature',
    PropertyPhoto: 'PropertyPhoto',
    PropertyReview: 'PropertyReview',
    Reservation: 'Reservation',
    CleaningSession: 'CleaningSession',
    CleaningChecklist: 'CleaningChecklist',
    CleaningPhoto: 'CleaningPhoto',
    Ticket: 'Ticket',
    TicketPhoto: 'TicketPhoto',
    MaintenanceSession: 'MaintenanceSession',
    MaintenanceMaterial: 'MaintenanceMaterial',
    MaintenancePhoto: 'MaintenancePhoto',
    LaundryProduct: 'LaundryProduct',
    LaundryOrder: 'LaundryOrder',
    LaundryOrderItem: 'LaundryOrderItem',
    DeliveryNote: 'DeliveryNote',
    TaskAssignment: 'TaskAssignment',
    PropertyContract: 'PropertyContract',
    SuperAdminInvoice: 'SuperAdminInvoice',
    SuperAdminInvoiceItem: 'SuperAdminInvoiceItem',
    LaundryInvoice: 'LaundryInvoice',
    Notification: 'Notification',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "superAdminProfile" | "poleSubscription" | "poleManagerProfile" | "propertyOwnerProfile" | "laundryClientProfile" | "agentProfile" | "agentSpecialty" | "property" | "propertyFeature" | "propertyPhoto" | "propertyReview" | "reservation" | "cleaningSession" | "cleaningChecklist" | "cleaningPhoto" | "ticket" | "ticketPhoto" | "maintenanceSession" | "maintenanceMaterial" | "maintenancePhoto" | "laundryProduct" | "laundryOrder" | "laundryOrderItem" | "deliveryNote" | "taskAssignment" | "propertyContract" | "superAdminInvoice" | "superAdminInvoiceItem" | "laundryInvoice" | "notification" | "session" | "account" | "verification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      SuperAdminProfile: {
        payload: Prisma.$SuperAdminProfilePayload<ExtArgs>
        fields: Prisma.SuperAdminProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuperAdminProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuperAdminProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminProfilePayload>
          }
          findFirst: {
            args: Prisma.SuperAdminProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuperAdminProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminProfilePayload>
          }
          findMany: {
            args: Prisma.SuperAdminProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminProfilePayload>[]
          }
          create: {
            args: Prisma.SuperAdminProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminProfilePayload>
          }
          createMany: {
            args: Prisma.SuperAdminProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuperAdminProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminProfilePayload>[]
          }
          delete: {
            args: Prisma.SuperAdminProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminProfilePayload>
          }
          update: {
            args: Prisma.SuperAdminProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminProfilePayload>
          }
          deleteMany: {
            args: Prisma.SuperAdminProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuperAdminProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SuperAdminProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminProfilePayload>[]
          }
          upsert: {
            args: Prisma.SuperAdminProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminProfilePayload>
          }
          aggregate: {
            args: Prisma.SuperAdminProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuperAdminProfile>
          }
          groupBy: {
            args: Prisma.SuperAdminProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuperAdminProfileCountArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminProfileCountAggregateOutputType> | number
          }
        }
      }
      PoleSubscription: {
        payload: Prisma.$PoleSubscriptionPayload<ExtArgs>
        fields: Prisma.PoleSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PoleSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PoleSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.PoleSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PoleSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleSubscriptionPayload>
          }
          findMany: {
            args: Prisma.PoleSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleSubscriptionPayload>[]
          }
          create: {
            args: Prisma.PoleSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleSubscriptionPayload>
          }
          createMany: {
            args: Prisma.PoleSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PoleSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.PoleSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleSubscriptionPayload>
          }
          update: {
            args: Prisma.PoleSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.PoleSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PoleSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PoleSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.PoleSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.PoleSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePoleSubscription>
          }
          groupBy: {
            args: Prisma.PoleSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PoleSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PoleSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PoleSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      PoleManagerProfile: {
        payload: Prisma.$PoleManagerProfilePayload<ExtArgs>
        fields: Prisma.PoleManagerProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PoleManagerProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleManagerProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PoleManagerProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleManagerProfilePayload>
          }
          findFirst: {
            args: Prisma.PoleManagerProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleManagerProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PoleManagerProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleManagerProfilePayload>
          }
          findMany: {
            args: Prisma.PoleManagerProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleManagerProfilePayload>[]
          }
          create: {
            args: Prisma.PoleManagerProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleManagerProfilePayload>
          }
          createMany: {
            args: Prisma.PoleManagerProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PoleManagerProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleManagerProfilePayload>[]
          }
          delete: {
            args: Prisma.PoleManagerProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleManagerProfilePayload>
          }
          update: {
            args: Prisma.PoleManagerProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleManagerProfilePayload>
          }
          deleteMany: {
            args: Prisma.PoleManagerProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PoleManagerProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PoleManagerProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleManagerProfilePayload>[]
          }
          upsert: {
            args: Prisma.PoleManagerProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoleManagerProfilePayload>
          }
          aggregate: {
            args: Prisma.PoleManagerProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePoleManagerProfile>
          }
          groupBy: {
            args: Prisma.PoleManagerProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<PoleManagerProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.PoleManagerProfileCountArgs<ExtArgs>
            result: $Utils.Optional<PoleManagerProfileCountAggregateOutputType> | number
          }
        }
      }
      PropertyOwnerProfile: {
        payload: Prisma.$PropertyOwnerProfilePayload<ExtArgs>
        fields: Prisma.PropertyOwnerProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyOwnerProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyOwnerProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerProfilePayload>
          }
          findFirst: {
            args: Prisma.PropertyOwnerProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyOwnerProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerProfilePayload>
          }
          findMany: {
            args: Prisma.PropertyOwnerProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerProfilePayload>[]
          }
          create: {
            args: Prisma.PropertyOwnerProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerProfilePayload>
          }
          createMany: {
            args: Prisma.PropertyOwnerProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyOwnerProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerProfilePayload>[]
          }
          delete: {
            args: Prisma.PropertyOwnerProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerProfilePayload>
          }
          update: {
            args: Prisma.PropertyOwnerProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerProfilePayload>
          }
          deleteMany: {
            args: Prisma.PropertyOwnerProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyOwnerProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyOwnerProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerProfilePayload>[]
          }
          upsert: {
            args: Prisma.PropertyOwnerProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerProfilePayload>
          }
          aggregate: {
            args: Prisma.PropertyOwnerProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyOwnerProfile>
          }
          groupBy: {
            args: Prisma.PropertyOwnerProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyOwnerProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyOwnerProfileCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyOwnerProfileCountAggregateOutputType> | number
          }
        }
      }
      LaundryClientProfile: {
        payload: Prisma.$LaundryClientProfilePayload<ExtArgs>
        fields: Prisma.LaundryClientProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LaundryClientProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryClientProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LaundryClientProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryClientProfilePayload>
          }
          findFirst: {
            args: Prisma.LaundryClientProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryClientProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LaundryClientProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryClientProfilePayload>
          }
          findMany: {
            args: Prisma.LaundryClientProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryClientProfilePayload>[]
          }
          create: {
            args: Prisma.LaundryClientProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryClientProfilePayload>
          }
          createMany: {
            args: Prisma.LaundryClientProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LaundryClientProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryClientProfilePayload>[]
          }
          delete: {
            args: Prisma.LaundryClientProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryClientProfilePayload>
          }
          update: {
            args: Prisma.LaundryClientProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryClientProfilePayload>
          }
          deleteMany: {
            args: Prisma.LaundryClientProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LaundryClientProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LaundryClientProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryClientProfilePayload>[]
          }
          upsert: {
            args: Prisma.LaundryClientProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryClientProfilePayload>
          }
          aggregate: {
            args: Prisma.LaundryClientProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLaundryClientProfile>
          }
          groupBy: {
            args: Prisma.LaundryClientProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<LaundryClientProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.LaundryClientProfileCountArgs<ExtArgs>
            result: $Utils.Optional<LaundryClientProfileCountAggregateOutputType> | number
          }
        }
      }
      AgentProfile: {
        payload: Prisma.$AgentProfilePayload<ExtArgs>
        fields: Prisma.AgentProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>
          }
          findFirst: {
            args: Prisma.AgentProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>
          }
          findMany: {
            args: Prisma.AgentProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>[]
          }
          create: {
            args: Prisma.AgentProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>
          }
          createMany: {
            args: Prisma.AgentProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>[]
          }
          delete: {
            args: Prisma.AgentProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>
          }
          update: {
            args: Prisma.AgentProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>
          }
          deleteMany: {
            args: Prisma.AgentProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>[]
          }
          upsert: {
            args: Prisma.AgentProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentProfilePayload>
          }
          aggregate: {
            args: Prisma.AgentProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentProfile>
          }
          groupBy: {
            args: Prisma.AgentProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentProfileCountArgs<ExtArgs>
            result: $Utils.Optional<AgentProfileCountAggregateOutputType> | number
          }
        }
      }
      AgentSpecialty: {
        payload: Prisma.$AgentSpecialtyPayload<ExtArgs>
        fields: Prisma.AgentSpecialtyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentSpecialtyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSpecialtyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentSpecialtyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSpecialtyPayload>
          }
          findFirst: {
            args: Prisma.AgentSpecialtyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSpecialtyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentSpecialtyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSpecialtyPayload>
          }
          findMany: {
            args: Prisma.AgentSpecialtyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSpecialtyPayload>[]
          }
          create: {
            args: Prisma.AgentSpecialtyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSpecialtyPayload>
          }
          createMany: {
            args: Prisma.AgentSpecialtyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentSpecialtyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSpecialtyPayload>[]
          }
          delete: {
            args: Prisma.AgentSpecialtyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSpecialtyPayload>
          }
          update: {
            args: Prisma.AgentSpecialtyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSpecialtyPayload>
          }
          deleteMany: {
            args: Prisma.AgentSpecialtyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentSpecialtyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentSpecialtyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSpecialtyPayload>[]
          }
          upsert: {
            args: Prisma.AgentSpecialtyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSpecialtyPayload>
          }
          aggregate: {
            args: Prisma.AgentSpecialtyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentSpecialty>
          }
          groupBy: {
            args: Prisma.AgentSpecialtyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentSpecialtyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentSpecialtyCountArgs<ExtArgs>
            result: $Utils.Optional<AgentSpecialtyCountAggregateOutputType> | number
          }
        }
      }
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      PropertyFeature: {
        payload: Prisma.$PropertyFeaturePayload<ExtArgs>
        fields: Prisma.PropertyFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
          }
          findFirst: {
            args: Prisma.PropertyFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
          }
          findMany: {
            args: Prisma.PropertyFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>[]
          }
          create: {
            args: Prisma.PropertyFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
          }
          createMany: {
            args: Prisma.PropertyFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>[]
          }
          delete: {
            args: Prisma.PropertyFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
          }
          update: {
            args: Prisma.PropertyFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
          }
          deleteMany: {
            args: Prisma.PropertyFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyFeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>[]
          }
          upsert: {
            args: Prisma.PropertyFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyFeaturePayload>
          }
          aggregate: {
            args: Prisma.PropertyFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyFeature>
          }
          groupBy: {
            args: Prisma.PropertyFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyFeatureCountAggregateOutputType> | number
          }
        }
      }
      PropertyPhoto: {
        payload: Prisma.$PropertyPhotoPayload<ExtArgs>
        fields: Prisma.PropertyPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>
          }
          findFirst: {
            args: Prisma.PropertyPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>
          }
          findMany: {
            args: Prisma.PropertyPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>[]
          }
          create: {
            args: Prisma.PropertyPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>
          }
          createMany: {
            args: Prisma.PropertyPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>[]
          }
          delete: {
            args: Prisma.PropertyPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>
          }
          update: {
            args: Prisma.PropertyPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>
          }
          deleteMany: {
            args: Prisma.PropertyPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyPhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>[]
          }
          upsert: {
            args: Prisma.PropertyPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPhotoPayload>
          }
          aggregate: {
            args: Prisma.PropertyPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyPhoto>
          }
          groupBy: {
            args: Prisma.PropertyPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyPhotoCountAggregateOutputType> | number
          }
        }
      }
      PropertyReview: {
        payload: Prisma.$PropertyReviewPayload<ExtArgs>
        fields: Prisma.PropertyReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyReviewPayload>
          }
          findFirst: {
            args: Prisma.PropertyReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyReviewPayload>
          }
          findMany: {
            args: Prisma.PropertyReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyReviewPayload>[]
          }
          create: {
            args: Prisma.PropertyReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyReviewPayload>
          }
          createMany: {
            args: Prisma.PropertyReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyReviewPayload>[]
          }
          delete: {
            args: Prisma.PropertyReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyReviewPayload>
          }
          update: {
            args: Prisma.PropertyReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyReviewPayload>
          }
          deleteMany: {
            args: Prisma.PropertyReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyReviewPayload>[]
          }
          upsert: {
            args: Prisma.PropertyReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyReviewPayload>
          }
          aggregate: {
            args: Prisma.PropertyReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyReview>
          }
          groupBy: {
            args: Prisma.PropertyReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyReviewCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyReviewCountAggregateOutputType> | number
          }
        }
      }
      Reservation: {
        payload: Prisma.$ReservationPayload<ExtArgs>
        fields: Prisma.ReservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findFirst: {
            args: Prisma.ReservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findMany: {
            args: Prisma.ReservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          create: {
            args: Prisma.ReservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          createMany: {
            args: Prisma.ReservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReservationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          delete: {
            args: Prisma.ReservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          update: {
            args: Prisma.ReservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          deleteMany: {
            args: Prisma.ReservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReservationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          upsert: {
            args: Prisma.ReservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          aggregate: {
            args: Prisma.ReservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservation>
          }
          groupBy: {
            args: Prisma.ReservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservationCountArgs<ExtArgs>
            result: $Utils.Optional<ReservationCountAggregateOutputType> | number
          }
        }
      }
      CleaningSession: {
        payload: Prisma.$CleaningSessionPayload<ExtArgs>
        fields: Prisma.CleaningSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CleaningSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CleaningSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>
          }
          findFirst: {
            args: Prisma.CleaningSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CleaningSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>
          }
          findMany: {
            args: Prisma.CleaningSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>[]
          }
          create: {
            args: Prisma.CleaningSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>
          }
          createMany: {
            args: Prisma.CleaningSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CleaningSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>[]
          }
          delete: {
            args: Prisma.CleaningSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>
          }
          update: {
            args: Prisma.CleaningSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>
          }
          deleteMany: {
            args: Prisma.CleaningSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CleaningSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CleaningSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>[]
          }
          upsert: {
            args: Prisma.CleaningSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSessionPayload>
          }
          aggregate: {
            args: Prisma.CleaningSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCleaningSession>
          }
          groupBy: {
            args: Prisma.CleaningSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CleaningSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CleaningSessionCountArgs<ExtArgs>
            result: $Utils.Optional<CleaningSessionCountAggregateOutputType> | number
          }
        }
      }
      CleaningChecklist: {
        payload: Prisma.$CleaningChecklistPayload<ExtArgs>
        fields: Prisma.CleaningChecklistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CleaningChecklistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CleaningChecklistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>
          }
          findFirst: {
            args: Prisma.CleaningChecklistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CleaningChecklistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>
          }
          findMany: {
            args: Prisma.CleaningChecklistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>[]
          }
          create: {
            args: Prisma.CleaningChecklistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>
          }
          createMany: {
            args: Prisma.CleaningChecklistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CleaningChecklistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>[]
          }
          delete: {
            args: Prisma.CleaningChecklistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>
          }
          update: {
            args: Prisma.CleaningChecklistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>
          }
          deleteMany: {
            args: Prisma.CleaningChecklistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CleaningChecklistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CleaningChecklistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>[]
          }
          upsert: {
            args: Prisma.CleaningChecklistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningChecklistPayload>
          }
          aggregate: {
            args: Prisma.CleaningChecklistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCleaningChecklist>
          }
          groupBy: {
            args: Prisma.CleaningChecklistGroupByArgs<ExtArgs>
            result: $Utils.Optional<CleaningChecklistGroupByOutputType>[]
          }
          count: {
            args: Prisma.CleaningChecklistCountArgs<ExtArgs>
            result: $Utils.Optional<CleaningChecklistCountAggregateOutputType> | number
          }
        }
      }
      CleaningPhoto: {
        payload: Prisma.$CleaningPhotoPayload<ExtArgs>
        fields: Prisma.CleaningPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CleaningPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CleaningPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>
          }
          findFirst: {
            args: Prisma.CleaningPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CleaningPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>
          }
          findMany: {
            args: Prisma.CleaningPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>[]
          }
          create: {
            args: Prisma.CleaningPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>
          }
          createMany: {
            args: Prisma.CleaningPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CleaningPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>[]
          }
          delete: {
            args: Prisma.CleaningPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>
          }
          update: {
            args: Prisma.CleaningPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>
          }
          deleteMany: {
            args: Prisma.CleaningPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CleaningPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CleaningPhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>[]
          }
          upsert: {
            args: Prisma.CleaningPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningPhotoPayload>
          }
          aggregate: {
            args: Prisma.CleaningPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCleaningPhoto>
          }
          groupBy: {
            args: Prisma.CleaningPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CleaningPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CleaningPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<CleaningPhotoCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      TicketPhoto: {
        payload: Prisma.$TicketPhotoPayload<ExtArgs>
        fields: Prisma.TicketPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>
          }
          findFirst: {
            args: Prisma.TicketPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>
          }
          findMany: {
            args: Prisma.TicketPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>[]
          }
          create: {
            args: Prisma.TicketPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>
          }
          createMany: {
            args: Prisma.TicketPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>[]
          }
          delete: {
            args: Prisma.TicketPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>
          }
          update: {
            args: Prisma.TicketPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>
          }
          deleteMany: {
            args: Prisma.TicketPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketPhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>[]
          }
          upsert: {
            args: Prisma.TicketPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPhotoPayload>
          }
          aggregate: {
            args: Prisma.TicketPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketPhoto>
          }
          groupBy: {
            args: Prisma.TicketPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<TicketPhotoCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceSession: {
        payload: Prisma.$MaintenanceSessionPayload<ExtArgs>
        fields: Prisma.MaintenanceSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>
          }
          findMany: {
            args: Prisma.MaintenanceSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>[]
          }
          create: {
            args: Prisma.MaintenanceSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>
          }
          createMany: {
            args: Prisma.MaintenanceSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>
          }
          update: {
            args: Prisma.MaintenanceSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintenanceSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>[]
          }
          upsert: {
            args: Prisma.MaintenanceSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceSessionPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceSession>
          }
          groupBy: {
            args: Prisma.MaintenanceSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceSessionCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceSessionCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceMaterial: {
        payload: Prisma.$MaintenanceMaterialPayload<ExtArgs>
        fields: Prisma.MaintenanceMaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceMaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceMaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceMaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceMaterialPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceMaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceMaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceMaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceMaterialPayload>
          }
          findMany: {
            args: Prisma.MaintenanceMaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceMaterialPayload>[]
          }
          create: {
            args: Prisma.MaintenanceMaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceMaterialPayload>
          }
          createMany: {
            args: Prisma.MaintenanceMaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceMaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceMaterialPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceMaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceMaterialPayload>
          }
          update: {
            args: Prisma.MaintenanceMaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceMaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceMaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceMaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintenanceMaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceMaterialPayload>[]
          }
          upsert: {
            args: Prisma.MaintenanceMaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceMaterialPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceMaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceMaterial>
          }
          groupBy: {
            args: Prisma.MaintenanceMaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceMaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceMaterialCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceMaterialCountAggregateOutputType> | number
          }
        }
      }
      MaintenancePhoto: {
        payload: Prisma.$MaintenancePhotoPayload<ExtArgs>
        fields: Prisma.MaintenancePhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenancePhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenancePhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>
          }
          findFirst: {
            args: Prisma.MaintenancePhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenancePhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>
          }
          findMany: {
            args: Prisma.MaintenancePhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>[]
          }
          create: {
            args: Prisma.MaintenancePhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>
          }
          createMany: {
            args: Prisma.MaintenancePhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenancePhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>[]
          }
          delete: {
            args: Prisma.MaintenancePhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>
          }
          update: {
            args: Prisma.MaintenancePhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>
          }
          deleteMany: {
            args: Prisma.MaintenancePhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenancePhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintenancePhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>[]
          }
          upsert: {
            args: Prisma.MaintenancePhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePhotoPayload>
          }
          aggregate: {
            args: Prisma.MaintenancePhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenancePhoto>
          }
          groupBy: {
            args: Prisma.MaintenancePhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenancePhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenancePhotoCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenancePhotoCountAggregateOutputType> | number
          }
        }
      }
      LaundryProduct: {
        payload: Prisma.$LaundryProductPayload<ExtArgs>
        fields: Prisma.LaundryProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LaundryProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LaundryProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryProductPayload>
          }
          findFirst: {
            args: Prisma.LaundryProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LaundryProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryProductPayload>
          }
          findMany: {
            args: Prisma.LaundryProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryProductPayload>[]
          }
          create: {
            args: Prisma.LaundryProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryProductPayload>
          }
          createMany: {
            args: Prisma.LaundryProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LaundryProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryProductPayload>[]
          }
          delete: {
            args: Prisma.LaundryProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryProductPayload>
          }
          update: {
            args: Prisma.LaundryProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryProductPayload>
          }
          deleteMany: {
            args: Prisma.LaundryProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LaundryProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LaundryProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryProductPayload>[]
          }
          upsert: {
            args: Prisma.LaundryProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryProductPayload>
          }
          aggregate: {
            args: Prisma.LaundryProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLaundryProduct>
          }
          groupBy: {
            args: Prisma.LaundryProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<LaundryProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.LaundryProductCountArgs<ExtArgs>
            result: $Utils.Optional<LaundryProductCountAggregateOutputType> | number
          }
        }
      }
      LaundryOrder: {
        payload: Prisma.$LaundryOrderPayload<ExtArgs>
        fields: Prisma.LaundryOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LaundryOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LaundryOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderPayload>
          }
          findFirst: {
            args: Prisma.LaundryOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LaundryOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderPayload>
          }
          findMany: {
            args: Prisma.LaundryOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderPayload>[]
          }
          create: {
            args: Prisma.LaundryOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderPayload>
          }
          createMany: {
            args: Prisma.LaundryOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LaundryOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderPayload>[]
          }
          delete: {
            args: Prisma.LaundryOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderPayload>
          }
          update: {
            args: Prisma.LaundryOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderPayload>
          }
          deleteMany: {
            args: Prisma.LaundryOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LaundryOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LaundryOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderPayload>[]
          }
          upsert: {
            args: Prisma.LaundryOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderPayload>
          }
          aggregate: {
            args: Prisma.LaundryOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLaundryOrder>
          }
          groupBy: {
            args: Prisma.LaundryOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<LaundryOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.LaundryOrderCountArgs<ExtArgs>
            result: $Utils.Optional<LaundryOrderCountAggregateOutputType> | number
          }
        }
      }
      LaundryOrderItem: {
        payload: Prisma.$LaundryOrderItemPayload<ExtArgs>
        fields: Prisma.LaundryOrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LaundryOrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LaundryOrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderItemPayload>
          }
          findFirst: {
            args: Prisma.LaundryOrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LaundryOrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderItemPayload>
          }
          findMany: {
            args: Prisma.LaundryOrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderItemPayload>[]
          }
          create: {
            args: Prisma.LaundryOrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderItemPayload>
          }
          createMany: {
            args: Prisma.LaundryOrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LaundryOrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderItemPayload>[]
          }
          delete: {
            args: Prisma.LaundryOrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderItemPayload>
          }
          update: {
            args: Prisma.LaundryOrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderItemPayload>
          }
          deleteMany: {
            args: Prisma.LaundryOrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LaundryOrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LaundryOrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderItemPayload>[]
          }
          upsert: {
            args: Prisma.LaundryOrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryOrderItemPayload>
          }
          aggregate: {
            args: Prisma.LaundryOrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLaundryOrderItem>
          }
          groupBy: {
            args: Prisma.LaundryOrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<LaundryOrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.LaundryOrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<LaundryOrderItemCountAggregateOutputType> | number
          }
        }
      }
      DeliveryNote: {
        payload: Prisma.$DeliveryNotePayload<ExtArgs>
        fields: Prisma.DeliveryNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>
          }
          findFirst: {
            args: Prisma.DeliveryNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>
          }
          findMany: {
            args: Prisma.DeliveryNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>[]
          }
          create: {
            args: Prisma.DeliveryNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>
          }
          createMany: {
            args: Prisma.DeliveryNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>[]
          }
          delete: {
            args: Prisma.DeliveryNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>
          }
          update: {
            args: Prisma.DeliveryNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>
          }
          deleteMany: {
            args: Prisma.DeliveryNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>[]
          }
          upsert: {
            args: Prisma.DeliveryNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryNotePayload>
          }
          aggregate: {
            args: Prisma.DeliveryNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryNote>
          }
          groupBy: {
            args: Prisma.DeliveryNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryNoteCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryNoteCountAggregateOutputType> | number
          }
        }
      }
      TaskAssignment: {
        payload: Prisma.$TaskAssignmentPayload<ExtArgs>
        fields: Prisma.TaskAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          findFirst: {
            args: Prisma.TaskAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          findMany: {
            args: Prisma.TaskAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>[]
          }
          create: {
            args: Prisma.TaskAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          createMany: {
            args: Prisma.TaskAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>[]
          }
          delete: {
            args: Prisma.TaskAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          update: {
            args: Prisma.TaskAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.TaskAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.TaskAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssignmentPayload>
          }
          aggregate: {
            args: Prisma.TaskAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskAssignment>
          }
          groupBy: {
            args: Prisma.TaskAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<TaskAssignmentCountAggregateOutputType> | number
          }
        }
      }
      PropertyContract: {
        payload: Prisma.$PropertyContractPayload<ExtArgs>
        fields: Prisma.PropertyContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContractPayload>
          }
          findFirst: {
            args: Prisma.PropertyContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContractPayload>
          }
          findMany: {
            args: Prisma.PropertyContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContractPayload>[]
          }
          create: {
            args: Prisma.PropertyContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContractPayload>
          }
          createMany: {
            args: Prisma.PropertyContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContractPayload>[]
          }
          delete: {
            args: Prisma.PropertyContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContractPayload>
          }
          update: {
            args: Prisma.PropertyContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContractPayload>
          }
          deleteMany: {
            args: Prisma.PropertyContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyContractUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContractPayload>[]
          }
          upsert: {
            args: Prisma.PropertyContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContractPayload>
          }
          aggregate: {
            args: Prisma.PropertyContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyContract>
          }
          groupBy: {
            args: Prisma.PropertyContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyContractCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyContractCountAggregateOutputType> | number
          }
        }
      }
      SuperAdminInvoice: {
        payload: Prisma.$SuperAdminInvoicePayload<ExtArgs>
        fields: Prisma.SuperAdminInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuperAdminInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuperAdminInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoicePayload>
          }
          findFirst: {
            args: Prisma.SuperAdminInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuperAdminInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoicePayload>
          }
          findMany: {
            args: Prisma.SuperAdminInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoicePayload>[]
          }
          create: {
            args: Prisma.SuperAdminInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoicePayload>
          }
          createMany: {
            args: Prisma.SuperAdminInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuperAdminInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoicePayload>[]
          }
          delete: {
            args: Prisma.SuperAdminInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoicePayload>
          }
          update: {
            args: Prisma.SuperAdminInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoicePayload>
          }
          deleteMany: {
            args: Prisma.SuperAdminInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuperAdminInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SuperAdminInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoicePayload>[]
          }
          upsert: {
            args: Prisma.SuperAdminInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoicePayload>
          }
          aggregate: {
            args: Prisma.SuperAdminInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuperAdminInvoice>
          }
          groupBy: {
            args: Prisma.SuperAdminInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuperAdminInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminInvoiceCountAggregateOutputType> | number
          }
        }
      }
      SuperAdminInvoiceItem: {
        payload: Prisma.$SuperAdminInvoiceItemPayload<ExtArgs>
        fields: Prisma.SuperAdminInvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuperAdminInvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuperAdminInvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.SuperAdminInvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuperAdminInvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoiceItemPayload>
          }
          findMany: {
            args: Prisma.SuperAdminInvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoiceItemPayload>[]
          }
          create: {
            args: Prisma.SuperAdminInvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoiceItemPayload>
          }
          createMany: {
            args: Prisma.SuperAdminInvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuperAdminInvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.SuperAdminInvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoiceItemPayload>
          }
          update: {
            args: Prisma.SuperAdminInvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.SuperAdminInvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuperAdminInvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SuperAdminInvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.SuperAdminInvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminInvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.SuperAdminInvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuperAdminInvoiceItem>
          }
          groupBy: {
            args: Prisma.SuperAdminInvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminInvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuperAdminInvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminInvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      LaundryInvoice: {
        payload: Prisma.$LaundryInvoicePayload<ExtArgs>
        fields: Prisma.LaundryInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LaundryInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LaundryInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryInvoicePayload>
          }
          findFirst: {
            args: Prisma.LaundryInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LaundryInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryInvoicePayload>
          }
          findMany: {
            args: Prisma.LaundryInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryInvoicePayload>[]
          }
          create: {
            args: Prisma.LaundryInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryInvoicePayload>
          }
          createMany: {
            args: Prisma.LaundryInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LaundryInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryInvoicePayload>[]
          }
          delete: {
            args: Prisma.LaundryInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryInvoicePayload>
          }
          update: {
            args: Prisma.LaundryInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryInvoicePayload>
          }
          deleteMany: {
            args: Prisma.LaundryInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LaundryInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LaundryInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryInvoicePayload>[]
          }
          upsert: {
            args: Prisma.LaundryInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaundryInvoicePayload>
          }
          aggregate: {
            args: Prisma.LaundryInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLaundryInvoice>
          }
          groupBy: {
            args: Prisma.LaundryInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<LaundryInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.LaundryInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<LaundryInvoiceCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    superAdminProfile?: SuperAdminProfileOmit
    poleSubscription?: PoleSubscriptionOmit
    poleManagerProfile?: PoleManagerProfileOmit
    propertyOwnerProfile?: PropertyOwnerProfileOmit
    laundryClientProfile?: LaundryClientProfileOmit
    agentProfile?: AgentProfileOmit
    agentSpecialty?: AgentSpecialtyOmit
    property?: PropertyOmit
    propertyFeature?: PropertyFeatureOmit
    propertyPhoto?: PropertyPhotoOmit
    propertyReview?: PropertyReviewOmit
    reservation?: ReservationOmit
    cleaningSession?: CleaningSessionOmit
    cleaningChecklist?: CleaningChecklistOmit
    cleaningPhoto?: CleaningPhotoOmit
    ticket?: TicketOmit
    ticketPhoto?: TicketPhotoOmit
    maintenanceSession?: MaintenanceSessionOmit
    maintenanceMaterial?: MaintenanceMaterialOmit
    maintenancePhoto?: MaintenancePhotoOmit
    laundryProduct?: LaundryProductOmit
    laundryOrder?: LaundryOrderOmit
    laundryOrderItem?: LaundryOrderItemOmit
    deliveryNote?: DeliveryNoteOmit
    taskAssignment?: TaskAssignmentOmit
    propertyContract?: PropertyContractOmit
    superAdminInvoice?: SuperAdminInvoiceOmit
    superAdminInvoiceItem?: SuperAdminInvoiceItemOmit
    laundryInvoice?: LaundryInvoiceOmit
    notification?: NotificationOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type SuperAdminProfileCountOutputType
   */

  export type SuperAdminProfileCountOutputType = {
    poleSubscriptions: number
    poleManagers: number
    invoices: number
  }

  export type SuperAdminProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poleSubscriptions?: boolean | SuperAdminProfileCountOutputTypeCountPoleSubscriptionsArgs
    poleManagers?: boolean | SuperAdminProfileCountOutputTypeCountPoleManagersArgs
    invoices?: boolean | SuperAdminProfileCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * SuperAdminProfileCountOutputType without action
   */
  export type SuperAdminProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminProfileCountOutputType
     */
    select?: SuperAdminProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SuperAdminProfileCountOutputType without action
   */
  export type SuperAdminProfileCountOutputTypeCountPoleSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PoleSubscriptionWhereInput
  }

  /**
   * SuperAdminProfileCountOutputType without action
   */
  export type SuperAdminProfileCountOutputTypeCountPoleManagersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PoleManagerProfileWhereInput
  }

  /**
   * SuperAdminProfileCountOutputType without action
   */
  export type SuperAdminProfileCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuperAdminInvoiceWhereInput
  }


  /**
   * Count Type PoleManagerProfileCountOutputType
   */

  export type PoleManagerProfileCountOutputType = {
    properties: number
    reservations: number
    cleaningSessions: number
    tickets: number
    maintenanceSessions: number
    laundryOrders: number
    managedAgents: number
  }

  export type PoleManagerProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | PoleManagerProfileCountOutputTypeCountPropertiesArgs
    reservations?: boolean | PoleManagerProfileCountOutputTypeCountReservationsArgs
    cleaningSessions?: boolean | PoleManagerProfileCountOutputTypeCountCleaningSessionsArgs
    tickets?: boolean | PoleManagerProfileCountOutputTypeCountTicketsArgs
    maintenanceSessions?: boolean | PoleManagerProfileCountOutputTypeCountMaintenanceSessionsArgs
    laundryOrders?: boolean | PoleManagerProfileCountOutputTypeCountLaundryOrdersArgs
    managedAgents?: boolean | PoleManagerProfileCountOutputTypeCountManagedAgentsArgs
  }

  // Custom InputTypes
  /**
   * PoleManagerProfileCountOutputType without action
   */
  export type PoleManagerProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleManagerProfileCountOutputType
     */
    select?: PoleManagerProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PoleManagerProfileCountOutputType without action
   */
  export type PoleManagerProfileCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * PoleManagerProfileCountOutputType without action
   */
  export type PoleManagerProfileCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * PoleManagerProfileCountOutputType without action
   */
  export type PoleManagerProfileCountOutputTypeCountCleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningSessionWhereInput
  }

  /**
   * PoleManagerProfileCountOutputType without action
   */
  export type PoleManagerProfileCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * PoleManagerProfileCountOutputType without action
   */
  export type PoleManagerProfileCountOutputTypeCountMaintenanceSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceSessionWhereInput
  }

  /**
   * PoleManagerProfileCountOutputType without action
   */
  export type PoleManagerProfileCountOutputTypeCountLaundryOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaundryOrderWhereInput
  }

  /**
   * PoleManagerProfileCountOutputType without action
   */
  export type PoleManagerProfileCountOutputTypeCountManagedAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentProfileWhereInput
  }


  /**
   * Count Type PropertyOwnerProfileCountOutputType
   */

  export type PropertyOwnerProfileCountOutputType = {
    properties: number
    contracts: number
  }

  export type PropertyOwnerProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | PropertyOwnerProfileCountOutputTypeCountPropertiesArgs
    contracts?: boolean | PropertyOwnerProfileCountOutputTypeCountContractsArgs
  }

  // Custom InputTypes
  /**
   * PropertyOwnerProfileCountOutputType without action
   */
  export type PropertyOwnerProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwnerProfileCountOutputType
     */
    select?: PropertyOwnerProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyOwnerProfileCountOutputType without action
   */
  export type PropertyOwnerProfileCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * PropertyOwnerProfileCountOutputType without action
   */
  export type PropertyOwnerProfileCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyContractWhereInput
  }


  /**
   * Count Type LaundryClientProfileCountOutputType
   */

  export type LaundryClientProfileCountOutputType = {
    laundryOrders: number
    laundryInvoices: number
  }

  export type LaundryClientProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    laundryOrders?: boolean | LaundryClientProfileCountOutputTypeCountLaundryOrdersArgs
    laundryInvoices?: boolean | LaundryClientProfileCountOutputTypeCountLaundryInvoicesArgs
  }

  // Custom InputTypes
  /**
   * LaundryClientProfileCountOutputType without action
   */
  export type LaundryClientProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryClientProfileCountOutputType
     */
    select?: LaundryClientProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LaundryClientProfileCountOutputType without action
   */
  export type LaundryClientProfileCountOutputTypeCountLaundryOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaundryOrderWhereInput
  }

  /**
   * LaundryClientProfileCountOutputType without action
   */
  export type LaundryClientProfileCountOutputTypeCountLaundryInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaundryInvoiceWhereInput
  }


  /**
   * Count Type AgentProfileCountOutputType
   */

  export type AgentProfileCountOutputType = {
    specialties: number
    cleaningSessions: number
    maintenanceSessions: number
    tickets: number
    taskAssignments: number
  }

  export type AgentProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specialties?: boolean | AgentProfileCountOutputTypeCountSpecialtiesArgs
    cleaningSessions?: boolean | AgentProfileCountOutputTypeCountCleaningSessionsArgs
    maintenanceSessions?: boolean | AgentProfileCountOutputTypeCountMaintenanceSessionsArgs
    tickets?: boolean | AgentProfileCountOutputTypeCountTicketsArgs
    taskAssignments?: boolean | AgentProfileCountOutputTypeCountTaskAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * AgentProfileCountOutputType without action
   */
  export type AgentProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfileCountOutputType
     */
    select?: AgentProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentProfileCountOutputType without action
   */
  export type AgentProfileCountOutputTypeCountSpecialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentSpecialtyWhereInput
  }

  /**
   * AgentProfileCountOutputType without action
   */
  export type AgentProfileCountOutputTypeCountCleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningSessionWhereInput
  }

  /**
   * AgentProfileCountOutputType without action
   */
  export type AgentProfileCountOutputTypeCountMaintenanceSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceSessionWhereInput
  }

  /**
   * AgentProfileCountOutputType without action
   */
  export type AgentProfileCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * AgentProfileCountOutputType without action
   */
  export type AgentProfileCountOutputTypeCountTaskAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssignmentWhereInput
  }


  /**
   * Count Type PropertyCountOutputType
   */

  export type PropertyCountOutputType = {
    features: number
    photos: number
    reservations: number
    cleaningSessions: number
    maintenanceSessions: number
    tickets: number
    reviews: number
    contracts: number
  }

  export type PropertyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | PropertyCountOutputTypeCountFeaturesArgs
    photos?: boolean | PropertyCountOutputTypeCountPhotosArgs
    reservations?: boolean | PropertyCountOutputTypeCountReservationsArgs
    cleaningSessions?: boolean | PropertyCountOutputTypeCountCleaningSessionsArgs
    maintenanceSessions?: boolean | PropertyCountOutputTypeCountMaintenanceSessionsArgs
    tickets?: boolean | PropertyCountOutputTypeCountTicketsArgs
    reviews?: boolean | PropertyCountOutputTypeCountReviewsArgs
    contracts?: boolean | PropertyCountOutputTypeCountContractsArgs
  }

  // Custom InputTypes
  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCountOutputType
     */
    select?: PropertyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyFeatureWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyPhotoWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountCleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningSessionWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountMaintenanceSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceSessionWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyReviewWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyContractWhereInput
  }


  /**
   * Count Type CleaningSessionCountOutputType
   */

  export type CleaningSessionCountOutputType = {
    checklist: number
    photos: number
  }

  export type CleaningSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checklist?: boolean | CleaningSessionCountOutputTypeCountChecklistArgs
    photos?: boolean | CleaningSessionCountOutputTypeCountPhotosArgs
  }

  // Custom InputTypes
  /**
   * CleaningSessionCountOutputType without action
   */
  export type CleaningSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSessionCountOutputType
     */
    select?: CleaningSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CleaningSessionCountOutputType without action
   */
  export type CleaningSessionCountOutputTypeCountChecklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningChecklistWhereInput
  }

  /**
   * CleaningSessionCountOutputType without action
   */
  export type CleaningSessionCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningPhotoWhereInput
  }


  /**
   * Count Type TicketCountOutputType
   */

  export type TicketCountOutputType = {
    photos: number
  }

  export type TicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | TicketCountOutputTypeCountPhotosArgs
  }

  // Custom InputTypes
  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCountOutputType
     */
    select?: TicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketPhotoWhereInput
  }


  /**
   * Count Type MaintenanceSessionCountOutputType
   */

  export type MaintenanceSessionCountOutputType = {
    materials: number
    photos: number
  }

  export type MaintenanceSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materials?: boolean | MaintenanceSessionCountOutputTypeCountMaterialsArgs
    photos?: boolean | MaintenanceSessionCountOutputTypeCountPhotosArgs
  }

  // Custom InputTypes
  /**
   * MaintenanceSessionCountOutputType without action
   */
  export type MaintenanceSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSessionCountOutputType
     */
    select?: MaintenanceSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaintenanceSessionCountOutputType without action
   */
  export type MaintenanceSessionCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceMaterialWhereInput
  }

  /**
   * MaintenanceSessionCountOutputType without action
   */
  export type MaintenanceSessionCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenancePhotoWhereInput
  }


  /**
   * Count Type LaundryProductCountOutputType
   */

  export type LaundryProductCountOutputType = {
    orderItems: number
  }

  export type LaundryProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | LaundryProductCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * LaundryProductCountOutputType without action
   */
  export type LaundryProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryProductCountOutputType
     */
    select?: LaundryProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LaundryProductCountOutputType without action
   */
  export type LaundryProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaundryOrderItemWhereInput
  }


  /**
   * Count Type LaundryOrderCountOutputType
   */

  export type LaundryOrderCountOutputType = {
    items: number
    deliveryNotes: number
  }

  export type LaundryOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | LaundryOrderCountOutputTypeCountItemsArgs
    deliveryNotes?: boolean | LaundryOrderCountOutputTypeCountDeliveryNotesArgs
  }

  // Custom InputTypes
  /**
   * LaundryOrderCountOutputType without action
   */
  export type LaundryOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrderCountOutputType
     */
    select?: LaundryOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LaundryOrderCountOutputType without action
   */
  export type LaundryOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaundryOrderItemWhereInput
  }

  /**
   * LaundryOrderCountOutputType without action
   */
  export type LaundryOrderCountOutputTypeCountDeliveryNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryNoteWhereInput
  }


  /**
   * Count Type SuperAdminInvoiceCountOutputType
   */

  export type SuperAdminInvoiceCountOutputType = {
    items: number
  }

  export type SuperAdminInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SuperAdminInvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * SuperAdminInvoiceCountOutputType without action
   */
  export type SuperAdminInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoiceCountOutputType
     */
    select?: SuperAdminInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SuperAdminInvoiceCountOutputType without action
   */
  export type SuperAdminInvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuperAdminInvoiceItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    avatar: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    language: string | null
    timezone: string | null
    emailVerified: boolean | null
    phoneVerified: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    avatar: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    language: string | null
    timezone: string | null
    emailVerified: boolean | null
    phoneVerified: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    firstName: number
    lastName: number
    phone: number
    avatar: number
    role: number
    status: number
    language: number
    timezone: number
    emailVerified: number
    phoneVerified: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    firstName?: true
    lastName?: true
    phone?: true
    avatar?: true
    role?: true
    status?: true
    language?: true
    timezone?: true
    emailVerified?: true
    phoneVerified?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    firstName?: true
    lastName?: true
    phone?: true
    avatar?: true
    role?: true
    status?: true
    language?: true
    timezone?: true
    emailVerified?: true
    phoneVerified?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    firstName?: true
    lastName?: true
    phone?: true
    avatar?: true
    role?: true
    status?: true
    language?: true
    timezone?: true
    emailVerified?: true
    phoneVerified?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string | null
    name: string
    firstName: string | null
    lastName: string | null
    phone: string | null
    avatar: string | null
    role: $Enums.UserRole
    status: $Enums.UserStatus
    language: string | null
    timezone: string | null
    emailVerified: boolean
    phoneVerified: boolean
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    avatar?: boolean
    role?: boolean
    status?: boolean
    language?: boolean
    timezone?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    superAdminProfile?: boolean | User$superAdminProfileArgs<ExtArgs>
    poleManagerProfile?: boolean | User$poleManagerProfileArgs<ExtArgs>
    propertyOwnerProfile?: boolean | User$propertyOwnerProfileArgs<ExtArgs>
    laundryClientProfile?: boolean | User$laundryClientProfileArgs<ExtArgs>
    agentProfile?: boolean | User$agentProfileArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    avatar?: boolean
    role?: boolean
    status?: boolean
    language?: boolean
    timezone?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    avatar?: boolean
    role?: boolean
    status?: boolean
    language?: boolean
    timezone?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    avatar?: boolean
    role?: boolean
    status?: boolean
    language?: boolean
    timezone?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "firstName" | "lastName" | "phone" | "avatar" | "role" | "status" | "language" | "timezone" | "emailVerified" | "phoneVerified" | "lastLoginAt" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    superAdminProfile?: boolean | User$superAdminProfileArgs<ExtArgs>
    poleManagerProfile?: boolean | User$poleManagerProfileArgs<ExtArgs>
    propertyOwnerProfile?: boolean | User$propertyOwnerProfileArgs<ExtArgs>
    laundryClientProfile?: boolean | User$laundryClientProfileArgs<ExtArgs>
    agentProfile?: boolean | User$agentProfileArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      superAdminProfile: Prisma.$SuperAdminProfilePayload<ExtArgs> | null
      poleManagerProfile: Prisma.$PoleManagerProfilePayload<ExtArgs> | null
      propertyOwnerProfile: Prisma.$PropertyOwnerProfilePayload<ExtArgs> | null
      laundryClientProfile: Prisma.$LaundryClientProfilePayload<ExtArgs> | null
      agentProfile: Prisma.$AgentProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string | null
      name: string
      firstName: string | null
      lastName: string | null
      phone: string | null
      avatar: string | null
      role: $Enums.UserRole
      status: $Enums.UserStatus
      language: string | null
      timezone: string | null
      emailVerified: boolean
      phoneVerified: boolean
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    superAdminProfile<T extends User$superAdminProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$superAdminProfileArgs<ExtArgs>>): Prisma__SuperAdminProfileClient<$Result.GetResult<Prisma.$SuperAdminProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    poleManagerProfile<T extends User$poleManagerProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$poleManagerProfileArgs<ExtArgs>>): Prisma__PoleManagerProfileClient<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    propertyOwnerProfile<T extends User$propertyOwnerProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$propertyOwnerProfileArgs<ExtArgs>>): Prisma__PropertyOwnerProfileClient<$Result.GetResult<Prisma.$PropertyOwnerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    laundryClientProfile<T extends User$laundryClientProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$laundryClientProfileArgs<ExtArgs>>): Prisma__LaundryClientProfileClient<$Result.GetResult<Prisma.$LaundryClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agentProfile<T extends User$agentProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$agentProfileArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly language: FieldRef<"User", 'String'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly phoneVerified: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.superAdminProfile
   */
  export type User$superAdminProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminProfile
     */
    select?: SuperAdminProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminProfile
     */
    omit?: SuperAdminProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminProfileInclude<ExtArgs> | null
    where?: SuperAdminProfileWhereInput
  }

  /**
   * User.poleManagerProfile
   */
  export type User$poleManagerProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleManagerProfile
     */
    select?: PoleManagerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleManagerProfile
     */
    omit?: PoleManagerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleManagerProfileInclude<ExtArgs> | null
    where?: PoleManagerProfileWhereInput
  }

  /**
   * User.propertyOwnerProfile
   */
  export type User$propertyOwnerProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwnerProfile
     */
    select?: PropertyOwnerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwnerProfile
     */
    omit?: PropertyOwnerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerProfileInclude<ExtArgs> | null
    where?: PropertyOwnerProfileWhereInput
  }

  /**
   * User.laundryClientProfile
   */
  export type User$laundryClientProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryClientProfile
     */
    select?: LaundryClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryClientProfile
     */
    omit?: LaundryClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryClientProfileInclude<ExtArgs> | null
    where?: LaundryClientProfileWhereInput
  }

  /**
   * User.agentProfile
   */
  export type User$agentProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    where?: AgentProfileWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model SuperAdminProfile
   */

  export type AggregateSuperAdminProfile = {
    _count: SuperAdminProfileCountAggregateOutputType | null
    _min: SuperAdminProfileMinAggregateOutputType | null
    _max: SuperAdminProfileMaxAggregateOutputType | null
  }

  export type SuperAdminProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    businessNumber: string | null
    vatNumber: string | null
    billingAddress: string | null
    billingCity: string | null
    billingCountry: string | null
    billingPostal: string | null
    subscriptionTier: string | null
    subscriptionStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuperAdminProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    businessNumber: string | null
    vatNumber: string | null
    billingAddress: string | null
    billingCity: string | null
    billingCountry: string | null
    billingPostal: string | null
    subscriptionTier: string | null
    subscriptionStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuperAdminProfileCountAggregateOutputType = {
    id: number
    userId: number
    companyName: number
    businessNumber: number
    vatNumber: number
    billingAddress: number
    billingCity: number
    billingCountry: number
    billingPostal: number
    subscriptionTier: number
    subscriptionStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SuperAdminProfileMinAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    businessNumber?: true
    vatNumber?: true
    billingAddress?: true
    billingCity?: true
    billingCountry?: true
    billingPostal?: true
    subscriptionTier?: true
    subscriptionStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuperAdminProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    businessNumber?: true
    vatNumber?: true
    billingAddress?: true
    billingCity?: true
    billingCountry?: true
    billingPostal?: true
    subscriptionTier?: true
    subscriptionStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuperAdminProfileCountAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    businessNumber?: true
    vatNumber?: true
    billingAddress?: true
    billingCity?: true
    billingCountry?: true
    billingPostal?: true
    subscriptionTier?: true
    subscriptionStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SuperAdminProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdminProfile to aggregate.
     */
    where?: SuperAdminProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdminProfiles to fetch.
     */
    orderBy?: SuperAdminProfileOrderByWithRelationInput | SuperAdminProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuperAdminProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdminProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdminProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuperAdminProfiles
    **/
    _count?: true | SuperAdminProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuperAdminProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuperAdminProfileMaxAggregateInputType
  }

  export type GetSuperAdminProfileAggregateType<T extends SuperAdminProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateSuperAdminProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperAdminProfile[P]>
      : GetScalarType<T[P], AggregateSuperAdminProfile[P]>
  }




  export type SuperAdminProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuperAdminProfileWhereInput
    orderBy?: SuperAdminProfileOrderByWithAggregationInput | SuperAdminProfileOrderByWithAggregationInput[]
    by: SuperAdminProfileScalarFieldEnum[] | SuperAdminProfileScalarFieldEnum
    having?: SuperAdminProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuperAdminProfileCountAggregateInputType | true
    _min?: SuperAdminProfileMinAggregateInputType
    _max?: SuperAdminProfileMaxAggregateInputType
  }

  export type SuperAdminProfileGroupByOutputType = {
    id: string
    userId: string
    companyName: string
    businessNumber: string | null
    vatNumber: string | null
    billingAddress: string
    billingCity: string
    billingCountry: string
    billingPostal: string
    subscriptionTier: string
    subscriptionStatus: string
    createdAt: Date
    updatedAt: Date
    _count: SuperAdminProfileCountAggregateOutputType | null
    _min: SuperAdminProfileMinAggregateOutputType | null
    _max: SuperAdminProfileMaxAggregateOutputType | null
  }

  type GetSuperAdminProfileGroupByPayload<T extends SuperAdminProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuperAdminProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuperAdminProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuperAdminProfileGroupByOutputType[P]>
            : GetScalarType<T[P], SuperAdminProfileGroupByOutputType[P]>
        }
      >
    >


  export type SuperAdminProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    businessNumber?: boolean
    vatNumber?: boolean
    billingAddress?: boolean
    billingCity?: boolean
    billingCountry?: boolean
    billingPostal?: boolean
    subscriptionTier?: boolean
    subscriptionStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    poleSubscriptions?: boolean | SuperAdminProfile$poleSubscriptionsArgs<ExtArgs>
    poleManagers?: boolean | SuperAdminProfile$poleManagersArgs<ExtArgs>
    invoices?: boolean | SuperAdminProfile$invoicesArgs<ExtArgs>
    _count?: boolean | SuperAdminProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdminProfile"]>

  export type SuperAdminProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    businessNumber?: boolean
    vatNumber?: boolean
    billingAddress?: boolean
    billingCity?: boolean
    billingCountry?: boolean
    billingPostal?: boolean
    subscriptionTier?: boolean
    subscriptionStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdminProfile"]>

  export type SuperAdminProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    businessNumber?: boolean
    vatNumber?: boolean
    billingAddress?: boolean
    billingCity?: boolean
    billingCountry?: boolean
    billingPostal?: boolean
    subscriptionTier?: boolean
    subscriptionStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdminProfile"]>

  export type SuperAdminProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    companyName?: boolean
    businessNumber?: boolean
    vatNumber?: boolean
    billingAddress?: boolean
    billingCity?: boolean
    billingCountry?: boolean
    billingPostal?: boolean
    subscriptionTier?: boolean
    subscriptionStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SuperAdminProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyName" | "businessNumber" | "vatNumber" | "billingAddress" | "billingCity" | "billingCountry" | "billingPostal" | "subscriptionTier" | "subscriptionStatus" | "createdAt" | "updatedAt", ExtArgs["result"]["superAdminProfile"]>
  export type SuperAdminProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    poleSubscriptions?: boolean | SuperAdminProfile$poleSubscriptionsArgs<ExtArgs>
    poleManagers?: boolean | SuperAdminProfile$poleManagersArgs<ExtArgs>
    invoices?: boolean | SuperAdminProfile$invoicesArgs<ExtArgs>
    _count?: boolean | SuperAdminProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SuperAdminProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SuperAdminProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SuperAdminProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SuperAdminProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      poleSubscriptions: Prisma.$PoleSubscriptionPayload<ExtArgs>[]
      poleManagers: Prisma.$PoleManagerProfilePayload<ExtArgs>[]
      invoices: Prisma.$SuperAdminInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyName: string
      businessNumber: string | null
      vatNumber: string | null
      billingAddress: string
      billingCity: string
      billingCountry: string
      billingPostal: string
      subscriptionTier: string
      subscriptionStatus: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["superAdminProfile"]>
    composites: {}
  }

  type SuperAdminProfileGetPayload<S extends boolean | null | undefined | SuperAdminProfileDefaultArgs> = $Result.GetResult<Prisma.$SuperAdminProfilePayload, S>

  type SuperAdminProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SuperAdminProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuperAdminProfileCountAggregateInputType | true
    }

  export interface SuperAdminProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SuperAdminProfile'], meta: { name: 'SuperAdminProfile' } }
    /**
     * Find zero or one SuperAdminProfile that matches the filter.
     * @param {SuperAdminProfileFindUniqueArgs} args - Arguments to find a SuperAdminProfile
     * @example
     * // Get one SuperAdminProfile
     * const superAdminProfile = await prisma.superAdminProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuperAdminProfileFindUniqueArgs>(args: SelectSubset<T, SuperAdminProfileFindUniqueArgs<ExtArgs>>): Prisma__SuperAdminProfileClient<$Result.GetResult<Prisma.$SuperAdminProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SuperAdminProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SuperAdminProfileFindUniqueOrThrowArgs} args - Arguments to find a SuperAdminProfile
     * @example
     * // Get one SuperAdminProfile
     * const superAdminProfile = await prisma.superAdminProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuperAdminProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, SuperAdminProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuperAdminProfileClient<$Result.GetResult<Prisma.$SuperAdminProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdminProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminProfileFindFirstArgs} args - Arguments to find a SuperAdminProfile
     * @example
     * // Get one SuperAdminProfile
     * const superAdminProfile = await prisma.superAdminProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuperAdminProfileFindFirstArgs>(args?: SelectSubset<T, SuperAdminProfileFindFirstArgs<ExtArgs>>): Prisma__SuperAdminProfileClient<$Result.GetResult<Prisma.$SuperAdminProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdminProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminProfileFindFirstOrThrowArgs} args - Arguments to find a SuperAdminProfile
     * @example
     * // Get one SuperAdminProfile
     * const superAdminProfile = await prisma.superAdminProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuperAdminProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, SuperAdminProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuperAdminProfileClient<$Result.GetResult<Prisma.$SuperAdminProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SuperAdminProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuperAdminProfiles
     * const superAdminProfiles = await prisma.superAdminProfile.findMany()
     * 
     * // Get first 10 SuperAdminProfiles
     * const superAdminProfiles = await prisma.superAdminProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const superAdminProfileWithIdOnly = await prisma.superAdminProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuperAdminProfileFindManyArgs>(args?: SelectSubset<T, SuperAdminProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SuperAdminProfile.
     * @param {SuperAdminProfileCreateArgs} args - Arguments to create a SuperAdminProfile.
     * @example
     * // Create one SuperAdminProfile
     * const SuperAdminProfile = await prisma.superAdminProfile.create({
     *   data: {
     *     // ... data to create a SuperAdminProfile
     *   }
     * })
     * 
     */
    create<T extends SuperAdminProfileCreateArgs>(args: SelectSubset<T, SuperAdminProfileCreateArgs<ExtArgs>>): Prisma__SuperAdminProfileClient<$Result.GetResult<Prisma.$SuperAdminProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SuperAdminProfiles.
     * @param {SuperAdminProfileCreateManyArgs} args - Arguments to create many SuperAdminProfiles.
     * @example
     * // Create many SuperAdminProfiles
     * const superAdminProfile = await prisma.superAdminProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuperAdminProfileCreateManyArgs>(args?: SelectSubset<T, SuperAdminProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SuperAdminProfiles and returns the data saved in the database.
     * @param {SuperAdminProfileCreateManyAndReturnArgs} args - Arguments to create many SuperAdminProfiles.
     * @example
     * // Create many SuperAdminProfiles
     * const superAdminProfile = await prisma.superAdminProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SuperAdminProfiles and only return the `id`
     * const superAdminProfileWithIdOnly = await prisma.superAdminProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuperAdminProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, SuperAdminProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SuperAdminProfile.
     * @param {SuperAdminProfileDeleteArgs} args - Arguments to delete one SuperAdminProfile.
     * @example
     * // Delete one SuperAdminProfile
     * const SuperAdminProfile = await prisma.superAdminProfile.delete({
     *   where: {
     *     // ... filter to delete one SuperAdminProfile
     *   }
     * })
     * 
     */
    delete<T extends SuperAdminProfileDeleteArgs>(args: SelectSubset<T, SuperAdminProfileDeleteArgs<ExtArgs>>): Prisma__SuperAdminProfileClient<$Result.GetResult<Prisma.$SuperAdminProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SuperAdminProfile.
     * @param {SuperAdminProfileUpdateArgs} args - Arguments to update one SuperAdminProfile.
     * @example
     * // Update one SuperAdminProfile
     * const superAdminProfile = await prisma.superAdminProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuperAdminProfileUpdateArgs>(args: SelectSubset<T, SuperAdminProfileUpdateArgs<ExtArgs>>): Prisma__SuperAdminProfileClient<$Result.GetResult<Prisma.$SuperAdminProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SuperAdminProfiles.
     * @param {SuperAdminProfileDeleteManyArgs} args - Arguments to filter SuperAdminProfiles to delete.
     * @example
     * // Delete a few SuperAdminProfiles
     * const { count } = await prisma.superAdminProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuperAdminProfileDeleteManyArgs>(args?: SelectSubset<T, SuperAdminProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdminProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuperAdminProfiles
     * const superAdminProfile = await prisma.superAdminProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuperAdminProfileUpdateManyArgs>(args: SelectSubset<T, SuperAdminProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdminProfiles and returns the data updated in the database.
     * @param {SuperAdminProfileUpdateManyAndReturnArgs} args - Arguments to update many SuperAdminProfiles.
     * @example
     * // Update many SuperAdminProfiles
     * const superAdminProfile = await prisma.superAdminProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SuperAdminProfiles and only return the `id`
     * const superAdminProfileWithIdOnly = await prisma.superAdminProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SuperAdminProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, SuperAdminProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SuperAdminProfile.
     * @param {SuperAdminProfileUpsertArgs} args - Arguments to update or create a SuperAdminProfile.
     * @example
     * // Update or create a SuperAdminProfile
     * const superAdminProfile = await prisma.superAdminProfile.upsert({
     *   create: {
     *     // ... data to create a SuperAdminProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuperAdminProfile we want to update
     *   }
     * })
     */
    upsert<T extends SuperAdminProfileUpsertArgs>(args: SelectSubset<T, SuperAdminProfileUpsertArgs<ExtArgs>>): Prisma__SuperAdminProfileClient<$Result.GetResult<Prisma.$SuperAdminProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SuperAdminProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminProfileCountArgs} args - Arguments to filter SuperAdminProfiles to count.
     * @example
     * // Count the number of SuperAdminProfiles
     * const count = await prisma.superAdminProfile.count({
     *   where: {
     *     // ... the filter for the SuperAdminProfiles we want to count
     *   }
     * })
    **/
    count<T extends SuperAdminProfileCountArgs>(
      args?: Subset<T, SuperAdminProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuperAdminProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuperAdminProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuperAdminProfileAggregateArgs>(args: Subset<T, SuperAdminProfileAggregateArgs>): Prisma.PrismaPromise<GetSuperAdminProfileAggregateType<T>>

    /**
     * Group by SuperAdminProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuperAdminProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuperAdminProfileGroupByArgs['orderBy'] }
        : { orderBy?: SuperAdminProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuperAdminProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuperAdminProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SuperAdminProfile model
   */
  readonly fields: SuperAdminProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuperAdminProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuperAdminProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    poleSubscriptions<T extends SuperAdminProfile$poleSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdminProfile$poleSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoleSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    poleManagers<T extends SuperAdminProfile$poleManagersArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdminProfile$poleManagersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends SuperAdminProfile$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdminProfile$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SuperAdminProfile model
   */
  interface SuperAdminProfileFieldRefs {
    readonly id: FieldRef<"SuperAdminProfile", 'String'>
    readonly userId: FieldRef<"SuperAdminProfile", 'String'>
    readonly companyName: FieldRef<"SuperAdminProfile", 'String'>
    readonly businessNumber: FieldRef<"SuperAdminProfile", 'String'>
    readonly vatNumber: FieldRef<"SuperAdminProfile", 'String'>
    readonly billingAddress: FieldRef<"SuperAdminProfile", 'String'>
    readonly billingCity: FieldRef<"SuperAdminProfile", 'String'>
    readonly billingCountry: FieldRef<"SuperAdminProfile", 'String'>
    readonly billingPostal: FieldRef<"SuperAdminProfile", 'String'>
    readonly subscriptionTier: FieldRef<"SuperAdminProfile", 'String'>
    readonly subscriptionStatus: FieldRef<"SuperAdminProfile", 'String'>
    readonly createdAt: FieldRef<"SuperAdminProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"SuperAdminProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SuperAdminProfile findUnique
   */
  export type SuperAdminProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminProfile
     */
    select?: SuperAdminProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminProfile
     */
    omit?: SuperAdminProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminProfileInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminProfile to fetch.
     */
    where: SuperAdminProfileWhereUniqueInput
  }

  /**
   * SuperAdminProfile findUniqueOrThrow
   */
  export type SuperAdminProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminProfile
     */
    select?: SuperAdminProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminProfile
     */
    omit?: SuperAdminProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminProfileInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminProfile to fetch.
     */
    where: SuperAdminProfileWhereUniqueInput
  }

  /**
   * SuperAdminProfile findFirst
   */
  export type SuperAdminProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminProfile
     */
    select?: SuperAdminProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminProfile
     */
    omit?: SuperAdminProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminProfileInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminProfile to fetch.
     */
    where?: SuperAdminProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdminProfiles to fetch.
     */
    orderBy?: SuperAdminProfileOrderByWithRelationInput | SuperAdminProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdminProfiles.
     */
    cursor?: SuperAdminProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdminProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdminProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdminProfiles.
     */
    distinct?: SuperAdminProfileScalarFieldEnum | SuperAdminProfileScalarFieldEnum[]
  }

  /**
   * SuperAdminProfile findFirstOrThrow
   */
  export type SuperAdminProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminProfile
     */
    select?: SuperAdminProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminProfile
     */
    omit?: SuperAdminProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminProfileInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminProfile to fetch.
     */
    where?: SuperAdminProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdminProfiles to fetch.
     */
    orderBy?: SuperAdminProfileOrderByWithRelationInput | SuperAdminProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdminProfiles.
     */
    cursor?: SuperAdminProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdminProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdminProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdminProfiles.
     */
    distinct?: SuperAdminProfileScalarFieldEnum | SuperAdminProfileScalarFieldEnum[]
  }

  /**
   * SuperAdminProfile findMany
   */
  export type SuperAdminProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminProfile
     */
    select?: SuperAdminProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminProfile
     */
    omit?: SuperAdminProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminProfileInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminProfiles to fetch.
     */
    where?: SuperAdminProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdminProfiles to fetch.
     */
    orderBy?: SuperAdminProfileOrderByWithRelationInput | SuperAdminProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuperAdminProfiles.
     */
    cursor?: SuperAdminProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdminProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdminProfiles.
     */
    skip?: number
    distinct?: SuperAdminProfileScalarFieldEnum | SuperAdminProfileScalarFieldEnum[]
  }

  /**
   * SuperAdminProfile create
   */
  export type SuperAdminProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminProfile
     */
    select?: SuperAdminProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminProfile
     */
    omit?: SuperAdminProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a SuperAdminProfile.
     */
    data: XOR<SuperAdminProfileCreateInput, SuperAdminProfileUncheckedCreateInput>
  }

  /**
   * SuperAdminProfile createMany
   */
  export type SuperAdminProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SuperAdminProfiles.
     */
    data: SuperAdminProfileCreateManyInput | SuperAdminProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuperAdminProfile createManyAndReturn
   */
  export type SuperAdminProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminProfile
     */
    select?: SuperAdminProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminProfile
     */
    omit?: SuperAdminProfileOmit<ExtArgs> | null
    /**
     * The data used to create many SuperAdminProfiles.
     */
    data: SuperAdminProfileCreateManyInput | SuperAdminProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SuperAdminProfile update
   */
  export type SuperAdminProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminProfile
     */
    select?: SuperAdminProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminProfile
     */
    omit?: SuperAdminProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a SuperAdminProfile.
     */
    data: XOR<SuperAdminProfileUpdateInput, SuperAdminProfileUncheckedUpdateInput>
    /**
     * Choose, which SuperAdminProfile to update.
     */
    where: SuperAdminProfileWhereUniqueInput
  }

  /**
   * SuperAdminProfile updateMany
   */
  export type SuperAdminProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SuperAdminProfiles.
     */
    data: XOR<SuperAdminProfileUpdateManyMutationInput, SuperAdminProfileUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdminProfiles to update
     */
    where?: SuperAdminProfileWhereInput
    /**
     * Limit how many SuperAdminProfiles to update.
     */
    limit?: number
  }

  /**
   * SuperAdminProfile updateManyAndReturn
   */
  export type SuperAdminProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminProfile
     */
    select?: SuperAdminProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminProfile
     */
    omit?: SuperAdminProfileOmit<ExtArgs> | null
    /**
     * The data used to update SuperAdminProfiles.
     */
    data: XOR<SuperAdminProfileUpdateManyMutationInput, SuperAdminProfileUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdminProfiles to update
     */
    where?: SuperAdminProfileWhereInput
    /**
     * Limit how many SuperAdminProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SuperAdminProfile upsert
   */
  export type SuperAdminProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminProfile
     */
    select?: SuperAdminProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminProfile
     */
    omit?: SuperAdminProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the SuperAdminProfile to update in case it exists.
     */
    where: SuperAdminProfileWhereUniqueInput
    /**
     * In case the SuperAdminProfile found by the `where` argument doesn't exist, create a new SuperAdminProfile with this data.
     */
    create: XOR<SuperAdminProfileCreateInput, SuperAdminProfileUncheckedCreateInput>
    /**
     * In case the SuperAdminProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuperAdminProfileUpdateInput, SuperAdminProfileUncheckedUpdateInput>
  }

  /**
   * SuperAdminProfile delete
   */
  export type SuperAdminProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminProfile
     */
    select?: SuperAdminProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminProfile
     */
    omit?: SuperAdminProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminProfileInclude<ExtArgs> | null
    /**
     * Filter which SuperAdminProfile to delete.
     */
    where: SuperAdminProfileWhereUniqueInput
  }

  /**
   * SuperAdminProfile deleteMany
   */
  export type SuperAdminProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdminProfiles to delete
     */
    where?: SuperAdminProfileWhereInput
    /**
     * Limit how many SuperAdminProfiles to delete.
     */
    limit?: number
  }

  /**
   * SuperAdminProfile.poleSubscriptions
   */
  export type SuperAdminProfile$poleSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleSubscription
     */
    select?: PoleSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleSubscription
     */
    omit?: PoleSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleSubscriptionInclude<ExtArgs> | null
    where?: PoleSubscriptionWhereInput
    orderBy?: PoleSubscriptionOrderByWithRelationInput | PoleSubscriptionOrderByWithRelationInput[]
    cursor?: PoleSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PoleSubscriptionScalarFieldEnum | PoleSubscriptionScalarFieldEnum[]
  }

  /**
   * SuperAdminProfile.poleManagers
   */
  export type SuperAdminProfile$poleManagersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleManagerProfile
     */
    select?: PoleManagerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleManagerProfile
     */
    omit?: PoleManagerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleManagerProfileInclude<ExtArgs> | null
    where?: PoleManagerProfileWhereInput
    orderBy?: PoleManagerProfileOrderByWithRelationInput | PoleManagerProfileOrderByWithRelationInput[]
    cursor?: PoleManagerProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PoleManagerProfileScalarFieldEnum | PoleManagerProfileScalarFieldEnum[]
  }

  /**
   * SuperAdminProfile.invoices
   */
  export type SuperAdminProfile$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoice
     */
    select?: SuperAdminInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoice
     */
    omit?: SuperAdminInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceInclude<ExtArgs> | null
    where?: SuperAdminInvoiceWhereInput
    orderBy?: SuperAdminInvoiceOrderByWithRelationInput | SuperAdminInvoiceOrderByWithRelationInput[]
    cursor?: SuperAdminInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SuperAdminInvoiceScalarFieldEnum | SuperAdminInvoiceScalarFieldEnum[]
  }

  /**
   * SuperAdminProfile without action
   */
  export type SuperAdminProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminProfile
     */
    select?: SuperAdminProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminProfile
     */
    omit?: SuperAdminProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminProfileInclude<ExtArgs> | null
  }


  /**
   * Model PoleSubscription
   */

  export type AggregatePoleSubscription = {
    _count: PoleSubscriptionCountAggregateOutputType | null
    _avg: PoleSubscriptionAvgAggregateOutputType | null
    _sum: PoleSubscriptionSumAggregateOutputType | null
    _min: PoleSubscriptionMinAggregateOutputType | null
    _max: PoleSubscriptionMaxAggregateOutputType | null
  }

  export type PoleSubscriptionAvgAggregateOutputType = {
    monthlyPrice: number | null
  }

  export type PoleSubscriptionSumAggregateOutputType = {
    monthlyPrice: number | null
  }

  export type PoleSubscriptionMinAggregateOutputType = {
    id: string | null
    poleType: $Enums.PoleType | null
    status: $Enums.PoleStatus | null
    startDate: Date | null
    endDate: Date | null
    trialEndDate: Date | null
    monthlyPrice: number | null
    lastBillingDate: Date | null
    nextBillingDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    superAdminId: string | null
  }

  export type PoleSubscriptionMaxAggregateOutputType = {
    id: string | null
    poleType: $Enums.PoleType | null
    status: $Enums.PoleStatus | null
    startDate: Date | null
    endDate: Date | null
    trialEndDate: Date | null
    monthlyPrice: number | null
    lastBillingDate: Date | null
    nextBillingDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    superAdminId: string | null
  }

  export type PoleSubscriptionCountAggregateOutputType = {
    id: number
    poleType: number
    status: number
    startDate: number
    endDate: number
    trialEndDate: number
    monthlyPrice: number
    lastBillingDate: number
    nextBillingDate: number
    createdAt: number
    updatedAt: number
    superAdminId: number
    _all: number
  }


  export type PoleSubscriptionAvgAggregateInputType = {
    monthlyPrice?: true
  }

  export type PoleSubscriptionSumAggregateInputType = {
    monthlyPrice?: true
  }

  export type PoleSubscriptionMinAggregateInputType = {
    id?: true
    poleType?: true
    status?: true
    startDate?: true
    endDate?: true
    trialEndDate?: true
    monthlyPrice?: true
    lastBillingDate?: true
    nextBillingDate?: true
    createdAt?: true
    updatedAt?: true
    superAdminId?: true
  }

  export type PoleSubscriptionMaxAggregateInputType = {
    id?: true
    poleType?: true
    status?: true
    startDate?: true
    endDate?: true
    trialEndDate?: true
    monthlyPrice?: true
    lastBillingDate?: true
    nextBillingDate?: true
    createdAt?: true
    updatedAt?: true
    superAdminId?: true
  }

  export type PoleSubscriptionCountAggregateInputType = {
    id?: true
    poleType?: true
    status?: true
    startDate?: true
    endDate?: true
    trialEndDate?: true
    monthlyPrice?: true
    lastBillingDate?: true
    nextBillingDate?: true
    createdAt?: true
    updatedAt?: true
    superAdminId?: true
    _all?: true
  }

  export type PoleSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PoleSubscription to aggregate.
     */
    where?: PoleSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoleSubscriptions to fetch.
     */
    orderBy?: PoleSubscriptionOrderByWithRelationInput | PoleSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PoleSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoleSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoleSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PoleSubscriptions
    **/
    _count?: true | PoleSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PoleSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PoleSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PoleSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PoleSubscriptionMaxAggregateInputType
  }

  export type GetPoleSubscriptionAggregateType<T extends PoleSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePoleSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoleSubscription[P]>
      : GetScalarType<T[P], AggregatePoleSubscription[P]>
  }




  export type PoleSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PoleSubscriptionWhereInput
    orderBy?: PoleSubscriptionOrderByWithAggregationInput | PoleSubscriptionOrderByWithAggregationInput[]
    by: PoleSubscriptionScalarFieldEnum[] | PoleSubscriptionScalarFieldEnum
    having?: PoleSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PoleSubscriptionCountAggregateInputType | true
    _avg?: PoleSubscriptionAvgAggregateInputType
    _sum?: PoleSubscriptionSumAggregateInputType
    _min?: PoleSubscriptionMinAggregateInputType
    _max?: PoleSubscriptionMaxAggregateInputType
  }

  export type PoleSubscriptionGroupByOutputType = {
    id: string
    poleType: $Enums.PoleType
    status: $Enums.PoleStatus
    startDate: Date | null
    endDate: Date | null
    trialEndDate: Date | null
    monthlyPrice: number
    lastBillingDate: Date | null
    nextBillingDate: Date | null
    createdAt: Date
    updatedAt: Date
    superAdminId: string
    _count: PoleSubscriptionCountAggregateOutputType | null
    _avg: PoleSubscriptionAvgAggregateOutputType | null
    _sum: PoleSubscriptionSumAggregateOutputType | null
    _min: PoleSubscriptionMinAggregateOutputType | null
    _max: PoleSubscriptionMaxAggregateOutputType | null
  }

  type GetPoleSubscriptionGroupByPayload<T extends PoleSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PoleSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PoleSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PoleSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PoleSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type PoleSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poleType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    trialEndDate?: boolean
    monthlyPrice?: boolean
    lastBillingDate?: boolean
    nextBillingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    superAdminId?: boolean
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["poleSubscription"]>

  export type PoleSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poleType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    trialEndDate?: boolean
    monthlyPrice?: boolean
    lastBillingDate?: boolean
    nextBillingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    superAdminId?: boolean
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["poleSubscription"]>

  export type PoleSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poleType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    trialEndDate?: boolean
    monthlyPrice?: boolean
    lastBillingDate?: boolean
    nextBillingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    superAdminId?: boolean
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["poleSubscription"]>

  export type PoleSubscriptionSelectScalar = {
    id?: boolean
    poleType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    trialEndDate?: boolean
    monthlyPrice?: boolean
    lastBillingDate?: boolean
    nextBillingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    superAdminId?: boolean
  }

  export type PoleSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "poleType" | "status" | "startDate" | "endDate" | "trialEndDate" | "monthlyPrice" | "lastBillingDate" | "nextBillingDate" | "createdAt" | "updatedAt" | "superAdminId", ExtArgs["result"]["poleSubscription"]>
  export type PoleSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
  }
  export type PoleSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
  }
  export type PoleSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
  }

  export type $PoleSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PoleSubscription"
    objects: {
      superAdmin: Prisma.$SuperAdminProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      poleType: $Enums.PoleType
      status: $Enums.PoleStatus
      startDate: Date | null
      endDate: Date | null
      trialEndDate: Date | null
      monthlyPrice: number
      lastBillingDate: Date | null
      nextBillingDate: Date | null
      createdAt: Date
      updatedAt: Date
      superAdminId: string
    }, ExtArgs["result"]["poleSubscription"]>
    composites: {}
  }

  type PoleSubscriptionGetPayload<S extends boolean | null | undefined | PoleSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$PoleSubscriptionPayload, S>

  type PoleSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PoleSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PoleSubscriptionCountAggregateInputType | true
    }

  export interface PoleSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PoleSubscription'], meta: { name: 'PoleSubscription' } }
    /**
     * Find zero or one PoleSubscription that matches the filter.
     * @param {PoleSubscriptionFindUniqueArgs} args - Arguments to find a PoleSubscription
     * @example
     * // Get one PoleSubscription
     * const poleSubscription = await prisma.poleSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PoleSubscriptionFindUniqueArgs>(args: SelectSubset<T, PoleSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__PoleSubscriptionClient<$Result.GetResult<Prisma.$PoleSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PoleSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PoleSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a PoleSubscription
     * @example
     * // Get one PoleSubscription
     * const poleSubscription = await prisma.poleSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PoleSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PoleSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PoleSubscriptionClient<$Result.GetResult<Prisma.$PoleSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PoleSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleSubscriptionFindFirstArgs} args - Arguments to find a PoleSubscription
     * @example
     * // Get one PoleSubscription
     * const poleSubscription = await prisma.poleSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PoleSubscriptionFindFirstArgs>(args?: SelectSubset<T, PoleSubscriptionFindFirstArgs<ExtArgs>>): Prisma__PoleSubscriptionClient<$Result.GetResult<Prisma.$PoleSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PoleSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleSubscriptionFindFirstOrThrowArgs} args - Arguments to find a PoleSubscription
     * @example
     * // Get one PoleSubscription
     * const poleSubscription = await prisma.poleSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PoleSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PoleSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PoleSubscriptionClient<$Result.GetResult<Prisma.$PoleSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PoleSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PoleSubscriptions
     * const poleSubscriptions = await prisma.poleSubscription.findMany()
     * 
     * // Get first 10 PoleSubscriptions
     * const poleSubscriptions = await prisma.poleSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const poleSubscriptionWithIdOnly = await prisma.poleSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PoleSubscriptionFindManyArgs>(args?: SelectSubset<T, PoleSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoleSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PoleSubscription.
     * @param {PoleSubscriptionCreateArgs} args - Arguments to create a PoleSubscription.
     * @example
     * // Create one PoleSubscription
     * const PoleSubscription = await prisma.poleSubscription.create({
     *   data: {
     *     // ... data to create a PoleSubscription
     *   }
     * })
     * 
     */
    create<T extends PoleSubscriptionCreateArgs>(args: SelectSubset<T, PoleSubscriptionCreateArgs<ExtArgs>>): Prisma__PoleSubscriptionClient<$Result.GetResult<Prisma.$PoleSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PoleSubscriptions.
     * @param {PoleSubscriptionCreateManyArgs} args - Arguments to create many PoleSubscriptions.
     * @example
     * // Create many PoleSubscriptions
     * const poleSubscription = await prisma.poleSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PoleSubscriptionCreateManyArgs>(args?: SelectSubset<T, PoleSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PoleSubscriptions and returns the data saved in the database.
     * @param {PoleSubscriptionCreateManyAndReturnArgs} args - Arguments to create many PoleSubscriptions.
     * @example
     * // Create many PoleSubscriptions
     * const poleSubscription = await prisma.poleSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PoleSubscriptions and only return the `id`
     * const poleSubscriptionWithIdOnly = await prisma.poleSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PoleSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PoleSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoleSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PoleSubscription.
     * @param {PoleSubscriptionDeleteArgs} args - Arguments to delete one PoleSubscription.
     * @example
     * // Delete one PoleSubscription
     * const PoleSubscription = await prisma.poleSubscription.delete({
     *   where: {
     *     // ... filter to delete one PoleSubscription
     *   }
     * })
     * 
     */
    delete<T extends PoleSubscriptionDeleteArgs>(args: SelectSubset<T, PoleSubscriptionDeleteArgs<ExtArgs>>): Prisma__PoleSubscriptionClient<$Result.GetResult<Prisma.$PoleSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PoleSubscription.
     * @param {PoleSubscriptionUpdateArgs} args - Arguments to update one PoleSubscription.
     * @example
     * // Update one PoleSubscription
     * const poleSubscription = await prisma.poleSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PoleSubscriptionUpdateArgs>(args: SelectSubset<T, PoleSubscriptionUpdateArgs<ExtArgs>>): Prisma__PoleSubscriptionClient<$Result.GetResult<Prisma.$PoleSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PoleSubscriptions.
     * @param {PoleSubscriptionDeleteManyArgs} args - Arguments to filter PoleSubscriptions to delete.
     * @example
     * // Delete a few PoleSubscriptions
     * const { count } = await prisma.poleSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PoleSubscriptionDeleteManyArgs>(args?: SelectSubset<T, PoleSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PoleSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PoleSubscriptions
     * const poleSubscription = await prisma.poleSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PoleSubscriptionUpdateManyArgs>(args: SelectSubset<T, PoleSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PoleSubscriptions and returns the data updated in the database.
     * @param {PoleSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many PoleSubscriptions.
     * @example
     * // Update many PoleSubscriptions
     * const poleSubscription = await prisma.poleSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PoleSubscriptions and only return the `id`
     * const poleSubscriptionWithIdOnly = await prisma.poleSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PoleSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PoleSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoleSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PoleSubscription.
     * @param {PoleSubscriptionUpsertArgs} args - Arguments to update or create a PoleSubscription.
     * @example
     * // Update or create a PoleSubscription
     * const poleSubscription = await prisma.poleSubscription.upsert({
     *   create: {
     *     // ... data to create a PoleSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PoleSubscription we want to update
     *   }
     * })
     */
    upsert<T extends PoleSubscriptionUpsertArgs>(args: SelectSubset<T, PoleSubscriptionUpsertArgs<ExtArgs>>): Prisma__PoleSubscriptionClient<$Result.GetResult<Prisma.$PoleSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PoleSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleSubscriptionCountArgs} args - Arguments to filter PoleSubscriptions to count.
     * @example
     * // Count the number of PoleSubscriptions
     * const count = await prisma.poleSubscription.count({
     *   where: {
     *     // ... the filter for the PoleSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends PoleSubscriptionCountArgs>(
      args?: Subset<T, PoleSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PoleSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PoleSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PoleSubscriptionAggregateArgs>(args: Subset<T, PoleSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetPoleSubscriptionAggregateType<T>>

    /**
     * Group by PoleSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PoleSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PoleSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: PoleSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PoleSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPoleSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PoleSubscription model
   */
  readonly fields: PoleSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PoleSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PoleSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    superAdmin<T extends SuperAdminProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdminProfileDefaultArgs<ExtArgs>>): Prisma__SuperAdminProfileClient<$Result.GetResult<Prisma.$SuperAdminProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PoleSubscription model
   */
  interface PoleSubscriptionFieldRefs {
    readonly id: FieldRef<"PoleSubscription", 'String'>
    readonly poleType: FieldRef<"PoleSubscription", 'PoleType'>
    readonly status: FieldRef<"PoleSubscription", 'PoleStatus'>
    readonly startDate: FieldRef<"PoleSubscription", 'DateTime'>
    readonly endDate: FieldRef<"PoleSubscription", 'DateTime'>
    readonly trialEndDate: FieldRef<"PoleSubscription", 'DateTime'>
    readonly monthlyPrice: FieldRef<"PoleSubscription", 'Float'>
    readonly lastBillingDate: FieldRef<"PoleSubscription", 'DateTime'>
    readonly nextBillingDate: FieldRef<"PoleSubscription", 'DateTime'>
    readonly createdAt: FieldRef<"PoleSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"PoleSubscription", 'DateTime'>
    readonly superAdminId: FieldRef<"PoleSubscription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PoleSubscription findUnique
   */
  export type PoleSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleSubscription
     */
    select?: PoleSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleSubscription
     */
    omit?: PoleSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PoleSubscription to fetch.
     */
    where: PoleSubscriptionWhereUniqueInput
  }

  /**
   * PoleSubscription findUniqueOrThrow
   */
  export type PoleSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleSubscription
     */
    select?: PoleSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleSubscription
     */
    omit?: PoleSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PoleSubscription to fetch.
     */
    where: PoleSubscriptionWhereUniqueInput
  }

  /**
   * PoleSubscription findFirst
   */
  export type PoleSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleSubscription
     */
    select?: PoleSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleSubscription
     */
    omit?: PoleSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PoleSubscription to fetch.
     */
    where?: PoleSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoleSubscriptions to fetch.
     */
    orderBy?: PoleSubscriptionOrderByWithRelationInput | PoleSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PoleSubscriptions.
     */
    cursor?: PoleSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoleSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoleSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PoleSubscriptions.
     */
    distinct?: PoleSubscriptionScalarFieldEnum | PoleSubscriptionScalarFieldEnum[]
  }

  /**
   * PoleSubscription findFirstOrThrow
   */
  export type PoleSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleSubscription
     */
    select?: PoleSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleSubscription
     */
    omit?: PoleSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PoleSubscription to fetch.
     */
    where?: PoleSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoleSubscriptions to fetch.
     */
    orderBy?: PoleSubscriptionOrderByWithRelationInput | PoleSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PoleSubscriptions.
     */
    cursor?: PoleSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoleSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoleSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PoleSubscriptions.
     */
    distinct?: PoleSubscriptionScalarFieldEnum | PoleSubscriptionScalarFieldEnum[]
  }

  /**
   * PoleSubscription findMany
   */
  export type PoleSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleSubscription
     */
    select?: PoleSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleSubscription
     */
    omit?: PoleSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PoleSubscriptions to fetch.
     */
    where?: PoleSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoleSubscriptions to fetch.
     */
    orderBy?: PoleSubscriptionOrderByWithRelationInput | PoleSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PoleSubscriptions.
     */
    cursor?: PoleSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoleSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoleSubscriptions.
     */
    skip?: number
    distinct?: PoleSubscriptionScalarFieldEnum | PoleSubscriptionScalarFieldEnum[]
  }

  /**
   * PoleSubscription create
   */
  export type PoleSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleSubscription
     */
    select?: PoleSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleSubscription
     */
    omit?: PoleSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PoleSubscription.
     */
    data: XOR<PoleSubscriptionCreateInput, PoleSubscriptionUncheckedCreateInput>
  }

  /**
   * PoleSubscription createMany
   */
  export type PoleSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PoleSubscriptions.
     */
    data: PoleSubscriptionCreateManyInput | PoleSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PoleSubscription createManyAndReturn
   */
  export type PoleSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleSubscription
     */
    select?: PoleSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PoleSubscription
     */
    omit?: PoleSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many PoleSubscriptions.
     */
    data: PoleSubscriptionCreateManyInput | PoleSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PoleSubscription update
   */
  export type PoleSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleSubscription
     */
    select?: PoleSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleSubscription
     */
    omit?: PoleSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PoleSubscription.
     */
    data: XOR<PoleSubscriptionUpdateInput, PoleSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which PoleSubscription to update.
     */
    where: PoleSubscriptionWhereUniqueInput
  }

  /**
   * PoleSubscription updateMany
   */
  export type PoleSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PoleSubscriptions.
     */
    data: XOR<PoleSubscriptionUpdateManyMutationInput, PoleSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which PoleSubscriptions to update
     */
    where?: PoleSubscriptionWhereInput
    /**
     * Limit how many PoleSubscriptions to update.
     */
    limit?: number
  }

  /**
   * PoleSubscription updateManyAndReturn
   */
  export type PoleSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleSubscription
     */
    select?: PoleSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PoleSubscription
     */
    omit?: PoleSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update PoleSubscriptions.
     */
    data: XOR<PoleSubscriptionUpdateManyMutationInput, PoleSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which PoleSubscriptions to update
     */
    where?: PoleSubscriptionWhereInput
    /**
     * Limit how many PoleSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PoleSubscription upsert
   */
  export type PoleSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleSubscription
     */
    select?: PoleSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleSubscription
     */
    omit?: PoleSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PoleSubscription to update in case it exists.
     */
    where: PoleSubscriptionWhereUniqueInput
    /**
     * In case the PoleSubscription found by the `where` argument doesn't exist, create a new PoleSubscription with this data.
     */
    create: XOR<PoleSubscriptionCreateInput, PoleSubscriptionUncheckedCreateInput>
    /**
     * In case the PoleSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PoleSubscriptionUpdateInput, PoleSubscriptionUncheckedUpdateInput>
  }

  /**
   * PoleSubscription delete
   */
  export type PoleSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleSubscription
     */
    select?: PoleSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleSubscription
     */
    omit?: PoleSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which PoleSubscription to delete.
     */
    where: PoleSubscriptionWhereUniqueInput
  }

  /**
   * PoleSubscription deleteMany
   */
  export type PoleSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PoleSubscriptions to delete
     */
    where?: PoleSubscriptionWhereInput
    /**
     * Limit how many PoleSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * PoleSubscription without action
   */
  export type PoleSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleSubscription
     */
    select?: PoleSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleSubscription
     */
    omit?: PoleSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model PoleManagerProfile
   */

  export type AggregatePoleManagerProfile = {
    _count: PoleManagerProfileCountAggregateOutputType | null
    _min: PoleManagerProfileMinAggregateOutputType | null
    _max: PoleManagerProfileMaxAggregateOutputType | null
  }

  export type PoleManagerProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    canViewAnalytics: boolean | null
    canManageAgents: boolean | null
    canManageClients: boolean | null
    canManageBilling: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    superAdminId: string | null
  }

  export type PoleManagerProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    canViewAnalytics: boolean | null
    canManageAgents: boolean | null
    canManageClients: boolean | null
    canManageBilling: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    superAdminId: string | null
  }

  export type PoleManagerProfileCountAggregateOutputType = {
    id: number
    userId: number
    poleTypes: number
    canViewAnalytics: number
    canManageAgents: number
    canManageClients: number
    canManageBilling: number
    createdAt: number
    updatedAt: number
    superAdminId: number
    _all: number
  }


  export type PoleManagerProfileMinAggregateInputType = {
    id?: true
    userId?: true
    canViewAnalytics?: true
    canManageAgents?: true
    canManageClients?: true
    canManageBilling?: true
    createdAt?: true
    updatedAt?: true
    superAdminId?: true
  }

  export type PoleManagerProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    canViewAnalytics?: true
    canManageAgents?: true
    canManageClients?: true
    canManageBilling?: true
    createdAt?: true
    updatedAt?: true
    superAdminId?: true
  }

  export type PoleManagerProfileCountAggregateInputType = {
    id?: true
    userId?: true
    poleTypes?: true
    canViewAnalytics?: true
    canManageAgents?: true
    canManageClients?: true
    canManageBilling?: true
    createdAt?: true
    updatedAt?: true
    superAdminId?: true
    _all?: true
  }

  export type PoleManagerProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PoleManagerProfile to aggregate.
     */
    where?: PoleManagerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoleManagerProfiles to fetch.
     */
    orderBy?: PoleManagerProfileOrderByWithRelationInput | PoleManagerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PoleManagerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoleManagerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoleManagerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PoleManagerProfiles
    **/
    _count?: true | PoleManagerProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PoleManagerProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PoleManagerProfileMaxAggregateInputType
  }

  export type GetPoleManagerProfileAggregateType<T extends PoleManagerProfileAggregateArgs> = {
        [P in keyof T & keyof AggregatePoleManagerProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoleManagerProfile[P]>
      : GetScalarType<T[P], AggregatePoleManagerProfile[P]>
  }




  export type PoleManagerProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PoleManagerProfileWhereInput
    orderBy?: PoleManagerProfileOrderByWithAggregationInput | PoleManagerProfileOrderByWithAggregationInput[]
    by: PoleManagerProfileScalarFieldEnum[] | PoleManagerProfileScalarFieldEnum
    having?: PoleManagerProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PoleManagerProfileCountAggregateInputType | true
    _min?: PoleManagerProfileMinAggregateInputType
    _max?: PoleManagerProfileMaxAggregateInputType
  }

  export type PoleManagerProfileGroupByOutputType = {
    id: string
    userId: string
    poleTypes: $Enums.PoleType[]
    canViewAnalytics: boolean
    canManageAgents: boolean
    canManageClients: boolean
    canManageBilling: boolean
    createdAt: Date
    updatedAt: Date
    superAdminId: string
    _count: PoleManagerProfileCountAggregateOutputType | null
    _min: PoleManagerProfileMinAggregateOutputType | null
    _max: PoleManagerProfileMaxAggregateOutputType | null
  }

  type GetPoleManagerProfileGroupByPayload<T extends PoleManagerProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PoleManagerProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PoleManagerProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PoleManagerProfileGroupByOutputType[P]>
            : GetScalarType<T[P], PoleManagerProfileGroupByOutputType[P]>
        }
      >
    >


  export type PoleManagerProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    poleTypes?: boolean
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    superAdminId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
    properties?: boolean | PoleManagerProfile$propertiesArgs<ExtArgs>
    reservations?: boolean | PoleManagerProfile$reservationsArgs<ExtArgs>
    cleaningSessions?: boolean | PoleManagerProfile$cleaningSessionsArgs<ExtArgs>
    tickets?: boolean | PoleManagerProfile$ticketsArgs<ExtArgs>
    maintenanceSessions?: boolean | PoleManagerProfile$maintenanceSessionsArgs<ExtArgs>
    laundryOrders?: boolean | PoleManagerProfile$laundryOrdersArgs<ExtArgs>
    managedAgents?: boolean | PoleManagerProfile$managedAgentsArgs<ExtArgs>
    _count?: boolean | PoleManagerProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["poleManagerProfile"]>

  export type PoleManagerProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    poleTypes?: boolean
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    superAdminId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["poleManagerProfile"]>

  export type PoleManagerProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    poleTypes?: boolean
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    superAdminId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["poleManagerProfile"]>

  export type PoleManagerProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    poleTypes?: boolean
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    superAdminId?: boolean
  }

  export type PoleManagerProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "poleTypes" | "canViewAnalytics" | "canManageAgents" | "canManageClients" | "canManageBilling" | "createdAt" | "updatedAt" | "superAdminId", ExtArgs["result"]["poleManagerProfile"]>
  export type PoleManagerProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
    properties?: boolean | PoleManagerProfile$propertiesArgs<ExtArgs>
    reservations?: boolean | PoleManagerProfile$reservationsArgs<ExtArgs>
    cleaningSessions?: boolean | PoleManagerProfile$cleaningSessionsArgs<ExtArgs>
    tickets?: boolean | PoleManagerProfile$ticketsArgs<ExtArgs>
    maintenanceSessions?: boolean | PoleManagerProfile$maintenanceSessionsArgs<ExtArgs>
    laundryOrders?: boolean | PoleManagerProfile$laundryOrdersArgs<ExtArgs>
    managedAgents?: boolean | PoleManagerProfile$managedAgentsArgs<ExtArgs>
    _count?: boolean | PoleManagerProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PoleManagerProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
  }
  export type PoleManagerProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
  }

  export type $PoleManagerProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PoleManagerProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      superAdmin: Prisma.$SuperAdminProfilePayload<ExtArgs>
      properties: Prisma.$PropertyPayload<ExtArgs>[]
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      cleaningSessions: Prisma.$CleaningSessionPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      maintenanceSessions: Prisma.$MaintenanceSessionPayload<ExtArgs>[]
      laundryOrders: Prisma.$LaundryOrderPayload<ExtArgs>[]
      managedAgents: Prisma.$AgentProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      poleTypes: $Enums.PoleType[]
      canViewAnalytics: boolean
      canManageAgents: boolean
      canManageClients: boolean
      canManageBilling: boolean
      createdAt: Date
      updatedAt: Date
      superAdminId: string
    }, ExtArgs["result"]["poleManagerProfile"]>
    composites: {}
  }

  type PoleManagerProfileGetPayload<S extends boolean | null | undefined | PoleManagerProfileDefaultArgs> = $Result.GetResult<Prisma.$PoleManagerProfilePayload, S>

  type PoleManagerProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PoleManagerProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PoleManagerProfileCountAggregateInputType | true
    }

  export interface PoleManagerProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PoleManagerProfile'], meta: { name: 'PoleManagerProfile' } }
    /**
     * Find zero or one PoleManagerProfile that matches the filter.
     * @param {PoleManagerProfileFindUniqueArgs} args - Arguments to find a PoleManagerProfile
     * @example
     * // Get one PoleManagerProfile
     * const poleManagerProfile = await prisma.poleManagerProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PoleManagerProfileFindUniqueArgs>(args: SelectSubset<T, PoleManagerProfileFindUniqueArgs<ExtArgs>>): Prisma__PoleManagerProfileClient<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PoleManagerProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PoleManagerProfileFindUniqueOrThrowArgs} args - Arguments to find a PoleManagerProfile
     * @example
     * // Get one PoleManagerProfile
     * const poleManagerProfile = await prisma.poleManagerProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PoleManagerProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, PoleManagerProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PoleManagerProfileClient<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PoleManagerProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleManagerProfileFindFirstArgs} args - Arguments to find a PoleManagerProfile
     * @example
     * // Get one PoleManagerProfile
     * const poleManagerProfile = await prisma.poleManagerProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PoleManagerProfileFindFirstArgs>(args?: SelectSubset<T, PoleManagerProfileFindFirstArgs<ExtArgs>>): Prisma__PoleManagerProfileClient<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PoleManagerProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleManagerProfileFindFirstOrThrowArgs} args - Arguments to find a PoleManagerProfile
     * @example
     * // Get one PoleManagerProfile
     * const poleManagerProfile = await prisma.poleManagerProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PoleManagerProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, PoleManagerProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__PoleManagerProfileClient<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PoleManagerProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleManagerProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PoleManagerProfiles
     * const poleManagerProfiles = await prisma.poleManagerProfile.findMany()
     * 
     * // Get first 10 PoleManagerProfiles
     * const poleManagerProfiles = await prisma.poleManagerProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const poleManagerProfileWithIdOnly = await prisma.poleManagerProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PoleManagerProfileFindManyArgs>(args?: SelectSubset<T, PoleManagerProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PoleManagerProfile.
     * @param {PoleManagerProfileCreateArgs} args - Arguments to create a PoleManagerProfile.
     * @example
     * // Create one PoleManagerProfile
     * const PoleManagerProfile = await prisma.poleManagerProfile.create({
     *   data: {
     *     // ... data to create a PoleManagerProfile
     *   }
     * })
     * 
     */
    create<T extends PoleManagerProfileCreateArgs>(args: SelectSubset<T, PoleManagerProfileCreateArgs<ExtArgs>>): Prisma__PoleManagerProfileClient<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PoleManagerProfiles.
     * @param {PoleManagerProfileCreateManyArgs} args - Arguments to create many PoleManagerProfiles.
     * @example
     * // Create many PoleManagerProfiles
     * const poleManagerProfile = await prisma.poleManagerProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PoleManagerProfileCreateManyArgs>(args?: SelectSubset<T, PoleManagerProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PoleManagerProfiles and returns the data saved in the database.
     * @param {PoleManagerProfileCreateManyAndReturnArgs} args - Arguments to create many PoleManagerProfiles.
     * @example
     * // Create many PoleManagerProfiles
     * const poleManagerProfile = await prisma.poleManagerProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PoleManagerProfiles and only return the `id`
     * const poleManagerProfileWithIdOnly = await prisma.poleManagerProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PoleManagerProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, PoleManagerProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PoleManagerProfile.
     * @param {PoleManagerProfileDeleteArgs} args - Arguments to delete one PoleManagerProfile.
     * @example
     * // Delete one PoleManagerProfile
     * const PoleManagerProfile = await prisma.poleManagerProfile.delete({
     *   where: {
     *     // ... filter to delete one PoleManagerProfile
     *   }
     * })
     * 
     */
    delete<T extends PoleManagerProfileDeleteArgs>(args: SelectSubset<T, PoleManagerProfileDeleteArgs<ExtArgs>>): Prisma__PoleManagerProfileClient<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PoleManagerProfile.
     * @param {PoleManagerProfileUpdateArgs} args - Arguments to update one PoleManagerProfile.
     * @example
     * // Update one PoleManagerProfile
     * const poleManagerProfile = await prisma.poleManagerProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PoleManagerProfileUpdateArgs>(args: SelectSubset<T, PoleManagerProfileUpdateArgs<ExtArgs>>): Prisma__PoleManagerProfileClient<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PoleManagerProfiles.
     * @param {PoleManagerProfileDeleteManyArgs} args - Arguments to filter PoleManagerProfiles to delete.
     * @example
     * // Delete a few PoleManagerProfiles
     * const { count } = await prisma.poleManagerProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PoleManagerProfileDeleteManyArgs>(args?: SelectSubset<T, PoleManagerProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PoleManagerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleManagerProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PoleManagerProfiles
     * const poleManagerProfile = await prisma.poleManagerProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PoleManagerProfileUpdateManyArgs>(args: SelectSubset<T, PoleManagerProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PoleManagerProfiles and returns the data updated in the database.
     * @param {PoleManagerProfileUpdateManyAndReturnArgs} args - Arguments to update many PoleManagerProfiles.
     * @example
     * // Update many PoleManagerProfiles
     * const poleManagerProfile = await prisma.poleManagerProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PoleManagerProfiles and only return the `id`
     * const poleManagerProfileWithIdOnly = await prisma.poleManagerProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PoleManagerProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, PoleManagerProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PoleManagerProfile.
     * @param {PoleManagerProfileUpsertArgs} args - Arguments to update or create a PoleManagerProfile.
     * @example
     * // Update or create a PoleManagerProfile
     * const poleManagerProfile = await prisma.poleManagerProfile.upsert({
     *   create: {
     *     // ... data to create a PoleManagerProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PoleManagerProfile we want to update
     *   }
     * })
     */
    upsert<T extends PoleManagerProfileUpsertArgs>(args: SelectSubset<T, PoleManagerProfileUpsertArgs<ExtArgs>>): Prisma__PoleManagerProfileClient<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PoleManagerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleManagerProfileCountArgs} args - Arguments to filter PoleManagerProfiles to count.
     * @example
     * // Count the number of PoleManagerProfiles
     * const count = await prisma.poleManagerProfile.count({
     *   where: {
     *     // ... the filter for the PoleManagerProfiles we want to count
     *   }
     * })
    **/
    count<T extends PoleManagerProfileCountArgs>(
      args?: Subset<T, PoleManagerProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PoleManagerProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PoleManagerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleManagerProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PoleManagerProfileAggregateArgs>(args: Subset<T, PoleManagerProfileAggregateArgs>): Prisma.PrismaPromise<GetPoleManagerProfileAggregateType<T>>

    /**
     * Group by PoleManagerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoleManagerProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PoleManagerProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PoleManagerProfileGroupByArgs['orderBy'] }
        : { orderBy?: PoleManagerProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PoleManagerProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPoleManagerProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PoleManagerProfile model
   */
  readonly fields: PoleManagerProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PoleManagerProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PoleManagerProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    superAdmin<T extends SuperAdminProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdminProfileDefaultArgs<ExtArgs>>): Prisma__SuperAdminProfileClient<$Result.GetResult<Prisma.$SuperAdminProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    properties<T extends PoleManagerProfile$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, PoleManagerProfile$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reservations<T extends PoleManagerProfile$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, PoleManagerProfile$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cleaningSessions<T extends PoleManagerProfile$cleaningSessionsArgs<ExtArgs> = {}>(args?: Subset<T, PoleManagerProfile$cleaningSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends PoleManagerProfile$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, PoleManagerProfile$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maintenanceSessions<T extends PoleManagerProfile$maintenanceSessionsArgs<ExtArgs> = {}>(args?: Subset<T, PoleManagerProfile$maintenanceSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    laundryOrders<T extends PoleManagerProfile$laundryOrdersArgs<ExtArgs> = {}>(args?: Subset<T, PoleManagerProfile$laundryOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    managedAgents<T extends PoleManagerProfile$managedAgentsArgs<ExtArgs> = {}>(args?: Subset<T, PoleManagerProfile$managedAgentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PoleManagerProfile model
   */
  interface PoleManagerProfileFieldRefs {
    readonly id: FieldRef<"PoleManagerProfile", 'String'>
    readonly userId: FieldRef<"PoleManagerProfile", 'String'>
    readonly poleTypes: FieldRef<"PoleManagerProfile", 'PoleType[]'>
    readonly canViewAnalytics: FieldRef<"PoleManagerProfile", 'Boolean'>
    readonly canManageAgents: FieldRef<"PoleManagerProfile", 'Boolean'>
    readonly canManageClients: FieldRef<"PoleManagerProfile", 'Boolean'>
    readonly canManageBilling: FieldRef<"PoleManagerProfile", 'Boolean'>
    readonly createdAt: FieldRef<"PoleManagerProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"PoleManagerProfile", 'DateTime'>
    readonly superAdminId: FieldRef<"PoleManagerProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PoleManagerProfile findUnique
   */
  export type PoleManagerProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleManagerProfile
     */
    select?: PoleManagerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleManagerProfile
     */
    omit?: PoleManagerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleManagerProfileInclude<ExtArgs> | null
    /**
     * Filter, which PoleManagerProfile to fetch.
     */
    where: PoleManagerProfileWhereUniqueInput
  }

  /**
   * PoleManagerProfile findUniqueOrThrow
   */
  export type PoleManagerProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleManagerProfile
     */
    select?: PoleManagerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleManagerProfile
     */
    omit?: PoleManagerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleManagerProfileInclude<ExtArgs> | null
    /**
     * Filter, which PoleManagerProfile to fetch.
     */
    where: PoleManagerProfileWhereUniqueInput
  }

  /**
   * PoleManagerProfile findFirst
   */
  export type PoleManagerProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleManagerProfile
     */
    select?: PoleManagerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleManagerProfile
     */
    omit?: PoleManagerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleManagerProfileInclude<ExtArgs> | null
    /**
     * Filter, which PoleManagerProfile to fetch.
     */
    where?: PoleManagerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoleManagerProfiles to fetch.
     */
    orderBy?: PoleManagerProfileOrderByWithRelationInput | PoleManagerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PoleManagerProfiles.
     */
    cursor?: PoleManagerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoleManagerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoleManagerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PoleManagerProfiles.
     */
    distinct?: PoleManagerProfileScalarFieldEnum | PoleManagerProfileScalarFieldEnum[]
  }

  /**
   * PoleManagerProfile findFirstOrThrow
   */
  export type PoleManagerProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleManagerProfile
     */
    select?: PoleManagerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleManagerProfile
     */
    omit?: PoleManagerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleManagerProfileInclude<ExtArgs> | null
    /**
     * Filter, which PoleManagerProfile to fetch.
     */
    where?: PoleManagerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoleManagerProfiles to fetch.
     */
    orderBy?: PoleManagerProfileOrderByWithRelationInput | PoleManagerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PoleManagerProfiles.
     */
    cursor?: PoleManagerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoleManagerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoleManagerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PoleManagerProfiles.
     */
    distinct?: PoleManagerProfileScalarFieldEnum | PoleManagerProfileScalarFieldEnum[]
  }

  /**
   * PoleManagerProfile findMany
   */
  export type PoleManagerProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleManagerProfile
     */
    select?: PoleManagerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleManagerProfile
     */
    omit?: PoleManagerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleManagerProfileInclude<ExtArgs> | null
    /**
     * Filter, which PoleManagerProfiles to fetch.
     */
    where?: PoleManagerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoleManagerProfiles to fetch.
     */
    orderBy?: PoleManagerProfileOrderByWithRelationInput | PoleManagerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PoleManagerProfiles.
     */
    cursor?: PoleManagerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoleManagerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoleManagerProfiles.
     */
    skip?: number
    distinct?: PoleManagerProfileScalarFieldEnum | PoleManagerProfileScalarFieldEnum[]
  }

  /**
   * PoleManagerProfile create
   */
  export type PoleManagerProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleManagerProfile
     */
    select?: PoleManagerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleManagerProfile
     */
    omit?: PoleManagerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleManagerProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a PoleManagerProfile.
     */
    data: XOR<PoleManagerProfileCreateInput, PoleManagerProfileUncheckedCreateInput>
  }

  /**
   * PoleManagerProfile createMany
   */
  export type PoleManagerProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PoleManagerProfiles.
     */
    data: PoleManagerProfileCreateManyInput | PoleManagerProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PoleManagerProfile createManyAndReturn
   */
  export type PoleManagerProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleManagerProfile
     */
    select?: PoleManagerProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PoleManagerProfile
     */
    omit?: PoleManagerProfileOmit<ExtArgs> | null
    /**
     * The data used to create many PoleManagerProfiles.
     */
    data: PoleManagerProfileCreateManyInput | PoleManagerProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleManagerProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PoleManagerProfile update
   */
  export type PoleManagerProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleManagerProfile
     */
    select?: PoleManagerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleManagerProfile
     */
    omit?: PoleManagerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleManagerProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a PoleManagerProfile.
     */
    data: XOR<PoleManagerProfileUpdateInput, PoleManagerProfileUncheckedUpdateInput>
    /**
     * Choose, which PoleManagerProfile to update.
     */
    where: PoleManagerProfileWhereUniqueInput
  }

  /**
   * PoleManagerProfile updateMany
   */
  export type PoleManagerProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PoleManagerProfiles.
     */
    data: XOR<PoleManagerProfileUpdateManyMutationInput, PoleManagerProfileUncheckedUpdateManyInput>
    /**
     * Filter which PoleManagerProfiles to update
     */
    where?: PoleManagerProfileWhereInput
    /**
     * Limit how many PoleManagerProfiles to update.
     */
    limit?: number
  }

  /**
   * PoleManagerProfile updateManyAndReturn
   */
  export type PoleManagerProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleManagerProfile
     */
    select?: PoleManagerProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PoleManagerProfile
     */
    omit?: PoleManagerProfileOmit<ExtArgs> | null
    /**
     * The data used to update PoleManagerProfiles.
     */
    data: XOR<PoleManagerProfileUpdateManyMutationInput, PoleManagerProfileUncheckedUpdateManyInput>
    /**
     * Filter which PoleManagerProfiles to update
     */
    where?: PoleManagerProfileWhereInput
    /**
     * Limit how many PoleManagerProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleManagerProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PoleManagerProfile upsert
   */
  export type PoleManagerProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleManagerProfile
     */
    select?: PoleManagerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleManagerProfile
     */
    omit?: PoleManagerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleManagerProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the PoleManagerProfile to update in case it exists.
     */
    where: PoleManagerProfileWhereUniqueInput
    /**
     * In case the PoleManagerProfile found by the `where` argument doesn't exist, create a new PoleManagerProfile with this data.
     */
    create: XOR<PoleManagerProfileCreateInput, PoleManagerProfileUncheckedCreateInput>
    /**
     * In case the PoleManagerProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PoleManagerProfileUpdateInput, PoleManagerProfileUncheckedUpdateInput>
  }

  /**
   * PoleManagerProfile delete
   */
  export type PoleManagerProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleManagerProfile
     */
    select?: PoleManagerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleManagerProfile
     */
    omit?: PoleManagerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleManagerProfileInclude<ExtArgs> | null
    /**
     * Filter which PoleManagerProfile to delete.
     */
    where: PoleManagerProfileWhereUniqueInput
  }

  /**
   * PoleManagerProfile deleteMany
   */
  export type PoleManagerProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PoleManagerProfiles to delete
     */
    where?: PoleManagerProfileWhereInput
    /**
     * Limit how many PoleManagerProfiles to delete.
     */
    limit?: number
  }

  /**
   * PoleManagerProfile.properties
   */
  export type PoleManagerProfile$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * PoleManagerProfile.reservations
   */
  export type PoleManagerProfile$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * PoleManagerProfile.cleaningSessions
   */
  export type PoleManagerProfile$cleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    where?: CleaningSessionWhereInput
    orderBy?: CleaningSessionOrderByWithRelationInput | CleaningSessionOrderByWithRelationInput[]
    cursor?: CleaningSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningSessionScalarFieldEnum | CleaningSessionScalarFieldEnum[]
  }

  /**
   * PoleManagerProfile.tickets
   */
  export type PoleManagerProfile$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * PoleManagerProfile.maintenanceSessions
   */
  export type PoleManagerProfile$maintenanceSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    where?: MaintenanceSessionWhereInput
    orderBy?: MaintenanceSessionOrderByWithRelationInput | MaintenanceSessionOrderByWithRelationInput[]
    cursor?: MaintenanceSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceSessionScalarFieldEnum | MaintenanceSessionScalarFieldEnum[]
  }

  /**
   * PoleManagerProfile.laundryOrders
   */
  export type PoleManagerProfile$laundryOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrder
     */
    select?: LaundryOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrder
     */
    omit?: LaundryOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderInclude<ExtArgs> | null
    where?: LaundryOrderWhereInput
    orderBy?: LaundryOrderOrderByWithRelationInput | LaundryOrderOrderByWithRelationInput[]
    cursor?: LaundryOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaundryOrderScalarFieldEnum | LaundryOrderScalarFieldEnum[]
  }

  /**
   * PoleManagerProfile.managedAgents
   */
  export type PoleManagerProfile$managedAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    where?: AgentProfileWhereInput
    orderBy?: AgentProfileOrderByWithRelationInput | AgentProfileOrderByWithRelationInput[]
    cursor?: AgentProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentProfileScalarFieldEnum | AgentProfileScalarFieldEnum[]
  }

  /**
   * PoleManagerProfile without action
   */
  export type PoleManagerProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleManagerProfile
     */
    select?: PoleManagerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleManagerProfile
     */
    omit?: PoleManagerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleManagerProfileInclude<ExtArgs> | null
  }


  /**
   * Model PropertyOwnerProfile
   */

  export type AggregatePropertyOwnerProfile = {
    _count: PropertyOwnerProfileCountAggregateOutputType | null
    _min: PropertyOwnerProfileMinAggregateOutputType | null
    _max: PropertyOwnerProfileMaxAggregateOutputType | null
  }

  export type PropertyOwnerProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    company: string | null
    taxNumber: string | null
    address: string | null
    city: string | null
    country: string | null
    postal: string | null
    preferredContactMethod: string | null
    receiveNotifications: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyOwnerProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    company: string | null
    taxNumber: string | null
    address: string | null
    city: string | null
    country: string | null
    postal: string | null
    preferredContactMethod: string | null
    receiveNotifications: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyOwnerProfileCountAggregateOutputType = {
    id: number
    userId: number
    company: number
    taxNumber: number
    address: number
    city: number
    country: number
    postal: number
    preferredContactMethod: number
    receiveNotifications: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyOwnerProfileMinAggregateInputType = {
    id?: true
    userId?: true
    company?: true
    taxNumber?: true
    address?: true
    city?: true
    country?: true
    postal?: true
    preferredContactMethod?: true
    receiveNotifications?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyOwnerProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    company?: true
    taxNumber?: true
    address?: true
    city?: true
    country?: true
    postal?: true
    preferredContactMethod?: true
    receiveNotifications?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyOwnerProfileCountAggregateInputType = {
    id?: true
    userId?: true
    company?: true
    taxNumber?: true
    address?: true
    city?: true
    country?: true
    postal?: true
    preferredContactMethod?: true
    receiveNotifications?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyOwnerProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyOwnerProfile to aggregate.
     */
    where?: PropertyOwnerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyOwnerProfiles to fetch.
     */
    orderBy?: PropertyOwnerProfileOrderByWithRelationInput | PropertyOwnerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyOwnerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyOwnerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyOwnerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyOwnerProfiles
    **/
    _count?: true | PropertyOwnerProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyOwnerProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyOwnerProfileMaxAggregateInputType
  }

  export type GetPropertyOwnerProfileAggregateType<T extends PropertyOwnerProfileAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyOwnerProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyOwnerProfile[P]>
      : GetScalarType<T[P], AggregatePropertyOwnerProfile[P]>
  }




  export type PropertyOwnerProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyOwnerProfileWhereInput
    orderBy?: PropertyOwnerProfileOrderByWithAggregationInput | PropertyOwnerProfileOrderByWithAggregationInput[]
    by: PropertyOwnerProfileScalarFieldEnum[] | PropertyOwnerProfileScalarFieldEnum
    having?: PropertyOwnerProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyOwnerProfileCountAggregateInputType | true
    _min?: PropertyOwnerProfileMinAggregateInputType
    _max?: PropertyOwnerProfileMaxAggregateInputType
  }

  export type PropertyOwnerProfileGroupByOutputType = {
    id: string
    userId: string
    company: string | null
    taxNumber: string | null
    address: string | null
    city: string | null
    country: string | null
    postal: string | null
    preferredContactMethod: string | null
    receiveNotifications: boolean
    createdAt: Date
    updatedAt: Date
    _count: PropertyOwnerProfileCountAggregateOutputType | null
    _min: PropertyOwnerProfileMinAggregateOutputType | null
    _max: PropertyOwnerProfileMaxAggregateOutputType | null
  }

  type GetPropertyOwnerProfileGroupByPayload<T extends PropertyOwnerProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyOwnerProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyOwnerProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyOwnerProfileGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyOwnerProfileGroupByOutputType[P]>
        }
      >
    >


  export type PropertyOwnerProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company?: boolean
    taxNumber?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postal?: boolean
    preferredContactMethod?: boolean
    receiveNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    properties?: boolean | PropertyOwnerProfile$propertiesArgs<ExtArgs>
    contracts?: boolean | PropertyOwnerProfile$contractsArgs<ExtArgs>
    _count?: boolean | PropertyOwnerProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyOwnerProfile"]>

  export type PropertyOwnerProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company?: boolean
    taxNumber?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postal?: boolean
    preferredContactMethod?: boolean
    receiveNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyOwnerProfile"]>

  export type PropertyOwnerProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company?: boolean
    taxNumber?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postal?: boolean
    preferredContactMethod?: boolean
    receiveNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyOwnerProfile"]>

  export type PropertyOwnerProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    company?: boolean
    taxNumber?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postal?: boolean
    preferredContactMethod?: boolean
    receiveNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyOwnerProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "company" | "taxNumber" | "address" | "city" | "country" | "postal" | "preferredContactMethod" | "receiveNotifications" | "createdAt" | "updatedAt", ExtArgs["result"]["propertyOwnerProfile"]>
  export type PropertyOwnerProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    properties?: boolean | PropertyOwnerProfile$propertiesArgs<ExtArgs>
    contracts?: boolean | PropertyOwnerProfile$contractsArgs<ExtArgs>
    _count?: boolean | PropertyOwnerProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyOwnerProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PropertyOwnerProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PropertyOwnerProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyOwnerProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      properties: Prisma.$PropertyPayload<ExtArgs>[]
      contracts: Prisma.$PropertyContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      company: string | null
      taxNumber: string | null
      address: string | null
      city: string | null
      country: string | null
      postal: string | null
      preferredContactMethod: string | null
      receiveNotifications: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyOwnerProfile"]>
    composites: {}
  }

  type PropertyOwnerProfileGetPayload<S extends boolean | null | undefined | PropertyOwnerProfileDefaultArgs> = $Result.GetResult<Prisma.$PropertyOwnerProfilePayload, S>

  type PropertyOwnerProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyOwnerProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyOwnerProfileCountAggregateInputType | true
    }

  export interface PropertyOwnerProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyOwnerProfile'], meta: { name: 'PropertyOwnerProfile' } }
    /**
     * Find zero or one PropertyOwnerProfile that matches the filter.
     * @param {PropertyOwnerProfileFindUniqueArgs} args - Arguments to find a PropertyOwnerProfile
     * @example
     * // Get one PropertyOwnerProfile
     * const propertyOwnerProfile = await prisma.propertyOwnerProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyOwnerProfileFindUniqueArgs>(args: SelectSubset<T, PropertyOwnerProfileFindUniqueArgs<ExtArgs>>): Prisma__PropertyOwnerProfileClient<$Result.GetResult<Prisma.$PropertyOwnerProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyOwnerProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyOwnerProfileFindUniqueOrThrowArgs} args - Arguments to find a PropertyOwnerProfile
     * @example
     * // Get one PropertyOwnerProfile
     * const propertyOwnerProfile = await prisma.propertyOwnerProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyOwnerProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyOwnerProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyOwnerProfileClient<$Result.GetResult<Prisma.$PropertyOwnerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyOwnerProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnerProfileFindFirstArgs} args - Arguments to find a PropertyOwnerProfile
     * @example
     * // Get one PropertyOwnerProfile
     * const propertyOwnerProfile = await prisma.propertyOwnerProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyOwnerProfileFindFirstArgs>(args?: SelectSubset<T, PropertyOwnerProfileFindFirstArgs<ExtArgs>>): Prisma__PropertyOwnerProfileClient<$Result.GetResult<Prisma.$PropertyOwnerProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyOwnerProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnerProfileFindFirstOrThrowArgs} args - Arguments to find a PropertyOwnerProfile
     * @example
     * // Get one PropertyOwnerProfile
     * const propertyOwnerProfile = await prisma.propertyOwnerProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyOwnerProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyOwnerProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyOwnerProfileClient<$Result.GetResult<Prisma.$PropertyOwnerProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyOwnerProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnerProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyOwnerProfiles
     * const propertyOwnerProfiles = await prisma.propertyOwnerProfile.findMany()
     * 
     * // Get first 10 PropertyOwnerProfiles
     * const propertyOwnerProfiles = await prisma.propertyOwnerProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyOwnerProfileWithIdOnly = await prisma.propertyOwnerProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyOwnerProfileFindManyArgs>(args?: SelectSubset<T, PropertyOwnerProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyOwnerProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyOwnerProfile.
     * @param {PropertyOwnerProfileCreateArgs} args - Arguments to create a PropertyOwnerProfile.
     * @example
     * // Create one PropertyOwnerProfile
     * const PropertyOwnerProfile = await prisma.propertyOwnerProfile.create({
     *   data: {
     *     // ... data to create a PropertyOwnerProfile
     *   }
     * })
     * 
     */
    create<T extends PropertyOwnerProfileCreateArgs>(args: SelectSubset<T, PropertyOwnerProfileCreateArgs<ExtArgs>>): Prisma__PropertyOwnerProfileClient<$Result.GetResult<Prisma.$PropertyOwnerProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyOwnerProfiles.
     * @param {PropertyOwnerProfileCreateManyArgs} args - Arguments to create many PropertyOwnerProfiles.
     * @example
     * // Create many PropertyOwnerProfiles
     * const propertyOwnerProfile = await prisma.propertyOwnerProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyOwnerProfileCreateManyArgs>(args?: SelectSubset<T, PropertyOwnerProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyOwnerProfiles and returns the data saved in the database.
     * @param {PropertyOwnerProfileCreateManyAndReturnArgs} args - Arguments to create many PropertyOwnerProfiles.
     * @example
     * // Create many PropertyOwnerProfiles
     * const propertyOwnerProfile = await prisma.propertyOwnerProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyOwnerProfiles and only return the `id`
     * const propertyOwnerProfileWithIdOnly = await prisma.propertyOwnerProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyOwnerProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyOwnerProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyOwnerProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyOwnerProfile.
     * @param {PropertyOwnerProfileDeleteArgs} args - Arguments to delete one PropertyOwnerProfile.
     * @example
     * // Delete one PropertyOwnerProfile
     * const PropertyOwnerProfile = await prisma.propertyOwnerProfile.delete({
     *   where: {
     *     // ... filter to delete one PropertyOwnerProfile
     *   }
     * })
     * 
     */
    delete<T extends PropertyOwnerProfileDeleteArgs>(args: SelectSubset<T, PropertyOwnerProfileDeleteArgs<ExtArgs>>): Prisma__PropertyOwnerProfileClient<$Result.GetResult<Prisma.$PropertyOwnerProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyOwnerProfile.
     * @param {PropertyOwnerProfileUpdateArgs} args - Arguments to update one PropertyOwnerProfile.
     * @example
     * // Update one PropertyOwnerProfile
     * const propertyOwnerProfile = await prisma.propertyOwnerProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyOwnerProfileUpdateArgs>(args: SelectSubset<T, PropertyOwnerProfileUpdateArgs<ExtArgs>>): Prisma__PropertyOwnerProfileClient<$Result.GetResult<Prisma.$PropertyOwnerProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyOwnerProfiles.
     * @param {PropertyOwnerProfileDeleteManyArgs} args - Arguments to filter PropertyOwnerProfiles to delete.
     * @example
     * // Delete a few PropertyOwnerProfiles
     * const { count } = await prisma.propertyOwnerProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyOwnerProfileDeleteManyArgs>(args?: SelectSubset<T, PropertyOwnerProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyOwnerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnerProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyOwnerProfiles
     * const propertyOwnerProfile = await prisma.propertyOwnerProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyOwnerProfileUpdateManyArgs>(args: SelectSubset<T, PropertyOwnerProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyOwnerProfiles and returns the data updated in the database.
     * @param {PropertyOwnerProfileUpdateManyAndReturnArgs} args - Arguments to update many PropertyOwnerProfiles.
     * @example
     * // Update many PropertyOwnerProfiles
     * const propertyOwnerProfile = await prisma.propertyOwnerProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyOwnerProfiles and only return the `id`
     * const propertyOwnerProfileWithIdOnly = await prisma.propertyOwnerProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyOwnerProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyOwnerProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyOwnerProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyOwnerProfile.
     * @param {PropertyOwnerProfileUpsertArgs} args - Arguments to update or create a PropertyOwnerProfile.
     * @example
     * // Update or create a PropertyOwnerProfile
     * const propertyOwnerProfile = await prisma.propertyOwnerProfile.upsert({
     *   create: {
     *     // ... data to create a PropertyOwnerProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyOwnerProfile we want to update
     *   }
     * })
     */
    upsert<T extends PropertyOwnerProfileUpsertArgs>(args: SelectSubset<T, PropertyOwnerProfileUpsertArgs<ExtArgs>>): Prisma__PropertyOwnerProfileClient<$Result.GetResult<Prisma.$PropertyOwnerProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyOwnerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnerProfileCountArgs} args - Arguments to filter PropertyOwnerProfiles to count.
     * @example
     * // Count the number of PropertyOwnerProfiles
     * const count = await prisma.propertyOwnerProfile.count({
     *   where: {
     *     // ... the filter for the PropertyOwnerProfiles we want to count
     *   }
     * })
    **/
    count<T extends PropertyOwnerProfileCountArgs>(
      args?: Subset<T, PropertyOwnerProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyOwnerProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyOwnerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnerProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyOwnerProfileAggregateArgs>(args: Subset<T, PropertyOwnerProfileAggregateArgs>): Prisma.PrismaPromise<GetPropertyOwnerProfileAggregateType<T>>

    /**
     * Group by PropertyOwnerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnerProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyOwnerProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyOwnerProfileGroupByArgs['orderBy'] }
        : { orderBy?: PropertyOwnerProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyOwnerProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyOwnerProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyOwnerProfile model
   */
  readonly fields: PropertyOwnerProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyOwnerProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyOwnerProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    properties<T extends PropertyOwnerProfile$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, PropertyOwnerProfile$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contracts<T extends PropertyOwnerProfile$contractsArgs<ExtArgs> = {}>(args?: Subset<T, PropertyOwnerProfile$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyOwnerProfile model
   */
  interface PropertyOwnerProfileFieldRefs {
    readonly id: FieldRef<"PropertyOwnerProfile", 'String'>
    readonly userId: FieldRef<"PropertyOwnerProfile", 'String'>
    readonly company: FieldRef<"PropertyOwnerProfile", 'String'>
    readonly taxNumber: FieldRef<"PropertyOwnerProfile", 'String'>
    readonly address: FieldRef<"PropertyOwnerProfile", 'String'>
    readonly city: FieldRef<"PropertyOwnerProfile", 'String'>
    readonly country: FieldRef<"PropertyOwnerProfile", 'String'>
    readonly postal: FieldRef<"PropertyOwnerProfile", 'String'>
    readonly preferredContactMethod: FieldRef<"PropertyOwnerProfile", 'String'>
    readonly receiveNotifications: FieldRef<"PropertyOwnerProfile", 'Boolean'>
    readonly createdAt: FieldRef<"PropertyOwnerProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyOwnerProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyOwnerProfile findUnique
   */
  export type PropertyOwnerProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwnerProfile
     */
    select?: PropertyOwnerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwnerProfile
     */
    omit?: PropertyOwnerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerProfileInclude<ExtArgs> | null
    /**
     * Filter, which PropertyOwnerProfile to fetch.
     */
    where: PropertyOwnerProfileWhereUniqueInput
  }

  /**
   * PropertyOwnerProfile findUniqueOrThrow
   */
  export type PropertyOwnerProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwnerProfile
     */
    select?: PropertyOwnerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwnerProfile
     */
    omit?: PropertyOwnerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerProfileInclude<ExtArgs> | null
    /**
     * Filter, which PropertyOwnerProfile to fetch.
     */
    where: PropertyOwnerProfileWhereUniqueInput
  }

  /**
   * PropertyOwnerProfile findFirst
   */
  export type PropertyOwnerProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwnerProfile
     */
    select?: PropertyOwnerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwnerProfile
     */
    omit?: PropertyOwnerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerProfileInclude<ExtArgs> | null
    /**
     * Filter, which PropertyOwnerProfile to fetch.
     */
    where?: PropertyOwnerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyOwnerProfiles to fetch.
     */
    orderBy?: PropertyOwnerProfileOrderByWithRelationInput | PropertyOwnerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyOwnerProfiles.
     */
    cursor?: PropertyOwnerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyOwnerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyOwnerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyOwnerProfiles.
     */
    distinct?: PropertyOwnerProfileScalarFieldEnum | PropertyOwnerProfileScalarFieldEnum[]
  }

  /**
   * PropertyOwnerProfile findFirstOrThrow
   */
  export type PropertyOwnerProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwnerProfile
     */
    select?: PropertyOwnerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwnerProfile
     */
    omit?: PropertyOwnerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerProfileInclude<ExtArgs> | null
    /**
     * Filter, which PropertyOwnerProfile to fetch.
     */
    where?: PropertyOwnerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyOwnerProfiles to fetch.
     */
    orderBy?: PropertyOwnerProfileOrderByWithRelationInput | PropertyOwnerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyOwnerProfiles.
     */
    cursor?: PropertyOwnerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyOwnerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyOwnerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyOwnerProfiles.
     */
    distinct?: PropertyOwnerProfileScalarFieldEnum | PropertyOwnerProfileScalarFieldEnum[]
  }

  /**
   * PropertyOwnerProfile findMany
   */
  export type PropertyOwnerProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwnerProfile
     */
    select?: PropertyOwnerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwnerProfile
     */
    omit?: PropertyOwnerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerProfileInclude<ExtArgs> | null
    /**
     * Filter, which PropertyOwnerProfiles to fetch.
     */
    where?: PropertyOwnerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyOwnerProfiles to fetch.
     */
    orderBy?: PropertyOwnerProfileOrderByWithRelationInput | PropertyOwnerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyOwnerProfiles.
     */
    cursor?: PropertyOwnerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyOwnerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyOwnerProfiles.
     */
    skip?: number
    distinct?: PropertyOwnerProfileScalarFieldEnum | PropertyOwnerProfileScalarFieldEnum[]
  }

  /**
   * PropertyOwnerProfile create
   */
  export type PropertyOwnerProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwnerProfile
     */
    select?: PropertyOwnerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwnerProfile
     */
    omit?: PropertyOwnerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyOwnerProfile.
     */
    data: XOR<PropertyOwnerProfileCreateInput, PropertyOwnerProfileUncheckedCreateInput>
  }

  /**
   * PropertyOwnerProfile createMany
   */
  export type PropertyOwnerProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyOwnerProfiles.
     */
    data: PropertyOwnerProfileCreateManyInput | PropertyOwnerProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyOwnerProfile createManyAndReturn
   */
  export type PropertyOwnerProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwnerProfile
     */
    select?: PropertyOwnerProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwnerProfile
     */
    omit?: PropertyOwnerProfileOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyOwnerProfiles.
     */
    data: PropertyOwnerProfileCreateManyInput | PropertyOwnerProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyOwnerProfile update
   */
  export type PropertyOwnerProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwnerProfile
     */
    select?: PropertyOwnerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwnerProfile
     */
    omit?: PropertyOwnerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyOwnerProfile.
     */
    data: XOR<PropertyOwnerProfileUpdateInput, PropertyOwnerProfileUncheckedUpdateInput>
    /**
     * Choose, which PropertyOwnerProfile to update.
     */
    where: PropertyOwnerProfileWhereUniqueInput
  }

  /**
   * PropertyOwnerProfile updateMany
   */
  export type PropertyOwnerProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyOwnerProfiles.
     */
    data: XOR<PropertyOwnerProfileUpdateManyMutationInput, PropertyOwnerProfileUncheckedUpdateManyInput>
    /**
     * Filter which PropertyOwnerProfiles to update
     */
    where?: PropertyOwnerProfileWhereInput
    /**
     * Limit how many PropertyOwnerProfiles to update.
     */
    limit?: number
  }

  /**
   * PropertyOwnerProfile updateManyAndReturn
   */
  export type PropertyOwnerProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwnerProfile
     */
    select?: PropertyOwnerProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwnerProfile
     */
    omit?: PropertyOwnerProfileOmit<ExtArgs> | null
    /**
     * The data used to update PropertyOwnerProfiles.
     */
    data: XOR<PropertyOwnerProfileUpdateManyMutationInput, PropertyOwnerProfileUncheckedUpdateManyInput>
    /**
     * Filter which PropertyOwnerProfiles to update
     */
    where?: PropertyOwnerProfileWhereInput
    /**
     * Limit how many PropertyOwnerProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyOwnerProfile upsert
   */
  export type PropertyOwnerProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwnerProfile
     */
    select?: PropertyOwnerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwnerProfile
     */
    omit?: PropertyOwnerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyOwnerProfile to update in case it exists.
     */
    where: PropertyOwnerProfileWhereUniqueInput
    /**
     * In case the PropertyOwnerProfile found by the `where` argument doesn't exist, create a new PropertyOwnerProfile with this data.
     */
    create: XOR<PropertyOwnerProfileCreateInput, PropertyOwnerProfileUncheckedCreateInput>
    /**
     * In case the PropertyOwnerProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyOwnerProfileUpdateInput, PropertyOwnerProfileUncheckedUpdateInput>
  }

  /**
   * PropertyOwnerProfile delete
   */
  export type PropertyOwnerProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwnerProfile
     */
    select?: PropertyOwnerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwnerProfile
     */
    omit?: PropertyOwnerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerProfileInclude<ExtArgs> | null
    /**
     * Filter which PropertyOwnerProfile to delete.
     */
    where: PropertyOwnerProfileWhereUniqueInput
  }

  /**
   * PropertyOwnerProfile deleteMany
   */
  export type PropertyOwnerProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyOwnerProfiles to delete
     */
    where?: PropertyOwnerProfileWhereInput
    /**
     * Limit how many PropertyOwnerProfiles to delete.
     */
    limit?: number
  }

  /**
   * PropertyOwnerProfile.properties
   */
  export type PropertyOwnerProfile$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * PropertyOwnerProfile.contracts
   */
  export type PropertyOwnerProfile$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContract
     */
    select?: PropertyContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContract
     */
    omit?: PropertyContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContractInclude<ExtArgs> | null
    where?: PropertyContractWhereInput
    orderBy?: PropertyContractOrderByWithRelationInput | PropertyContractOrderByWithRelationInput[]
    cursor?: PropertyContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyContractScalarFieldEnum | PropertyContractScalarFieldEnum[]
  }

  /**
   * PropertyOwnerProfile without action
   */
  export type PropertyOwnerProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwnerProfile
     */
    select?: PropertyOwnerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwnerProfile
     */
    omit?: PropertyOwnerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerProfileInclude<ExtArgs> | null
  }


  /**
   * Model LaundryClientProfile
   */

  export type AggregateLaundryClientProfile = {
    _count: LaundryClientProfileCountAggregateOutputType | null
    _avg: LaundryClientProfileAvgAggregateOutputType | null
    _sum: LaundryClientProfileSumAggregateOutputType | null
    _min: LaundryClientProfileMinAggregateOutputType | null
    _max: LaundryClientProfileMaxAggregateOutputType | null
  }

  export type LaundryClientProfileAvgAggregateOutputType = {
    creditLimit: number | null
    paymentTerms: number | null
  }

  export type LaundryClientProfileSumAggregateOutputType = {
    creditLimit: number | null
    paymentTerms: number | null
  }

  export type LaundryClientProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    contactPerson: string | null
    defaultPickupAddress: string | null
    defaultDeliveryAddress: string | null
    preferredPickupTime: string | null
    specialInstructions: string | null
    creditLimit: number | null
    paymentTerms: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryClientProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    contactPerson: string | null
    defaultPickupAddress: string | null
    defaultDeliveryAddress: string | null
    preferredPickupTime: string | null
    specialInstructions: string | null
    creditLimit: number | null
    paymentTerms: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryClientProfileCountAggregateOutputType = {
    id: number
    userId: number
    companyName: number
    contactPerson: number
    defaultPickupAddress: number
    defaultDeliveryAddress: number
    preferredPickupTime: number
    specialInstructions: number
    creditLimit: number
    paymentTerms: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaundryClientProfileAvgAggregateInputType = {
    creditLimit?: true
    paymentTerms?: true
  }

  export type LaundryClientProfileSumAggregateInputType = {
    creditLimit?: true
    paymentTerms?: true
  }

  export type LaundryClientProfileMinAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    contactPerson?: true
    defaultPickupAddress?: true
    defaultDeliveryAddress?: true
    preferredPickupTime?: true
    specialInstructions?: true
    creditLimit?: true
    paymentTerms?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryClientProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    contactPerson?: true
    defaultPickupAddress?: true
    defaultDeliveryAddress?: true
    preferredPickupTime?: true
    specialInstructions?: true
    creditLimit?: true
    paymentTerms?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryClientProfileCountAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    contactPerson?: true
    defaultPickupAddress?: true
    defaultDeliveryAddress?: true
    preferredPickupTime?: true
    specialInstructions?: true
    creditLimit?: true
    paymentTerms?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaundryClientProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaundryClientProfile to aggregate.
     */
    where?: LaundryClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryClientProfiles to fetch.
     */
    orderBy?: LaundryClientProfileOrderByWithRelationInput | LaundryClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaundryClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaundryClientProfiles
    **/
    _count?: true | LaundryClientProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaundryClientProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaundryClientProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaundryClientProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaundryClientProfileMaxAggregateInputType
  }

  export type GetLaundryClientProfileAggregateType<T extends LaundryClientProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateLaundryClientProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaundryClientProfile[P]>
      : GetScalarType<T[P], AggregateLaundryClientProfile[P]>
  }




  export type LaundryClientProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaundryClientProfileWhereInput
    orderBy?: LaundryClientProfileOrderByWithAggregationInput | LaundryClientProfileOrderByWithAggregationInput[]
    by: LaundryClientProfileScalarFieldEnum[] | LaundryClientProfileScalarFieldEnum
    having?: LaundryClientProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaundryClientProfileCountAggregateInputType | true
    _avg?: LaundryClientProfileAvgAggregateInputType
    _sum?: LaundryClientProfileSumAggregateInputType
    _min?: LaundryClientProfileMinAggregateInputType
    _max?: LaundryClientProfileMaxAggregateInputType
  }

  export type LaundryClientProfileGroupByOutputType = {
    id: string
    userId: string
    companyName: string | null
    contactPerson: string | null
    defaultPickupAddress: string | null
    defaultDeliveryAddress: string
    preferredPickupTime: string | null
    specialInstructions: string | null
    creditLimit: number | null
    paymentTerms: number | null
    createdAt: Date
    updatedAt: Date
    _count: LaundryClientProfileCountAggregateOutputType | null
    _avg: LaundryClientProfileAvgAggregateOutputType | null
    _sum: LaundryClientProfileSumAggregateOutputType | null
    _min: LaundryClientProfileMinAggregateOutputType | null
    _max: LaundryClientProfileMaxAggregateOutputType | null
  }

  type GetLaundryClientProfileGroupByPayload<T extends LaundryClientProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LaundryClientProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaundryClientProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaundryClientProfileGroupByOutputType[P]>
            : GetScalarType<T[P], LaundryClientProfileGroupByOutputType[P]>
        }
      >
    >


  export type LaundryClientProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    contactPerson?: boolean
    defaultPickupAddress?: boolean
    defaultDeliveryAddress?: boolean
    preferredPickupTime?: boolean
    specialInstructions?: boolean
    creditLimit?: boolean
    paymentTerms?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    laundryOrders?: boolean | LaundryClientProfile$laundryOrdersArgs<ExtArgs>
    laundryInvoices?: boolean | LaundryClientProfile$laundryInvoicesArgs<ExtArgs>
    _count?: boolean | LaundryClientProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laundryClientProfile"]>

  export type LaundryClientProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    contactPerson?: boolean
    defaultPickupAddress?: boolean
    defaultDeliveryAddress?: boolean
    preferredPickupTime?: boolean
    specialInstructions?: boolean
    creditLimit?: boolean
    paymentTerms?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laundryClientProfile"]>

  export type LaundryClientProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    contactPerson?: boolean
    defaultPickupAddress?: boolean
    defaultDeliveryAddress?: boolean
    preferredPickupTime?: boolean
    specialInstructions?: boolean
    creditLimit?: boolean
    paymentTerms?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laundryClientProfile"]>

  export type LaundryClientProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    companyName?: boolean
    contactPerson?: boolean
    defaultPickupAddress?: boolean
    defaultDeliveryAddress?: boolean
    preferredPickupTime?: boolean
    specialInstructions?: boolean
    creditLimit?: boolean
    paymentTerms?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LaundryClientProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyName" | "contactPerson" | "defaultPickupAddress" | "defaultDeliveryAddress" | "preferredPickupTime" | "specialInstructions" | "creditLimit" | "paymentTerms" | "createdAt" | "updatedAt", ExtArgs["result"]["laundryClientProfile"]>
  export type LaundryClientProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    laundryOrders?: boolean | LaundryClientProfile$laundryOrdersArgs<ExtArgs>
    laundryInvoices?: boolean | LaundryClientProfile$laundryInvoicesArgs<ExtArgs>
    _count?: boolean | LaundryClientProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LaundryClientProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LaundryClientProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LaundryClientProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LaundryClientProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      laundryOrders: Prisma.$LaundryOrderPayload<ExtArgs>[]
      laundryInvoices: Prisma.$LaundryInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyName: string | null
      contactPerson: string | null
      defaultPickupAddress: string | null
      defaultDeliveryAddress: string
      preferredPickupTime: string | null
      specialInstructions: string | null
      creditLimit: number | null
      paymentTerms: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["laundryClientProfile"]>
    composites: {}
  }

  type LaundryClientProfileGetPayload<S extends boolean | null | undefined | LaundryClientProfileDefaultArgs> = $Result.GetResult<Prisma.$LaundryClientProfilePayload, S>

  type LaundryClientProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LaundryClientProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LaundryClientProfileCountAggregateInputType | true
    }

  export interface LaundryClientProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LaundryClientProfile'], meta: { name: 'LaundryClientProfile' } }
    /**
     * Find zero or one LaundryClientProfile that matches the filter.
     * @param {LaundryClientProfileFindUniqueArgs} args - Arguments to find a LaundryClientProfile
     * @example
     * // Get one LaundryClientProfile
     * const laundryClientProfile = await prisma.laundryClientProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LaundryClientProfileFindUniqueArgs>(args: SelectSubset<T, LaundryClientProfileFindUniqueArgs<ExtArgs>>): Prisma__LaundryClientProfileClient<$Result.GetResult<Prisma.$LaundryClientProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LaundryClientProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LaundryClientProfileFindUniqueOrThrowArgs} args - Arguments to find a LaundryClientProfile
     * @example
     * // Get one LaundryClientProfile
     * const laundryClientProfile = await prisma.laundryClientProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LaundryClientProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, LaundryClientProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LaundryClientProfileClient<$Result.GetResult<Prisma.$LaundryClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LaundryClientProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryClientProfileFindFirstArgs} args - Arguments to find a LaundryClientProfile
     * @example
     * // Get one LaundryClientProfile
     * const laundryClientProfile = await prisma.laundryClientProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LaundryClientProfileFindFirstArgs>(args?: SelectSubset<T, LaundryClientProfileFindFirstArgs<ExtArgs>>): Prisma__LaundryClientProfileClient<$Result.GetResult<Prisma.$LaundryClientProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LaundryClientProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryClientProfileFindFirstOrThrowArgs} args - Arguments to find a LaundryClientProfile
     * @example
     * // Get one LaundryClientProfile
     * const laundryClientProfile = await prisma.laundryClientProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LaundryClientProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, LaundryClientProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__LaundryClientProfileClient<$Result.GetResult<Prisma.$LaundryClientProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LaundryClientProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryClientProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaundryClientProfiles
     * const laundryClientProfiles = await prisma.laundryClientProfile.findMany()
     * 
     * // Get first 10 LaundryClientProfiles
     * const laundryClientProfiles = await prisma.laundryClientProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laundryClientProfileWithIdOnly = await prisma.laundryClientProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LaundryClientProfileFindManyArgs>(args?: SelectSubset<T, LaundryClientProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryClientProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LaundryClientProfile.
     * @param {LaundryClientProfileCreateArgs} args - Arguments to create a LaundryClientProfile.
     * @example
     * // Create one LaundryClientProfile
     * const LaundryClientProfile = await prisma.laundryClientProfile.create({
     *   data: {
     *     // ... data to create a LaundryClientProfile
     *   }
     * })
     * 
     */
    create<T extends LaundryClientProfileCreateArgs>(args: SelectSubset<T, LaundryClientProfileCreateArgs<ExtArgs>>): Prisma__LaundryClientProfileClient<$Result.GetResult<Prisma.$LaundryClientProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LaundryClientProfiles.
     * @param {LaundryClientProfileCreateManyArgs} args - Arguments to create many LaundryClientProfiles.
     * @example
     * // Create many LaundryClientProfiles
     * const laundryClientProfile = await prisma.laundryClientProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LaundryClientProfileCreateManyArgs>(args?: SelectSubset<T, LaundryClientProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LaundryClientProfiles and returns the data saved in the database.
     * @param {LaundryClientProfileCreateManyAndReturnArgs} args - Arguments to create many LaundryClientProfiles.
     * @example
     * // Create many LaundryClientProfiles
     * const laundryClientProfile = await prisma.laundryClientProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LaundryClientProfiles and only return the `id`
     * const laundryClientProfileWithIdOnly = await prisma.laundryClientProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LaundryClientProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, LaundryClientProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryClientProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LaundryClientProfile.
     * @param {LaundryClientProfileDeleteArgs} args - Arguments to delete one LaundryClientProfile.
     * @example
     * // Delete one LaundryClientProfile
     * const LaundryClientProfile = await prisma.laundryClientProfile.delete({
     *   where: {
     *     // ... filter to delete one LaundryClientProfile
     *   }
     * })
     * 
     */
    delete<T extends LaundryClientProfileDeleteArgs>(args: SelectSubset<T, LaundryClientProfileDeleteArgs<ExtArgs>>): Prisma__LaundryClientProfileClient<$Result.GetResult<Prisma.$LaundryClientProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LaundryClientProfile.
     * @param {LaundryClientProfileUpdateArgs} args - Arguments to update one LaundryClientProfile.
     * @example
     * // Update one LaundryClientProfile
     * const laundryClientProfile = await prisma.laundryClientProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LaundryClientProfileUpdateArgs>(args: SelectSubset<T, LaundryClientProfileUpdateArgs<ExtArgs>>): Prisma__LaundryClientProfileClient<$Result.GetResult<Prisma.$LaundryClientProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LaundryClientProfiles.
     * @param {LaundryClientProfileDeleteManyArgs} args - Arguments to filter LaundryClientProfiles to delete.
     * @example
     * // Delete a few LaundryClientProfiles
     * const { count } = await prisma.laundryClientProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LaundryClientProfileDeleteManyArgs>(args?: SelectSubset<T, LaundryClientProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryClientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryClientProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaundryClientProfiles
     * const laundryClientProfile = await prisma.laundryClientProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LaundryClientProfileUpdateManyArgs>(args: SelectSubset<T, LaundryClientProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryClientProfiles and returns the data updated in the database.
     * @param {LaundryClientProfileUpdateManyAndReturnArgs} args - Arguments to update many LaundryClientProfiles.
     * @example
     * // Update many LaundryClientProfiles
     * const laundryClientProfile = await prisma.laundryClientProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LaundryClientProfiles and only return the `id`
     * const laundryClientProfileWithIdOnly = await prisma.laundryClientProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LaundryClientProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, LaundryClientProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryClientProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LaundryClientProfile.
     * @param {LaundryClientProfileUpsertArgs} args - Arguments to update or create a LaundryClientProfile.
     * @example
     * // Update or create a LaundryClientProfile
     * const laundryClientProfile = await prisma.laundryClientProfile.upsert({
     *   create: {
     *     // ... data to create a LaundryClientProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaundryClientProfile we want to update
     *   }
     * })
     */
    upsert<T extends LaundryClientProfileUpsertArgs>(args: SelectSubset<T, LaundryClientProfileUpsertArgs<ExtArgs>>): Prisma__LaundryClientProfileClient<$Result.GetResult<Prisma.$LaundryClientProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LaundryClientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryClientProfileCountArgs} args - Arguments to filter LaundryClientProfiles to count.
     * @example
     * // Count the number of LaundryClientProfiles
     * const count = await prisma.laundryClientProfile.count({
     *   where: {
     *     // ... the filter for the LaundryClientProfiles we want to count
     *   }
     * })
    **/
    count<T extends LaundryClientProfileCountArgs>(
      args?: Subset<T, LaundryClientProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaundryClientProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaundryClientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryClientProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaundryClientProfileAggregateArgs>(args: Subset<T, LaundryClientProfileAggregateArgs>): Prisma.PrismaPromise<GetLaundryClientProfileAggregateType<T>>

    /**
     * Group by LaundryClientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryClientProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaundryClientProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaundryClientProfileGroupByArgs['orderBy'] }
        : { orderBy?: LaundryClientProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaundryClientProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaundryClientProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LaundryClientProfile model
   */
  readonly fields: LaundryClientProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LaundryClientProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LaundryClientProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    laundryOrders<T extends LaundryClientProfile$laundryOrdersArgs<ExtArgs> = {}>(args?: Subset<T, LaundryClientProfile$laundryOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    laundryInvoices<T extends LaundryClientProfile$laundryInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, LaundryClientProfile$laundryInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LaundryClientProfile model
   */
  interface LaundryClientProfileFieldRefs {
    readonly id: FieldRef<"LaundryClientProfile", 'String'>
    readonly userId: FieldRef<"LaundryClientProfile", 'String'>
    readonly companyName: FieldRef<"LaundryClientProfile", 'String'>
    readonly contactPerson: FieldRef<"LaundryClientProfile", 'String'>
    readonly defaultPickupAddress: FieldRef<"LaundryClientProfile", 'String'>
    readonly defaultDeliveryAddress: FieldRef<"LaundryClientProfile", 'String'>
    readonly preferredPickupTime: FieldRef<"LaundryClientProfile", 'String'>
    readonly specialInstructions: FieldRef<"LaundryClientProfile", 'String'>
    readonly creditLimit: FieldRef<"LaundryClientProfile", 'Float'>
    readonly paymentTerms: FieldRef<"LaundryClientProfile", 'Int'>
    readonly createdAt: FieldRef<"LaundryClientProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"LaundryClientProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LaundryClientProfile findUnique
   */
  export type LaundryClientProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryClientProfile
     */
    select?: LaundryClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryClientProfile
     */
    omit?: LaundryClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which LaundryClientProfile to fetch.
     */
    where: LaundryClientProfileWhereUniqueInput
  }

  /**
   * LaundryClientProfile findUniqueOrThrow
   */
  export type LaundryClientProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryClientProfile
     */
    select?: LaundryClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryClientProfile
     */
    omit?: LaundryClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which LaundryClientProfile to fetch.
     */
    where: LaundryClientProfileWhereUniqueInput
  }

  /**
   * LaundryClientProfile findFirst
   */
  export type LaundryClientProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryClientProfile
     */
    select?: LaundryClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryClientProfile
     */
    omit?: LaundryClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which LaundryClientProfile to fetch.
     */
    where?: LaundryClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryClientProfiles to fetch.
     */
    orderBy?: LaundryClientProfileOrderByWithRelationInput | LaundryClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryClientProfiles.
     */
    cursor?: LaundryClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryClientProfiles.
     */
    distinct?: LaundryClientProfileScalarFieldEnum | LaundryClientProfileScalarFieldEnum[]
  }

  /**
   * LaundryClientProfile findFirstOrThrow
   */
  export type LaundryClientProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryClientProfile
     */
    select?: LaundryClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryClientProfile
     */
    omit?: LaundryClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which LaundryClientProfile to fetch.
     */
    where?: LaundryClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryClientProfiles to fetch.
     */
    orderBy?: LaundryClientProfileOrderByWithRelationInput | LaundryClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryClientProfiles.
     */
    cursor?: LaundryClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryClientProfiles.
     */
    distinct?: LaundryClientProfileScalarFieldEnum | LaundryClientProfileScalarFieldEnum[]
  }

  /**
   * LaundryClientProfile findMany
   */
  export type LaundryClientProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryClientProfile
     */
    select?: LaundryClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryClientProfile
     */
    omit?: LaundryClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which LaundryClientProfiles to fetch.
     */
    where?: LaundryClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryClientProfiles to fetch.
     */
    orderBy?: LaundryClientProfileOrderByWithRelationInput | LaundryClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaundryClientProfiles.
     */
    cursor?: LaundryClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryClientProfiles.
     */
    skip?: number
    distinct?: LaundryClientProfileScalarFieldEnum | LaundryClientProfileScalarFieldEnum[]
  }

  /**
   * LaundryClientProfile create
   */
  export type LaundryClientProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryClientProfile
     */
    select?: LaundryClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryClientProfile
     */
    omit?: LaundryClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryClientProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a LaundryClientProfile.
     */
    data: XOR<LaundryClientProfileCreateInput, LaundryClientProfileUncheckedCreateInput>
  }

  /**
   * LaundryClientProfile createMany
   */
  export type LaundryClientProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LaundryClientProfiles.
     */
    data: LaundryClientProfileCreateManyInput | LaundryClientProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LaundryClientProfile createManyAndReturn
   */
  export type LaundryClientProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryClientProfile
     */
    select?: LaundryClientProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryClientProfile
     */
    omit?: LaundryClientProfileOmit<ExtArgs> | null
    /**
     * The data used to create many LaundryClientProfiles.
     */
    data: LaundryClientProfileCreateManyInput | LaundryClientProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryClientProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LaundryClientProfile update
   */
  export type LaundryClientProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryClientProfile
     */
    select?: LaundryClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryClientProfile
     */
    omit?: LaundryClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryClientProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a LaundryClientProfile.
     */
    data: XOR<LaundryClientProfileUpdateInput, LaundryClientProfileUncheckedUpdateInput>
    /**
     * Choose, which LaundryClientProfile to update.
     */
    where: LaundryClientProfileWhereUniqueInput
  }

  /**
   * LaundryClientProfile updateMany
   */
  export type LaundryClientProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LaundryClientProfiles.
     */
    data: XOR<LaundryClientProfileUpdateManyMutationInput, LaundryClientProfileUncheckedUpdateManyInput>
    /**
     * Filter which LaundryClientProfiles to update
     */
    where?: LaundryClientProfileWhereInput
    /**
     * Limit how many LaundryClientProfiles to update.
     */
    limit?: number
  }

  /**
   * LaundryClientProfile updateManyAndReturn
   */
  export type LaundryClientProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryClientProfile
     */
    select?: LaundryClientProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryClientProfile
     */
    omit?: LaundryClientProfileOmit<ExtArgs> | null
    /**
     * The data used to update LaundryClientProfiles.
     */
    data: XOR<LaundryClientProfileUpdateManyMutationInput, LaundryClientProfileUncheckedUpdateManyInput>
    /**
     * Filter which LaundryClientProfiles to update
     */
    where?: LaundryClientProfileWhereInput
    /**
     * Limit how many LaundryClientProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryClientProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LaundryClientProfile upsert
   */
  export type LaundryClientProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryClientProfile
     */
    select?: LaundryClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryClientProfile
     */
    omit?: LaundryClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryClientProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the LaundryClientProfile to update in case it exists.
     */
    where: LaundryClientProfileWhereUniqueInput
    /**
     * In case the LaundryClientProfile found by the `where` argument doesn't exist, create a new LaundryClientProfile with this data.
     */
    create: XOR<LaundryClientProfileCreateInput, LaundryClientProfileUncheckedCreateInput>
    /**
     * In case the LaundryClientProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaundryClientProfileUpdateInput, LaundryClientProfileUncheckedUpdateInput>
  }

  /**
   * LaundryClientProfile delete
   */
  export type LaundryClientProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryClientProfile
     */
    select?: LaundryClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryClientProfile
     */
    omit?: LaundryClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryClientProfileInclude<ExtArgs> | null
    /**
     * Filter which LaundryClientProfile to delete.
     */
    where: LaundryClientProfileWhereUniqueInput
  }

  /**
   * LaundryClientProfile deleteMany
   */
  export type LaundryClientProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaundryClientProfiles to delete
     */
    where?: LaundryClientProfileWhereInput
    /**
     * Limit how many LaundryClientProfiles to delete.
     */
    limit?: number
  }

  /**
   * LaundryClientProfile.laundryOrders
   */
  export type LaundryClientProfile$laundryOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrder
     */
    select?: LaundryOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrder
     */
    omit?: LaundryOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderInclude<ExtArgs> | null
    where?: LaundryOrderWhereInput
    orderBy?: LaundryOrderOrderByWithRelationInput | LaundryOrderOrderByWithRelationInput[]
    cursor?: LaundryOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaundryOrderScalarFieldEnum | LaundryOrderScalarFieldEnum[]
  }

  /**
   * LaundryClientProfile.laundryInvoices
   */
  export type LaundryClientProfile$laundryInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryInvoice
     */
    select?: LaundryInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryInvoice
     */
    omit?: LaundryInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryInvoiceInclude<ExtArgs> | null
    where?: LaundryInvoiceWhereInput
    orderBy?: LaundryInvoiceOrderByWithRelationInput | LaundryInvoiceOrderByWithRelationInput[]
    cursor?: LaundryInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaundryInvoiceScalarFieldEnum | LaundryInvoiceScalarFieldEnum[]
  }

  /**
   * LaundryClientProfile without action
   */
  export type LaundryClientProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryClientProfile
     */
    select?: LaundryClientProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryClientProfile
     */
    omit?: LaundryClientProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryClientProfileInclude<ExtArgs> | null
  }


  /**
   * Model AgentProfile
   */

  export type AggregateAgentProfile = {
    _count: AgentProfileCountAggregateOutputType | null
    _avg: AgentProfileAvgAggregateOutputType | null
    _sum: AgentProfileSumAggregateOutputType | null
    _min: AgentProfileMinAggregateOutputType | null
    _max: AgentProfileMaxAggregateOutputType | null
  }

  export type AgentProfileAvgAggregateOutputType = {
    rating: number | null
    completedTasks: number | null
    averageRating: number | null
    responseTime: number | null
    hourlyRate: number | null
  }

  export type AgentProfileSumAggregateOutputType = {
    rating: number | null
    completedTasks: number | null
    averageRating: number | null
    responseTime: number | null
    hourlyRate: number | null
  }

  export type AgentProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    agentType: $Enums.AgentType | null
    availability: $Enums.AgentAvailability | null
    employeeId: string | null
    rating: number | null
    completedTasks: number | null
    averageRating: number | null
    responseTime: number | null
    hourlyRate: number | null
    isActive: boolean | null
    hireDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    managerId: string | null
  }

  export type AgentProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    agentType: $Enums.AgentType | null
    availability: $Enums.AgentAvailability | null
    employeeId: string | null
    rating: number | null
    completedTasks: number | null
    averageRating: number | null
    responseTime: number | null
    hourlyRate: number | null
    isActive: boolean | null
    hireDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    managerId: string | null
  }

  export type AgentProfileCountAggregateOutputType = {
    id: number
    userId: number
    agentType: number
    availability: number
    employeeId: number
    certifications: number
    currentLocation: number
    serviceZones: number
    rating: number
    completedTasks: number
    averageRating: number
    responseTime: number
    workingHours: number
    availabilityCalendar: number
    hourlyRate: number
    isActive: number
    hireDate: number
    createdAt: number
    updatedAt: number
    managerId: number
    _all: number
  }


  export type AgentProfileAvgAggregateInputType = {
    rating?: true
    completedTasks?: true
    averageRating?: true
    responseTime?: true
    hourlyRate?: true
  }

  export type AgentProfileSumAggregateInputType = {
    rating?: true
    completedTasks?: true
    averageRating?: true
    responseTime?: true
    hourlyRate?: true
  }

  export type AgentProfileMinAggregateInputType = {
    id?: true
    userId?: true
    agentType?: true
    availability?: true
    employeeId?: true
    rating?: true
    completedTasks?: true
    averageRating?: true
    responseTime?: true
    hourlyRate?: true
    isActive?: true
    hireDate?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
  }

  export type AgentProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    agentType?: true
    availability?: true
    employeeId?: true
    rating?: true
    completedTasks?: true
    averageRating?: true
    responseTime?: true
    hourlyRate?: true
    isActive?: true
    hireDate?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
  }

  export type AgentProfileCountAggregateInputType = {
    id?: true
    userId?: true
    agentType?: true
    availability?: true
    employeeId?: true
    certifications?: true
    currentLocation?: true
    serviceZones?: true
    rating?: true
    completedTasks?: true
    averageRating?: true
    responseTime?: true
    workingHours?: true
    availabilityCalendar?: true
    hourlyRate?: true
    isActive?: true
    hireDate?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
    _all?: true
  }

  export type AgentProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentProfile to aggregate.
     */
    where?: AgentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentProfiles to fetch.
     */
    orderBy?: AgentProfileOrderByWithRelationInput | AgentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentProfiles
    **/
    _count?: true | AgentProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentProfileMaxAggregateInputType
  }

  export type GetAgentProfileAggregateType<T extends AgentProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentProfile[P]>
      : GetScalarType<T[P], AggregateAgentProfile[P]>
  }




  export type AgentProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentProfileWhereInput
    orderBy?: AgentProfileOrderByWithAggregationInput | AgentProfileOrderByWithAggregationInput[]
    by: AgentProfileScalarFieldEnum[] | AgentProfileScalarFieldEnum
    having?: AgentProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentProfileCountAggregateInputType | true
    _avg?: AgentProfileAvgAggregateInputType
    _sum?: AgentProfileSumAggregateInputType
    _min?: AgentProfileMinAggregateInputType
    _max?: AgentProfileMaxAggregateInputType
  }

  export type AgentProfileGroupByOutputType = {
    id: string
    userId: string
    agentType: $Enums.AgentType
    availability: $Enums.AgentAvailability
    employeeId: string | null
    certifications: string[]
    currentLocation: JsonValue | null
    serviceZones: string[]
    rating: number | null
    completedTasks: number
    averageRating: number | null
    responseTime: number | null
    workingHours: JsonValue | null
    availabilityCalendar: JsonValue | null
    hourlyRate: number | null
    isActive: boolean
    hireDate: Date | null
    createdAt: Date
    updatedAt: Date
    managerId: string
    _count: AgentProfileCountAggregateOutputType | null
    _avg: AgentProfileAvgAggregateOutputType | null
    _sum: AgentProfileSumAggregateOutputType | null
    _min: AgentProfileMinAggregateOutputType | null
    _max: AgentProfileMaxAggregateOutputType | null
  }

  type GetAgentProfileGroupByPayload<T extends AgentProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentProfileGroupByOutputType[P]>
            : GetScalarType<T[P], AgentProfileGroupByOutputType[P]>
        }
      >
    >


  export type AgentProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agentType?: boolean
    availability?: boolean
    employeeId?: boolean
    certifications?: boolean
    currentLocation?: boolean
    serviceZones?: boolean
    rating?: boolean
    completedTasks?: boolean
    averageRating?: boolean
    responseTime?: boolean
    workingHours?: boolean
    availabilityCalendar?: boolean
    hourlyRate?: boolean
    isActive?: boolean
    hireDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    specialties?: boolean | AgentProfile$specialtiesArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
    cleaningSessions?: boolean | AgentProfile$cleaningSessionsArgs<ExtArgs>
    maintenanceSessions?: boolean | AgentProfile$maintenanceSessionsArgs<ExtArgs>
    tickets?: boolean | AgentProfile$ticketsArgs<ExtArgs>
    taskAssignments?: boolean | AgentProfile$taskAssignmentsArgs<ExtArgs>
    _count?: boolean | AgentProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentProfile"]>

  export type AgentProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agentType?: boolean
    availability?: boolean
    employeeId?: boolean
    certifications?: boolean
    currentLocation?: boolean
    serviceZones?: boolean
    rating?: boolean
    completedTasks?: boolean
    averageRating?: boolean
    responseTime?: boolean
    workingHours?: boolean
    availabilityCalendar?: boolean
    hourlyRate?: boolean
    isActive?: boolean
    hireDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentProfile"]>

  export type AgentProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agentType?: boolean
    availability?: boolean
    employeeId?: boolean
    certifications?: boolean
    currentLocation?: boolean
    serviceZones?: boolean
    rating?: boolean
    completedTasks?: boolean
    averageRating?: boolean
    responseTime?: boolean
    workingHours?: boolean
    availabilityCalendar?: boolean
    hourlyRate?: boolean
    isActive?: boolean
    hireDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentProfile"]>

  export type AgentProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    agentType?: boolean
    availability?: boolean
    employeeId?: boolean
    certifications?: boolean
    currentLocation?: boolean
    serviceZones?: boolean
    rating?: boolean
    completedTasks?: boolean
    averageRating?: boolean
    responseTime?: boolean
    workingHours?: boolean
    availabilityCalendar?: boolean
    hourlyRate?: boolean
    isActive?: boolean
    hireDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
  }

  export type AgentProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "agentType" | "availability" | "employeeId" | "certifications" | "currentLocation" | "serviceZones" | "rating" | "completedTasks" | "averageRating" | "responseTime" | "workingHours" | "availabilityCalendar" | "hourlyRate" | "isActive" | "hireDate" | "createdAt" | "updatedAt" | "managerId", ExtArgs["result"]["agentProfile"]>
  export type AgentProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    specialties?: boolean | AgentProfile$specialtiesArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
    cleaningSessions?: boolean | AgentProfile$cleaningSessionsArgs<ExtArgs>
    maintenanceSessions?: boolean | AgentProfile$maintenanceSessionsArgs<ExtArgs>
    tickets?: boolean | AgentProfile$ticketsArgs<ExtArgs>
    taskAssignments?: boolean | AgentProfile$taskAssignmentsArgs<ExtArgs>
    _count?: boolean | AgentProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }
  export type AgentProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }

  export type $AgentProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      specialties: Prisma.$AgentSpecialtyPayload<ExtArgs>[]
      manager: Prisma.$PoleManagerProfilePayload<ExtArgs>
      cleaningSessions: Prisma.$CleaningSessionPayload<ExtArgs>[]
      maintenanceSessions: Prisma.$MaintenanceSessionPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      taskAssignments: Prisma.$TaskAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      agentType: $Enums.AgentType
      availability: $Enums.AgentAvailability
      employeeId: string | null
      certifications: string[]
      currentLocation: Prisma.JsonValue | null
      serviceZones: string[]
      rating: number | null
      completedTasks: number
      averageRating: number | null
      responseTime: number | null
      workingHours: Prisma.JsonValue | null
      availabilityCalendar: Prisma.JsonValue | null
      hourlyRate: number | null
      isActive: boolean
      hireDate: Date | null
      createdAt: Date
      updatedAt: Date
      managerId: string
    }, ExtArgs["result"]["agentProfile"]>
    composites: {}
  }

  type AgentProfileGetPayload<S extends boolean | null | undefined | AgentProfileDefaultArgs> = $Result.GetResult<Prisma.$AgentProfilePayload, S>

  type AgentProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentProfileCountAggregateInputType | true
    }

  export interface AgentProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentProfile'], meta: { name: 'AgentProfile' } }
    /**
     * Find zero or one AgentProfile that matches the filter.
     * @param {AgentProfileFindUniqueArgs} args - Arguments to find a AgentProfile
     * @example
     * // Get one AgentProfile
     * const agentProfile = await prisma.agentProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentProfileFindUniqueArgs>(args: SelectSubset<T, AgentProfileFindUniqueArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentProfileFindUniqueOrThrowArgs} args - Arguments to find a AgentProfile
     * @example
     * // Get one AgentProfile
     * const agentProfile = await prisma.agentProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentProfileFindFirstArgs} args - Arguments to find a AgentProfile
     * @example
     * // Get one AgentProfile
     * const agentProfile = await prisma.agentProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentProfileFindFirstArgs>(args?: SelectSubset<T, AgentProfileFindFirstArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentProfileFindFirstOrThrowArgs} args - Arguments to find a AgentProfile
     * @example
     * // Get one AgentProfile
     * const agentProfile = await prisma.agentProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentProfiles
     * const agentProfiles = await prisma.agentProfile.findMany()
     * 
     * // Get first 10 AgentProfiles
     * const agentProfiles = await prisma.agentProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentProfileWithIdOnly = await prisma.agentProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentProfileFindManyArgs>(args?: SelectSubset<T, AgentProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentProfile.
     * @param {AgentProfileCreateArgs} args - Arguments to create a AgentProfile.
     * @example
     * // Create one AgentProfile
     * const AgentProfile = await prisma.agentProfile.create({
     *   data: {
     *     // ... data to create a AgentProfile
     *   }
     * })
     * 
     */
    create<T extends AgentProfileCreateArgs>(args: SelectSubset<T, AgentProfileCreateArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentProfiles.
     * @param {AgentProfileCreateManyArgs} args - Arguments to create many AgentProfiles.
     * @example
     * // Create many AgentProfiles
     * const agentProfile = await prisma.agentProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentProfileCreateManyArgs>(args?: SelectSubset<T, AgentProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentProfiles and returns the data saved in the database.
     * @param {AgentProfileCreateManyAndReturnArgs} args - Arguments to create many AgentProfiles.
     * @example
     * // Create many AgentProfiles
     * const agentProfile = await prisma.agentProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentProfiles and only return the `id`
     * const agentProfileWithIdOnly = await prisma.agentProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentProfile.
     * @param {AgentProfileDeleteArgs} args - Arguments to delete one AgentProfile.
     * @example
     * // Delete one AgentProfile
     * const AgentProfile = await prisma.agentProfile.delete({
     *   where: {
     *     // ... filter to delete one AgentProfile
     *   }
     * })
     * 
     */
    delete<T extends AgentProfileDeleteArgs>(args: SelectSubset<T, AgentProfileDeleteArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentProfile.
     * @param {AgentProfileUpdateArgs} args - Arguments to update one AgentProfile.
     * @example
     * // Update one AgentProfile
     * const agentProfile = await prisma.agentProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentProfileUpdateArgs>(args: SelectSubset<T, AgentProfileUpdateArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentProfiles.
     * @param {AgentProfileDeleteManyArgs} args - Arguments to filter AgentProfiles to delete.
     * @example
     * // Delete a few AgentProfiles
     * const { count } = await prisma.agentProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentProfileDeleteManyArgs>(args?: SelectSubset<T, AgentProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentProfiles
     * const agentProfile = await prisma.agentProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentProfileUpdateManyArgs>(args: SelectSubset<T, AgentProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentProfiles and returns the data updated in the database.
     * @param {AgentProfileUpdateManyAndReturnArgs} args - Arguments to update many AgentProfiles.
     * @example
     * // Update many AgentProfiles
     * const agentProfile = await prisma.agentProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentProfiles and only return the `id`
     * const agentProfileWithIdOnly = await prisma.agentProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentProfile.
     * @param {AgentProfileUpsertArgs} args - Arguments to update or create a AgentProfile.
     * @example
     * // Update or create a AgentProfile
     * const agentProfile = await prisma.agentProfile.upsert({
     *   create: {
     *     // ... data to create a AgentProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentProfile we want to update
     *   }
     * })
     */
    upsert<T extends AgentProfileUpsertArgs>(args: SelectSubset<T, AgentProfileUpsertArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentProfileCountArgs} args - Arguments to filter AgentProfiles to count.
     * @example
     * // Count the number of AgentProfiles
     * const count = await prisma.agentProfile.count({
     *   where: {
     *     // ... the filter for the AgentProfiles we want to count
     *   }
     * })
    **/
    count<T extends AgentProfileCountArgs>(
      args?: Subset<T, AgentProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentProfileAggregateArgs>(args: Subset<T, AgentProfileAggregateArgs>): Prisma.PrismaPromise<GetAgentProfileAggregateType<T>>

    /**
     * Group by AgentProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentProfileGroupByArgs['orderBy'] }
        : { orderBy?: AgentProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentProfile model
   */
  readonly fields: AgentProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    specialties<T extends AgentProfile$specialtiesArgs<ExtArgs> = {}>(args?: Subset<T, AgentProfile$specialtiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentSpecialtyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manager<T extends PoleManagerProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PoleManagerProfileDefaultArgs<ExtArgs>>): Prisma__PoleManagerProfileClient<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cleaningSessions<T extends AgentProfile$cleaningSessionsArgs<ExtArgs> = {}>(args?: Subset<T, AgentProfile$cleaningSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maintenanceSessions<T extends AgentProfile$maintenanceSessionsArgs<ExtArgs> = {}>(args?: Subset<T, AgentProfile$maintenanceSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends AgentProfile$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, AgentProfile$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskAssignments<T extends AgentProfile$taskAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, AgentProfile$taskAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentProfile model
   */
  interface AgentProfileFieldRefs {
    readonly id: FieldRef<"AgentProfile", 'String'>
    readonly userId: FieldRef<"AgentProfile", 'String'>
    readonly agentType: FieldRef<"AgentProfile", 'AgentType'>
    readonly availability: FieldRef<"AgentProfile", 'AgentAvailability'>
    readonly employeeId: FieldRef<"AgentProfile", 'String'>
    readonly certifications: FieldRef<"AgentProfile", 'String[]'>
    readonly currentLocation: FieldRef<"AgentProfile", 'Json'>
    readonly serviceZones: FieldRef<"AgentProfile", 'String[]'>
    readonly rating: FieldRef<"AgentProfile", 'Float'>
    readonly completedTasks: FieldRef<"AgentProfile", 'Int'>
    readonly averageRating: FieldRef<"AgentProfile", 'Float'>
    readonly responseTime: FieldRef<"AgentProfile", 'Int'>
    readonly workingHours: FieldRef<"AgentProfile", 'Json'>
    readonly availabilityCalendar: FieldRef<"AgentProfile", 'Json'>
    readonly hourlyRate: FieldRef<"AgentProfile", 'Float'>
    readonly isActive: FieldRef<"AgentProfile", 'Boolean'>
    readonly hireDate: FieldRef<"AgentProfile", 'DateTime'>
    readonly createdAt: FieldRef<"AgentProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentProfile", 'DateTime'>
    readonly managerId: FieldRef<"AgentProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AgentProfile findUnique
   */
  export type AgentProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * Filter, which AgentProfile to fetch.
     */
    where: AgentProfileWhereUniqueInput
  }

  /**
   * AgentProfile findUniqueOrThrow
   */
  export type AgentProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * Filter, which AgentProfile to fetch.
     */
    where: AgentProfileWhereUniqueInput
  }

  /**
   * AgentProfile findFirst
   */
  export type AgentProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * Filter, which AgentProfile to fetch.
     */
    where?: AgentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentProfiles to fetch.
     */
    orderBy?: AgentProfileOrderByWithRelationInput | AgentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentProfiles.
     */
    cursor?: AgentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentProfiles.
     */
    distinct?: AgentProfileScalarFieldEnum | AgentProfileScalarFieldEnum[]
  }

  /**
   * AgentProfile findFirstOrThrow
   */
  export type AgentProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * Filter, which AgentProfile to fetch.
     */
    where?: AgentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentProfiles to fetch.
     */
    orderBy?: AgentProfileOrderByWithRelationInput | AgentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentProfiles.
     */
    cursor?: AgentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentProfiles.
     */
    distinct?: AgentProfileScalarFieldEnum | AgentProfileScalarFieldEnum[]
  }

  /**
   * AgentProfile findMany
   */
  export type AgentProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * Filter, which AgentProfiles to fetch.
     */
    where?: AgentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentProfiles to fetch.
     */
    orderBy?: AgentProfileOrderByWithRelationInput | AgentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentProfiles.
     */
    cursor?: AgentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentProfiles.
     */
    skip?: number
    distinct?: AgentProfileScalarFieldEnum | AgentProfileScalarFieldEnum[]
  }

  /**
   * AgentProfile create
   */
  export type AgentProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentProfile.
     */
    data: XOR<AgentProfileCreateInput, AgentProfileUncheckedCreateInput>
  }

  /**
   * AgentProfile createMany
   */
  export type AgentProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentProfiles.
     */
    data: AgentProfileCreateManyInput | AgentProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentProfile createManyAndReturn
   */
  export type AgentProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * The data used to create many AgentProfiles.
     */
    data: AgentProfileCreateManyInput | AgentProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentProfile update
   */
  export type AgentProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentProfile.
     */
    data: XOR<AgentProfileUpdateInput, AgentProfileUncheckedUpdateInput>
    /**
     * Choose, which AgentProfile to update.
     */
    where: AgentProfileWhereUniqueInput
  }

  /**
   * AgentProfile updateMany
   */
  export type AgentProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentProfiles.
     */
    data: XOR<AgentProfileUpdateManyMutationInput, AgentProfileUncheckedUpdateManyInput>
    /**
     * Filter which AgentProfiles to update
     */
    where?: AgentProfileWhereInput
    /**
     * Limit how many AgentProfiles to update.
     */
    limit?: number
  }

  /**
   * AgentProfile updateManyAndReturn
   */
  export type AgentProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * The data used to update AgentProfiles.
     */
    data: XOR<AgentProfileUpdateManyMutationInput, AgentProfileUncheckedUpdateManyInput>
    /**
     * Filter which AgentProfiles to update
     */
    where?: AgentProfileWhereInput
    /**
     * Limit how many AgentProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentProfile upsert
   */
  export type AgentProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentProfile to update in case it exists.
     */
    where: AgentProfileWhereUniqueInput
    /**
     * In case the AgentProfile found by the `where` argument doesn't exist, create a new AgentProfile with this data.
     */
    create: XOR<AgentProfileCreateInput, AgentProfileUncheckedCreateInput>
    /**
     * In case the AgentProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentProfileUpdateInput, AgentProfileUncheckedUpdateInput>
  }

  /**
   * AgentProfile delete
   */
  export type AgentProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    /**
     * Filter which AgentProfile to delete.
     */
    where: AgentProfileWhereUniqueInput
  }

  /**
   * AgentProfile deleteMany
   */
  export type AgentProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentProfiles to delete
     */
    where?: AgentProfileWhereInput
    /**
     * Limit how many AgentProfiles to delete.
     */
    limit?: number
  }

  /**
   * AgentProfile.specialties
   */
  export type AgentProfile$specialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSpecialty
     */
    select?: AgentSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSpecialty
     */
    omit?: AgentSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSpecialtyInclude<ExtArgs> | null
    where?: AgentSpecialtyWhereInput
    orderBy?: AgentSpecialtyOrderByWithRelationInput | AgentSpecialtyOrderByWithRelationInput[]
    cursor?: AgentSpecialtyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentSpecialtyScalarFieldEnum | AgentSpecialtyScalarFieldEnum[]
  }

  /**
   * AgentProfile.cleaningSessions
   */
  export type AgentProfile$cleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    where?: CleaningSessionWhereInput
    orderBy?: CleaningSessionOrderByWithRelationInput | CleaningSessionOrderByWithRelationInput[]
    cursor?: CleaningSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningSessionScalarFieldEnum | CleaningSessionScalarFieldEnum[]
  }

  /**
   * AgentProfile.maintenanceSessions
   */
  export type AgentProfile$maintenanceSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    where?: MaintenanceSessionWhereInput
    orderBy?: MaintenanceSessionOrderByWithRelationInput | MaintenanceSessionOrderByWithRelationInput[]
    cursor?: MaintenanceSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceSessionScalarFieldEnum | MaintenanceSessionScalarFieldEnum[]
  }

  /**
   * AgentProfile.tickets
   */
  export type AgentProfile$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * AgentProfile.taskAssignments
   */
  export type AgentProfile$taskAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    where?: TaskAssignmentWhereInput
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    cursor?: TaskAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * AgentProfile without action
   */
  export type AgentProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
  }


  /**
   * Model AgentSpecialty
   */

  export type AggregateAgentSpecialty = {
    _count: AgentSpecialtyCountAggregateOutputType | null
    _min: AgentSpecialtyMinAggregateOutputType | null
    _max: AgentSpecialtyMaxAggregateOutputType | null
  }

  export type AgentSpecialtyMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    level: string | null
    certified: boolean | null
    agentId: string | null
  }

  export type AgentSpecialtyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    level: string | null
    certified: boolean | null
    agentId: string | null
  }

  export type AgentSpecialtyCountAggregateOutputType = {
    id: number
    name: number
    category: number
    level: number
    certified: number
    agentId: number
    _all: number
  }


  export type AgentSpecialtyMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    level?: true
    certified?: true
    agentId?: true
  }

  export type AgentSpecialtyMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    level?: true
    certified?: true
    agentId?: true
  }

  export type AgentSpecialtyCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    level?: true
    certified?: true
    agentId?: true
    _all?: true
  }

  export type AgentSpecialtyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentSpecialty to aggregate.
     */
    where?: AgentSpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentSpecialties to fetch.
     */
    orderBy?: AgentSpecialtyOrderByWithRelationInput | AgentSpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentSpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentSpecialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentSpecialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentSpecialties
    **/
    _count?: true | AgentSpecialtyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentSpecialtyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentSpecialtyMaxAggregateInputType
  }

  export type GetAgentSpecialtyAggregateType<T extends AgentSpecialtyAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentSpecialty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentSpecialty[P]>
      : GetScalarType<T[P], AggregateAgentSpecialty[P]>
  }




  export type AgentSpecialtyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentSpecialtyWhereInput
    orderBy?: AgentSpecialtyOrderByWithAggregationInput | AgentSpecialtyOrderByWithAggregationInput[]
    by: AgentSpecialtyScalarFieldEnum[] | AgentSpecialtyScalarFieldEnum
    having?: AgentSpecialtyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentSpecialtyCountAggregateInputType | true
    _min?: AgentSpecialtyMinAggregateInputType
    _max?: AgentSpecialtyMaxAggregateInputType
  }

  export type AgentSpecialtyGroupByOutputType = {
    id: string
    name: string
    category: string | null
    level: string | null
    certified: boolean
    agentId: string
    _count: AgentSpecialtyCountAggregateOutputType | null
    _min: AgentSpecialtyMinAggregateOutputType | null
    _max: AgentSpecialtyMaxAggregateOutputType | null
  }

  type GetAgentSpecialtyGroupByPayload<T extends AgentSpecialtyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentSpecialtyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentSpecialtyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentSpecialtyGroupByOutputType[P]>
            : GetScalarType<T[P], AgentSpecialtyGroupByOutputType[P]>
        }
      >
    >


  export type AgentSpecialtySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    level?: boolean
    certified?: boolean
    agentId?: boolean
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentSpecialty"]>

  export type AgentSpecialtySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    level?: boolean
    certified?: boolean
    agentId?: boolean
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentSpecialty"]>

  export type AgentSpecialtySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    level?: boolean
    certified?: boolean
    agentId?: boolean
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentSpecialty"]>

  export type AgentSpecialtySelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    level?: boolean
    certified?: boolean
    agentId?: boolean
  }

  export type AgentSpecialtyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "level" | "certified" | "agentId", ExtArgs["result"]["agentSpecialty"]>
  export type AgentSpecialtyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
  }
  export type AgentSpecialtyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
  }
  export type AgentSpecialtyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
  }

  export type $AgentSpecialtyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentSpecialty"
    objects: {
      agent: Prisma.$AgentProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string | null
      level: string | null
      certified: boolean
      agentId: string
    }, ExtArgs["result"]["agentSpecialty"]>
    composites: {}
  }

  type AgentSpecialtyGetPayload<S extends boolean | null | undefined | AgentSpecialtyDefaultArgs> = $Result.GetResult<Prisma.$AgentSpecialtyPayload, S>

  type AgentSpecialtyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentSpecialtyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentSpecialtyCountAggregateInputType | true
    }

  export interface AgentSpecialtyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentSpecialty'], meta: { name: 'AgentSpecialty' } }
    /**
     * Find zero or one AgentSpecialty that matches the filter.
     * @param {AgentSpecialtyFindUniqueArgs} args - Arguments to find a AgentSpecialty
     * @example
     * // Get one AgentSpecialty
     * const agentSpecialty = await prisma.agentSpecialty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentSpecialtyFindUniqueArgs>(args: SelectSubset<T, AgentSpecialtyFindUniqueArgs<ExtArgs>>): Prisma__AgentSpecialtyClient<$Result.GetResult<Prisma.$AgentSpecialtyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentSpecialty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentSpecialtyFindUniqueOrThrowArgs} args - Arguments to find a AgentSpecialty
     * @example
     * // Get one AgentSpecialty
     * const agentSpecialty = await prisma.agentSpecialty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentSpecialtyFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentSpecialtyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentSpecialtyClient<$Result.GetResult<Prisma.$AgentSpecialtyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentSpecialty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentSpecialtyFindFirstArgs} args - Arguments to find a AgentSpecialty
     * @example
     * // Get one AgentSpecialty
     * const agentSpecialty = await prisma.agentSpecialty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentSpecialtyFindFirstArgs>(args?: SelectSubset<T, AgentSpecialtyFindFirstArgs<ExtArgs>>): Prisma__AgentSpecialtyClient<$Result.GetResult<Prisma.$AgentSpecialtyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentSpecialty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentSpecialtyFindFirstOrThrowArgs} args - Arguments to find a AgentSpecialty
     * @example
     * // Get one AgentSpecialty
     * const agentSpecialty = await prisma.agentSpecialty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentSpecialtyFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentSpecialtyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentSpecialtyClient<$Result.GetResult<Prisma.$AgentSpecialtyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentSpecialties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentSpecialtyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentSpecialties
     * const agentSpecialties = await prisma.agentSpecialty.findMany()
     * 
     * // Get first 10 AgentSpecialties
     * const agentSpecialties = await prisma.agentSpecialty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentSpecialtyWithIdOnly = await prisma.agentSpecialty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentSpecialtyFindManyArgs>(args?: SelectSubset<T, AgentSpecialtyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentSpecialtyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentSpecialty.
     * @param {AgentSpecialtyCreateArgs} args - Arguments to create a AgentSpecialty.
     * @example
     * // Create one AgentSpecialty
     * const AgentSpecialty = await prisma.agentSpecialty.create({
     *   data: {
     *     // ... data to create a AgentSpecialty
     *   }
     * })
     * 
     */
    create<T extends AgentSpecialtyCreateArgs>(args: SelectSubset<T, AgentSpecialtyCreateArgs<ExtArgs>>): Prisma__AgentSpecialtyClient<$Result.GetResult<Prisma.$AgentSpecialtyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentSpecialties.
     * @param {AgentSpecialtyCreateManyArgs} args - Arguments to create many AgentSpecialties.
     * @example
     * // Create many AgentSpecialties
     * const agentSpecialty = await prisma.agentSpecialty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentSpecialtyCreateManyArgs>(args?: SelectSubset<T, AgentSpecialtyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentSpecialties and returns the data saved in the database.
     * @param {AgentSpecialtyCreateManyAndReturnArgs} args - Arguments to create many AgentSpecialties.
     * @example
     * // Create many AgentSpecialties
     * const agentSpecialty = await prisma.agentSpecialty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentSpecialties and only return the `id`
     * const agentSpecialtyWithIdOnly = await prisma.agentSpecialty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentSpecialtyCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentSpecialtyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentSpecialtyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentSpecialty.
     * @param {AgentSpecialtyDeleteArgs} args - Arguments to delete one AgentSpecialty.
     * @example
     * // Delete one AgentSpecialty
     * const AgentSpecialty = await prisma.agentSpecialty.delete({
     *   where: {
     *     // ... filter to delete one AgentSpecialty
     *   }
     * })
     * 
     */
    delete<T extends AgentSpecialtyDeleteArgs>(args: SelectSubset<T, AgentSpecialtyDeleteArgs<ExtArgs>>): Prisma__AgentSpecialtyClient<$Result.GetResult<Prisma.$AgentSpecialtyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentSpecialty.
     * @param {AgentSpecialtyUpdateArgs} args - Arguments to update one AgentSpecialty.
     * @example
     * // Update one AgentSpecialty
     * const agentSpecialty = await prisma.agentSpecialty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentSpecialtyUpdateArgs>(args: SelectSubset<T, AgentSpecialtyUpdateArgs<ExtArgs>>): Prisma__AgentSpecialtyClient<$Result.GetResult<Prisma.$AgentSpecialtyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentSpecialties.
     * @param {AgentSpecialtyDeleteManyArgs} args - Arguments to filter AgentSpecialties to delete.
     * @example
     * // Delete a few AgentSpecialties
     * const { count } = await prisma.agentSpecialty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentSpecialtyDeleteManyArgs>(args?: SelectSubset<T, AgentSpecialtyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentSpecialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentSpecialtyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentSpecialties
     * const agentSpecialty = await prisma.agentSpecialty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentSpecialtyUpdateManyArgs>(args: SelectSubset<T, AgentSpecialtyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentSpecialties and returns the data updated in the database.
     * @param {AgentSpecialtyUpdateManyAndReturnArgs} args - Arguments to update many AgentSpecialties.
     * @example
     * // Update many AgentSpecialties
     * const agentSpecialty = await prisma.agentSpecialty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentSpecialties and only return the `id`
     * const agentSpecialtyWithIdOnly = await prisma.agentSpecialty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentSpecialtyUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentSpecialtyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentSpecialtyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentSpecialty.
     * @param {AgentSpecialtyUpsertArgs} args - Arguments to update or create a AgentSpecialty.
     * @example
     * // Update or create a AgentSpecialty
     * const agentSpecialty = await prisma.agentSpecialty.upsert({
     *   create: {
     *     // ... data to create a AgentSpecialty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentSpecialty we want to update
     *   }
     * })
     */
    upsert<T extends AgentSpecialtyUpsertArgs>(args: SelectSubset<T, AgentSpecialtyUpsertArgs<ExtArgs>>): Prisma__AgentSpecialtyClient<$Result.GetResult<Prisma.$AgentSpecialtyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentSpecialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentSpecialtyCountArgs} args - Arguments to filter AgentSpecialties to count.
     * @example
     * // Count the number of AgentSpecialties
     * const count = await prisma.agentSpecialty.count({
     *   where: {
     *     // ... the filter for the AgentSpecialties we want to count
     *   }
     * })
    **/
    count<T extends AgentSpecialtyCountArgs>(
      args?: Subset<T, AgentSpecialtyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentSpecialtyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentSpecialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentSpecialtyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentSpecialtyAggregateArgs>(args: Subset<T, AgentSpecialtyAggregateArgs>): Prisma.PrismaPromise<GetAgentSpecialtyAggregateType<T>>

    /**
     * Group by AgentSpecialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentSpecialtyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentSpecialtyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentSpecialtyGroupByArgs['orderBy'] }
        : { orderBy?: AgentSpecialtyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentSpecialtyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentSpecialtyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentSpecialty model
   */
  readonly fields: AgentSpecialtyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentSpecialty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentSpecialtyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentProfileDefaultArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentSpecialty model
   */
  interface AgentSpecialtyFieldRefs {
    readonly id: FieldRef<"AgentSpecialty", 'String'>
    readonly name: FieldRef<"AgentSpecialty", 'String'>
    readonly category: FieldRef<"AgentSpecialty", 'String'>
    readonly level: FieldRef<"AgentSpecialty", 'String'>
    readonly certified: FieldRef<"AgentSpecialty", 'Boolean'>
    readonly agentId: FieldRef<"AgentSpecialty", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AgentSpecialty findUnique
   */
  export type AgentSpecialtyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSpecialty
     */
    select?: AgentSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSpecialty
     */
    omit?: AgentSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which AgentSpecialty to fetch.
     */
    where: AgentSpecialtyWhereUniqueInput
  }

  /**
   * AgentSpecialty findUniqueOrThrow
   */
  export type AgentSpecialtyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSpecialty
     */
    select?: AgentSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSpecialty
     */
    omit?: AgentSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which AgentSpecialty to fetch.
     */
    where: AgentSpecialtyWhereUniqueInput
  }

  /**
   * AgentSpecialty findFirst
   */
  export type AgentSpecialtyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSpecialty
     */
    select?: AgentSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSpecialty
     */
    omit?: AgentSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which AgentSpecialty to fetch.
     */
    where?: AgentSpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentSpecialties to fetch.
     */
    orderBy?: AgentSpecialtyOrderByWithRelationInput | AgentSpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentSpecialties.
     */
    cursor?: AgentSpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentSpecialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentSpecialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentSpecialties.
     */
    distinct?: AgentSpecialtyScalarFieldEnum | AgentSpecialtyScalarFieldEnum[]
  }

  /**
   * AgentSpecialty findFirstOrThrow
   */
  export type AgentSpecialtyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSpecialty
     */
    select?: AgentSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSpecialty
     */
    omit?: AgentSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which AgentSpecialty to fetch.
     */
    where?: AgentSpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentSpecialties to fetch.
     */
    orderBy?: AgentSpecialtyOrderByWithRelationInput | AgentSpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentSpecialties.
     */
    cursor?: AgentSpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentSpecialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentSpecialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentSpecialties.
     */
    distinct?: AgentSpecialtyScalarFieldEnum | AgentSpecialtyScalarFieldEnum[]
  }

  /**
   * AgentSpecialty findMany
   */
  export type AgentSpecialtyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSpecialty
     */
    select?: AgentSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSpecialty
     */
    omit?: AgentSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which AgentSpecialties to fetch.
     */
    where?: AgentSpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentSpecialties to fetch.
     */
    orderBy?: AgentSpecialtyOrderByWithRelationInput | AgentSpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentSpecialties.
     */
    cursor?: AgentSpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentSpecialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentSpecialties.
     */
    skip?: number
    distinct?: AgentSpecialtyScalarFieldEnum | AgentSpecialtyScalarFieldEnum[]
  }

  /**
   * AgentSpecialty create
   */
  export type AgentSpecialtyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSpecialty
     */
    select?: AgentSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSpecialty
     */
    omit?: AgentSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentSpecialty.
     */
    data: XOR<AgentSpecialtyCreateInput, AgentSpecialtyUncheckedCreateInput>
  }

  /**
   * AgentSpecialty createMany
   */
  export type AgentSpecialtyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentSpecialties.
     */
    data: AgentSpecialtyCreateManyInput | AgentSpecialtyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentSpecialty createManyAndReturn
   */
  export type AgentSpecialtyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSpecialty
     */
    select?: AgentSpecialtySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSpecialty
     */
    omit?: AgentSpecialtyOmit<ExtArgs> | null
    /**
     * The data used to create many AgentSpecialties.
     */
    data: AgentSpecialtyCreateManyInput | AgentSpecialtyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSpecialtyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentSpecialty update
   */
  export type AgentSpecialtyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSpecialty
     */
    select?: AgentSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSpecialty
     */
    omit?: AgentSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentSpecialty.
     */
    data: XOR<AgentSpecialtyUpdateInput, AgentSpecialtyUncheckedUpdateInput>
    /**
     * Choose, which AgentSpecialty to update.
     */
    where: AgentSpecialtyWhereUniqueInput
  }

  /**
   * AgentSpecialty updateMany
   */
  export type AgentSpecialtyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentSpecialties.
     */
    data: XOR<AgentSpecialtyUpdateManyMutationInput, AgentSpecialtyUncheckedUpdateManyInput>
    /**
     * Filter which AgentSpecialties to update
     */
    where?: AgentSpecialtyWhereInput
    /**
     * Limit how many AgentSpecialties to update.
     */
    limit?: number
  }

  /**
   * AgentSpecialty updateManyAndReturn
   */
  export type AgentSpecialtyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSpecialty
     */
    select?: AgentSpecialtySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSpecialty
     */
    omit?: AgentSpecialtyOmit<ExtArgs> | null
    /**
     * The data used to update AgentSpecialties.
     */
    data: XOR<AgentSpecialtyUpdateManyMutationInput, AgentSpecialtyUncheckedUpdateManyInput>
    /**
     * Filter which AgentSpecialties to update
     */
    where?: AgentSpecialtyWhereInput
    /**
     * Limit how many AgentSpecialties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSpecialtyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentSpecialty upsert
   */
  export type AgentSpecialtyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSpecialty
     */
    select?: AgentSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSpecialty
     */
    omit?: AgentSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSpecialtyInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentSpecialty to update in case it exists.
     */
    where: AgentSpecialtyWhereUniqueInput
    /**
     * In case the AgentSpecialty found by the `where` argument doesn't exist, create a new AgentSpecialty with this data.
     */
    create: XOR<AgentSpecialtyCreateInput, AgentSpecialtyUncheckedCreateInput>
    /**
     * In case the AgentSpecialty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentSpecialtyUpdateInput, AgentSpecialtyUncheckedUpdateInput>
  }

  /**
   * AgentSpecialty delete
   */
  export type AgentSpecialtyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSpecialty
     */
    select?: AgentSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSpecialty
     */
    omit?: AgentSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSpecialtyInclude<ExtArgs> | null
    /**
     * Filter which AgentSpecialty to delete.
     */
    where: AgentSpecialtyWhereUniqueInput
  }

  /**
   * AgentSpecialty deleteMany
   */
  export type AgentSpecialtyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentSpecialties to delete
     */
    where?: AgentSpecialtyWhereInput
    /**
     * Limit how many AgentSpecialties to delete.
     */
    limit?: number
  }

  /**
   * AgentSpecialty without action
   */
  export type AgentSpecialtyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSpecialty
     */
    select?: AgentSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSpecialty
     */
    omit?: AgentSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentSpecialtyInclude<ExtArgs> | null
  }


  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    surface: number | null
    numberOfRooms: number | null
    numberOfBedrooms: number | null
    numberOfBathrooms: number | null
    maxGuests: number | null
    floor: number | null
    pricePerNight: number | null
    cleaningFee: number | null
    serviceFee: number | null
    securityDeposit: number | null
    averageRating: number | null
    totalReviews: number | null
  }

  export type PropertySumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    surface: number | null
    numberOfRooms: number | null
    numberOfBedrooms: number | null
    numberOfBathrooms: number | null
    maxGuests: number | null
    floor: number | null
    pricePerNight: number | null
    cleaningFee: number | null
    serviceFee: number | null
    securityDeposit: number | null
    averageRating: number | null
    totalReviews: number | null
  }

  export type PropertyMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.PropertyStatus | null
    address: string | null
    city: string | null
    country: string | null
    postalCode: string | null
    latitude: number | null
    longitude: number | null
    surface: number | null
    numberOfRooms: number | null
    numberOfBedrooms: number | null
    numberOfBathrooms: number | null
    maxGuests: number | null
    floor: number | null
    hasElevator: boolean | null
    hasParking: boolean | null
    hasBalcony: boolean | null
    pricePerNight: number | null
    cleaningFee: number | null
    serviceFee: number | null
    securityDeposit: number | null
    averageRating: number | null
    totalReviews: number | null
    checkInTime: string | null
    checkOutTime: string | null
    cancellationPolicy: string | null
    houseRules: string | null
    accessInstructions: string | null
    cleaningInstructions: string | null
    maintenanceNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
    managerId: string | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.PropertyStatus | null
    address: string | null
    city: string | null
    country: string | null
    postalCode: string | null
    latitude: number | null
    longitude: number | null
    surface: number | null
    numberOfRooms: number | null
    numberOfBedrooms: number | null
    numberOfBathrooms: number | null
    maxGuests: number | null
    floor: number | null
    hasElevator: boolean | null
    hasParking: boolean | null
    hasBalcony: boolean | null
    pricePerNight: number | null
    cleaningFee: number | null
    serviceFee: number | null
    securityDeposit: number | null
    averageRating: number | null
    totalReviews: number | null
    checkInTime: string | null
    checkOutTime: string | null
    cancellationPolicy: string | null
    houseRules: string | null
    accessInstructions: string | null
    cleaningInstructions: string | null
    maintenanceNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
    managerId: string | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    address: number
    city: number
    country: number
    postalCode: number
    latitude: number
    longitude: number
    surface: number
    numberOfRooms: number
    numberOfBedrooms: number
    numberOfBathrooms: number
    maxGuests: number
    floor: number
    hasElevator: number
    hasParking: number
    hasBalcony: number
    pricePerNight: number
    cleaningFee: number
    serviceFee: number
    securityDeposit: number
    averageRating: number
    totalReviews: number
    checkInTime: number
    checkOutTime: number
    cancellationPolicy: number
    houseRules: number
    accessInstructions: number
    cleaningInstructions: number
    maintenanceNotes: number
    createdAt: number
    updatedAt: number
    ownerId: number
    managerId: number
    _all: number
  }


  export type PropertyAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    surface?: true
    numberOfRooms?: true
    numberOfBedrooms?: true
    numberOfBathrooms?: true
    maxGuests?: true
    floor?: true
    pricePerNight?: true
    cleaningFee?: true
    serviceFee?: true
    securityDeposit?: true
    averageRating?: true
    totalReviews?: true
  }

  export type PropertySumAggregateInputType = {
    latitude?: true
    longitude?: true
    surface?: true
    numberOfRooms?: true
    numberOfBedrooms?: true
    numberOfBathrooms?: true
    maxGuests?: true
    floor?: true
    pricePerNight?: true
    cleaningFee?: true
    serviceFee?: true
    securityDeposit?: true
    averageRating?: true
    totalReviews?: true
  }

  export type PropertyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    address?: true
    city?: true
    country?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    surface?: true
    numberOfRooms?: true
    numberOfBedrooms?: true
    numberOfBathrooms?: true
    maxGuests?: true
    floor?: true
    hasElevator?: true
    hasParking?: true
    hasBalcony?: true
    pricePerNight?: true
    cleaningFee?: true
    serviceFee?: true
    securityDeposit?: true
    averageRating?: true
    totalReviews?: true
    checkInTime?: true
    checkOutTime?: true
    cancellationPolicy?: true
    houseRules?: true
    accessInstructions?: true
    cleaningInstructions?: true
    maintenanceNotes?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    managerId?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    address?: true
    city?: true
    country?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    surface?: true
    numberOfRooms?: true
    numberOfBedrooms?: true
    numberOfBathrooms?: true
    maxGuests?: true
    floor?: true
    hasElevator?: true
    hasParking?: true
    hasBalcony?: true
    pricePerNight?: true
    cleaningFee?: true
    serviceFee?: true
    securityDeposit?: true
    averageRating?: true
    totalReviews?: true
    checkInTime?: true
    checkOutTime?: true
    cancellationPolicy?: true
    houseRules?: true
    accessInstructions?: true
    cleaningInstructions?: true
    maintenanceNotes?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    managerId?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    address?: true
    city?: true
    country?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    surface?: true
    numberOfRooms?: true
    numberOfBedrooms?: true
    numberOfBathrooms?: true
    maxGuests?: true
    floor?: true
    hasElevator?: true
    hasParking?: true
    hasBalcony?: true
    pricePerNight?: true
    cleaningFee?: true
    serviceFee?: true
    securityDeposit?: true
    averageRating?: true
    totalReviews?: true
    checkInTime?: true
    checkOutTime?: true
    cancellationPolicy?: true
    houseRules?: true
    accessInstructions?: true
    cleaningInstructions?: true
    maintenanceNotes?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    managerId?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _avg?: PropertyAvgAggregateInputType
    _sum?: PropertySumAggregateInputType
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: string
    name: string
    description: string
    status: $Enums.PropertyStatus
    address: string
    city: string
    country: string
    postalCode: string | null
    latitude: number | null
    longitude: number | null
    surface: number | null
    numberOfRooms: number | null
    numberOfBedrooms: number | null
    numberOfBathrooms: number | null
    maxGuests: number | null
    floor: number | null
    hasElevator: boolean | null
    hasParking: boolean | null
    hasBalcony: boolean | null
    pricePerNight: number | null
    cleaningFee: number | null
    serviceFee: number | null
    securityDeposit: number | null
    averageRating: number | null
    totalReviews: number
    checkInTime: string | null
    checkOutTime: string | null
    cancellationPolicy: string | null
    houseRules: string | null
    accessInstructions: string | null
    cleaningInstructions: string | null
    maintenanceNotes: string | null
    createdAt: Date
    updatedAt: Date
    ownerId: string
    managerId: string | null
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    surface?: boolean
    numberOfRooms?: boolean
    numberOfBedrooms?: boolean
    numberOfBathrooms?: boolean
    maxGuests?: boolean
    floor?: boolean
    hasElevator?: boolean
    hasParking?: boolean
    hasBalcony?: boolean
    pricePerNight?: boolean
    cleaningFee?: boolean
    serviceFee?: boolean
    securityDeposit?: boolean
    averageRating?: boolean
    totalReviews?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    cancellationPolicy?: boolean
    houseRules?: boolean
    accessInstructions?: boolean
    cleaningInstructions?: boolean
    maintenanceNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    managerId?: boolean
    features?: boolean | Property$featuresArgs<ExtArgs>
    photos?: boolean | Property$photosArgs<ExtArgs>
    owner?: boolean | PropertyOwnerProfileDefaultArgs<ExtArgs>
    manager?: boolean | Property$managerArgs<ExtArgs>
    reservations?: boolean | Property$reservationsArgs<ExtArgs>
    cleaningSessions?: boolean | Property$cleaningSessionsArgs<ExtArgs>
    maintenanceSessions?: boolean | Property$maintenanceSessionsArgs<ExtArgs>
    tickets?: boolean | Property$ticketsArgs<ExtArgs>
    reviews?: boolean | Property$reviewsArgs<ExtArgs>
    contracts?: boolean | Property$contractsArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    surface?: boolean
    numberOfRooms?: boolean
    numberOfBedrooms?: boolean
    numberOfBathrooms?: boolean
    maxGuests?: boolean
    floor?: boolean
    hasElevator?: boolean
    hasParking?: boolean
    hasBalcony?: boolean
    pricePerNight?: boolean
    cleaningFee?: boolean
    serviceFee?: boolean
    securityDeposit?: boolean
    averageRating?: boolean
    totalReviews?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    cancellationPolicy?: boolean
    houseRules?: boolean
    accessInstructions?: boolean
    cleaningInstructions?: boolean
    maintenanceNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    managerId?: boolean
    owner?: boolean | PropertyOwnerProfileDefaultArgs<ExtArgs>
    manager?: boolean | Property$managerArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    surface?: boolean
    numberOfRooms?: boolean
    numberOfBedrooms?: boolean
    numberOfBathrooms?: boolean
    maxGuests?: boolean
    floor?: boolean
    hasElevator?: boolean
    hasParking?: boolean
    hasBalcony?: boolean
    pricePerNight?: boolean
    cleaningFee?: boolean
    serviceFee?: boolean
    securityDeposit?: boolean
    averageRating?: boolean
    totalReviews?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    cancellationPolicy?: boolean
    houseRules?: boolean
    accessInstructions?: boolean
    cleaningInstructions?: boolean
    maintenanceNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    managerId?: boolean
    owner?: boolean | PropertyOwnerProfileDefaultArgs<ExtArgs>
    manager?: boolean | Property$managerArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    surface?: boolean
    numberOfRooms?: boolean
    numberOfBedrooms?: boolean
    numberOfBathrooms?: boolean
    maxGuests?: boolean
    floor?: boolean
    hasElevator?: boolean
    hasParking?: boolean
    hasBalcony?: boolean
    pricePerNight?: boolean
    cleaningFee?: boolean
    serviceFee?: boolean
    securityDeposit?: boolean
    averageRating?: boolean
    totalReviews?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    cancellationPolicy?: boolean
    houseRules?: boolean
    accessInstructions?: boolean
    cleaningInstructions?: boolean
    maintenanceNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    managerId?: boolean
  }

  export type PropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "address" | "city" | "country" | "postalCode" | "latitude" | "longitude" | "surface" | "numberOfRooms" | "numberOfBedrooms" | "numberOfBathrooms" | "maxGuests" | "floor" | "hasElevator" | "hasParking" | "hasBalcony" | "pricePerNight" | "cleaningFee" | "serviceFee" | "securityDeposit" | "averageRating" | "totalReviews" | "checkInTime" | "checkOutTime" | "cancellationPolicy" | "houseRules" | "accessInstructions" | "cleaningInstructions" | "maintenanceNotes" | "createdAt" | "updatedAt" | "ownerId" | "managerId", ExtArgs["result"]["property"]>
  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | Property$featuresArgs<ExtArgs>
    photos?: boolean | Property$photosArgs<ExtArgs>
    owner?: boolean | PropertyOwnerProfileDefaultArgs<ExtArgs>
    manager?: boolean | Property$managerArgs<ExtArgs>
    reservations?: boolean | Property$reservationsArgs<ExtArgs>
    cleaningSessions?: boolean | Property$cleaningSessionsArgs<ExtArgs>
    maintenanceSessions?: boolean | Property$maintenanceSessionsArgs<ExtArgs>
    tickets?: boolean | Property$ticketsArgs<ExtArgs>
    reviews?: boolean | Property$reviewsArgs<ExtArgs>
    contracts?: boolean | Property$contractsArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | PropertyOwnerProfileDefaultArgs<ExtArgs>
    manager?: boolean | Property$managerArgs<ExtArgs>
  }
  export type PropertyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | PropertyOwnerProfileDefaultArgs<ExtArgs>
    manager?: boolean | Property$managerArgs<ExtArgs>
  }

  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      features: Prisma.$PropertyFeaturePayload<ExtArgs>[]
      photos: Prisma.$PropertyPhotoPayload<ExtArgs>[]
      owner: Prisma.$PropertyOwnerProfilePayload<ExtArgs>
      manager: Prisma.$PoleManagerProfilePayload<ExtArgs> | null
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      cleaningSessions: Prisma.$CleaningSessionPayload<ExtArgs>[]
      maintenanceSessions: Prisma.$MaintenanceSessionPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      reviews: Prisma.$PropertyReviewPayload<ExtArgs>[]
      contracts: Prisma.$PropertyContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      status: $Enums.PropertyStatus
      address: string
      city: string
      country: string
      postalCode: string | null
      latitude: number | null
      longitude: number | null
      surface: number | null
      numberOfRooms: number | null
      numberOfBedrooms: number | null
      numberOfBathrooms: number | null
      maxGuests: number | null
      floor: number | null
      hasElevator: boolean | null
      hasParking: boolean | null
      hasBalcony: boolean | null
      pricePerNight: number | null
      cleaningFee: number | null
      serviceFee: number | null
      securityDeposit: number | null
      averageRating: number | null
      totalReviews: number
      checkInTime: string | null
      checkOutTime: string | null
      cancellationPolicy: string | null
      houseRules: string | null
      accessInstructions: string | null
      cleaningInstructions: string | null
      maintenanceNotes: string | null
      createdAt: Date
      updatedAt: Date
      ownerId: string
      managerId: string | null
    }, ExtArgs["result"]["property"]>
    composites: {}
  }

  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFindManyArgs>(args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
     */
    create<T extends PropertyCreateArgs>(args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCreateManyArgs>(args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {PropertyCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
     */
    delete<T extends PropertyDeleteArgs>(args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUpdateArgs>(args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDeleteManyArgs>(args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUpdateManyArgs>(args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties and returns the data updated in the database.
     * @param {PropertyUpdateManyAndReturnArgs} args - Arguments to update many Properties.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    features<T extends Property$featuresArgs<ExtArgs> = {}>(args?: Subset<T, Property$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos<T extends Property$photosArgs<ExtArgs> = {}>(args?: Subset<T, Property$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    owner<T extends PropertyOwnerProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyOwnerProfileDefaultArgs<ExtArgs>>): Prisma__PropertyOwnerProfileClient<$Result.GetResult<Prisma.$PropertyOwnerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    manager<T extends Property$managerArgs<ExtArgs> = {}>(args?: Subset<T, Property$managerArgs<ExtArgs>>): Prisma__PoleManagerProfileClient<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reservations<T extends Property$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Property$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cleaningSessions<T extends Property$cleaningSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Property$cleaningSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maintenanceSessions<T extends Property$maintenanceSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Property$maintenanceSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends Property$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Property$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Property$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Property$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contracts<T extends Property$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Property$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Property model
   */
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'String'>
    readonly name: FieldRef<"Property", 'String'>
    readonly description: FieldRef<"Property", 'String'>
    readonly status: FieldRef<"Property", 'PropertyStatus'>
    readonly address: FieldRef<"Property", 'String'>
    readonly city: FieldRef<"Property", 'String'>
    readonly country: FieldRef<"Property", 'String'>
    readonly postalCode: FieldRef<"Property", 'String'>
    readonly latitude: FieldRef<"Property", 'Float'>
    readonly longitude: FieldRef<"Property", 'Float'>
    readonly surface: FieldRef<"Property", 'Float'>
    readonly numberOfRooms: FieldRef<"Property", 'Int'>
    readonly numberOfBedrooms: FieldRef<"Property", 'Int'>
    readonly numberOfBathrooms: FieldRef<"Property", 'Int'>
    readonly maxGuests: FieldRef<"Property", 'Int'>
    readonly floor: FieldRef<"Property", 'Int'>
    readonly hasElevator: FieldRef<"Property", 'Boolean'>
    readonly hasParking: FieldRef<"Property", 'Boolean'>
    readonly hasBalcony: FieldRef<"Property", 'Boolean'>
    readonly pricePerNight: FieldRef<"Property", 'Float'>
    readonly cleaningFee: FieldRef<"Property", 'Float'>
    readonly serviceFee: FieldRef<"Property", 'Float'>
    readonly securityDeposit: FieldRef<"Property", 'Float'>
    readonly averageRating: FieldRef<"Property", 'Float'>
    readonly totalReviews: FieldRef<"Property", 'Int'>
    readonly checkInTime: FieldRef<"Property", 'String'>
    readonly checkOutTime: FieldRef<"Property", 'String'>
    readonly cancellationPolicy: FieldRef<"Property", 'String'>
    readonly houseRules: FieldRef<"Property", 'String'>
    readonly accessInstructions: FieldRef<"Property", 'String'>
    readonly cleaningInstructions: FieldRef<"Property", 'String'>
    readonly maintenanceNotes: FieldRef<"Property", 'String'>
    readonly createdAt: FieldRef<"Property", 'DateTime'>
    readonly updatedAt: FieldRef<"Property", 'DateTime'>
    readonly ownerId: FieldRef<"Property", 'String'>
    readonly managerId: FieldRef<"Property", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Property createManyAndReturn
   */
  export type PropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
  }

  /**
   * Property updateManyAndReturn
   */
  export type PropertyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to delete.
     */
    limit?: number
  }

  /**
   * Property.features
   */
  export type Property$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    where?: PropertyFeatureWhereInput
    orderBy?: PropertyFeatureOrderByWithRelationInput | PropertyFeatureOrderByWithRelationInput[]
    cursor?: PropertyFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyFeatureScalarFieldEnum | PropertyFeatureScalarFieldEnum[]
  }

  /**
   * Property.photos
   */
  export type Property$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    where?: PropertyPhotoWhereInput
    orderBy?: PropertyPhotoOrderByWithRelationInput | PropertyPhotoOrderByWithRelationInput[]
    cursor?: PropertyPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyPhotoScalarFieldEnum | PropertyPhotoScalarFieldEnum[]
  }

  /**
   * Property.manager
   */
  export type Property$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoleManagerProfile
     */
    select?: PoleManagerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoleManagerProfile
     */
    omit?: PoleManagerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoleManagerProfileInclude<ExtArgs> | null
    where?: PoleManagerProfileWhereInput
  }

  /**
   * Property.reservations
   */
  export type Property$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Property.cleaningSessions
   */
  export type Property$cleaningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    where?: CleaningSessionWhereInput
    orderBy?: CleaningSessionOrderByWithRelationInput | CleaningSessionOrderByWithRelationInput[]
    cursor?: CleaningSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningSessionScalarFieldEnum | CleaningSessionScalarFieldEnum[]
  }

  /**
   * Property.maintenanceSessions
   */
  export type Property$maintenanceSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    where?: MaintenanceSessionWhereInput
    orderBy?: MaintenanceSessionOrderByWithRelationInput | MaintenanceSessionOrderByWithRelationInput[]
    cursor?: MaintenanceSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceSessionScalarFieldEnum | MaintenanceSessionScalarFieldEnum[]
  }

  /**
   * Property.tickets
   */
  export type Property$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Property.reviews
   */
  export type Property$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyReview
     */
    select?: PropertyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyReview
     */
    omit?: PropertyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyReviewInclude<ExtArgs> | null
    where?: PropertyReviewWhereInput
    orderBy?: PropertyReviewOrderByWithRelationInput | PropertyReviewOrderByWithRelationInput[]
    cursor?: PropertyReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyReviewScalarFieldEnum | PropertyReviewScalarFieldEnum[]
  }

  /**
   * Property.contracts
   */
  export type Property$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContract
     */
    select?: PropertyContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContract
     */
    omit?: PropertyContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContractInclude<ExtArgs> | null
    where?: PropertyContractWhereInput
    orderBy?: PropertyContractOrderByWithRelationInput | PropertyContractOrderByWithRelationInput[]
    cursor?: PropertyContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyContractScalarFieldEnum | PropertyContractScalarFieldEnum[]
  }

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
  }


  /**
   * Model PropertyFeature
   */

  export type AggregatePropertyFeature = {
    _count: PropertyFeatureCountAggregateOutputType | null
    _min: PropertyFeatureMinAggregateOutputType | null
    _max: PropertyFeatureMaxAggregateOutputType | null
  }

  export type PropertyFeatureMinAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    category: string | null
    propertyId: string | null
  }

  export type PropertyFeatureMaxAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    category: string | null
    propertyId: string | null
  }

  export type PropertyFeatureCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    category: number
    propertyId: number
    _all: number
  }


  export type PropertyFeatureMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    category?: true
    propertyId?: true
  }

  export type PropertyFeatureMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    category?: true
    propertyId?: true
  }

  export type PropertyFeatureCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    category?: true
    propertyId?: true
    _all?: true
  }

  export type PropertyFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyFeature to aggregate.
     */
    where?: PropertyFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyFeatures to fetch.
     */
    orderBy?: PropertyFeatureOrderByWithRelationInput | PropertyFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyFeatures
    **/
    _count?: true | PropertyFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyFeatureMaxAggregateInputType
  }

  export type GetPropertyFeatureAggregateType<T extends PropertyFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyFeature[P]>
      : GetScalarType<T[P], AggregatePropertyFeature[P]>
  }




  export type PropertyFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyFeatureWhereInput
    orderBy?: PropertyFeatureOrderByWithAggregationInput | PropertyFeatureOrderByWithAggregationInput[]
    by: PropertyFeatureScalarFieldEnum[] | PropertyFeatureScalarFieldEnum
    having?: PropertyFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyFeatureCountAggregateInputType | true
    _min?: PropertyFeatureMinAggregateInputType
    _max?: PropertyFeatureMaxAggregateInputType
  }

  export type PropertyFeatureGroupByOutputType = {
    id: string
    name: string
    icon: string | null
    category: string | null
    propertyId: string
    _count: PropertyFeatureCountAggregateOutputType | null
    _min: PropertyFeatureMinAggregateOutputType | null
    _max: PropertyFeatureMaxAggregateOutputType | null
  }

  type GetPropertyFeatureGroupByPayload<T extends PropertyFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyFeatureGroupByOutputType[P]>
        }
      >
    >


  export type PropertyFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    category?: boolean
    propertyId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyFeature"]>

  export type PropertyFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    category?: boolean
    propertyId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyFeature"]>

  export type PropertyFeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    category?: boolean
    propertyId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyFeature"]>

  export type PropertyFeatureSelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    category?: boolean
    propertyId?: boolean
  }

  export type PropertyFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "icon" | "category" | "propertyId", ExtArgs["result"]["propertyFeature"]>
  export type PropertyFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyFeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyFeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyFeature"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      icon: string | null
      category: string | null
      propertyId: string
    }, ExtArgs["result"]["propertyFeature"]>
    composites: {}
  }

  type PropertyFeatureGetPayload<S extends boolean | null | undefined | PropertyFeatureDefaultArgs> = $Result.GetResult<Prisma.$PropertyFeaturePayload, S>

  type PropertyFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyFeatureCountAggregateInputType | true
    }

  export interface PropertyFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyFeature'], meta: { name: 'PropertyFeature' } }
    /**
     * Find zero or one PropertyFeature that matches the filter.
     * @param {PropertyFeatureFindUniqueArgs} args - Arguments to find a PropertyFeature
     * @example
     * // Get one PropertyFeature
     * const propertyFeature = await prisma.propertyFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFeatureFindUniqueArgs>(args: SelectSubset<T, PropertyFeatureFindUniqueArgs<ExtArgs>>): Prisma__PropertyFeatureClient<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFeatureFindUniqueOrThrowArgs} args - Arguments to find a PropertyFeature
     * @example
     * // Get one PropertyFeature
     * const propertyFeature = await prisma.propertyFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyFeatureClient<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFeatureFindFirstArgs} args - Arguments to find a PropertyFeature
     * @example
     * // Get one PropertyFeature
     * const propertyFeature = await prisma.propertyFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFeatureFindFirstArgs>(args?: SelectSubset<T, PropertyFeatureFindFirstArgs<ExtArgs>>): Prisma__PropertyFeatureClient<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFeatureFindFirstOrThrowArgs} args - Arguments to find a PropertyFeature
     * @example
     * // Get one PropertyFeature
     * const propertyFeature = await prisma.propertyFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyFeatureClient<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyFeatures
     * const propertyFeatures = await prisma.propertyFeature.findMany()
     * 
     * // Get first 10 PropertyFeatures
     * const propertyFeatures = await prisma.propertyFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyFeatureWithIdOnly = await prisma.propertyFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFeatureFindManyArgs>(args?: SelectSubset<T, PropertyFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyFeature.
     * @param {PropertyFeatureCreateArgs} args - Arguments to create a PropertyFeature.
     * @example
     * // Create one PropertyFeature
     * const PropertyFeature = await prisma.propertyFeature.create({
     *   data: {
     *     // ... data to create a PropertyFeature
     *   }
     * })
     * 
     */
    create<T extends PropertyFeatureCreateArgs>(args: SelectSubset<T, PropertyFeatureCreateArgs<ExtArgs>>): Prisma__PropertyFeatureClient<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyFeatures.
     * @param {PropertyFeatureCreateManyArgs} args - Arguments to create many PropertyFeatures.
     * @example
     * // Create many PropertyFeatures
     * const propertyFeature = await prisma.propertyFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyFeatureCreateManyArgs>(args?: SelectSubset<T, PropertyFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyFeatures and returns the data saved in the database.
     * @param {PropertyFeatureCreateManyAndReturnArgs} args - Arguments to create many PropertyFeatures.
     * @example
     * // Create many PropertyFeatures
     * const propertyFeature = await prisma.propertyFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyFeatures and only return the `id`
     * const propertyFeatureWithIdOnly = await prisma.propertyFeature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyFeature.
     * @param {PropertyFeatureDeleteArgs} args - Arguments to delete one PropertyFeature.
     * @example
     * // Delete one PropertyFeature
     * const PropertyFeature = await prisma.propertyFeature.delete({
     *   where: {
     *     // ... filter to delete one PropertyFeature
     *   }
     * })
     * 
     */
    delete<T extends PropertyFeatureDeleteArgs>(args: SelectSubset<T, PropertyFeatureDeleteArgs<ExtArgs>>): Prisma__PropertyFeatureClient<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyFeature.
     * @param {PropertyFeatureUpdateArgs} args - Arguments to update one PropertyFeature.
     * @example
     * // Update one PropertyFeature
     * const propertyFeature = await prisma.propertyFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyFeatureUpdateArgs>(args: SelectSubset<T, PropertyFeatureUpdateArgs<ExtArgs>>): Prisma__PropertyFeatureClient<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyFeatures.
     * @param {PropertyFeatureDeleteManyArgs} args - Arguments to filter PropertyFeatures to delete.
     * @example
     * // Delete a few PropertyFeatures
     * const { count } = await prisma.propertyFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyFeatureDeleteManyArgs>(args?: SelectSubset<T, PropertyFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyFeatures
     * const propertyFeature = await prisma.propertyFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyFeatureUpdateManyArgs>(args: SelectSubset<T, PropertyFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyFeatures and returns the data updated in the database.
     * @param {PropertyFeatureUpdateManyAndReturnArgs} args - Arguments to update many PropertyFeatures.
     * @example
     * // Update many PropertyFeatures
     * const propertyFeature = await prisma.propertyFeature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyFeatures and only return the `id`
     * const propertyFeatureWithIdOnly = await prisma.propertyFeature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyFeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyFeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyFeature.
     * @param {PropertyFeatureUpsertArgs} args - Arguments to update or create a PropertyFeature.
     * @example
     * // Update or create a PropertyFeature
     * const propertyFeature = await prisma.propertyFeature.upsert({
     *   create: {
     *     // ... data to create a PropertyFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyFeature we want to update
     *   }
     * })
     */
    upsert<T extends PropertyFeatureUpsertArgs>(args: SelectSubset<T, PropertyFeatureUpsertArgs<ExtArgs>>): Prisma__PropertyFeatureClient<$Result.GetResult<Prisma.$PropertyFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFeatureCountArgs} args - Arguments to filter PropertyFeatures to count.
     * @example
     * // Count the number of PropertyFeatures
     * const count = await prisma.propertyFeature.count({
     *   where: {
     *     // ... the filter for the PropertyFeatures we want to count
     *   }
     * })
    **/
    count<T extends PropertyFeatureCountArgs>(
      args?: Subset<T, PropertyFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyFeatureAggregateArgs>(args: Subset<T, PropertyFeatureAggregateArgs>): Prisma.PrismaPromise<GetPropertyFeatureAggregateType<T>>

    /**
     * Group by PropertyFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyFeatureGroupByArgs['orderBy'] }
        : { orderBy?: PropertyFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyFeature model
   */
  readonly fields: PropertyFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyFeature model
   */
  interface PropertyFeatureFieldRefs {
    readonly id: FieldRef<"PropertyFeature", 'String'>
    readonly name: FieldRef<"PropertyFeature", 'String'>
    readonly icon: FieldRef<"PropertyFeature", 'String'>
    readonly category: FieldRef<"PropertyFeature", 'String'>
    readonly propertyId: FieldRef<"PropertyFeature", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PropertyFeature findUnique
   */
  export type PropertyFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PropertyFeature to fetch.
     */
    where: PropertyFeatureWhereUniqueInput
  }

  /**
   * PropertyFeature findUniqueOrThrow
   */
  export type PropertyFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PropertyFeature to fetch.
     */
    where: PropertyFeatureWhereUniqueInput
  }

  /**
   * PropertyFeature findFirst
   */
  export type PropertyFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PropertyFeature to fetch.
     */
    where?: PropertyFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyFeatures to fetch.
     */
    orderBy?: PropertyFeatureOrderByWithRelationInput | PropertyFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyFeatures.
     */
    cursor?: PropertyFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyFeatures.
     */
    distinct?: PropertyFeatureScalarFieldEnum | PropertyFeatureScalarFieldEnum[]
  }

  /**
   * PropertyFeature findFirstOrThrow
   */
  export type PropertyFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PropertyFeature to fetch.
     */
    where?: PropertyFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyFeatures to fetch.
     */
    orderBy?: PropertyFeatureOrderByWithRelationInput | PropertyFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyFeatures.
     */
    cursor?: PropertyFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyFeatures.
     */
    distinct?: PropertyFeatureScalarFieldEnum | PropertyFeatureScalarFieldEnum[]
  }

  /**
   * PropertyFeature findMany
   */
  export type PropertyFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * Filter, which PropertyFeatures to fetch.
     */
    where?: PropertyFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyFeatures to fetch.
     */
    orderBy?: PropertyFeatureOrderByWithRelationInput | PropertyFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyFeatures.
     */
    cursor?: PropertyFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyFeatures.
     */
    skip?: number
    distinct?: PropertyFeatureScalarFieldEnum | PropertyFeatureScalarFieldEnum[]
  }

  /**
   * PropertyFeature create
   */
  export type PropertyFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyFeature.
     */
    data: XOR<PropertyFeatureCreateInput, PropertyFeatureUncheckedCreateInput>
  }

  /**
   * PropertyFeature createMany
   */
  export type PropertyFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyFeatures.
     */
    data: PropertyFeatureCreateManyInput | PropertyFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyFeature createManyAndReturn
   */
  export type PropertyFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyFeatures.
     */
    data: PropertyFeatureCreateManyInput | PropertyFeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyFeature update
   */
  export type PropertyFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyFeature.
     */
    data: XOR<PropertyFeatureUpdateInput, PropertyFeatureUncheckedUpdateInput>
    /**
     * Choose, which PropertyFeature to update.
     */
    where: PropertyFeatureWhereUniqueInput
  }

  /**
   * PropertyFeature updateMany
   */
  export type PropertyFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyFeatures.
     */
    data: XOR<PropertyFeatureUpdateManyMutationInput, PropertyFeatureUncheckedUpdateManyInput>
    /**
     * Filter which PropertyFeatures to update
     */
    where?: PropertyFeatureWhereInput
    /**
     * Limit how many PropertyFeatures to update.
     */
    limit?: number
  }

  /**
   * PropertyFeature updateManyAndReturn
   */
  export type PropertyFeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * The data used to update PropertyFeatures.
     */
    data: XOR<PropertyFeatureUpdateManyMutationInput, PropertyFeatureUncheckedUpdateManyInput>
    /**
     * Filter which PropertyFeatures to update
     */
    where?: PropertyFeatureWhereInput
    /**
     * Limit how many PropertyFeatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyFeature upsert
   */
  export type PropertyFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyFeature to update in case it exists.
     */
    where: PropertyFeatureWhereUniqueInput
    /**
     * In case the PropertyFeature found by the `where` argument doesn't exist, create a new PropertyFeature with this data.
     */
    create: XOR<PropertyFeatureCreateInput, PropertyFeatureUncheckedCreateInput>
    /**
     * In case the PropertyFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyFeatureUpdateInput, PropertyFeatureUncheckedUpdateInput>
  }

  /**
   * PropertyFeature delete
   */
  export type PropertyFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
    /**
     * Filter which PropertyFeature to delete.
     */
    where: PropertyFeatureWhereUniqueInput
  }

  /**
   * PropertyFeature deleteMany
   */
  export type PropertyFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyFeatures to delete
     */
    where?: PropertyFeatureWhereInput
    /**
     * Limit how many PropertyFeatures to delete.
     */
    limit?: number
  }

  /**
   * PropertyFeature without action
   */
  export type PropertyFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyFeature
     */
    select?: PropertyFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyFeature
     */
    omit?: PropertyFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyFeatureInclude<ExtArgs> | null
  }


  /**
   * Model PropertyPhoto
   */

  export type AggregatePropertyPhoto = {
    _count: PropertyPhotoCountAggregateOutputType | null
    _avg: PropertyPhotoAvgAggregateOutputType | null
    _sum: PropertyPhotoSumAggregateOutputType | null
    _min: PropertyPhotoMinAggregateOutputType | null
    _max: PropertyPhotoMaxAggregateOutputType | null
  }

  export type PropertyPhotoAvgAggregateOutputType = {
    order: number | null
  }

  export type PropertyPhotoSumAggregateOutputType = {
    order: number | null
  }

  export type PropertyPhotoMinAggregateOutputType = {
    id: string | null
    url: string | null
    caption: string | null
    isMain: boolean | null
    order: number | null
    type: string | null
    propertyId: string | null
    createdAt: Date | null
  }

  export type PropertyPhotoMaxAggregateOutputType = {
    id: string | null
    url: string | null
    caption: string | null
    isMain: boolean | null
    order: number | null
    type: string | null
    propertyId: string | null
    createdAt: Date | null
  }

  export type PropertyPhotoCountAggregateOutputType = {
    id: number
    url: number
    caption: number
    isMain: number
    order: number
    type: number
    propertyId: number
    createdAt: number
    _all: number
  }


  export type PropertyPhotoAvgAggregateInputType = {
    order?: true
  }

  export type PropertyPhotoSumAggregateInputType = {
    order?: true
  }

  export type PropertyPhotoMinAggregateInputType = {
    id?: true
    url?: true
    caption?: true
    isMain?: true
    order?: true
    type?: true
    propertyId?: true
    createdAt?: true
  }

  export type PropertyPhotoMaxAggregateInputType = {
    id?: true
    url?: true
    caption?: true
    isMain?: true
    order?: true
    type?: true
    propertyId?: true
    createdAt?: true
  }

  export type PropertyPhotoCountAggregateInputType = {
    id?: true
    url?: true
    caption?: true
    isMain?: true
    order?: true
    type?: true
    propertyId?: true
    createdAt?: true
    _all?: true
  }

  export type PropertyPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyPhoto to aggregate.
     */
    where?: PropertyPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPhotos to fetch.
     */
    orderBy?: PropertyPhotoOrderByWithRelationInput | PropertyPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyPhotos
    **/
    _count?: true | PropertyPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyPhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyPhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyPhotoMaxAggregateInputType
  }

  export type GetPropertyPhotoAggregateType<T extends PropertyPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyPhoto[P]>
      : GetScalarType<T[P], AggregatePropertyPhoto[P]>
  }




  export type PropertyPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyPhotoWhereInput
    orderBy?: PropertyPhotoOrderByWithAggregationInput | PropertyPhotoOrderByWithAggregationInput[]
    by: PropertyPhotoScalarFieldEnum[] | PropertyPhotoScalarFieldEnum
    having?: PropertyPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyPhotoCountAggregateInputType | true
    _avg?: PropertyPhotoAvgAggregateInputType
    _sum?: PropertyPhotoSumAggregateInputType
    _min?: PropertyPhotoMinAggregateInputType
    _max?: PropertyPhotoMaxAggregateInputType
  }

  export type PropertyPhotoGroupByOutputType = {
    id: string
    url: string
    caption: string | null
    isMain: boolean
    order: number
    type: string | null
    propertyId: string
    createdAt: Date
    _count: PropertyPhotoCountAggregateOutputType | null
    _avg: PropertyPhotoAvgAggregateOutputType | null
    _sum: PropertyPhotoSumAggregateOutputType | null
    _min: PropertyPhotoMinAggregateOutputType | null
    _max: PropertyPhotoMaxAggregateOutputType | null
  }

  type GetPropertyPhotoGroupByPayload<T extends PropertyPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyPhotoGroupByOutputType[P]>
        }
      >
    >


  export type PropertyPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    caption?: boolean
    isMain?: boolean
    order?: boolean
    type?: boolean
    propertyId?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyPhoto"]>

  export type PropertyPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    caption?: boolean
    isMain?: boolean
    order?: boolean
    type?: boolean
    propertyId?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyPhoto"]>

  export type PropertyPhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    caption?: boolean
    isMain?: boolean
    order?: boolean
    type?: boolean
    propertyId?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyPhoto"]>

  export type PropertyPhotoSelectScalar = {
    id?: boolean
    url?: boolean
    caption?: boolean
    isMain?: boolean
    order?: boolean
    type?: boolean
    propertyId?: boolean
    createdAt?: boolean
  }

  export type PropertyPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "caption" | "isMain" | "order" | "type" | "propertyId" | "createdAt", ExtArgs["result"]["propertyPhoto"]>
  export type PropertyPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyPhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyPhoto"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      caption: string | null
      isMain: boolean
      order: number
      type: string | null
      propertyId: string
      createdAt: Date
    }, ExtArgs["result"]["propertyPhoto"]>
    composites: {}
  }

  type PropertyPhotoGetPayload<S extends boolean | null | undefined | PropertyPhotoDefaultArgs> = $Result.GetResult<Prisma.$PropertyPhotoPayload, S>

  type PropertyPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyPhotoCountAggregateInputType | true
    }

  export interface PropertyPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyPhoto'], meta: { name: 'PropertyPhoto' } }
    /**
     * Find zero or one PropertyPhoto that matches the filter.
     * @param {PropertyPhotoFindUniqueArgs} args - Arguments to find a PropertyPhoto
     * @example
     * // Get one PropertyPhoto
     * const propertyPhoto = await prisma.propertyPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyPhotoFindUniqueArgs>(args: SelectSubset<T, PropertyPhotoFindUniqueArgs<ExtArgs>>): Prisma__PropertyPhotoClient<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyPhotoFindUniqueOrThrowArgs} args - Arguments to find a PropertyPhoto
     * @example
     * // Get one PropertyPhoto
     * const propertyPhoto = await prisma.propertyPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyPhotoClient<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPhotoFindFirstArgs} args - Arguments to find a PropertyPhoto
     * @example
     * // Get one PropertyPhoto
     * const propertyPhoto = await prisma.propertyPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyPhotoFindFirstArgs>(args?: SelectSubset<T, PropertyPhotoFindFirstArgs<ExtArgs>>): Prisma__PropertyPhotoClient<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPhotoFindFirstOrThrowArgs} args - Arguments to find a PropertyPhoto
     * @example
     * // Get one PropertyPhoto
     * const propertyPhoto = await prisma.propertyPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyPhotoClient<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyPhotos
     * const propertyPhotos = await prisma.propertyPhoto.findMany()
     * 
     * // Get first 10 PropertyPhotos
     * const propertyPhotos = await prisma.propertyPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyPhotoWithIdOnly = await prisma.propertyPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyPhotoFindManyArgs>(args?: SelectSubset<T, PropertyPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyPhoto.
     * @param {PropertyPhotoCreateArgs} args - Arguments to create a PropertyPhoto.
     * @example
     * // Create one PropertyPhoto
     * const PropertyPhoto = await prisma.propertyPhoto.create({
     *   data: {
     *     // ... data to create a PropertyPhoto
     *   }
     * })
     * 
     */
    create<T extends PropertyPhotoCreateArgs>(args: SelectSubset<T, PropertyPhotoCreateArgs<ExtArgs>>): Prisma__PropertyPhotoClient<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyPhotos.
     * @param {PropertyPhotoCreateManyArgs} args - Arguments to create many PropertyPhotos.
     * @example
     * // Create many PropertyPhotos
     * const propertyPhoto = await prisma.propertyPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyPhotoCreateManyArgs>(args?: SelectSubset<T, PropertyPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyPhotos and returns the data saved in the database.
     * @param {PropertyPhotoCreateManyAndReturnArgs} args - Arguments to create many PropertyPhotos.
     * @example
     * // Create many PropertyPhotos
     * const propertyPhoto = await prisma.propertyPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyPhotos and only return the `id`
     * const propertyPhotoWithIdOnly = await prisma.propertyPhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyPhoto.
     * @param {PropertyPhotoDeleteArgs} args - Arguments to delete one PropertyPhoto.
     * @example
     * // Delete one PropertyPhoto
     * const PropertyPhoto = await prisma.propertyPhoto.delete({
     *   where: {
     *     // ... filter to delete one PropertyPhoto
     *   }
     * })
     * 
     */
    delete<T extends PropertyPhotoDeleteArgs>(args: SelectSubset<T, PropertyPhotoDeleteArgs<ExtArgs>>): Prisma__PropertyPhotoClient<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyPhoto.
     * @param {PropertyPhotoUpdateArgs} args - Arguments to update one PropertyPhoto.
     * @example
     * // Update one PropertyPhoto
     * const propertyPhoto = await prisma.propertyPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyPhotoUpdateArgs>(args: SelectSubset<T, PropertyPhotoUpdateArgs<ExtArgs>>): Prisma__PropertyPhotoClient<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyPhotos.
     * @param {PropertyPhotoDeleteManyArgs} args - Arguments to filter PropertyPhotos to delete.
     * @example
     * // Delete a few PropertyPhotos
     * const { count } = await prisma.propertyPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyPhotoDeleteManyArgs>(args?: SelectSubset<T, PropertyPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyPhotos
     * const propertyPhoto = await prisma.propertyPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyPhotoUpdateManyArgs>(args: SelectSubset<T, PropertyPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyPhotos and returns the data updated in the database.
     * @param {PropertyPhotoUpdateManyAndReturnArgs} args - Arguments to update many PropertyPhotos.
     * @example
     * // Update many PropertyPhotos
     * const propertyPhoto = await prisma.propertyPhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyPhotos and only return the `id`
     * const propertyPhotoWithIdOnly = await prisma.propertyPhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyPhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyPhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyPhoto.
     * @param {PropertyPhotoUpsertArgs} args - Arguments to update or create a PropertyPhoto.
     * @example
     * // Update or create a PropertyPhoto
     * const propertyPhoto = await prisma.propertyPhoto.upsert({
     *   create: {
     *     // ... data to create a PropertyPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyPhoto we want to update
     *   }
     * })
     */
    upsert<T extends PropertyPhotoUpsertArgs>(args: SelectSubset<T, PropertyPhotoUpsertArgs<ExtArgs>>): Prisma__PropertyPhotoClient<$Result.GetResult<Prisma.$PropertyPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPhotoCountArgs} args - Arguments to filter PropertyPhotos to count.
     * @example
     * // Count the number of PropertyPhotos
     * const count = await prisma.propertyPhoto.count({
     *   where: {
     *     // ... the filter for the PropertyPhotos we want to count
     *   }
     * })
    **/
    count<T extends PropertyPhotoCountArgs>(
      args?: Subset<T, PropertyPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyPhotoAggregateArgs>(args: Subset<T, PropertyPhotoAggregateArgs>): Prisma.PrismaPromise<GetPropertyPhotoAggregateType<T>>

    /**
     * Group by PropertyPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyPhotoGroupByArgs['orderBy'] }
        : { orderBy?: PropertyPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyPhoto model
   */
  readonly fields: PropertyPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyPhoto model
   */
  interface PropertyPhotoFieldRefs {
    readonly id: FieldRef<"PropertyPhoto", 'String'>
    readonly url: FieldRef<"PropertyPhoto", 'String'>
    readonly caption: FieldRef<"PropertyPhoto", 'String'>
    readonly isMain: FieldRef<"PropertyPhoto", 'Boolean'>
    readonly order: FieldRef<"PropertyPhoto", 'Int'>
    readonly type: FieldRef<"PropertyPhoto", 'String'>
    readonly propertyId: FieldRef<"PropertyPhoto", 'String'>
    readonly createdAt: FieldRef<"PropertyPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyPhoto findUnique
   */
  export type PropertyPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPhoto to fetch.
     */
    where: PropertyPhotoWhereUniqueInput
  }

  /**
   * PropertyPhoto findUniqueOrThrow
   */
  export type PropertyPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPhoto to fetch.
     */
    where: PropertyPhotoWhereUniqueInput
  }

  /**
   * PropertyPhoto findFirst
   */
  export type PropertyPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPhoto to fetch.
     */
    where?: PropertyPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPhotos to fetch.
     */
    orderBy?: PropertyPhotoOrderByWithRelationInput | PropertyPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyPhotos.
     */
    cursor?: PropertyPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyPhotos.
     */
    distinct?: PropertyPhotoScalarFieldEnum | PropertyPhotoScalarFieldEnum[]
  }

  /**
   * PropertyPhoto findFirstOrThrow
   */
  export type PropertyPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPhoto to fetch.
     */
    where?: PropertyPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPhotos to fetch.
     */
    orderBy?: PropertyPhotoOrderByWithRelationInput | PropertyPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyPhotos.
     */
    cursor?: PropertyPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyPhotos.
     */
    distinct?: PropertyPhotoScalarFieldEnum | PropertyPhotoScalarFieldEnum[]
  }

  /**
   * PropertyPhoto findMany
   */
  export type PropertyPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPhotos to fetch.
     */
    where?: PropertyPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPhotos to fetch.
     */
    orderBy?: PropertyPhotoOrderByWithRelationInput | PropertyPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyPhotos.
     */
    cursor?: PropertyPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPhotos.
     */
    skip?: number
    distinct?: PropertyPhotoScalarFieldEnum | PropertyPhotoScalarFieldEnum[]
  }

  /**
   * PropertyPhoto create
   */
  export type PropertyPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyPhoto.
     */
    data: XOR<PropertyPhotoCreateInput, PropertyPhotoUncheckedCreateInput>
  }

  /**
   * PropertyPhoto createMany
   */
  export type PropertyPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyPhotos.
     */
    data: PropertyPhotoCreateManyInput | PropertyPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyPhoto createManyAndReturn
   */
  export type PropertyPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyPhotos.
     */
    data: PropertyPhotoCreateManyInput | PropertyPhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyPhoto update
   */
  export type PropertyPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyPhoto.
     */
    data: XOR<PropertyPhotoUpdateInput, PropertyPhotoUncheckedUpdateInput>
    /**
     * Choose, which PropertyPhoto to update.
     */
    where: PropertyPhotoWhereUniqueInput
  }

  /**
   * PropertyPhoto updateMany
   */
  export type PropertyPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyPhotos.
     */
    data: XOR<PropertyPhotoUpdateManyMutationInput, PropertyPhotoUncheckedUpdateManyInput>
    /**
     * Filter which PropertyPhotos to update
     */
    where?: PropertyPhotoWhereInput
    /**
     * Limit how many PropertyPhotos to update.
     */
    limit?: number
  }

  /**
   * PropertyPhoto updateManyAndReturn
   */
  export type PropertyPhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * The data used to update PropertyPhotos.
     */
    data: XOR<PropertyPhotoUpdateManyMutationInput, PropertyPhotoUncheckedUpdateManyInput>
    /**
     * Filter which PropertyPhotos to update
     */
    where?: PropertyPhotoWhereInput
    /**
     * Limit how many PropertyPhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyPhoto upsert
   */
  export type PropertyPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyPhoto to update in case it exists.
     */
    where: PropertyPhotoWhereUniqueInput
    /**
     * In case the PropertyPhoto found by the `where` argument doesn't exist, create a new PropertyPhoto with this data.
     */
    create: XOR<PropertyPhotoCreateInput, PropertyPhotoUncheckedCreateInput>
    /**
     * In case the PropertyPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyPhotoUpdateInput, PropertyPhotoUncheckedUpdateInput>
  }

  /**
   * PropertyPhoto delete
   */
  export type PropertyPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
    /**
     * Filter which PropertyPhoto to delete.
     */
    where: PropertyPhotoWhereUniqueInput
  }

  /**
   * PropertyPhoto deleteMany
   */
  export type PropertyPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyPhotos to delete
     */
    where?: PropertyPhotoWhereInput
    /**
     * Limit how many PropertyPhotos to delete.
     */
    limit?: number
  }

  /**
   * PropertyPhoto without action
   */
  export type PropertyPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPhoto
     */
    select?: PropertyPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPhoto
     */
    omit?: PropertyPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPhotoInclude<ExtArgs> | null
  }


  /**
   * Model PropertyReview
   */

  export type AggregatePropertyReview = {
    _count: PropertyReviewCountAggregateOutputType | null
    _avg: PropertyReviewAvgAggregateOutputType | null
    _sum: PropertyReviewSumAggregateOutputType | null
    _min: PropertyReviewMinAggregateOutputType | null
    _max: PropertyReviewMaxAggregateOutputType | null
  }

  export type PropertyReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type PropertyReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type PropertyReviewMinAggregateOutputType = {
    id: string | null
    rating: number | null
    comment: string | null
    guestName: string | null
    guestEmail: string | null
    propertyId: string | null
    createdAt: Date | null
  }

  export type PropertyReviewMaxAggregateOutputType = {
    id: string | null
    rating: number | null
    comment: string | null
    guestName: string | null
    guestEmail: string | null
    propertyId: string | null
    createdAt: Date | null
  }

  export type PropertyReviewCountAggregateOutputType = {
    id: number
    rating: number
    comment: number
    guestName: number
    guestEmail: number
    propertyId: number
    createdAt: number
    _all: number
  }


  export type PropertyReviewAvgAggregateInputType = {
    rating?: true
  }

  export type PropertyReviewSumAggregateInputType = {
    rating?: true
  }

  export type PropertyReviewMinAggregateInputType = {
    id?: true
    rating?: true
    comment?: true
    guestName?: true
    guestEmail?: true
    propertyId?: true
    createdAt?: true
  }

  export type PropertyReviewMaxAggregateInputType = {
    id?: true
    rating?: true
    comment?: true
    guestName?: true
    guestEmail?: true
    propertyId?: true
    createdAt?: true
  }

  export type PropertyReviewCountAggregateInputType = {
    id?: true
    rating?: true
    comment?: true
    guestName?: true
    guestEmail?: true
    propertyId?: true
    createdAt?: true
    _all?: true
  }

  export type PropertyReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyReview to aggregate.
     */
    where?: PropertyReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyReviews to fetch.
     */
    orderBy?: PropertyReviewOrderByWithRelationInput | PropertyReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyReviews
    **/
    _count?: true | PropertyReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyReviewMaxAggregateInputType
  }

  export type GetPropertyReviewAggregateType<T extends PropertyReviewAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyReview[P]>
      : GetScalarType<T[P], AggregatePropertyReview[P]>
  }




  export type PropertyReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyReviewWhereInput
    orderBy?: PropertyReviewOrderByWithAggregationInput | PropertyReviewOrderByWithAggregationInput[]
    by: PropertyReviewScalarFieldEnum[] | PropertyReviewScalarFieldEnum
    having?: PropertyReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyReviewCountAggregateInputType | true
    _avg?: PropertyReviewAvgAggregateInputType
    _sum?: PropertyReviewSumAggregateInputType
    _min?: PropertyReviewMinAggregateInputType
    _max?: PropertyReviewMaxAggregateInputType
  }

  export type PropertyReviewGroupByOutputType = {
    id: string
    rating: number
    comment: string | null
    guestName: string
    guestEmail: string | null
    propertyId: string
    createdAt: Date
    _count: PropertyReviewCountAggregateOutputType | null
    _avg: PropertyReviewAvgAggregateOutputType | null
    _sum: PropertyReviewSumAggregateOutputType | null
    _min: PropertyReviewMinAggregateOutputType | null
    _max: PropertyReviewMaxAggregateOutputType | null
  }

  type GetPropertyReviewGroupByPayload<T extends PropertyReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyReviewGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyReviewGroupByOutputType[P]>
        }
      >
    >


  export type PropertyReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    comment?: boolean
    guestName?: boolean
    guestEmail?: boolean
    propertyId?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyReview"]>

  export type PropertyReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    comment?: boolean
    guestName?: boolean
    guestEmail?: boolean
    propertyId?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyReview"]>

  export type PropertyReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    comment?: boolean
    guestName?: boolean
    guestEmail?: boolean
    propertyId?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyReview"]>

  export type PropertyReviewSelectScalar = {
    id?: boolean
    rating?: boolean
    comment?: boolean
    guestName?: boolean
    guestEmail?: boolean
    propertyId?: boolean
    createdAt?: boolean
  }

  export type PropertyReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rating" | "comment" | "guestName" | "guestEmail" | "propertyId" | "createdAt", ExtArgs["result"]["propertyReview"]>
  export type PropertyReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyReview"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rating: number
      comment: string | null
      guestName: string
      guestEmail: string | null
      propertyId: string
      createdAt: Date
    }, ExtArgs["result"]["propertyReview"]>
    composites: {}
  }

  type PropertyReviewGetPayload<S extends boolean | null | undefined | PropertyReviewDefaultArgs> = $Result.GetResult<Prisma.$PropertyReviewPayload, S>

  type PropertyReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyReviewCountAggregateInputType | true
    }

  export interface PropertyReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyReview'], meta: { name: 'PropertyReview' } }
    /**
     * Find zero or one PropertyReview that matches the filter.
     * @param {PropertyReviewFindUniqueArgs} args - Arguments to find a PropertyReview
     * @example
     * // Get one PropertyReview
     * const propertyReview = await prisma.propertyReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyReviewFindUniqueArgs>(args: SelectSubset<T, PropertyReviewFindUniqueArgs<ExtArgs>>): Prisma__PropertyReviewClient<$Result.GetResult<Prisma.$PropertyReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyReviewFindUniqueOrThrowArgs} args - Arguments to find a PropertyReview
     * @example
     * // Get one PropertyReview
     * const propertyReview = await prisma.propertyReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyReviewClient<$Result.GetResult<Prisma.$PropertyReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyReviewFindFirstArgs} args - Arguments to find a PropertyReview
     * @example
     * // Get one PropertyReview
     * const propertyReview = await prisma.propertyReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyReviewFindFirstArgs>(args?: SelectSubset<T, PropertyReviewFindFirstArgs<ExtArgs>>): Prisma__PropertyReviewClient<$Result.GetResult<Prisma.$PropertyReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyReviewFindFirstOrThrowArgs} args - Arguments to find a PropertyReview
     * @example
     * // Get one PropertyReview
     * const propertyReview = await prisma.propertyReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyReviewClient<$Result.GetResult<Prisma.$PropertyReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyReviews
     * const propertyReviews = await prisma.propertyReview.findMany()
     * 
     * // Get first 10 PropertyReviews
     * const propertyReviews = await prisma.propertyReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyReviewWithIdOnly = await prisma.propertyReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyReviewFindManyArgs>(args?: SelectSubset<T, PropertyReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyReview.
     * @param {PropertyReviewCreateArgs} args - Arguments to create a PropertyReview.
     * @example
     * // Create one PropertyReview
     * const PropertyReview = await prisma.propertyReview.create({
     *   data: {
     *     // ... data to create a PropertyReview
     *   }
     * })
     * 
     */
    create<T extends PropertyReviewCreateArgs>(args: SelectSubset<T, PropertyReviewCreateArgs<ExtArgs>>): Prisma__PropertyReviewClient<$Result.GetResult<Prisma.$PropertyReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyReviews.
     * @param {PropertyReviewCreateManyArgs} args - Arguments to create many PropertyReviews.
     * @example
     * // Create many PropertyReviews
     * const propertyReview = await prisma.propertyReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyReviewCreateManyArgs>(args?: SelectSubset<T, PropertyReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyReviews and returns the data saved in the database.
     * @param {PropertyReviewCreateManyAndReturnArgs} args - Arguments to create many PropertyReviews.
     * @example
     * // Create many PropertyReviews
     * const propertyReview = await prisma.propertyReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyReviews and only return the `id`
     * const propertyReviewWithIdOnly = await prisma.propertyReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyReview.
     * @param {PropertyReviewDeleteArgs} args - Arguments to delete one PropertyReview.
     * @example
     * // Delete one PropertyReview
     * const PropertyReview = await prisma.propertyReview.delete({
     *   where: {
     *     // ... filter to delete one PropertyReview
     *   }
     * })
     * 
     */
    delete<T extends PropertyReviewDeleteArgs>(args: SelectSubset<T, PropertyReviewDeleteArgs<ExtArgs>>): Prisma__PropertyReviewClient<$Result.GetResult<Prisma.$PropertyReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyReview.
     * @param {PropertyReviewUpdateArgs} args - Arguments to update one PropertyReview.
     * @example
     * // Update one PropertyReview
     * const propertyReview = await prisma.propertyReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyReviewUpdateArgs>(args: SelectSubset<T, PropertyReviewUpdateArgs<ExtArgs>>): Prisma__PropertyReviewClient<$Result.GetResult<Prisma.$PropertyReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyReviews.
     * @param {PropertyReviewDeleteManyArgs} args - Arguments to filter PropertyReviews to delete.
     * @example
     * // Delete a few PropertyReviews
     * const { count } = await prisma.propertyReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyReviewDeleteManyArgs>(args?: SelectSubset<T, PropertyReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyReviews
     * const propertyReview = await prisma.propertyReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyReviewUpdateManyArgs>(args: SelectSubset<T, PropertyReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyReviews and returns the data updated in the database.
     * @param {PropertyReviewUpdateManyAndReturnArgs} args - Arguments to update many PropertyReviews.
     * @example
     * // Update many PropertyReviews
     * const propertyReview = await prisma.propertyReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyReviews and only return the `id`
     * const propertyReviewWithIdOnly = await prisma.propertyReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyReview.
     * @param {PropertyReviewUpsertArgs} args - Arguments to update or create a PropertyReview.
     * @example
     * // Update or create a PropertyReview
     * const propertyReview = await prisma.propertyReview.upsert({
     *   create: {
     *     // ... data to create a PropertyReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyReview we want to update
     *   }
     * })
     */
    upsert<T extends PropertyReviewUpsertArgs>(args: SelectSubset<T, PropertyReviewUpsertArgs<ExtArgs>>): Prisma__PropertyReviewClient<$Result.GetResult<Prisma.$PropertyReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyReviewCountArgs} args - Arguments to filter PropertyReviews to count.
     * @example
     * // Count the number of PropertyReviews
     * const count = await prisma.propertyReview.count({
     *   where: {
     *     // ... the filter for the PropertyReviews we want to count
     *   }
     * })
    **/
    count<T extends PropertyReviewCountArgs>(
      args?: Subset<T, PropertyReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyReviewAggregateArgs>(args: Subset<T, PropertyReviewAggregateArgs>): Prisma.PrismaPromise<GetPropertyReviewAggregateType<T>>

    /**
     * Group by PropertyReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyReviewGroupByArgs['orderBy'] }
        : { orderBy?: PropertyReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyReview model
   */
  readonly fields: PropertyReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyReview model
   */
  interface PropertyReviewFieldRefs {
    readonly id: FieldRef<"PropertyReview", 'String'>
    readonly rating: FieldRef<"PropertyReview", 'Float'>
    readonly comment: FieldRef<"PropertyReview", 'String'>
    readonly guestName: FieldRef<"PropertyReview", 'String'>
    readonly guestEmail: FieldRef<"PropertyReview", 'String'>
    readonly propertyId: FieldRef<"PropertyReview", 'String'>
    readonly createdAt: FieldRef<"PropertyReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyReview findUnique
   */
  export type PropertyReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyReview
     */
    select?: PropertyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyReview
     */
    omit?: PropertyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyReviewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyReview to fetch.
     */
    where: PropertyReviewWhereUniqueInput
  }

  /**
   * PropertyReview findUniqueOrThrow
   */
  export type PropertyReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyReview
     */
    select?: PropertyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyReview
     */
    omit?: PropertyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyReviewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyReview to fetch.
     */
    where: PropertyReviewWhereUniqueInput
  }

  /**
   * PropertyReview findFirst
   */
  export type PropertyReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyReview
     */
    select?: PropertyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyReview
     */
    omit?: PropertyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyReviewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyReview to fetch.
     */
    where?: PropertyReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyReviews to fetch.
     */
    orderBy?: PropertyReviewOrderByWithRelationInput | PropertyReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyReviews.
     */
    cursor?: PropertyReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyReviews.
     */
    distinct?: PropertyReviewScalarFieldEnum | PropertyReviewScalarFieldEnum[]
  }

  /**
   * PropertyReview findFirstOrThrow
   */
  export type PropertyReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyReview
     */
    select?: PropertyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyReview
     */
    omit?: PropertyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyReviewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyReview to fetch.
     */
    where?: PropertyReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyReviews to fetch.
     */
    orderBy?: PropertyReviewOrderByWithRelationInput | PropertyReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyReviews.
     */
    cursor?: PropertyReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyReviews.
     */
    distinct?: PropertyReviewScalarFieldEnum | PropertyReviewScalarFieldEnum[]
  }

  /**
   * PropertyReview findMany
   */
  export type PropertyReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyReview
     */
    select?: PropertyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyReview
     */
    omit?: PropertyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyReviewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyReviews to fetch.
     */
    where?: PropertyReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyReviews to fetch.
     */
    orderBy?: PropertyReviewOrderByWithRelationInput | PropertyReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyReviews.
     */
    cursor?: PropertyReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyReviews.
     */
    skip?: number
    distinct?: PropertyReviewScalarFieldEnum | PropertyReviewScalarFieldEnum[]
  }

  /**
   * PropertyReview create
   */
  export type PropertyReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyReview
     */
    select?: PropertyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyReview
     */
    omit?: PropertyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyReview.
     */
    data: XOR<PropertyReviewCreateInput, PropertyReviewUncheckedCreateInput>
  }

  /**
   * PropertyReview createMany
   */
  export type PropertyReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyReviews.
     */
    data: PropertyReviewCreateManyInput | PropertyReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyReview createManyAndReturn
   */
  export type PropertyReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyReview
     */
    select?: PropertyReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyReview
     */
    omit?: PropertyReviewOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyReviews.
     */
    data: PropertyReviewCreateManyInput | PropertyReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyReview update
   */
  export type PropertyReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyReview
     */
    select?: PropertyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyReview
     */
    omit?: PropertyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyReview.
     */
    data: XOR<PropertyReviewUpdateInput, PropertyReviewUncheckedUpdateInput>
    /**
     * Choose, which PropertyReview to update.
     */
    where: PropertyReviewWhereUniqueInput
  }

  /**
   * PropertyReview updateMany
   */
  export type PropertyReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyReviews.
     */
    data: XOR<PropertyReviewUpdateManyMutationInput, PropertyReviewUncheckedUpdateManyInput>
    /**
     * Filter which PropertyReviews to update
     */
    where?: PropertyReviewWhereInput
    /**
     * Limit how many PropertyReviews to update.
     */
    limit?: number
  }

  /**
   * PropertyReview updateManyAndReturn
   */
  export type PropertyReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyReview
     */
    select?: PropertyReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyReview
     */
    omit?: PropertyReviewOmit<ExtArgs> | null
    /**
     * The data used to update PropertyReviews.
     */
    data: XOR<PropertyReviewUpdateManyMutationInput, PropertyReviewUncheckedUpdateManyInput>
    /**
     * Filter which PropertyReviews to update
     */
    where?: PropertyReviewWhereInput
    /**
     * Limit how many PropertyReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyReview upsert
   */
  export type PropertyReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyReview
     */
    select?: PropertyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyReview
     */
    omit?: PropertyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyReview to update in case it exists.
     */
    where: PropertyReviewWhereUniqueInput
    /**
     * In case the PropertyReview found by the `where` argument doesn't exist, create a new PropertyReview with this data.
     */
    create: XOR<PropertyReviewCreateInput, PropertyReviewUncheckedCreateInput>
    /**
     * In case the PropertyReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyReviewUpdateInput, PropertyReviewUncheckedUpdateInput>
  }

  /**
   * PropertyReview delete
   */
  export type PropertyReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyReview
     */
    select?: PropertyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyReview
     */
    omit?: PropertyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyReviewInclude<ExtArgs> | null
    /**
     * Filter which PropertyReview to delete.
     */
    where: PropertyReviewWhereUniqueInput
  }

  /**
   * PropertyReview deleteMany
   */
  export type PropertyReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyReviews to delete
     */
    where?: PropertyReviewWhereInput
    /**
     * Limit how many PropertyReviews to delete.
     */
    limit?: number
  }

  /**
   * PropertyReview without action
   */
  export type PropertyReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyReview
     */
    select?: PropertyReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyReview
     */
    omit?: PropertyReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyReviewInclude<ExtArgs> | null
  }


  /**
   * Model Reservation
   */

  export type AggregateReservation = {
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  export type ReservationAvgAggregateOutputType = {
    guestCount: number | null
    nights: number | null
    basePrice: number | null
    cleaningFee: number | null
    serviceFee: number | null
    taxes: number | null
    totalPrice: number | null
  }

  export type ReservationSumAggregateOutputType = {
    guestCount: number | null
    nights: number | null
    basePrice: number | null
    cleaningFee: number | null
    serviceFee: number | null
    taxes: number | null
    totalPrice: number | null
  }

  export type ReservationMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    guestName: string | null
    guestEmail: string | null
    guestPhone: string | null
    guestCount: number | null
    checkIn: Date | null
    checkOut: Date | null
    nights: number | null
    basePrice: number | null
    cleaningFee: number | null
    serviceFee: number | null
    taxes: number | null
    totalPrice: number | null
    status: $Enums.ReservationStatus | null
    notes: string | null
    confirmationCode: string | null
    bookingSource: string | null
    checkInTime: Date | null
    checkOutTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    managerId: string | null
  }

  export type ReservationMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    guestName: string | null
    guestEmail: string | null
    guestPhone: string | null
    guestCount: number | null
    checkIn: Date | null
    checkOut: Date | null
    nights: number | null
    basePrice: number | null
    cleaningFee: number | null
    serviceFee: number | null
    taxes: number | null
    totalPrice: number | null
    status: $Enums.ReservationStatus | null
    notes: string | null
    confirmationCode: string | null
    bookingSource: string | null
    checkInTime: Date | null
    checkOutTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    managerId: string | null
  }

  export type ReservationCountAggregateOutputType = {
    id: number
    propertyId: number
    guestName: number
    guestEmail: number
    guestPhone: number
    guestCount: number
    checkIn: number
    checkOut: number
    nights: number
    basePrice: number
    cleaningFee: number
    serviceFee: number
    taxes: number
    totalPrice: number
    status: number
    notes: number
    confirmationCode: number
    bookingSource: number
    checkInTime: number
    checkOutTime: number
    createdAt: number
    updatedAt: number
    managerId: number
    _all: number
  }


  export type ReservationAvgAggregateInputType = {
    guestCount?: true
    nights?: true
    basePrice?: true
    cleaningFee?: true
    serviceFee?: true
    taxes?: true
    totalPrice?: true
  }

  export type ReservationSumAggregateInputType = {
    guestCount?: true
    nights?: true
    basePrice?: true
    cleaningFee?: true
    serviceFee?: true
    taxes?: true
    totalPrice?: true
  }

  export type ReservationMinAggregateInputType = {
    id?: true
    propertyId?: true
    guestName?: true
    guestEmail?: true
    guestPhone?: true
    guestCount?: true
    checkIn?: true
    checkOut?: true
    nights?: true
    basePrice?: true
    cleaningFee?: true
    serviceFee?: true
    taxes?: true
    totalPrice?: true
    status?: true
    notes?: true
    confirmationCode?: true
    bookingSource?: true
    checkInTime?: true
    checkOutTime?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
  }

  export type ReservationMaxAggregateInputType = {
    id?: true
    propertyId?: true
    guestName?: true
    guestEmail?: true
    guestPhone?: true
    guestCount?: true
    checkIn?: true
    checkOut?: true
    nights?: true
    basePrice?: true
    cleaningFee?: true
    serviceFee?: true
    taxes?: true
    totalPrice?: true
    status?: true
    notes?: true
    confirmationCode?: true
    bookingSource?: true
    checkInTime?: true
    checkOutTime?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
  }

  export type ReservationCountAggregateInputType = {
    id?: true
    propertyId?: true
    guestName?: true
    guestEmail?: true
    guestPhone?: true
    guestCount?: true
    checkIn?: true
    checkOut?: true
    nights?: true
    basePrice?: true
    cleaningFee?: true
    serviceFee?: true
    taxes?: true
    totalPrice?: true
    status?: true
    notes?: true
    confirmationCode?: true
    bookingSource?: true
    checkInTime?: true
    checkOutTime?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
    _all?: true
  }

  export type ReservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservation to aggregate.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservations
    **/
    _count?: true | ReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationMaxAggregateInputType
  }

  export type GetReservationAggregateType<T extends ReservationAggregateArgs> = {
        [P in keyof T & keyof AggregateReservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservation[P]>
      : GetScalarType<T[P], AggregateReservation[P]>
  }




  export type ReservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithAggregationInput | ReservationOrderByWithAggregationInput[]
    by: ReservationScalarFieldEnum[] | ReservationScalarFieldEnum
    having?: ReservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationCountAggregateInputType | true
    _avg?: ReservationAvgAggregateInputType
    _sum?: ReservationSumAggregateInputType
    _min?: ReservationMinAggregateInputType
    _max?: ReservationMaxAggregateInputType
  }

  export type ReservationGroupByOutputType = {
    id: string
    propertyId: string
    guestName: string
    guestEmail: string
    guestPhone: string | null
    guestCount: number
    checkIn: Date
    checkOut: Date
    nights: number
    basePrice: number
    cleaningFee: number | null
    serviceFee: number | null
    taxes: number | null
    totalPrice: number
    status: $Enums.ReservationStatus
    notes: string | null
    confirmationCode: string | null
    bookingSource: string | null
    checkInTime: Date | null
    checkOutTime: Date | null
    createdAt: Date
    updatedAt: Date
    managerId: string
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  type GetReservationGroupByPayload<T extends ReservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationGroupByOutputType[P]>
        }
      >
    >


  export type ReservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    guestName?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    guestCount?: boolean
    checkIn?: boolean
    checkOut?: boolean
    nights?: boolean
    basePrice?: boolean
    cleaningFee?: boolean
    serviceFee?: boolean
    taxes?: boolean
    totalPrice?: boolean
    status?: boolean
    notes?: boolean
    confirmationCode?: boolean
    bookingSource?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    guestName?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    guestCount?: boolean
    checkIn?: boolean
    checkOut?: boolean
    nights?: boolean
    basePrice?: boolean
    cleaningFee?: boolean
    serviceFee?: boolean
    taxes?: boolean
    totalPrice?: boolean
    status?: boolean
    notes?: boolean
    confirmationCode?: boolean
    bookingSource?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    guestName?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    guestCount?: boolean
    checkIn?: boolean
    checkOut?: boolean
    nights?: boolean
    basePrice?: boolean
    cleaningFee?: boolean
    serviceFee?: boolean
    taxes?: boolean
    totalPrice?: boolean
    status?: boolean
    notes?: boolean
    confirmationCode?: boolean
    bookingSource?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectScalar = {
    id?: boolean
    propertyId?: boolean
    guestName?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    guestCount?: boolean
    checkIn?: boolean
    checkOut?: boolean
    nights?: boolean
    basePrice?: boolean
    cleaningFee?: boolean
    serviceFee?: boolean
    taxes?: boolean
    totalPrice?: boolean
    status?: boolean
    notes?: boolean
    confirmationCode?: boolean
    bookingSource?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
  }

  export type ReservationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "guestName" | "guestEmail" | "guestPhone" | "guestCount" | "checkIn" | "checkOut" | "nights" | "basePrice" | "cleaningFee" | "serviceFee" | "taxes" | "totalPrice" | "status" | "notes" | "confirmationCode" | "bookingSource" | "checkInTime" | "checkOutTime" | "createdAt" | "updatedAt" | "managerId", ExtArgs["result"]["reservation"]>
  export type ReservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }
  export type ReservationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }
  export type ReservationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }

  export type $ReservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reservation"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      manager: Prisma.$PoleManagerProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      guestName: string
      guestEmail: string
      guestPhone: string | null
      guestCount: number
      checkIn: Date
      checkOut: Date
      nights: number
      basePrice: number
      cleaningFee: number | null
      serviceFee: number | null
      taxes: number | null
      totalPrice: number
      status: $Enums.ReservationStatus
      notes: string | null
      confirmationCode: string | null
      bookingSource: string | null
      checkInTime: Date | null
      checkOutTime: Date | null
      createdAt: Date
      updatedAt: Date
      managerId: string
    }, ExtArgs["result"]["reservation"]>
    composites: {}
  }

  type ReservationGetPayload<S extends boolean | null | undefined | ReservationDefaultArgs> = $Result.GetResult<Prisma.$ReservationPayload, S>

  type ReservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReservationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReservationCountAggregateInputType | true
    }

  export interface ReservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reservation'], meta: { name: 'Reservation' } }
    /**
     * Find zero or one Reservation that matches the filter.
     * @param {ReservationFindUniqueArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservationFindUniqueArgs>(args: SelectSubset<T, ReservationFindUniqueArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reservation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReservationFindUniqueOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservationFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservationFindFirstArgs>(args?: SelectSubset<T, ReservationFindFirstArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservationFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservation.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationWithIdOnly = await prisma.reservation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReservationFindManyArgs>(args?: SelectSubset<T, ReservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reservation.
     * @param {ReservationCreateArgs} args - Arguments to create a Reservation.
     * @example
     * // Create one Reservation
     * const Reservation = await prisma.reservation.create({
     *   data: {
     *     // ... data to create a Reservation
     *   }
     * })
     * 
     */
    create<T extends ReservationCreateArgs>(args: SelectSubset<T, ReservationCreateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reservations.
     * @param {ReservationCreateManyArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservationCreateManyArgs>(args?: SelectSubset<T, ReservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reservations and returns the data saved in the database.
     * @param {ReservationCreateManyAndReturnArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReservationCreateManyAndReturnArgs>(args?: SelectSubset<T, ReservationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reservation.
     * @param {ReservationDeleteArgs} args - Arguments to delete one Reservation.
     * @example
     * // Delete one Reservation
     * const Reservation = await prisma.reservation.delete({
     *   where: {
     *     // ... filter to delete one Reservation
     *   }
     * })
     * 
     */
    delete<T extends ReservationDeleteArgs>(args: SelectSubset<T, ReservationDeleteArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reservation.
     * @param {ReservationUpdateArgs} args - Arguments to update one Reservation.
     * @example
     * // Update one Reservation
     * const reservation = await prisma.reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservationUpdateArgs>(args: SelectSubset<T, ReservationUpdateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reservations.
     * @param {ReservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservationDeleteManyArgs>(args?: SelectSubset<T, ReservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservationUpdateManyArgs>(args: SelectSubset<T, ReservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations and returns the data updated in the database.
     * @param {ReservationUpdateManyAndReturnArgs} args - Arguments to update many Reservations.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReservationUpdateManyAndReturnArgs>(args: SelectSubset<T, ReservationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reservation.
     * @param {ReservationUpsertArgs} args - Arguments to update or create a Reservation.
     * @example
     * // Update or create a Reservation
     * const reservation = await prisma.reservation.upsert({
     *   create: {
     *     // ... data to create a Reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservation we want to update
     *   }
     * })
     */
    upsert<T extends ReservationUpsertArgs>(args: SelectSubset<T, ReservationUpsertArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservation.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends ReservationCountArgs>(
      args?: Subset<T, ReservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationAggregateArgs>(args: Subset<T, ReservationAggregateArgs>): Prisma.PrismaPromise<GetReservationAggregateType<T>>

    /**
     * Group by Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationGroupByArgs['orderBy'] }
        : { orderBy?: ReservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reservation model
   */
  readonly fields: ReservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    manager<T extends PoleManagerProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PoleManagerProfileDefaultArgs<ExtArgs>>): Prisma__PoleManagerProfileClient<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reservation model
   */
  interface ReservationFieldRefs {
    readonly id: FieldRef<"Reservation", 'String'>
    readonly propertyId: FieldRef<"Reservation", 'String'>
    readonly guestName: FieldRef<"Reservation", 'String'>
    readonly guestEmail: FieldRef<"Reservation", 'String'>
    readonly guestPhone: FieldRef<"Reservation", 'String'>
    readonly guestCount: FieldRef<"Reservation", 'Int'>
    readonly checkIn: FieldRef<"Reservation", 'DateTime'>
    readonly checkOut: FieldRef<"Reservation", 'DateTime'>
    readonly nights: FieldRef<"Reservation", 'Int'>
    readonly basePrice: FieldRef<"Reservation", 'Float'>
    readonly cleaningFee: FieldRef<"Reservation", 'Float'>
    readonly serviceFee: FieldRef<"Reservation", 'Float'>
    readonly taxes: FieldRef<"Reservation", 'Float'>
    readonly totalPrice: FieldRef<"Reservation", 'Float'>
    readonly status: FieldRef<"Reservation", 'ReservationStatus'>
    readonly notes: FieldRef<"Reservation", 'String'>
    readonly confirmationCode: FieldRef<"Reservation", 'String'>
    readonly bookingSource: FieldRef<"Reservation", 'String'>
    readonly checkInTime: FieldRef<"Reservation", 'DateTime'>
    readonly checkOutTime: FieldRef<"Reservation", 'DateTime'>
    readonly createdAt: FieldRef<"Reservation", 'DateTime'>
    readonly updatedAt: FieldRef<"Reservation", 'DateTime'>
    readonly managerId: FieldRef<"Reservation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Reservation findUnique
   */
  export type ReservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findUniqueOrThrow
   */
  export type ReservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findFirst
   */
  export type ReservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findFirstOrThrow
   */
  export type ReservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findMany
   */
  export type ReservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservations to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation create
   */
  export type ReservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to create a Reservation.
     */
    data: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
  }

  /**
   * Reservation createMany
   */
  export type ReservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reservation createManyAndReturn
   */
  export type ReservationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation update
   */
  export type ReservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to update a Reservation.
     */
    data: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
    /**
     * Choose, which Reservation to update.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation updateMany
   */
  export type ReservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to update.
     */
    limit?: number
  }

  /**
   * Reservation updateManyAndReturn
   */
  export type ReservationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation upsert
   */
  export type ReservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The filter to search for the Reservation to update in case it exists.
     */
    where: ReservationWhereUniqueInput
    /**
     * In case the Reservation found by the `where` argument doesn't exist, create a new Reservation with this data.
     */
    create: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
    /**
     * In case the Reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
  }

  /**
   * Reservation delete
   */
  export type ReservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter which Reservation to delete.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation deleteMany
   */
  export type ReservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservations to delete
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to delete.
     */
    limit?: number
  }

  /**
   * Reservation without action
   */
  export type ReservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
  }


  /**
   * Model CleaningSession
   */

  export type AggregateCleaningSession = {
    _count: CleaningSessionCountAggregateOutputType | null
    _avg: CleaningSessionAvgAggregateOutputType | null
    _sum: CleaningSessionSumAggregateOutputType | null
    _min: CleaningSessionMinAggregateOutputType | null
    _max: CleaningSessionMaxAggregateOutputType | null
  }

  export type CleaningSessionAvgAggregateOutputType = {
    duration: number | null
    ownerRating: number | null
    managerRating: number | null
  }

  export type CleaningSessionSumAggregateOutputType = {
    duration: number | null
    ownerRating: number | null
    managerRating: number | null
  }

  export type CleaningSessionMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    agentId: string | null
    scheduledDate: Date | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    cleaningType: string | null
    status: $Enums.SessionStatus | null
    notes: string | null
    agentNotes: string | null
    ownerRating: number | null
    managerRating: number | null
    feedback: string | null
    createdAt: Date | null
    updatedAt: Date | null
    managerId: string | null
  }

  export type CleaningSessionMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    agentId: string | null
    scheduledDate: Date | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    cleaningType: string | null
    status: $Enums.SessionStatus | null
    notes: string | null
    agentNotes: string | null
    ownerRating: number | null
    managerRating: number | null
    feedback: string | null
    createdAt: Date | null
    updatedAt: Date | null
    managerId: string | null
  }

  export type CleaningSessionCountAggregateOutputType = {
    id: number
    propertyId: number
    agentId: number
    scheduledDate: number
    startTime: number
    endTime: number
    duration: number
    cleaningType: number
    status: number
    notes: number
    agentNotes: number
    ownerRating: number
    managerRating: number
    feedback: number
    createdAt: number
    updatedAt: number
    managerId: number
    _all: number
  }


  export type CleaningSessionAvgAggregateInputType = {
    duration?: true
    ownerRating?: true
    managerRating?: true
  }

  export type CleaningSessionSumAggregateInputType = {
    duration?: true
    ownerRating?: true
    managerRating?: true
  }

  export type CleaningSessionMinAggregateInputType = {
    id?: true
    propertyId?: true
    agentId?: true
    scheduledDate?: true
    startTime?: true
    endTime?: true
    duration?: true
    cleaningType?: true
    status?: true
    notes?: true
    agentNotes?: true
    ownerRating?: true
    managerRating?: true
    feedback?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
  }

  export type CleaningSessionMaxAggregateInputType = {
    id?: true
    propertyId?: true
    agentId?: true
    scheduledDate?: true
    startTime?: true
    endTime?: true
    duration?: true
    cleaningType?: true
    status?: true
    notes?: true
    agentNotes?: true
    ownerRating?: true
    managerRating?: true
    feedback?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
  }

  export type CleaningSessionCountAggregateInputType = {
    id?: true
    propertyId?: true
    agentId?: true
    scheduledDate?: true
    startTime?: true
    endTime?: true
    duration?: true
    cleaningType?: true
    status?: true
    notes?: true
    agentNotes?: true
    ownerRating?: true
    managerRating?: true
    feedback?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
    _all?: true
  }

  export type CleaningSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningSession to aggregate.
     */
    where?: CleaningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSessions to fetch.
     */
    orderBy?: CleaningSessionOrderByWithRelationInput | CleaningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CleaningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CleaningSessions
    **/
    _count?: true | CleaningSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CleaningSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CleaningSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CleaningSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CleaningSessionMaxAggregateInputType
  }

  export type GetCleaningSessionAggregateType<T extends CleaningSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateCleaningSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCleaningSession[P]>
      : GetScalarType<T[P], AggregateCleaningSession[P]>
  }




  export type CleaningSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningSessionWhereInput
    orderBy?: CleaningSessionOrderByWithAggregationInput | CleaningSessionOrderByWithAggregationInput[]
    by: CleaningSessionScalarFieldEnum[] | CleaningSessionScalarFieldEnum
    having?: CleaningSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CleaningSessionCountAggregateInputType | true
    _avg?: CleaningSessionAvgAggregateInputType
    _sum?: CleaningSessionSumAggregateInputType
    _min?: CleaningSessionMinAggregateInputType
    _max?: CleaningSessionMaxAggregateInputType
  }

  export type CleaningSessionGroupByOutputType = {
    id: string
    propertyId: string
    agentId: string
    scheduledDate: Date
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    cleaningType: string
    status: $Enums.SessionStatus
    notes: string | null
    agentNotes: string | null
    ownerRating: number | null
    managerRating: number | null
    feedback: string | null
    createdAt: Date
    updatedAt: Date
    managerId: string
    _count: CleaningSessionCountAggregateOutputType | null
    _avg: CleaningSessionAvgAggregateOutputType | null
    _sum: CleaningSessionSumAggregateOutputType | null
    _min: CleaningSessionMinAggregateOutputType | null
    _max: CleaningSessionMaxAggregateOutputType | null
  }

  type GetCleaningSessionGroupByPayload<T extends CleaningSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CleaningSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CleaningSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CleaningSessionGroupByOutputType[P]>
            : GetScalarType<T[P], CleaningSessionGroupByOutputType[P]>
        }
      >
    >


  export type CleaningSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    agentId?: boolean
    scheduledDate?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    cleaningType?: boolean
    status?: boolean
    notes?: boolean
    agentNotes?: boolean
    ownerRating?: boolean
    managerRating?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
    checklist?: boolean | CleaningSession$checklistArgs<ExtArgs>
    photos?: boolean | CleaningSession$photosArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
    _count?: boolean | CleaningSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningSession"]>

  export type CleaningSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    agentId?: boolean
    scheduledDate?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    cleaningType?: boolean
    status?: boolean
    notes?: boolean
    agentNotes?: boolean
    ownerRating?: boolean
    managerRating?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningSession"]>

  export type CleaningSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    agentId?: boolean
    scheduledDate?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    cleaningType?: boolean
    status?: boolean
    notes?: boolean
    agentNotes?: boolean
    ownerRating?: boolean
    managerRating?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningSession"]>

  export type CleaningSessionSelectScalar = {
    id?: boolean
    propertyId?: boolean
    agentId?: boolean
    scheduledDate?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    cleaningType?: boolean
    status?: boolean
    notes?: boolean
    agentNotes?: boolean
    ownerRating?: boolean
    managerRating?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
  }

  export type CleaningSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "agentId" | "scheduledDate" | "startTime" | "endTime" | "duration" | "cleaningType" | "status" | "notes" | "agentNotes" | "ownerRating" | "managerRating" | "feedback" | "createdAt" | "updatedAt" | "managerId", ExtArgs["result"]["cleaningSession"]>
  export type CleaningSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
    checklist?: boolean | CleaningSession$checklistArgs<ExtArgs>
    photos?: boolean | CleaningSession$photosArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
    _count?: boolean | CleaningSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CleaningSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }
  export type CleaningSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }

  export type $CleaningSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CleaningSession"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      agent: Prisma.$AgentProfilePayload<ExtArgs>
      checklist: Prisma.$CleaningChecklistPayload<ExtArgs>[]
      photos: Prisma.$CleaningPhotoPayload<ExtArgs>[]
      manager: Prisma.$PoleManagerProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      agentId: string
      scheduledDate: Date
      startTime: Date | null
      endTime: Date | null
      duration: number | null
      cleaningType: string
      status: $Enums.SessionStatus
      notes: string | null
      agentNotes: string | null
      ownerRating: number | null
      managerRating: number | null
      feedback: string | null
      createdAt: Date
      updatedAt: Date
      managerId: string
    }, ExtArgs["result"]["cleaningSession"]>
    composites: {}
  }

  type CleaningSessionGetPayload<S extends boolean | null | undefined | CleaningSessionDefaultArgs> = $Result.GetResult<Prisma.$CleaningSessionPayload, S>

  type CleaningSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CleaningSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CleaningSessionCountAggregateInputType | true
    }

  export interface CleaningSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CleaningSession'], meta: { name: 'CleaningSession' } }
    /**
     * Find zero or one CleaningSession that matches the filter.
     * @param {CleaningSessionFindUniqueArgs} args - Arguments to find a CleaningSession
     * @example
     * // Get one CleaningSession
     * const cleaningSession = await prisma.cleaningSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CleaningSessionFindUniqueArgs>(args: SelectSubset<T, CleaningSessionFindUniqueArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CleaningSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CleaningSessionFindUniqueOrThrowArgs} args - Arguments to find a CleaningSession
     * @example
     * // Get one CleaningSession
     * const cleaningSession = await prisma.cleaningSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CleaningSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, CleaningSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSessionFindFirstArgs} args - Arguments to find a CleaningSession
     * @example
     * // Get one CleaningSession
     * const cleaningSession = await prisma.cleaningSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CleaningSessionFindFirstArgs>(args?: SelectSubset<T, CleaningSessionFindFirstArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSessionFindFirstOrThrowArgs} args - Arguments to find a CleaningSession
     * @example
     * // Get one CleaningSession
     * const cleaningSession = await prisma.cleaningSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CleaningSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, CleaningSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CleaningSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CleaningSessions
     * const cleaningSessions = await prisma.cleaningSession.findMany()
     * 
     * // Get first 10 CleaningSessions
     * const cleaningSessions = await prisma.cleaningSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cleaningSessionWithIdOnly = await prisma.cleaningSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CleaningSessionFindManyArgs>(args?: SelectSubset<T, CleaningSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CleaningSession.
     * @param {CleaningSessionCreateArgs} args - Arguments to create a CleaningSession.
     * @example
     * // Create one CleaningSession
     * const CleaningSession = await prisma.cleaningSession.create({
     *   data: {
     *     // ... data to create a CleaningSession
     *   }
     * })
     * 
     */
    create<T extends CleaningSessionCreateArgs>(args: SelectSubset<T, CleaningSessionCreateArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CleaningSessions.
     * @param {CleaningSessionCreateManyArgs} args - Arguments to create many CleaningSessions.
     * @example
     * // Create many CleaningSessions
     * const cleaningSession = await prisma.cleaningSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CleaningSessionCreateManyArgs>(args?: SelectSubset<T, CleaningSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CleaningSessions and returns the data saved in the database.
     * @param {CleaningSessionCreateManyAndReturnArgs} args - Arguments to create many CleaningSessions.
     * @example
     * // Create many CleaningSessions
     * const cleaningSession = await prisma.cleaningSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CleaningSessions and only return the `id`
     * const cleaningSessionWithIdOnly = await prisma.cleaningSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CleaningSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, CleaningSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CleaningSession.
     * @param {CleaningSessionDeleteArgs} args - Arguments to delete one CleaningSession.
     * @example
     * // Delete one CleaningSession
     * const CleaningSession = await prisma.cleaningSession.delete({
     *   where: {
     *     // ... filter to delete one CleaningSession
     *   }
     * })
     * 
     */
    delete<T extends CleaningSessionDeleteArgs>(args: SelectSubset<T, CleaningSessionDeleteArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CleaningSession.
     * @param {CleaningSessionUpdateArgs} args - Arguments to update one CleaningSession.
     * @example
     * // Update one CleaningSession
     * const cleaningSession = await prisma.cleaningSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CleaningSessionUpdateArgs>(args: SelectSubset<T, CleaningSessionUpdateArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CleaningSessions.
     * @param {CleaningSessionDeleteManyArgs} args - Arguments to filter CleaningSessions to delete.
     * @example
     * // Delete a few CleaningSessions
     * const { count } = await prisma.cleaningSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CleaningSessionDeleteManyArgs>(args?: SelectSubset<T, CleaningSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CleaningSessions
     * const cleaningSession = await prisma.cleaningSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CleaningSessionUpdateManyArgs>(args: SelectSubset<T, CleaningSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningSessions and returns the data updated in the database.
     * @param {CleaningSessionUpdateManyAndReturnArgs} args - Arguments to update many CleaningSessions.
     * @example
     * // Update many CleaningSessions
     * const cleaningSession = await prisma.cleaningSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CleaningSessions and only return the `id`
     * const cleaningSessionWithIdOnly = await prisma.cleaningSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CleaningSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, CleaningSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CleaningSession.
     * @param {CleaningSessionUpsertArgs} args - Arguments to update or create a CleaningSession.
     * @example
     * // Update or create a CleaningSession
     * const cleaningSession = await prisma.cleaningSession.upsert({
     *   create: {
     *     // ... data to create a CleaningSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CleaningSession we want to update
     *   }
     * })
     */
    upsert<T extends CleaningSessionUpsertArgs>(args: SelectSubset<T, CleaningSessionUpsertArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CleaningSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSessionCountArgs} args - Arguments to filter CleaningSessions to count.
     * @example
     * // Count the number of CleaningSessions
     * const count = await prisma.cleaningSession.count({
     *   where: {
     *     // ... the filter for the CleaningSessions we want to count
     *   }
     * })
    **/
    count<T extends CleaningSessionCountArgs>(
      args?: Subset<T, CleaningSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CleaningSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CleaningSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CleaningSessionAggregateArgs>(args: Subset<T, CleaningSessionAggregateArgs>): Prisma.PrismaPromise<GetCleaningSessionAggregateType<T>>

    /**
     * Group by CleaningSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CleaningSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CleaningSessionGroupByArgs['orderBy'] }
        : { orderBy?: CleaningSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CleaningSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCleaningSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CleaningSession model
   */
  readonly fields: CleaningSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CleaningSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CleaningSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends AgentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentProfileDefaultArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    checklist<T extends CleaningSession$checklistArgs<ExtArgs> = {}>(args?: Subset<T, CleaningSession$checklistArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos<T extends CleaningSession$photosArgs<ExtArgs> = {}>(args?: Subset<T, CleaningSession$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manager<T extends PoleManagerProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PoleManagerProfileDefaultArgs<ExtArgs>>): Prisma__PoleManagerProfileClient<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CleaningSession model
   */
  interface CleaningSessionFieldRefs {
    readonly id: FieldRef<"CleaningSession", 'String'>
    readonly propertyId: FieldRef<"CleaningSession", 'String'>
    readonly agentId: FieldRef<"CleaningSession", 'String'>
    readonly scheduledDate: FieldRef<"CleaningSession", 'DateTime'>
    readonly startTime: FieldRef<"CleaningSession", 'DateTime'>
    readonly endTime: FieldRef<"CleaningSession", 'DateTime'>
    readonly duration: FieldRef<"CleaningSession", 'Int'>
    readonly cleaningType: FieldRef<"CleaningSession", 'String'>
    readonly status: FieldRef<"CleaningSession", 'SessionStatus'>
    readonly notes: FieldRef<"CleaningSession", 'String'>
    readonly agentNotes: FieldRef<"CleaningSession", 'String'>
    readonly ownerRating: FieldRef<"CleaningSession", 'Float'>
    readonly managerRating: FieldRef<"CleaningSession", 'Float'>
    readonly feedback: FieldRef<"CleaningSession", 'String'>
    readonly createdAt: FieldRef<"CleaningSession", 'DateTime'>
    readonly updatedAt: FieldRef<"CleaningSession", 'DateTime'>
    readonly managerId: FieldRef<"CleaningSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CleaningSession findUnique
   */
  export type CleaningSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSession to fetch.
     */
    where: CleaningSessionWhereUniqueInput
  }

  /**
   * CleaningSession findUniqueOrThrow
   */
  export type CleaningSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSession to fetch.
     */
    where: CleaningSessionWhereUniqueInput
  }

  /**
   * CleaningSession findFirst
   */
  export type CleaningSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSession to fetch.
     */
    where?: CleaningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSessions to fetch.
     */
    orderBy?: CleaningSessionOrderByWithRelationInput | CleaningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningSessions.
     */
    cursor?: CleaningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningSessions.
     */
    distinct?: CleaningSessionScalarFieldEnum | CleaningSessionScalarFieldEnum[]
  }

  /**
   * CleaningSession findFirstOrThrow
   */
  export type CleaningSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSession to fetch.
     */
    where?: CleaningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSessions to fetch.
     */
    orderBy?: CleaningSessionOrderByWithRelationInput | CleaningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningSessions.
     */
    cursor?: CleaningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningSessions.
     */
    distinct?: CleaningSessionScalarFieldEnum | CleaningSessionScalarFieldEnum[]
  }

  /**
   * CleaningSession findMany
   */
  export type CleaningSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSessions to fetch.
     */
    where?: CleaningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSessions to fetch.
     */
    orderBy?: CleaningSessionOrderByWithRelationInput | CleaningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CleaningSessions.
     */
    cursor?: CleaningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSessions.
     */
    skip?: number
    distinct?: CleaningSessionScalarFieldEnum | CleaningSessionScalarFieldEnum[]
  }

  /**
   * CleaningSession create
   */
  export type CleaningSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a CleaningSession.
     */
    data: XOR<CleaningSessionCreateInput, CleaningSessionUncheckedCreateInput>
  }

  /**
   * CleaningSession createMany
   */
  export type CleaningSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CleaningSessions.
     */
    data: CleaningSessionCreateManyInput | CleaningSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CleaningSession createManyAndReturn
   */
  export type CleaningSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * The data used to create many CleaningSessions.
     */
    data: CleaningSessionCreateManyInput | CleaningSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningSession update
   */
  export type CleaningSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a CleaningSession.
     */
    data: XOR<CleaningSessionUpdateInput, CleaningSessionUncheckedUpdateInput>
    /**
     * Choose, which CleaningSession to update.
     */
    where: CleaningSessionWhereUniqueInput
  }

  /**
   * CleaningSession updateMany
   */
  export type CleaningSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CleaningSessions.
     */
    data: XOR<CleaningSessionUpdateManyMutationInput, CleaningSessionUncheckedUpdateManyInput>
    /**
     * Filter which CleaningSessions to update
     */
    where?: CleaningSessionWhereInput
    /**
     * Limit how many CleaningSessions to update.
     */
    limit?: number
  }

  /**
   * CleaningSession updateManyAndReturn
   */
  export type CleaningSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * The data used to update CleaningSessions.
     */
    data: XOR<CleaningSessionUpdateManyMutationInput, CleaningSessionUncheckedUpdateManyInput>
    /**
     * Filter which CleaningSessions to update
     */
    where?: CleaningSessionWhereInput
    /**
     * Limit how many CleaningSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningSession upsert
   */
  export type CleaningSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the CleaningSession to update in case it exists.
     */
    where: CleaningSessionWhereUniqueInput
    /**
     * In case the CleaningSession found by the `where` argument doesn't exist, create a new CleaningSession with this data.
     */
    create: XOR<CleaningSessionCreateInput, CleaningSessionUncheckedCreateInput>
    /**
     * In case the CleaningSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CleaningSessionUpdateInput, CleaningSessionUncheckedUpdateInput>
  }

  /**
   * CleaningSession delete
   */
  export type CleaningSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
    /**
     * Filter which CleaningSession to delete.
     */
    where: CleaningSessionWhereUniqueInput
  }

  /**
   * CleaningSession deleteMany
   */
  export type CleaningSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningSessions to delete
     */
    where?: CleaningSessionWhereInput
    /**
     * Limit how many CleaningSessions to delete.
     */
    limit?: number
  }

  /**
   * CleaningSession.checklist
   */
  export type CleaningSession$checklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    where?: CleaningChecklistWhereInput
    orderBy?: CleaningChecklistOrderByWithRelationInput | CleaningChecklistOrderByWithRelationInput[]
    cursor?: CleaningChecklistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningChecklistScalarFieldEnum | CleaningChecklistScalarFieldEnum[]
  }

  /**
   * CleaningSession.photos
   */
  export type CleaningSession$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    where?: CleaningPhotoWhereInput
    orderBy?: CleaningPhotoOrderByWithRelationInput | CleaningPhotoOrderByWithRelationInput[]
    cursor?: CleaningPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningPhotoScalarFieldEnum | CleaningPhotoScalarFieldEnum[]
  }

  /**
   * CleaningSession without action
   */
  export type CleaningSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSession
     */
    select?: CleaningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSession
     */
    omit?: CleaningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningSessionInclude<ExtArgs> | null
  }


  /**
   * Model CleaningChecklist
   */

  export type AggregateCleaningChecklist = {
    _count: CleaningChecklistCountAggregateOutputType | null
    _avg: CleaningChecklistAvgAggregateOutputType | null
    _sum: CleaningChecklistSumAggregateOutputType | null
    _min: CleaningChecklistMinAggregateOutputType | null
    _max: CleaningChecklistMaxAggregateOutputType | null
  }

  export type CleaningChecklistAvgAggregateOutputType = {
    order: number | null
  }

  export type CleaningChecklistSumAggregateOutputType = {
    order: number | null
  }

  export type CleaningChecklistMinAggregateOutputType = {
    id: string | null
    item: string | null
    completed: boolean | null
    notes: string | null
    order: number | null
    cleaningSessionId: string | null
  }

  export type CleaningChecklistMaxAggregateOutputType = {
    id: string | null
    item: string | null
    completed: boolean | null
    notes: string | null
    order: number | null
    cleaningSessionId: string | null
  }

  export type CleaningChecklistCountAggregateOutputType = {
    id: number
    item: number
    completed: number
    notes: number
    order: number
    cleaningSessionId: number
    _all: number
  }


  export type CleaningChecklistAvgAggregateInputType = {
    order?: true
  }

  export type CleaningChecklistSumAggregateInputType = {
    order?: true
  }

  export type CleaningChecklistMinAggregateInputType = {
    id?: true
    item?: true
    completed?: true
    notes?: true
    order?: true
    cleaningSessionId?: true
  }

  export type CleaningChecklistMaxAggregateInputType = {
    id?: true
    item?: true
    completed?: true
    notes?: true
    order?: true
    cleaningSessionId?: true
  }

  export type CleaningChecklistCountAggregateInputType = {
    id?: true
    item?: true
    completed?: true
    notes?: true
    order?: true
    cleaningSessionId?: true
    _all?: true
  }

  export type CleaningChecklistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningChecklist to aggregate.
     */
    where?: CleaningChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningChecklists to fetch.
     */
    orderBy?: CleaningChecklistOrderByWithRelationInput | CleaningChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CleaningChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CleaningChecklists
    **/
    _count?: true | CleaningChecklistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CleaningChecklistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CleaningChecklistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CleaningChecklistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CleaningChecklistMaxAggregateInputType
  }

  export type GetCleaningChecklistAggregateType<T extends CleaningChecklistAggregateArgs> = {
        [P in keyof T & keyof AggregateCleaningChecklist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCleaningChecklist[P]>
      : GetScalarType<T[P], AggregateCleaningChecklist[P]>
  }




  export type CleaningChecklistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningChecklistWhereInput
    orderBy?: CleaningChecklistOrderByWithAggregationInput | CleaningChecklistOrderByWithAggregationInput[]
    by: CleaningChecklistScalarFieldEnum[] | CleaningChecklistScalarFieldEnum
    having?: CleaningChecklistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CleaningChecklistCountAggregateInputType | true
    _avg?: CleaningChecklistAvgAggregateInputType
    _sum?: CleaningChecklistSumAggregateInputType
    _min?: CleaningChecklistMinAggregateInputType
    _max?: CleaningChecklistMaxAggregateInputType
  }

  export type CleaningChecklistGroupByOutputType = {
    id: string
    item: string
    completed: boolean
    notes: string | null
    order: number
    cleaningSessionId: string
    _count: CleaningChecklistCountAggregateOutputType | null
    _avg: CleaningChecklistAvgAggregateOutputType | null
    _sum: CleaningChecklistSumAggregateOutputType | null
    _min: CleaningChecklistMinAggregateOutputType | null
    _max: CleaningChecklistMaxAggregateOutputType | null
  }

  type GetCleaningChecklistGroupByPayload<T extends CleaningChecklistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CleaningChecklistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CleaningChecklistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CleaningChecklistGroupByOutputType[P]>
            : GetScalarType<T[P], CleaningChecklistGroupByOutputType[P]>
        }
      >
    >


  export type CleaningChecklistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item?: boolean
    completed?: boolean
    notes?: boolean
    order?: boolean
    cleaningSessionId?: boolean
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningChecklist"]>

  export type CleaningChecklistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item?: boolean
    completed?: boolean
    notes?: boolean
    order?: boolean
    cleaningSessionId?: boolean
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningChecklist"]>

  export type CleaningChecklistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item?: boolean
    completed?: boolean
    notes?: boolean
    order?: boolean
    cleaningSessionId?: boolean
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningChecklist"]>

  export type CleaningChecklistSelectScalar = {
    id?: boolean
    item?: boolean
    completed?: boolean
    notes?: boolean
    order?: boolean
    cleaningSessionId?: boolean
  }

  export type CleaningChecklistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "item" | "completed" | "notes" | "order" | "cleaningSessionId", ExtArgs["result"]["cleaningChecklist"]>
  export type CleaningChecklistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }
  export type CleaningChecklistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }
  export type CleaningChecklistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }

  export type $CleaningChecklistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CleaningChecklist"
    objects: {
      cleaningSession: Prisma.$CleaningSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      item: string
      completed: boolean
      notes: string | null
      order: number
      cleaningSessionId: string
    }, ExtArgs["result"]["cleaningChecklist"]>
    composites: {}
  }

  type CleaningChecklistGetPayload<S extends boolean | null | undefined | CleaningChecklistDefaultArgs> = $Result.GetResult<Prisma.$CleaningChecklistPayload, S>

  type CleaningChecklistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CleaningChecklistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CleaningChecklistCountAggregateInputType | true
    }

  export interface CleaningChecklistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CleaningChecklist'], meta: { name: 'CleaningChecklist' } }
    /**
     * Find zero or one CleaningChecklist that matches the filter.
     * @param {CleaningChecklistFindUniqueArgs} args - Arguments to find a CleaningChecklist
     * @example
     * // Get one CleaningChecklist
     * const cleaningChecklist = await prisma.cleaningChecklist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CleaningChecklistFindUniqueArgs>(args: SelectSubset<T, CleaningChecklistFindUniqueArgs<ExtArgs>>): Prisma__CleaningChecklistClient<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CleaningChecklist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CleaningChecklistFindUniqueOrThrowArgs} args - Arguments to find a CleaningChecklist
     * @example
     * // Get one CleaningChecklist
     * const cleaningChecklist = await prisma.cleaningChecklist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CleaningChecklistFindUniqueOrThrowArgs>(args: SelectSubset<T, CleaningChecklistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CleaningChecklistClient<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningChecklist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningChecklistFindFirstArgs} args - Arguments to find a CleaningChecklist
     * @example
     * // Get one CleaningChecklist
     * const cleaningChecklist = await prisma.cleaningChecklist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CleaningChecklistFindFirstArgs>(args?: SelectSubset<T, CleaningChecklistFindFirstArgs<ExtArgs>>): Prisma__CleaningChecklistClient<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningChecklist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningChecklistFindFirstOrThrowArgs} args - Arguments to find a CleaningChecklist
     * @example
     * // Get one CleaningChecklist
     * const cleaningChecklist = await prisma.cleaningChecklist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CleaningChecklistFindFirstOrThrowArgs>(args?: SelectSubset<T, CleaningChecklistFindFirstOrThrowArgs<ExtArgs>>): Prisma__CleaningChecklistClient<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CleaningChecklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningChecklistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CleaningChecklists
     * const cleaningChecklists = await prisma.cleaningChecklist.findMany()
     * 
     * // Get first 10 CleaningChecklists
     * const cleaningChecklists = await prisma.cleaningChecklist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cleaningChecklistWithIdOnly = await prisma.cleaningChecklist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CleaningChecklistFindManyArgs>(args?: SelectSubset<T, CleaningChecklistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CleaningChecklist.
     * @param {CleaningChecklistCreateArgs} args - Arguments to create a CleaningChecklist.
     * @example
     * // Create one CleaningChecklist
     * const CleaningChecklist = await prisma.cleaningChecklist.create({
     *   data: {
     *     // ... data to create a CleaningChecklist
     *   }
     * })
     * 
     */
    create<T extends CleaningChecklistCreateArgs>(args: SelectSubset<T, CleaningChecklistCreateArgs<ExtArgs>>): Prisma__CleaningChecklistClient<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CleaningChecklists.
     * @param {CleaningChecklistCreateManyArgs} args - Arguments to create many CleaningChecklists.
     * @example
     * // Create many CleaningChecklists
     * const cleaningChecklist = await prisma.cleaningChecklist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CleaningChecklistCreateManyArgs>(args?: SelectSubset<T, CleaningChecklistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CleaningChecklists and returns the data saved in the database.
     * @param {CleaningChecklistCreateManyAndReturnArgs} args - Arguments to create many CleaningChecklists.
     * @example
     * // Create many CleaningChecklists
     * const cleaningChecklist = await prisma.cleaningChecklist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CleaningChecklists and only return the `id`
     * const cleaningChecklistWithIdOnly = await prisma.cleaningChecklist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CleaningChecklistCreateManyAndReturnArgs>(args?: SelectSubset<T, CleaningChecklistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CleaningChecklist.
     * @param {CleaningChecklistDeleteArgs} args - Arguments to delete one CleaningChecklist.
     * @example
     * // Delete one CleaningChecklist
     * const CleaningChecklist = await prisma.cleaningChecklist.delete({
     *   where: {
     *     // ... filter to delete one CleaningChecklist
     *   }
     * })
     * 
     */
    delete<T extends CleaningChecklistDeleteArgs>(args: SelectSubset<T, CleaningChecklistDeleteArgs<ExtArgs>>): Prisma__CleaningChecklistClient<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CleaningChecklist.
     * @param {CleaningChecklistUpdateArgs} args - Arguments to update one CleaningChecklist.
     * @example
     * // Update one CleaningChecklist
     * const cleaningChecklist = await prisma.cleaningChecklist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CleaningChecklistUpdateArgs>(args: SelectSubset<T, CleaningChecklistUpdateArgs<ExtArgs>>): Prisma__CleaningChecklistClient<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CleaningChecklists.
     * @param {CleaningChecklistDeleteManyArgs} args - Arguments to filter CleaningChecklists to delete.
     * @example
     * // Delete a few CleaningChecklists
     * const { count } = await prisma.cleaningChecklist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CleaningChecklistDeleteManyArgs>(args?: SelectSubset<T, CleaningChecklistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningChecklistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CleaningChecklists
     * const cleaningChecklist = await prisma.cleaningChecklist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CleaningChecklistUpdateManyArgs>(args: SelectSubset<T, CleaningChecklistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningChecklists and returns the data updated in the database.
     * @param {CleaningChecklistUpdateManyAndReturnArgs} args - Arguments to update many CleaningChecklists.
     * @example
     * // Update many CleaningChecklists
     * const cleaningChecklist = await prisma.cleaningChecklist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CleaningChecklists and only return the `id`
     * const cleaningChecklistWithIdOnly = await prisma.cleaningChecklist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CleaningChecklistUpdateManyAndReturnArgs>(args: SelectSubset<T, CleaningChecklistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CleaningChecklist.
     * @param {CleaningChecklistUpsertArgs} args - Arguments to update or create a CleaningChecklist.
     * @example
     * // Update or create a CleaningChecklist
     * const cleaningChecklist = await prisma.cleaningChecklist.upsert({
     *   create: {
     *     // ... data to create a CleaningChecklist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CleaningChecklist we want to update
     *   }
     * })
     */
    upsert<T extends CleaningChecklistUpsertArgs>(args: SelectSubset<T, CleaningChecklistUpsertArgs<ExtArgs>>): Prisma__CleaningChecklistClient<$Result.GetResult<Prisma.$CleaningChecklistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CleaningChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningChecklistCountArgs} args - Arguments to filter CleaningChecklists to count.
     * @example
     * // Count the number of CleaningChecklists
     * const count = await prisma.cleaningChecklist.count({
     *   where: {
     *     // ... the filter for the CleaningChecklists we want to count
     *   }
     * })
    **/
    count<T extends CleaningChecklistCountArgs>(
      args?: Subset<T, CleaningChecklistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CleaningChecklistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CleaningChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningChecklistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CleaningChecklistAggregateArgs>(args: Subset<T, CleaningChecklistAggregateArgs>): Prisma.PrismaPromise<GetCleaningChecklistAggregateType<T>>

    /**
     * Group by CleaningChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningChecklistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CleaningChecklistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CleaningChecklistGroupByArgs['orderBy'] }
        : { orderBy?: CleaningChecklistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CleaningChecklistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCleaningChecklistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CleaningChecklist model
   */
  readonly fields: CleaningChecklistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CleaningChecklist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CleaningChecklistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cleaningSession<T extends CleaningSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CleaningSessionDefaultArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CleaningChecklist model
   */
  interface CleaningChecklistFieldRefs {
    readonly id: FieldRef<"CleaningChecklist", 'String'>
    readonly item: FieldRef<"CleaningChecklist", 'String'>
    readonly completed: FieldRef<"CleaningChecklist", 'Boolean'>
    readonly notes: FieldRef<"CleaningChecklist", 'String'>
    readonly order: FieldRef<"CleaningChecklist", 'Int'>
    readonly cleaningSessionId: FieldRef<"CleaningChecklist", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CleaningChecklist findUnique
   */
  export type CleaningChecklistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter, which CleaningChecklist to fetch.
     */
    where: CleaningChecklistWhereUniqueInput
  }

  /**
   * CleaningChecklist findUniqueOrThrow
   */
  export type CleaningChecklistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter, which CleaningChecklist to fetch.
     */
    where: CleaningChecklistWhereUniqueInput
  }

  /**
   * CleaningChecklist findFirst
   */
  export type CleaningChecklistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter, which CleaningChecklist to fetch.
     */
    where?: CleaningChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningChecklists to fetch.
     */
    orderBy?: CleaningChecklistOrderByWithRelationInput | CleaningChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningChecklists.
     */
    cursor?: CleaningChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningChecklists.
     */
    distinct?: CleaningChecklistScalarFieldEnum | CleaningChecklistScalarFieldEnum[]
  }

  /**
   * CleaningChecklist findFirstOrThrow
   */
  export type CleaningChecklistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter, which CleaningChecklist to fetch.
     */
    where?: CleaningChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningChecklists to fetch.
     */
    orderBy?: CleaningChecklistOrderByWithRelationInput | CleaningChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningChecklists.
     */
    cursor?: CleaningChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningChecklists.
     */
    distinct?: CleaningChecklistScalarFieldEnum | CleaningChecklistScalarFieldEnum[]
  }

  /**
   * CleaningChecklist findMany
   */
  export type CleaningChecklistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter, which CleaningChecklists to fetch.
     */
    where?: CleaningChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningChecklists to fetch.
     */
    orderBy?: CleaningChecklistOrderByWithRelationInput | CleaningChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CleaningChecklists.
     */
    cursor?: CleaningChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningChecklists.
     */
    skip?: number
    distinct?: CleaningChecklistScalarFieldEnum | CleaningChecklistScalarFieldEnum[]
  }

  /**
   * CleaningChecklist create
   */
  export type CleaningChecklistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * The data needed to create a CleaningChecklist.
     */
    data: XOR<CleaningChecklistCreateInput, CleaningChecklistUncheckedCreateInput>
  }

  /**
   * CleaningChecklist createMany
   */
  export type CleaningChecklistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CleaningChecklists.
     */
    data: CleaningChecklistCreateManyInput | CleaningChecklistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CleaningChecklist createManyAndReturn
   */
  export type CleaningChecklistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * The data used to create many CleaningChecklists.
     */
    data: CleaningChecklistCreateManyInput | CleaningChecklistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningChecklist update
   */
  export type CleaningChecklistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * The data needed to update a CleaningChecklist.
     */
    data: XOR<CleaningChecklistUpdateInput, CleaningChecklistUncheckedUpdateInput>
    /**
     * Choose, which CleaningChecklist to update.
     */
    where: CleaningChecklistWhereUniqueInput
  }

  /**
   * CleaningChecklist updateMany
   */
  export type CleaningChecklistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CleaningChecklists.
     */
    data: XOR<CleaningChecklistUpdateManyMutationInput, CleaningChecklistUncheckedUpdateManyInput>
    /**
     * Filter which CleaningChecklists to update
     */
    where?: CleaningChecklistWhereInput
    /**
     * Limit how many CleaningChecklists to update.
     */
    limit?: number
  }

  /**
   * CleaningChecklist updateManyAndReturn
   */
  export type CleaningChecklistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * The data used to update CleaningChecklists.
     */
    data: XOR<CleaningChecklistUpdateManyMutationInput, CleaningChecklistUncheckedUpdateManyInput>
    /**
     * Filter which CleaningChecklists to update
     */
    where?: CleaningChecklistWhereInput
    /**
     * Limit how many CleaningChecklists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningChecklist upsert
   */
  export type CleaningChecklistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * The filter to search for the CleaningChecklist to update in case it exists.
     */
    where: CleaningChecklistWhereUniqueInput
    /**
     * In case the CleaningChecklist found by the `where` argument doesn't exist, create a new CleaningChecklist with this data.
     */
    create: XOR<CleaningChecklistCreateInput, CleaningChecklistUncheckedCreateInput>
    /**
     * In case the CleaningChecklist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CleaningChecklistUpdateInput, CleaningChecklistUncheckedUpdateInput>
  }

  /**
   * CleaningChecklist delete
   */
  export type CleaningChecklistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
    /**
     * Filter which CleaningChecklist to delete.
     */
    where: CleaningChecklistWhereUniqueInput
  }

  /**
   * CleaningChecklist deleteMany
   */
  export type CleaningChecklistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningChecklists to delete
     */
    where?: CleaningChecklistWhereInput
    /**
     * Limit how many CleaningChecklists to delete.
     */
    limit?: number
  }

  /**
   * CleaningChecklist without action
   */
  export type CleaningChecklistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningChecklist
     */
    select?: CleaningChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningChecklist
     */
    omit?: CleaningChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningChecklistInclude<ExtArgs> | null
  }


  /**
   * Model CleaningPhoto
   */

  export type AggregateCleaningPhoto = {
    _count: CleaningPhotoCountAggregateOutputType | null
    _min: CleaningPhotoMinAggregateOutputType | null
    _max: CleaningPhotoMaxAggregateOutputType | null
  }

  export type CleaningPhotoMinAggregateOutputType = {
    id: string | null
    url: string | null
    type: string | null
    caption: string | null
    cleaningSessionId: string | null
    createdAt: Date | null
  }

  export type CleaningPhotoMaxAggregateOutputType = {
    id: string | null
    url: string | null
    type: string | null
    caption: string | null
    cleaningSessionId: string | null
    createdAt: Date | null
  }

  export type CleaningPhotoCountAggregateOutputType = {
    id: number
    url: number
    type: number
    caption: number
    cleaningSessionId: number
    createdAt: number
    _all: number
  }


  export type CleaningPhotoMinAggregateInputType = {
    id?: true
    url?: true
    type?: true
    caption?: true
    cleaningSessionId?: true
    createdAt?: true
  }

  export type CleaningPhotoMaxAggregateInputType = {
    id?: true
    url?: true
    type?: true
    caption?: true
    cleaningSessionId?: true
    createdAt?: true
  }

  export type CleaningPhotoCountAggregateInputType = {
    id?: true
    url?: true
    type?: true
    caption?: true
    cleaningSessionId?: true
    createdAt?: true
    _all?: true
  }

  export type CleaningPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningPhoto to aggregate.
     */
    where?: CleaningPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningPhotos to fetch.
     */
    orderBy?: CleaningPhotoOrderByWithRelationInput | CleaningPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CleaningPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CleaningPhotos
    **/
    _count?: true | CleaningPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CleaningPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CleaningPhotoMaxAggregateInputType
  }

  export type GetCleaningPhotoAggregateType<T extends CleaningPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateCleaningPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCleaningPhoto[P]>
      : GetScalarType<T[P], AggregateCleaningPhoto[P]>
  }




  export type CleaningPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningPhotoWhereInput
    orderBy?: CleaningPhotoOrderByWithAggregationInput | CleaningPhotoOrderByWithAggregationInput[]
    by: CleaningPhotoScalarFieldEnum[] | CleaningPhotoScalarFieldEnum
    having?: CleaningPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CleaningPhotoCountAggregateInputType | true
    _min?: CleaningPhotoMinAggregateInputType
    _max?: CleaningPhotoMaxAggregateInputType
  }

  export type CleaningPhotoGroupByOutputType = {
    id: string
    url: string
    type: string | null
    caption: string | null
    cleaningSessionId: string
    createdAt: Date
    _count: CleaningPhotoCountAggregateOutputType | null
    _min: CleaningPhotoMinAggregateOutputType | null
    _max: CleaningPhotoMaxAggregateOutputType | null
  }

  type GetCleaningPhotoGroupByPayload<T extends CleaningPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CleaningPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CleaningPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CleaningPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], CleaningPhotoGroupByOutputType[P]>
        }
      >
    >


  export type CleaningPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    caption?: boolean
    cleaningSessionId?: boolean
    createdAt?: boolean
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningPhoto"]>

  export type CleaningPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    caption?: boolean
    cleaningSessionId?: boolean
    createdAt?: boolean
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningPhoto"]>

  export type CleaningPhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    caption?: boolean
    cleaningSessionId?: boolean
    createdAt?: boolean
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningPhoto"]>

  export type CleaningPhotoSelectScalar = {
    id?: boolean
    url?: boolean
    type?: boolean
    caption?: boolean
    cleaningSessionId?: boolean
    createdAt?: boolean
  }

  export type CleaningPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "type" | "caption" | "cleaningSessionId" | "createdAt", ExtArgs["result"]["cleaningPhoto"]>
  export type CleaningPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }
  export type CleaningPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }
  export type CleaningPhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cleaningSession?: boolean | CleaningSessionDefaultArgs<ExtArgs>
  }

  export type $CleaningPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CleaningPhoto"
    objects: {
      cleaningSession: Prisma.$CleaningSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      type: string | null
      caption: string | null
      cleaningSessionId: string
      createdAt: Date
    }, ExtArgs["result"]["cleaningPhoto"]>
    composites: {}
  }

  type CleaningPhotoGetPayload<S extends boolean | null | undefined | CleaningPhotoDefaultArgs> = $Result.GetResult<Prisma.$CleaningPhotoPayload, S>

  type CleaningPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CleaningPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CleaningPhotoCountAggregateInputType | true
    }

  export interface CleaningPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CleaningPhoto'], meta: { name: 'CleaningPhoto' } }
    /**
     * Find zero or one CleaningPhoto that matches the filter.
     * @param {CleaningPhotoFindUniqueArgs} args - Arguments to find a CleaningPhoto
     * @example
     * // Get one CleaningPhoto
     * const cleaningPhoto = await prisma.cleaningPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CleaningPhotoFindUniqueArgs>(args: SelectSubset<T, CleaningPhotoFindUniqueArgs<ExtArgs>>): Prisma__CleaningPhotoClient<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CleaningPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CleaningPhotoFindUniqueOrThrowArgs} args - Arguments to find a CleaningPhoto
     * @example
     * // Get one CleaningPhoto
     * const cleaningPhoto = await prisma.cleaningPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CleaningPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, CleaningPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CleaningPhotoClient<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPhotoFindFirstArgs} args - Arguments to find a CleaningPhoto
     * @example
     * // Get one CleaningPhoto
     * const cleaningPhoto = await prisma.cleaningPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CleaningPhotoFindFirstArgs>(args?: SelectSubset<T, CleaningPhotoFindFirstArgs<ExtArgs>>): Prisma__CleaningPhotoClient<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPhotoFindFirstOrThrowArgs} args - Arguments to find a CleaningPhoto
     * @example
     * // Get one CleaningPhoto
     * const cleaningPhoto = await prisma.cleaningPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CleaningPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, CleaningPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CleaningPhotoClient<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CleaningPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CleaningPhotos
     * const cleaningPhotos = await prisma.cleaningPhoto.findMany()
     * 
     * // Get first 10 CleaningPhotos
     * const cleaningPhotos = await prisma.cleaningPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cleaningPhotoWithIdOnly = await prisma.cleaningPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CleaningPhotoFindManyArgs>(args?: SelectSubset<T, CleaningPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CleaningPhoto.
     * @param {CleaningPhotoCreateArgs} args - Arguments to create a CleaningPhoto.
     * @example
     * // Create one CleaningPhoto
     * const CleaningPhoto = await prisma.cleaningPhoto.create({
     *   data: {
     *     // ... data to create a CleaningPhoto
     *   }
     * })
     * 
     */
    create<T extends CleaningPhotoCreateArgs>(args: SelectSubset<T, CleaningPhotoCreateArgs<ExtArgs>>): Prisma__CleaningPhotoClient<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CleaningPhotos.
     * @param {CleaningPhotoCreateManyArgs} args - Arguments to create many CleaningPhotos.
     * @example
     * // Create many CleaningPhotos
     * const cleaningPhoto = await prisma.cleaningPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CleaningPhotoCreateManyArgs>(args?: SelectSubset<T, CleaningPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CleaningPhotos and returns the data saved in the database.
     * @param {CleaningPhotoCreateManyAndReturnArgs} args - Arguments to create many CleaningPhotos.
     * @example
     * // Create many CleaningPhotos
     * const cleaningPhoto = await prisma.cleaningPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CleaningPhotos and only return the `id`
     * const cleaningPhotoWithIdOnly = await prisma.cleaningPhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CleaningPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, CleaningPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CleaningPhoto.
     * @param {CleaningPhotoDeleteArgs} args - Arguments to delete one CleaningPhoto.
     * @example
     * // Delete one CleaningPhoto
     * const CleaningPhoto = await prisma.cleaningPhoto.delete({
     *   where: {
     *     // ... filter to delete one CleaningPhoto
     *   }
     * })
     * 
     */
    delete<T extends CleaningPhotoDeleteArgs>(args: SelectSubset<T, CleaningPhotoDeleteArgs<ExtArgs>>): Prisma__CleaningPhotoClient<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CleaningPhoto.
     * @param {CleaningPhotoUpdateArgs} args - Arguments to update one CleaningPhoto.
     * @example
     * // Update one CleaningPhoto
     * const cleaningPhoto = await prisma.cleaningPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CleaningPhotoUpdateArgs>(args: SelectSubset<T, CleaningPhotoUpdateArgs<ExtArgs>>): Prisma__CleaningPhotoClient<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CleaningPhotos.
     * @param {CleaningPhotoDeleteManyArgs} args - Arguments to filter CleaningPhotos to delete.
     * @example
     * // Delete a few CleaningPhotos
     * const { count } = await prisma.cleaningPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CleaningPhotoDeleteManyArgs>(args?: SelectSubset<T, CleaningPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CleaningPhotos
     * const cleaningPhoto = await prisma.cleaningPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CleaningPhotoUpdateManyArgs>(args: SelectSubset<T, CleaningPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningPhotos and returns the data updated in the database.
     * @param {CleaningPhotoUpdateManyAndReturnArgs} args - Arguments to update many CleaningPhotos.
     * @example
     * // Update many CleaningPhotos
     * const cleaningPhoto = await prisma.cleaningPhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CleaningPhotos and only return the `id`
     * const cleaningPhotoWithIdOnly = await prisma.cleaningPhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CleaningPhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, CleaningPhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CleaningPhoto.
     * @param {CleaningPhotoUpsertArgs} args - Arguments to update or create a CleaningPhoto.
     * @example
     * // Update or create a CleaningPhoto
     * const cleaningPhoto = await prisma.cleaningPhoto.upsert({
     *   create: {
     *     // ... data to create a CleaningPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CleaningPhoto we want to update
     *   }
     * })
     */
    upsert<T extends CleaningPhotoUpsertArgs>(args: SelectSubset<T, CleaningPhotoUpsertArgs<ExtArgs>>): Prisma__CleaningPhotoClient<$Result.GetResult<Prisma.$CleaningPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CleaningPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPhotoCountArgs} args - Arguments to filter CleaningPhotos to count.
     * @example
     * // Count the number of CleaningPhotos
     * const count = await prisma.cleaningPhoto.count({
     *   where: {
     *     // ... the filter for the CleaningPhotos we want to count
     *   }
     * })
    **/
    count<T extends CleaningPhotoCountArgs>(
      args?: Subset<T, CleaningPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CleaningPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CleaningPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CleaningPhotoAggregateArgs>(args: Subset<T, CleaningPhotoAggregateArgs>): Prisma.PrismaPromise<GetCleaningPhotoAggregateType<T>>

    /**
     * Group by CleaningPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CleaningPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CleaningPhotoGroupByArgs['orderBy'] }
        : { orderBy?: CleaningPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CleaningPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCleaningPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CleaningPhoto model
   */
  readonly fields: CleaningPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CleaningPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CleaningPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cleaningSession<T extends CleaningSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CleaningSessionDefaultArgs<ExtArgs>>): Prisma__CleaningSessionClient<$Result.GetResult<Prisma.$CleaningSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CleaningPhoto model
   */
  interface CleaningPhotoFieldRefs {
    readonly id: FieldRef<"CleaningPhoto", 'String'>
    readonly url: FieldRef<"CleaningPhoto", 'String'>
    readonly type: FieldRef<"CleaningPhoto", 'String'>
    readonly caption: FieldRef<"CleaningPhoto", 'String'>
    readonly cleaningSessionId: FieldRef<"CleaningPhoto", 'String'>
    readonly createdAt: FieldRef<"CleaningPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CleaningPhoto findUnique
   */
  export type CleaningPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter, which CleaningPhoto to fetch.
     */
    where: CleaningPhotoWhereUniqueInput
  }

  /**
   * CleaningPhoto findUniqueOrThrow
   */
  export type CleaningPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter, which CleaningPhoto to fetch.
     */
    where: CleaningPhotoWhereUniqueInput
  }

  /**
   * CleaningPhoto findFirst
   */
  export type CleaningPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter, which CleaningPhoto to fetch.
     */
    where?: CleaningPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningPhotos to fetch.
     */
    orderBy?: CleaningPhotoOrderByWithRelationInput | CleaningPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningPhotos.
     */
    cursor?: CleaningPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningPhotos.
     */
    distinct?: CleaningPhotoScalarFieldEnum | CleaningPhotoScalarFieldEnum[]
  }

  /**
   * CleaningPhoto findFirstOrThrow
   */
  export type CleaningPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter, which CleaningPhoto to fetch.
     */
    where?: CleaningPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningPhotos to fetch.
     */
    orderBy?: CleaningPhotoOrderByWithRelationInput | CleaningPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningPhotos.
     */
    cursor?: CleaningPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningPhotos.
     */
    distinct?: CleaningPhotoScalarFieldEnum | CleaningPhotoScalarFieldEnum[]
  }

  /**
   * CleaningPhoto findMany
   */
  export type CleaningPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter, which CleaningPhotos to fetch.
     */
    where?: CleaningPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningPhotos to fetch.
     */
    orderBy?: CleaningPhotoOrderByWithRelationInput | CleaningPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CleaningPhotos.
     */
    cursor?: CleaningPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningPhotos.
     */
    skip?: number
    distinct?: CleaningPhotoScalarFieldEnum | CleaningPhotoScalarFieldEnum[]
  }

  /**
   * CleaningPhoto create
   */
  export type CleaningPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a CleaningPhoto.
     */
    data: XOR<CleaningPhotoCreateInput, CleaningPhotoUncheckedCreateInput>
  }

  /**
   * CleaningPhoto createMany
   */
  export type CleaningPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CleaningPhotos.
     */
    data: CleaningPhotoCreateManyInput | CleaningPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CleaningPhoto createManyAndReturn
   */
  export type CleaningPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * The data used to create many CleaningPhotos.
     */
    data: CleaningPhotoCreateManyInput | CleaningPhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningPhoto update
   */
  export type CleaningPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a CleaningPhoto.
     */
    data: XOR<CleaningPhotoUpdateInput, CleaningPhotoUncheckedUpdateInput>
    /**
     * Choose, which CleaningPhoto to update.
     */
    where: CleaningPhotoWhereUniqueInput
  }

  /**
   * CleaningPhoto updateMany
   */
  export type CleaningPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CleaningPhotos.
     */
    data: XOR<CleaningPhotoUpdateManyMutationInput, CleaningPhotoUncheckedUpdateManyInput>
    /**
     * Filter which CleaningPhotos to update
     */
    where?: CleaningPhotoWhereInput
    /**
     * Limit how many CleaningPhotos to update.
     */
    limit?: number
  }

  /**
   * CleaningPhoto updateManyAndReturn
   */
  export type CleaningPhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * The data used to update CleaningPhotos.
     */
    data: XOR<CleaningPhotoUpdateManyMutationInput, CleaningPhotoUncheckedUpdateManyInput>
    /**
     * Filter which CleaningPhotos to update
     */
    where?: CleaningPhotoWhereInput
    /**
     * Limit how many CleaningPhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningPhoto upsert
   */
  export type CleaningPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the CleaningPhoto to update in case it exists.
     */
    where: CleaningPhotoWhereUniqueInput
    /**
     * In case the CleaningPhoto found by the `where` argument doesn't exist, create a new CleaningPhoto with this data.
     */
    create: XOR<CleaningPhotoCreateInput, CleaningPhotoUncheckedCreateInput>
    /**
     * In case the CleaningPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CleaningPhotoUpdateInput, CleaningPhotoUncheckedUpdateInput>
  }

  /**
   * CleaningPhoto delete
   */
  export type CleaningPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
    /**
     * Filter which CleaningPhoto to delete.
     */
    where: CleaningPhotoWhereUniqueInput
  }

  /**
   * CleaningPhoto deleteMany
   */
  export type CleaningPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningPhotos to delete
     */
    where?: CleaningPhotoWhereInput
    /**
     * Limit how many CleaningPhotos to delete.
     */
    limit?: number
  }

  /**
   * CleaningPhoto without action
   */
  export type CleaningPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningPhoto
     */
    select?: CleaningPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningPhoto
     */
    omit?: CleaningPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningPhotoInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketAvgAggregateOutputType = {
    estimatedCost: number | null
    estimatedDuration: number | null
  }

  export type TicketSumAggregateOutputType = {
    estimatedCost: number | null
    estimatedDuration: number | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
    ticketNumber: string | null
    title: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    priority: $Enums.TicketPriority | null
    propertyId: string | null
    reportedBy: string | null
    reportedAt: Date | null
    agentId: string | null
    assignedAt: Date | null
    category: string | null
    issueType: string | null
    roomLocation: string | null
    resolution: string | null
    resolvedAt: Date | null
    estimatedCost: number | null
    estimatedDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    managerId: string | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
    ticketNumber: string | null
    title: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    priority: $Enums.TicketPriority | null
    propertyId: string | null
    reportedBy: string | null
    reportedAt: Date | null
    agentId: string | null
    assignedAt: Date | null
    category: string | null
    issueType: string | null
    roomLocation: string | null
    resolution: string | null
    resolvedAt: Date | null
    estimatedCost: number | null
    estimatedDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    managerId: string | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    ticketNumber: number
    title: number
    description: number
    status: number
    priority: number
    propertyId: number
    reportedBy: number
    reportedAt: number
    agentId: number
    assignedAt: number
    category: number
    issueType: number
    roomLocation: number
    resolution: number
    resolvedAt: number
    estimatedCost: number
    estimatedDuration: number
    createdAt: number
    updatedAt: number
    managerId: number
    _all: number
  }


  export type TicketAvgAggregateInputType = {
    estimatedCost?: true
    estimatedDuration?: true
  }

  export type TicketSumAggregateInputType = {
    estimatedCost?: true
    estimatedDuration?: true
  }

  export type TicketMinAggregateInputType = {
    id?: true
    ticketNumber?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    propertyId?: true
    reportedBy?: true
    reportedAt?: true
    agentId?: true
    assignedAt?: true
    category?: true
    issueType?: true
    roomLocation?: true
    resolution?: true
    resolvedAt?: true
    estimatedCost?: true
    estimatedDuration?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    ticketNumber?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    propertyId?: true
    reportedBy?: true
    reportedAt?: true
    agentId?: true
    assignedAt?: true
    category?: true
    issueType?: true
    roomLocation?: true
    resolution?: true
    resolvedAt?: true
    estimatedCost?: true
    estimatedDuration?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    ticketNumber?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    propertyId?: true
    reportedBy?: true
    reportedAt?: true
    agentId?: true
    assignedAt?: true
    category?: true
    issueType?: true
    roomLocation?: true
    resolution?: true
    resolvedAt?: true
    estimatedCost?: true
    estimatedDuration?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _avg?: TicketAvgAggregateInputType
    _sum?: TicketSumAggregateInputType
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    ticketNumber: string
    title: string
    description: string
    status: $Enums.TicketStatus
    priority: $Enums.TicketPriority
    propertyId: string
    reportedBy: string
    reportedAt: Date
    agentId: string | null
    assignedAt: Date | null
    category: string | null
    issueType: string | null
    roomLocation: string | null
    resolution: string | null
    resolvedAt: Date | null
    estimatedCost: number | null
    estimatedDuration: number | null
    createdAt: Date
    updatedAt: Date
    managerId: string
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    propertyId?: boolean
    reportedBy?: boolean
    reportedAt?: boolean
    agentId?: boolean
    assignedAt?: boolean
    category?: boolean
    issueType?: boolean
    roomLocation?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    estimatedCost?: boolean
    estimatedDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | Ticket$agentArgs<ExtArgs>
    photos?: boolean | Ticket$photosArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
    maintenanceSession?: boolean | Ticket$maintenanceSessionArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    propertyId?: boolean
    reportedBy?: boolean
    reportedAt?: boolean
    agentId?: boolean
    assignedAt?: boolean
    category?: boolean
    issueType?: boolean
    roomLocation?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    estimatedCost?: boolean
    estimatedDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | Ticket$agentArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    propertyId?: boolean
    reportedBy?: boolean
    reportedAt?: boolean
    agentId?: boolean
    assignedAt?: boolean
    category?: boolean
    issueType?: boolean
    roomLocation?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    estimatedCost?: boolean
    estimatedDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | Ticket$agentArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    ticketNumber?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    propertyId?: boolean
    reportedBy?: boolean
    reportedAt?: boolean
    agentId?: boolean
    assignedAt?: boolean
    category?: boolean
    issueType?: boolean
    roomLocation?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    estimatedCost?: boolean
    estimatedDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
  }

  export type TicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticketNumber" | "title" | "description" | "status" | "priority" | "propertyId" | "reportedBy" | "reportedAt" | "agentId" | "assignedAt" | "category" | "issueType" | "roomLocation" | "resolution" | "resolvedAt" | "estimatedCost" | "estimatedDuration" | "createdAt" | "updatedAt" | "managerId", ExtArgs["result"]["ticket"]>
  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | Ticket$agentArgs<ExtArgs>
    photos?: boolean | Ticket$photosArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
    maintenanceSession?: boolean | Ticket$maintenanceSessionArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | Ticket$agentArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }
  export type TicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | Ticket$agentArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      agent: Prisma.$AgentProfilePayload<ExtArgs> | null
      photos: Prisma.$TicketPhotoPayload<ExtArgs>[]
      manager: Prisma.$PoleManagerProfilePayload<ExtArgs>
      maintenanceSession: Prisma.$MaintenanceSessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketNumber: string
      title: string
      description: string
      status: $Enums.TicketStatus
      priority: $Enums.TicketPriority
      propertyId: string
      reportedBy: string
      reportedAt: Date
      agentId: string | null
      assignedAt: Date | null
      category: string | null
      issueType: string | null
      roomLocation: string | null
      resolution: string | null
      resolvedAt: Date | null
      estimatedCost: number | null
      estimatedDuration: number | null
      createdAt: Date
      updatedAt: Date
      managerId: string
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets and returns the data updated in the database.
     * @param {TicketUpdateManyAndReturnArgs} args - Arguments to update many Tickets.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends Ticket$agentArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$agentArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    photos<T extends Ticket$photosArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manager<T extends PoleManagerProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PoleManagerProfileDefaultArgs<ExtArgs>>): Prisma__PoleManagerProfileClient<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    maintenanceSession<T extends Ticket$maintenanceSessionArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$maintenanceSessionArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
    readonly ticketNumber: FieldRef<"Ticket", 'String'>
    readonly title: FieldRef<"Ticket", 'String'>
    readonly description: FieldRef<"Ticket", 'String'>
    readonly status: FieldRef<"Ticket", 'TicketStatus'>
    readonly priority: FieldRef<"Ticket", 'TicketPriority'>
    readonly propertyId: FieldRef<"Ticket", 'String'>
    readonly reportedBy: FieldRef<"Ticket", 'String'>
    readonly reportedAt: FieldRef<"Ticket", 'DateTime'>
    readonly agentId: FieldRef<"Ticket", 'String'>
    readonly assignedAt: FieldRef<"Ticket", 'DateTime'>
    readonly category: FieldRef<"Ticket", 'String'>
    readonly issueType: FieldRef<"Ticket", 'String'>
    readonly roomLocation: FieldRef<"Ticket", 'String'>
    readonly resolution: FieldRef<"Ticket", 'String'>
    readonly resolvedAt: FieldRef<"Ticket", 'DateTime'>
    readonly estimatedCost: FieldRef<"Ticket", 'Float'>
    readonly estimatedDuration: FieldRef<"Ticket", 'Int'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
    readonly updatedAt: FieldRef<"Ticket", 'DateTime'>
    readonly managerId: FieldRef<"Ticket", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Ticket updateManyAndReturn
   */
  export type TicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Ticket.agent
   */
  export type Ticket$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentProfile
     */
    select?: AgentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentProfile
     */
    omit?: AgentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentProfileInclude<ExtArgs> | null
    where?: AgentProfileWhereInput
  }

  /**
   * Ticket.photos
   */
  export type Ticket$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    where?: TicketPhotoWhereInput
    orderBy?: TicketPhotoOrderByWithRelationInput | TicketPhotoOrderByWithRelationInput[]
    cursor?: TicketPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketPhotoScalarFieldEnum | TicketPhotoScalarFieldEnum[]
  }

  /**
   * Ticket.maintenanceSession
   */
  export type Ticket$maintenanceSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    where?: MaintenanceSessionWhereInput
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model TicketPhoto
   */

  export type AggregateTicketPhoto = {
    _count: TicketPhotoCountAggregateOutputType | null
    _min: TicketPhotoMinAggregateOutputType | null
    _max: TicketPhotoMaxAggregateOutputType | null
  }

  export type TicketPhotoMinAggregateOutputType = {
    id: string | null
    url: string | null
    caption: string | null
    ticketId: string | null
    createdAt: Date | null
  }

  export type TicketPhotoMaxAggregateOutputType = {
    id: string | null
    url: string | null
    caption: string | null
    ticketId: string | null
    createdAt: Date | null
  }

  export type TicketPhotoCountAggregateOutputType = {
    id: number
    url: number
    caption: number
    ticketId: number
    createdAt: number
    _all: number
  }


  export type TicketPhotoMinAggregateInputType = {
    id?: true
    url?: true
    caption?: true
    ticketId?: true
    createdAt?: true
  }

  export type TicketPhotoMaxAggregateInputType = {
    id?: true
    url?: true
    caption?: true
    ticketId?: true
    createdAt?: true
  }

  export type TicketPhotoCountAggregateInputType = {
    id?: true
    url?: true
    caption?: true
    ticketId?: true
    createdAt?: true
    _all?: true
  }

  export type TicketPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketPhoto to aggregate.
     */
    where?: TicketPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketPhotos to fetch.
     */
    orderBy?: TicketPhotoOrderByWithRelationInput | TicketPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketPhotos
    **/
    _count?: true | TicketPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketPhotoMaxAggregateInputType
  }

  export type GetTicketPhotoAggregateType<T extends TicketPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketPhoto[P]>
      : GetScalarType<T[P], AggregateTicketPhoto[P]>
  }




  export type TicketPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketPhotoWhereInput
    orderBy?: TicketPhotoOrderByWithAggregationInput | TicketPhotoOrderByWithAggregationInput[]
    by: TicketPhotoScalarFieldEnum[] | TicketPhotoScalarFieldEnum
    having?: TicketPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketPhotoCountAggregateInputType | true
    _min?: TicketPhotoMinAggregateInputType
    _max?: TicketPhotoMaxAggregateInputType
  }

  export type TicketPhotoGroupByOutputType = {
    id: string
    url: string
    caption: string | null
    ticketId: string
    createdAt: Date
    _count: TicketPhotoCountAggregateOutputType | null
    _min: TicketPhotoMinAggregateOutputType | null
    _max: TicketPhotoMaxAggregateOutputType | null
  }

  type GetTicketPhotoGroupByPayload<T extends TicketPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], TicketPhotoGroupByOutputType[P]>
        }
      >
    >


  export type TicketPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    caption?: boolean
    ticketId?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketPhoto"]>

  export type TicketPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    caption?: boolean
    ticketId?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketPhoto"]>

  export type TicketPhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    caption?: boolean
    ticketId?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketPhoto"]>

  export type TicketPhotoSelectScalar = {
    id?: boolean
    url?: boolean
    caption?: boolean
    ticketId?: boolean
    createdAt?: boolean
  }

  export type TicketPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "caption" | "ticketId" | "createdAt", ExtArgs["result"]["ticketPhoto"]>
  export type TicketPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type TicketPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type TicketPhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }

  export type $TicketPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketPhoto"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      caption: string | null
      ticketId: string
      createdAt: Date
    }, ExtArgs["result"]["ticketPhoto"]>
    composites: {}
  }

  type TicketPhotoGetPayload<S extends boolean | null | undefined | TicketPhotoDefaultArgs> = $Result.GetResult<Prisma.$TicketPhotoPayload, S>

  type TicketPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketPhotoCountAggregateInputType | true
    }

  export interface TicketPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketPhoto'], meta: { name: 'TicketPhoto' } }
    /**
     * Find zero or one TicketPhoto that matches the filter.
     * @param {TicketPhotoFindUniqueArgs} args - Arguments to find a TicketPhoto
     * @example
     * // Get one TicketPhoto
     * const ticketPhoto = await prisma.ticketPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketPhotoFindUniqueArgs>(args: SelectSubset<T, TicketPhotoFindUniqueArgs<ExtArgs>>): Prisma__TicketPhotoClient<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketPhotoFindUniqueOrThrowArgs} args - Arguments to find a TicketPhoto
     * @example
     * // Get one TicketPhoto
     * const ticketPhoto = await prisma.ticketPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketPhotoClient<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketPhotoFindFirstArgs} args - Arguments to find a TicketPhoto
     * @example
     * // Get one TicketPhoto
     * const ticketPhoto = await prisma.ticketPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketPhotoFindFirstArgs>(args?: SelectSubset<T, TicketPhotoFindFirstArgs<ExtArgs>>): Prisma__TicketPhotoClient<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketPhotoFindFirstOrThrowArgs} args - Arguments to find a TicketPhoto
     * @example
     * // Get one TicketPhoto
     * const ticketPhoto = await prisma.ticketPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketPhotoClient<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketPhotos
     * const ticketPhotos = await prisma.ticketPhoto.findMany()
     * 
     * // Get first 10 TicketPhotos
     * const ticketPhotos = await prisma.ticketPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketPhotoWithIdOnly = await prisma.ticketPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketPhotoFindManyArgs>(args?: SelectSubset<T, TicketPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketPhoto.
     * @param {TicketPhotoCreateArgs} args - Arguments to create a TicketPhoto.
     * @example
     * // Create one TicketPhoto
     * const TicketPhoto = await prisma.ticketPhoto.create({
     *   data: {
     *     // ... data to create a TicketPhoto
     *   }
     * })
     * 
     */
    create<T extends TicketPhotoCreateArgs>(args: SelectSubset<T, TicketPhotoCreateArgs<ExtArgs>>): Prisma__TicketPhotoClient<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketPhotos.
     * @param {TicketPhotoCreateManyArgs} args - Arguments to create many TicketPhotos.
     * @example
     * // Create many TicketPhotos
     * const ticketPhoto = await prisma.ticketPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketPhotoCreateManyArgs>(args?: SelectSubset<T, TicketPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketPhotos and returns the data saved in the database.
     * @param {TicketPhotoCreateManyAndReturnArgs} args - Arguments to create many TicketPhotos.
     * @example
     * // Create many TicketPhotos
     * const ticketPhoto = await prisma.ticketPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketPhotos and only return the `id`
     * const ticketPhotoWithIdOnly = await prisma.ticketPhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketPhoto.
     * @param {TicketPhotoDeleteArgs} args - Arguments to delete one TicketPhoto.
     * @example
     * // Delete one TicketPhoto
     * const TicketPhoto = await prisma.ticketPhoto.delete({
     *   where: {
     *     // ... filter to delete one TicketPhoto
     *   }
     * })
     * 
     */
    delete<T extends TicketPhotoDeleteArgs>(args: SelectSubset<T, TicketPhotoDeleteArgs<ExtArgs>>): Prisma__TicketPhotoClient<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketPhoto.
     * @param {TicketPhotoUpdateArgs} args - Arguments to update one TicketPhoto.
     * @example
     * // Update one TicketPhoto
     * const ticketPhoto = await prisma.ticketPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketPhotoUpdateArgs>(args: SelectSubset<T, TicketPhotoUpdateArgs<ExtArgs>>): Prisma__TicketPhotoClient<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketPhotos.
     * @param {TicketPhotoDeleteManyArgs} args - Arguments to filter TicketPhotos to delete.
     * @example
     * // Delete a few TicketPhotos
     * const { count } = await prisma.ticketPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketPhotoDeleteManyArgs>(args?: SelectSubset<T, TicketPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketPhotos
     * const ticketPhoto = await prisma.ticketPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketPhotoUpdateManyArgs>(args: SelectSubset<T, TicketPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketPhotos and returns the data updated in the database.
     * @param {TicketPhotoUpdateManyAndReturnArgs} args - Arguments to update many TicketPhotos.
     * @example
     * // Update many TicketPhotos
     * const ticketPhoto = await prisma.ticketPhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketPhotos and only return the `id`
     * const ticketPhotoWithIdOnly = await prisma.ticketPhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketPhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketPhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketPhoto.
     * @param {TicketPhotoUpsertArgs} args - Arguments to update or create a TicketPhoto.
     * @example
     * // Update or create a TicketPhoto
     * const ticketPhoto = await prisma.ticketPhoto.upsert({
     *   create: {
     *     // ... data to create a TicketPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketPhoto we want to update
     *   }
     * })
     */
    upsert<T extends TicketPhotoUpsertArgs>(args: SelectSubset<T, TicketPhotoUpsertArgs<ExtArgs>>): Prisma__TicketPhotoClient<$Result.GetResult<Prisma.$TicketPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketPhotoCountArgs} args - Arguments to filter TicketPhotos to count.
     * @example
     * // Count the number of TicketPhotos
     * const count = await prisma.ticketPhoto.count({
     *   where: {
     *     // ... the filter for the TicketPhotos we want to count
     *   }
     * })
    **/
    count<T extends TicketPhotoCountArgs>(
      args?: Subset<T, TicketPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketPhotoAggregateArgs>(args: Subset<T, TicketPhotoAggregateArgs>): Prisma.PrismaPromise<GetTicketPhotoAggregateType<T>>

    /**
     * Group by TicketPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketPhotoGroupByArgs['orderBy'] }
        : { orderBy?: TicketPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketPhoto model
   */
  readonly fields: TicketPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketPhoto model
   */
  interface TicketPhotoFieldRefs {
    readonly id: FieldRef<"TicketPhoto", 'String'>
    readonly url: FieldRef<"TicketPhoto", 'String'>
    readonly caption: FieldRef<"TicketPhoto", 'String'>
    readonly ticketId: FieldRef<"TicketPhoto", 'String'>
    readonly createdAt: FieldRef<"TicketPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketPhoto findUnique
   */
  export type TicketPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TicketPhoto to fetch.
     */
    where: TicketPhotoWhereUniqueInput
  }

  /**
   * TicketPhoto findUniqueOrThrow
   */
  export type TicketPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TicketPhoto to fetch.
     */
    where: TicketPhotoWhereUniqueInput
  }

  /**
   * TicketPhoto findFirst
   */
  export type TicketPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TicketPhoto to fetch.
     */
    where?: TicketPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketPhotos to fetch.
     */
    orderBy?: TicketPhotoOrderByWithRelationInput | TicketPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketPhotos.
     */
    cursor?: TicketPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketPhotos.
     */
    distinct?: TicketPhotoScalarFieldEnum | TicketPhotoScalarFieldEnum[]
  }

  /**
   * TicketPhoto findFirstOrThrow
   */
  export type TicketPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TicketPhoto to fetch.
     */
    where?: TicketPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketPhotos to fetch.
     */
    orderBy?: TicketPhotoOrderByWithRelationInput | TicketPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketPhotos.
     */
    cursor?: TicketPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketPhotos.
     */
    distinct?: TicketPhotoScalarFieldEnum | TicketPhotoScalarFieldEnum[]
  }

  /**
   * TicketPhoto findMany
   */
  export type TicketPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TicketPhotos to fetch.
     */
    where?: TicketPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketPhotos to fetch.
     */
    orderBy?: TicketPhotoOrderByWithRelationInput | TicketPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketPhotos.
     */
    cursor?: TicketPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketPhotos.
     */
    skip?: number
    distinct?: TicketPhotoScalarFieldEnum | TicketPhotoScalarFieldEnum[]
  }

  /**
   * TicketPhoto create
   */
  export type TicketPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketPhoto.
     */
    data: XOR<TicketPhotoCreateInput, TicketPhotoUncheckedCreateInput>
  }

  /**
   * TicketPhoto createMany
   */
  export type TicketPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketPhotos.
     */
    data: TicketPhotoCreateManyInput | TicketPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketPhoto createManyAndReturn
   */
  export type TicketPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * The data used to create many TicketPhotos.
     */
    data: TicketPhotoCreateManyInput | TicketPhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketPhoto update
   */
  export type TicketPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketPhoto.
     */
    data: XOR<TicketPhotoUpdateInput, TicketPhotoUncheckedUpdateInput>
    /**
     * Choose, which TicketPhoto to update.
     */
    where: TicketPhotoWhereUniqueInput
  }

  /**
   * TicketPhoto updateMany
   */
  export type TicketPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketPhotos.
     */
    data: XOR<TicketPhotoUpdateManyMutationInput, TicketPhotoUncheckedUpdateManyInput>
    /**
     * Filter which TicketPhotos to update
     */
    where?: TicketPhotoWhereInput
    /**
     * Limit how many TicketPhotos to update.
     */
    limit?: number
  }

  /**
   * TicketPhoto updateManyAndReturn
   */
  export type TicketPhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * The data used to update TicketPhotos.
     */
    data: XOR<TicketPhotoUpdateManyMutationInput, TicketPhotoUncheckedUpdateManyInput>
    /**
     * Filter which TicketPhotos to update
     */
    where?: TicketPhotoWhereInput
    /**
     * Limit how many TicketPhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketPhoto upsert
   */
  export type TicketPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketPhoto to update in case it exists.
     */
    where: TicketPhotoWhereUniqueInput
    /**
     * In case the TicketPhoto found by the `where` argument doesn't exist, create a new TicketPhoto with this data.
     */
    create: XOR<TicketPhotoCreateInput, TicketPhotoUncheckedCreateInput>
    /**
     * In case the TicketPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketPhotoUpdateInput, TicketPhotoUncheckedUpdateInput>
  }

  /**
   * TicketPhoto delete
   */
  export type TicketPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
    /**
     * Filter which TicketPhoto to delete.
     */
    where: TicketPhotoWhereUniqueInput
  }

  /**
   * TicketPhoto deleteMany
   */
  export type TicketPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketPhotos to delete
     */
    where?: TicketPhotoWhereInput
    /**
     * Limit how many TicketPhotos to delete.
     */
    limit?: number
  }

  /**
   * TicketPhoto without action
   */
  export type TicketPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketPhoto
     */
    select?: TicketPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketPhoto
     */
    omit?: TicketPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketPhotoInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceSession
   */

  export type AggregateMaintenanceSession = {
    _count: MaintenanceSessionCountAggregateOutputType | null
    _avg: MaintenanceSessionAvgAggregateOutputType | null
    _sum: MaintenanceSessionSumAggregateOutputType | null
    _min: MaintenanceSessionMinAggregateOutputType | null
    _max: MaintenanceSessionMaxAggregateOutputType | null
  }

  export type MaintenanceSessionAvgAggregateOutputType = {
    estimatedDuration: number | null
    actualDuration: number | null
    laborCost: number | null
    materialsCost: number | null
    totalCost: number | null
  }

  export type MaintenanceSessionSumAggregateOutputType = {
    estimatedDuration: number | null
    actualDuration: number | null
    laborCost: number | null
    materialsCost: number | null
    totalCost: number | null
  }

  export type MaintenanceSessionMinAggregateOutputType = {
    id: string | null
    sessionNumber: string | null
    ticketId: string | null
    propertyId: string | null
    agentId: string | null
    scheduledDate: Date | null
    startTime: Date | null
    endTime: Date | null
    estimatedDuration: number | null
    actualDuration: number | null
    status: $Enums.SessionStatus | null
    notes: string | null
    workDescription: string | null
    agentNotes: string | null
    laborCost: number | null
    materialsCost: number | null
    totalCost: number | null
    ownerApproval: boolean | null
    managerApproval: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    managerId: string | null
  }

  export type MaintenanceSessionMaxAggregateOutputType = {
    id: string | null
    sessionNumber: string | null
    ticketId: string | null
    propertyId: string | null
    agentId: string | null
    scheduledDate: Date | null
    startTime: Date | null
    endTime: Date | null
    estimatedDuration: number | null
    actualDuration: number | null
    status: $Enums.SessionStatus | null
    notes: string | null
    workDescription: string | null
    agentNotes: string | null
    laborCost: number | null
    materialsCost: number | null
    totalCost: number | null
    ownerApproval: boolean | null
    managerApproval: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    managerId: string | null
  }

  export type MaintenanceSessionCountAggregateOutputType = {
    id: number
    sessionNumber: number
    ticketId: number
    propertyId: number
    agentId: number
    scheduledDate: number
    startTime: number
    endTime: number
    estimatedDuration: number
    actualDuration: number
    status: number
    notes: number
    workDescription: number
    agentNotes: number
    laborCost: number
    materialsCost: number
    totalCost: number
    ownerApproval: number
    managerApproval: number
    createdAt: number
    updatedAt: number
    managerId: number
    _all: number
  }


  export type MaintenanceSessionAvgAggregateInputType = {
    estimatedDuration?: true
    actualDuration?: true
    laborCost?: true
    materialsCost?: true
    totalCost?: true
  }

  export type MaintenanceSessionSumAggregateInputType = {
    estimatedDuration?: true
    actualDuration?: true
    laborCost?: true
    materialsCost?: true
    totalCost?: true
  }

  export type MaintenanceSessionMinAggregateInputType = {
    id?: true
    sessionNumber?: true
    ticketId?: true
    propertyId?: true
    agentId?: true
    scheduledDate?: true
    startTime?: true
    endTime?: true
    estimatedDuration?: true
    actualDuration?: true
    status?: true
    notes?: true
    workDescription?: true
    agentNotes?: true
    laborCost?: true
    materialsCost?: true
    totalCost?: true
    ownerApproval?: true
    managerApproval?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
  }

  export type MaintenanceSessionMaxAggregateInputType = {
    id?: true
    sessionNumber?: true
    ticketId?: true
    propertyId?: true
    agentId?: true
    scheduledDate?: true
    startTime?: true
    endTime?: true
    estimatedDuration?: true
    actualDuration?: true
    status?: true
    notes?: true
    workDescription?: true
    agentNotes?: true
    laborCost?: true
    materialsCost?: true
    totalCost?: true
    ownerApproval?: true
    managerApproval?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
  }

  export type MaintenanceSessionCountAggregateInputType = {
    id?: true
    sessionNumber?: true
    ticketId?: true
    propertyId?: true
    agentId?: true
    scheduledDate?: true
    startTime?: true
    endTime?: true
    estimatedDuration?: true
    actualDuration?: true
    status?: true
    notes?: true
    workDescription?: true
    agentNotes?: true
    laborCost?: true
    materialsCost?: true
    totalCost?: true
    ownerApproval?: true
    managerApproval?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
    _all?: true
  }

  export type MaintenanceSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceSession to aggregate.
     */
    where?: MaintenanceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceSessions to fetch.
     */
    orderBy?: MaintenanceSessionOrderByWithRelationInput | MaintenanceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceSessions
    **/
    _count?: true | MaintenanceSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaintenanceSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaintenanceSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceSessionMaxAggregateInputType
  }

  export type GetMaintenanceSessionAggregateType<T extends MaintenanceSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceSession[P]>
      : GetScalarType<T[P], AggregateMaintenanceSession[P]>
  }




  export type MaintenanceSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceSessionWhereInput
    orderBy?: MaintenanceSessionOrderByWithAggregationInput | MaintenanceSessionOrderByWithAggregationInput[]
    by: MaintenanceSessionScalarFieldEnum[] | MaintenanceSessionScalarFieldEnum
    having?: MaintenanceSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceSessionCountAggregateInputType | true
    _avg?: MaintenanceSessionAvgAggregateInputType
    _sum?: MaintenanceSessionSumAggregateInputType
    _min?: MaintenanceSessionMinAggregateInputType
    _max?: MaintenanceSessionMaxAggregateInputType
  }

  export type MaintenanceSessionGroupByOutputType = {
    id: string
    sessionNumber: string
    ticketId: string
    propertyId: string
    agentId: string
    scheduledDate: Date
    startTime: Date | null
    endTime: Date | null
    estimatedDuration: number | null
    actualDuration: number | null
    status: $Enums.SessionStatus
    notes: string | null
    workDescription: string | null
    agentNotes: string | null
    laborCost: number | null
    materialsCost: number | null
    totalCost: number | null
    ownerApproval: boolean | null
    managerApproval: boolean | null
    createdAt: Date
    updatedAt: Date
    managerId: string
    _count: MaintenanceSessionCountAggregateOutputType | null
    _avg: MaintenanceSessionAvgAggregateOutputType | null
    _sum: MaintenanceSessionSumAggregateOutputType | null
    _min: MaintenanceSessionMinAggregateOutputType | null
    _max: MaintenanceSessionMaxAggregateOutputType | null
  }

  type GetMaintenanceSessionGroupByPayload<T extends MaintenanceSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceSessionGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceSessionGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionNumber?: boolean
    ticketId?: boolean
    propertyId?: boolean
    agentId?: boolean
    scheduledDate?: boolean
    startTime?: boolean
    endTime?: boolean
    estimatedDuration?: boolean
    actualDuration?: boolean
    status?: boolean
    notes?: boolean
    workDescription?: boolean
    agentNotes?: boolean
    laborCost?: boolean
    materialsCost?: boolean
    totalCost?: boolean
    ownerApproval?: boolean
    managerApproval?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
    materials?: boolean | MaintenanceSession$materialsArgs<ExtArgs>
    photos?: boolean | MaintenanceSession$photosArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
    _count?: boolean | MaintenanceSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceSession"]>

  export type MaintenanceSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionNumber?: boolean
    ticketId?: boolean
    propertyId?: boolean
    agentId?: boolean
    scheduledDate?: boolean
    startTime?: boolean
    endTime?: boolean
    estimatedDuration?: boolean
    actualDuration?: boolean
    status?: boolean
    notes?: boolean
    workDescription?: boolean
    agentNotes?: boolean
    laborCost?: boolean
    materialsCost?: boolean
    totalCost?: boolean
    ownerApproval?: boolean
    managerApproval?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceSession"]>

  export type MaintenanceSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionNumber?: boolean
    ticketId?: boolean
    propertyId?: boolean
    agentId?: boolean
    scheduledDate?: boolean
    startTime?: boolean
    endTime?: boolean
    estimatedDuration?: boolean
    actualDuration?: boolean
    status?: boolean
    notes?: boolean
    workDescription?: boolean
    agentNotes?: boolean
    laborCost?: boolean
    materialsCost?: boolean
    totalCost?: boolean
    ownerApproval?: boolean
    managerApproval?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceSession"]>

  export type MaintenanceSessionSelectScalar = {
    id?: boolean
    sessionNumber?: boolean
    ticketId?: boolean
    propertyId?: boolean
    agentId?: boolean
    scheduledDate?: boolean
    startTime?: boolean
    endTime?: boolean
    estimatedDuration?: boolean
    actualDuration?: boolean
    status?: boolean
    notes?: boolean
    workDescription?: boolean
    agentNotes?: boolean
    laborCost?: boolean
    materialsCost?: boolean
    totalCost?: boolean
    ownerApproval?: boolean
    managerApproval?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
  }

  export type MaintenanceSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionNumber" | "ticketId" | "propertyId" | "agentId" | "scheduledDate" | "startTime" | "endTime" | "estimatedDuration" | "actualDuration" | "status" | "notes" | "workDescription" | "agentNotes" | "laborCost" | "materialsCost" | "totalCost" | "ownerApproval" | "managerApproval" | "createdAt" | "updatedAt" | "managerId", ExtArgs["result"]["maintenanceSession"]>
  export type MaintenanceSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
    materials?: boolean | MaintenanceSession$materialsArgs<ExtArgs>
    photos?: boolean | MaintenanceSession$photosArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
    _count?: boolean | MaintenanceSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaintenanceSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }
  export type MaintenanceSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
  }

  export type $MaintenanceSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceSession"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
      property: Prisma.$PropertyPayload<ExtArgs>
      agent: Prisma.$AgentProfilePayload<ExtArgs>
      materials: Prisma.$MaintenanceMaterialPayload<ExtArgs>[]
      photos: Prisma.$MaintenancePhotoPayload<ExtArgs>[]
      manager: Prisma.$PoleManagerProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionNumber: string
      ticketId: string
      propertyId: string
      agentId: string
      scheduledDate: Date
      startTime: Date | null
      endTime: Date | null
      estimatedDuration: number | null
      actualDuration: number | null
      status: $Enums.SessionStatus
      notes: string | null
      workDescription: string | null
      agentNotes: string | null
      laborCost: number | null
      materialsCost: number | null
      totalCost: number | null
      ownerApproval: boolean | null
      managerApproval: boolean | null
      createdAt: Date
      updatedAt: Date
      managerId: string
    }, ExtArgs["result"]["maintenanceSession"]>
    composites: {}
  }

  type MaintenanceSessionGetPayload<S extends boolean | null | undefined | MaintenanceSessionDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceSessionPayload, S>

  type MaintenanceSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenanceSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenanceSessionCountAggregateInputType | true
    }

  export interface MaintenanceSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceSession'], meta: { name: 'MaintenanceSession' } }
    /**
     * Find zero or one MaintenanceSession that matches the filter.
     * @param {MaintenanceSessionFindUniqueArgs} args - Arguments to find a MaintenanceSession
     * @example
     * // Get one MaintenanceSession
     * const maintenanceSession = await prisma.maintenanceSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceSessionFindUniqueArgs>(args: SelectSubset<T, MaintenanceSessionFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaintenanceSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenanceSessionFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceSession
     * @example
     * // Get one MaintenanceSession
     * const maintenanceSession = await prisma.maintenanceSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSessionFindFirstArgs} args - Arguments to find a MaintenanceSession
     * @example
     * // Get one MaintenanceSession
     * const maintenanceSession = await prisma.maintenanceSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceSessionFindFirstArgs>(args?: SelectSubset<T, MaintenanceSessionFindFirstArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSessionFindFirstOrThrowArgs} args - Arguments to find a MaintenanceSession
     * @example
     * // Get one MaintenanceSession
     * const maintenanceSession = await prisma.maintenanceSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaintenanceSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceSessions
     * const maintenanceSessions = await prisma.maintenanceSession.findMany()
     * 
     * // Get first 10 MaintenanceSessions
     * const maintenanceSessions = await prisma.maintenanceSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceSessionWithIdOnly = await prisma.maintenanceSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceSessionFindManyArgs>(args?: SelectSubset<T, MaintenanceSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaintenanceSession.
     * @param {MaintenanceSessionCreateArgs} args - Arguments to create a MaintenanceSession.
     * @example
     * // Create one MaintenanceSession
     * const MaintenanceSession = await prisma.maintenanceSession.create({
     *   data: {
     *     // ... data to create a MaintenanceSession
     *   }
     * })
     * 
     */
    create<T extends MaintenanceSessionCreateArgs>(args: SelectSubset<T, MaintenanceSessionCreateArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaintenanceSessions.
     * @param {MaintenanceSessionCreateManyArgs} args - Arguments to create many MaintenanceSessions.
     * @example
     * // Create many MaintenanceSessions
     * const maintenanceSession = await prisma.maintenanceSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceSessionCreateManyArgs>(args?: SelectSubset<T, MaintenanceSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceSessions and returns the data saved in the database.
     * @param {MaintenanceSessionCreateManyAndReturnArgs} args - Arguments to create many MaintenanceSessions.
     * @example
     * // Create many MaintenanceSessions
     * const maintenanceSession = await prisma.maintenanceSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceSessions and only return the `id`
     * const maintenanceSessionWithIdOnly = await prisma.maintenanceSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaintenanceSession.
     * @param {MaintenanceSessionDeleteArgs} args - Arguments to delete one MaintenanceSession.
     * @example
     * // Delete one MaintenanceSession
     * const MaintenanceSession = await prisma.maintenanceSession.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceSession
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceSessionDeleteArgs>(args: SelectSubset<T, MaintenanceSessionDeleteArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaintenanceSession.
     * @param {MaintenanceSessionUpdateArgs} args - Arguments to update one MaintenanceSession.
     * @example
     * // Update one MaintenanceSession
     * const maintenanceSession = await prisma.maintenanceSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceSessionUpdateArgs>(args: SelectSubset<T, MaintenanceSessionUpdateArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaintenanceSessions.
     * @param {MaintenanceSessionDeleteManyArgs} args - Arguments to filter MaintenanceSessions to delete.
     * @example
     * // Delete a few MaintenanceSessions
     * const { count } = await prisma.maintenanceSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceSessionDeleteManyArgs>(args?: SelectSubset<T, MaintenanceSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceSessions
     * const maintenanceSession = await prisma.maintenanceSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceSessionUpdateManyArgs>(args: SelectSubset<T, MaintenanceSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceSessions and returns the data updated in the database.
     * @param {MaintenanceSessionUpdateManyAndReturnArgs} args - Arguments to update many MaintenanceSessions.
     * @example
     * // Update many MaintenanceSessions
     * const maintenanceSession = await prisma.maintenanceSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaintenanceSessions and only return the `id`
     * const maintenanceSessionWithIdOnly = await prisma.maintenanceSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintenanceSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintenanceSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaintenanceSession.
     * @param {MaintenanceSessionUpsertArgs} args - Arguments to update or create a MaintenanceSession.
     * @example
     * // Update or create a MaintenanceSession
     * const maintenanceSession = await prisma.maintenanceSession.upsert({
     *   create: {
     *     // ... data to create a MaintenanceSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceSession we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceSessionUpsertArgs>(args: SelectSubset<T, MaintenanceSessionUpsertArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaintenanceSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSessionCountArgs} args - Arguments to filter MaintenanceSessions to count.
     * @example
     * // Count the number of MaintenanceSessions
     * const count = await prisma.maintenanceSession.count({
     *   where: {
     *     // ... the filter for the MaintenanceSessions we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceSessionCountArgs>(
      args?: Subset<T, MaintenanceSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceSessionAggregateArgs>(args: Subset<T, MaintenanceSessionAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceSessionAggregateType<T>>

    /**
     * Group by MaintenanceSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceSessionGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceSession model
   */
  readonly fields: MaintenanceSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends AgentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentProfileDefaultArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    materials<T extends MaintenanceSession$materialsArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceSession$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos<T extends MaintenanceSession$photosArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceSession$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manager<T extends PoleManagerProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PoleManagerProfileDefaultArgs<ExtArgs>>): Prisma__PoleManagerProfileClient<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceSession model
   */
  interface MaintenanceSessionFieldRefs {
    readonly id: FieldRef<"MaintenanceSession", 'String'>
    readonly sessionNumber: FieldRef<"MaintenanceSession", 'String'>
    readonly ticketId: FieldRef<"MaintenanceSession", 'String'>
    readonly propertyId: FieldRef<"MaintenanceSession", 'String'>
    readonly agentId: FieldRef<"MaintenanceSession", 'String'>
    readonly scheduledDate: FieldRef<"MaintenanceSession", 'DateTime'>
    readonly startTime: FieldRef<"MaintenanceSession", 'DateTime'>
    readonly endTime: FieldRef<"MaintenanceSession", 'DateTime'>
    readonly estimatedDuration: FieldRef<"MaintenanceSession", 'Int'>
    readonly actualDuration: FieldRef<"MaintenanceSession", 'Int'>
    readonly status: FieldRef<"MaintenanceSession", 'SessionStatus'>
    readonly notes: FieldRef<"MaintenanceSession", 'String'>
    readonly workDescription: FieldRef<"MaintenanceSession", 'String'>
    readonly agentNotes: FieldRef<"MaintenanceSession", 'String'>
    readonly laborCost: FieldRef<"MaintenanceSession", 'Float'>
    readonly materialsCost: FieldRef<"MaintenanceSession", 'Float'>
    readonly totalCost: FieldRef<"MaintenanceSession", 'Float'>
    readonly ownerApproval: FieldRef<"MaintenanceSession", 'Boolean'>
    readonly managerApproval: FieldRef<"MaintenanceSession", 'Boolean'>
    readonly createdAt: FieldRef<"MaintenanceSession", 'DateTime'>
    readonly updatedAt: FieldRef<"MaintenanceSession", 'DateTime'>
    readonly managerId: FieldRef<"MaintenanceSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceSession findUnique
   */
  export type MaintenanceSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceSession to fetch.
     */
    where: MaintenanceSessionWhereUniqueInput
  }

  /**
   * MaintenanceSession findUniqueOrThrow
   */
  export type MaintenanceSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceSession to fetch.
     */
    where: MaintenanceSessionWhereUniqueInput
  }

  /**
   * MaintenanceSession findFirst
   */
  export type MaintenanceSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceSession to fetch.
     */
    where?: MaintenanceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceSessions to fetch.
     */
    orderBy?: MaintenanceSessionOrderByWithRelationInput | MaintenanceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceSessions.
     */
    cursor?: MaintenanceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceSessions.
     */
    distinct?: MaintenanceSessionScalarFieldEnum | MaintenanceSessionScalarFieldEnum[]
  }

  /**
   * MaintenanceSession findFirstOrThrow
   */
  export type MaintenanceSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceSession to fetch.
     */
    where?: MaintenanceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceSessions to fetch.
     */
    orderBy?: MaintenanceSessionOrderByWithRelationInput | MaintenanceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceSessions.
     */
    cursor?: MaintenanceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceSessions.
     */
    distinct?: MaintenanceSessionScalarFieldEnum | MaintenanceSessionScalarFieldEnum[]
  }

  /**
   * MaintenanceSession findMany
   */
  export type MaintenanceSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceSessions to fetch.
     */
    where?: MaintenanceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceSessions to fetch.
     */
    orderBy?: MaintenanceSessionOrderByWithRelationInput | MaintenanceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceSessions.
     */
    cursor?: MaintenanceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceSessions.
     */
    skip?: number
    distinct?: MaintenanceSessionScalarFieldEnum | MaintenanceSessionScalarFieldEnum[]
  }

  /**
   * MaintenanceSession create
   */
  export type MaintenanceSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceSession.
     */
    data: XOR<MaintenanceSessionCreateInput, MaintenanceSessionUncheckedCreateInput>
  }

  /**
   * MaintenanceSession createMany
   */
  export type MaintenanceSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceSessions.
     */
    data: MaintenanceSessionCreateManyInput | MaintenanceSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaintenanceSession createManyAndReturn
   */
  export type MaintenanceSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * The data used to create many MaintenanceSessions.
     */
    data: MaintenanceSessionCreateManyInput | MaintenanceSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceSession update
   */
  export type MaintenanceSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceSession.
     */
    data: XOR<MaintenanceSessionUpdateInput, MaintenanceSessionUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceSession to update.
     */
    where: MaintenanceSessionWhereUniqueInput
  }

  /**
   * MaintenanceSession updateMany
   */
  export type MaintenanceSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceSessions.
     */
    data: XOR<MaintenanceSessionUpdateManyMutationInput, MaintenanceSessionUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceSessions to update
     */
    where?: MaintenanceSessionWhereInput
    /**
     * Limit how many MaintenanceSessions to update.
     */
    limit?: number
  }

  /**
   * MaintenanceSession updateManyAndReturn
   */
  export type MaintenanceSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * The data used to update MaintenanceSessions.
     */
    data: XOR<MaintenanceSessionUpdateManyMutationInput, MaintenanceSessionUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceSessions to update
     */
    where?: MaintenanceSessionWhereInput
    /**
     * Limit how many MaintenanceSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceSession upsert
   */
  export type MaintenanceSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceSession to update in case it exists.
     */
    where: MaintenanceSessionWhereUniqueInput
    /**
     * In case the MaintenanceSession found by the `where` argument doesn't exist, create a new MaintenanceSession with this data.
     */
    create: XOR<MaintenanceSessionCreateInput, MaintenanceSessionUncheckedCreateInput>
    /**
     * In case the MaintenanceSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceSessionUpdateInput, MaintenanceSessionUncheckedUpdateInput>
  }

  /**
   * MaintenanceSession delete
   */
  export type MaintenanceSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
    /**
     * Filter which MaintenanceSession to delete.
     */
    where: MaintenanceSessionWhereUniqueInput
  }

  /**
   * MaintenanceSession deleteMany
   */
  export type MaintenanceSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceSessions to delete
     */
    where?: MaintenanceSessionWhereInput
    /**
     * Limit how many MaintenanceSessions to delete.
     */
    limit?: number
  }

  /**
   * MaintenanceSession.materials
   */
  export type MaintenanceSession$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceMaterial
     */
    select?: MaintenanceMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceMaterial
     */
    omit?: MaintenanceMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceMaterialInclude<ExtArgs> | null
    where?: MaintenanceMaterialWhereInput
    orderBy?: MaintenanceMaterialOrderByWithRelationInput | MaintenanceMaterialOrderByWithRelationInput[]
    cursor?: MaintenanceMaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceMaterialScalarFieldEnum | MaintenanceMaterialScalarFieldEnum[]
  }

  /**
   * MaintenanceSession.photos
   */
  export type MaintenanceSession$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    where?: MaintenancePhotoWhereInput
    orderBy?: MaintenancePhotoOrderByWithRelationInput | MaintenancePhotoOrderByWithRelationInput[]
    cursor?: MaintenancePhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenancePhotoScalarFieldEnum | MaintenancePhotoScalarFieldEnum[]
  }

  /**
   * MaintenanceSession without action
   */
  export type MaintenanceSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceSession
     */
    select?: MaintenanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceSession
     */
    omit?: MaintenanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceSessionInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceMaterial
   */

  export type AggregateMaintenanceMaterial = {
    _count: MaintenanceMaterialCountAggregateOutputType | null
    _avg: MaintenanceMaterialAvgAggregateOutputType | null
    _sum: MaintenanceMaterialSumAggregateOutputType | null
    _min: MaintenanceMaterialMinAggregateOutputType | null
    _max: MaintenanceMaterialMaxAggregateOutputType | null
  }

  export type MaintenanceMaterialAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type MaintenanceMaterialSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type MaintenanceMaterialMinAggregateOutputType = {
    id: string | null
    name: string | null
    quantity: number | null
    unit: string | null
    unitPrice: number | null
    totalPrice: number | null
    supplier: string | null
    maintenanceSessionId: string | null
  }

  export type MaintenanceMaterialMaxAggregateOutputType = {
    id: string | null
    name: string | null
    quantity: number | null
    unit: string | null
    unitPrice: number | null
    totalPrice: number | null
    supplier: string | null
    maintenanceSessionId: string | null
  }

  export type MaintenanceMaterialCountAggregateOutputType = {
    id: number
    name: number
    quantity: number
    unit: number
    unitPrice: number
    totalPrice: number
    supplier: number
    maintenanceSessionId: number
    _all: number
  }


  export type MaintenanceMaterialAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type MaintenanceMaterialSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type MaintenanceMaterialMinAggregateInputType = {
    id?: true
    name?: true
    quantity?: true
    unit?: true
    unitPrice?: true
    totalPrice?: true
    supplier?: true
    maintenanceSessionId?: true
  }

  export type MaintenanceMaterialMaxAggregateInputType = {
    id?: true
    name?: true
    quantity?: true
    unit?: true
    unitPrice?: true
    totalPrice?: true
    supplier?: true
    maintenanceSessionId?: true
  }

  export type MaintenanceMaterialCountAggregateInputType = {
    id?: true
    name?: true
    quantity?: true
    unit?: true
    unitPrice?: true
    totalPrice?: true
    supplier?: true
    maintenanceSessionId?: true
    _all?: true
  }

  export type MaintenanceMaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceMaterial to aggregate.
     */
    where?: MaintenanceMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceMaterials to fetch.
     */
    orderBy?: MaintenanceMaterialOrderByWithRelationInput | MaintenanceMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceMaterials
    **/
    _count?: true | MaintenanceMaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaintenanceMaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaintenanceMaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceMaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceMaterialMaxAggregateInputType
  }

  export type GetMaintenanceMaterialAggregateType<T extends MaintenanceMaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceMaterial[P]>
      : GetScalarType<T[P], AggregateMaintenanceMaterial[P]>
  }




  export type MaintenanceMaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceMaterialWhereInput
    orderBy?: MaintenanceMaterialOrderByWithAggregationInput | MaintenanceMaterialOrderByWithAggregationInput[]
    by: MaintenanceMaterialScalarFieldEnum[] | MaintenanceMaterialScalarFieldEnum
    having?: MaintenanceMaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceMaterialCountAggregateInputType | true
    _avg?: MaintenanceMaterialAvgAggregateInputType
    _sum?: MaintenanceMaterialSumAggregateInputType
    _min?: MaintenanceMaterialMinAggregateInputType
    _max?: MaintenanceMaterialMaxAggregateInputType
  }

  export type MaintenanceMaterialGroupByOutputType = {
    id: string
    name: string
    quantity: number
    unit: string
    unitPrice: number
    totalPrice: number
    supplier: string | null
    maintenanceSessionId: string
    _count: MaintenanceMaterialCountAggregateOutputType | null
    _avg: MaintenanceMaterialAvgAggregateOutputType | null
    _sum: MaintenanceMaterialSumAggregateOutputType | null
    _min: MaintenanceMaterialMinAggregateOutputType | null
    _max: MaintenanceMaterialMaxAggregateOutputType | null
  }

  type GetMaintenanceMaterialGroupByPayload<T extends MaintenanceMaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceMaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceMaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceMaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceMaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    quantity?: boolean
    unit?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    supplier?: boolean
    maintenanceSessionId?: boolean
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceMaterial"]>

  export type MaintenanceMaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    quantity?: boolean
    unit?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    supplier?: boolean
    maintenanceSessionId?: boolean
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceMaterial"]>

  export type MaintenanceMaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    quantity?: boolean
    unit?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    supplier?: boolean
    maintenanceSessionId?: boolean
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceMaterial"]>

  export type MaintenanceMaterialSelectScalar = {
    id?: boolean
    name?: boolean
    quantity?: boolean
    unit?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    supplier?: boolean
    maintenanceSessionId?: boolean
  }

  export type MaintenanceMaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "quantity" | "unit" | "unitPrice" | "totalPrice" | "supplier" | "maintenanceSessionId", ExtArgs["result"]["maintenanceMaterial"]>
  export type MaintenanceMaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }
  export type MaintenanceMaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }
  export type MaintenanceMaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }

  export type $MaintenanceMaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceMaterial"
    objects: {
      maintenanceSession: Prisma.$MaintenanceSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      quantity: number
      unit: string
      unitPrice: number
      totalPrice: number
      supplier: string | null
      maintenanceSessionId: string
    }, ExtArgs["result"]["maintenanceMaterial"]>
    composites: {}
  }

  type MaintenanceMaterialGetPayload<S extends boolean | null | undefined | MaintenanceMaterialDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceMaterialPayload, S>

  type MaintenanceMaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenanceMaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenanceMaterialCountAggregateInputType | true
    }

  export interface MaintenanceMaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceMaterial'], meta: { name: 'MaintenanceMaterial' } }
    /**
     * Find zero or one MaintenanceMaterial that matches the filter.
     * @param {MaintenanceMaterialFindUniqueArgs} args - Arguments to find a MaintenanceMaterial
     * @example
     * // Get one MaintenanceMaterial
     * const maintenanceMaterial = await prisma.maintenanceMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceMaterialFindUniqueArgs>(args: SelectSubset<T, MaintenanceMaterialFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceMaterialClient<$Result.GetResult<Prisma.$MaintenanceMaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaintenanceMaterial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenanceMaterialFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceMaterial
     * @example
     * // Get one MaintenanceMaterial
     * const maintenanceMaterial = await prisma.maintenanceMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceMaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceMaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceMaterialClient<$Result.GetResult<Prisma.$MaintenanceMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceMaterialFindFirstArgs} args - Arguments to find a MaintenanceMaterial
     * @example
     * // Get one MaintenanceMaterial
     * const maintenanceMaterial = await prisma.maintenanceMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceMaterialFindFirstArgs>(args?: SelectSubset<T, MaintenanceMaterialFindFirstArgs<ExtArgs>>): Prisma__MaintenanceMaterialClient<$Result.GetResult<Prisma.$MaintenanceMaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceMaterial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceMaterialFindFirstOrThrowArgs} args - Arguments to find a MaintenanceMaterial
     * @example
     * // Get one MaintenanceMaterial
     * const maintenanceMaterial = await prisma.maintenanceMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceMaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceMaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceMaterialClient<$Result.GetResult<Prisma.$MaintenanceMaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaintenanceMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceMaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceMaterials
     * const maintenanceMaterials = await prisma.maintenanceMaterial.findMany()
     * 
     * // Get first 10 MaintenanceMaterials
     * const maintenanceMaterials = await prisma.maintenanceMaterial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceMaterialWithIdOnly = await prisma.maintenanceMaterial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceMaterialFindManyArgs>(args?: SelectSubset<T, MaintenanceMaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaintenanceMaterial.
     * @param {MaintenanceMaterialCreateArgs} args - Arguments to create a MaintenanceMaterial.
     * @example
     * // Create one MaintenanceMaterial
     * const MaintenanceMaterial = await prisma.maintenanceMaterial.create({
     *   data: {
     *     // ... data to create a MaintenanceMaterial
     *   }
     * })
     * 
     */
    create<T extends MaintenanceMaterialCreateArgs>(args: SelectSubset<T, MaintenanceMaterialCreateArgs<ExtArgs>>): Prisma__MaintenanceMaterialClient<$Result.GetResult<Prisma.$MaintenanceMaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaintenanceMaterials.
     * @param {MaintenanceMaterialCreateManyArgs} args - Arguments to create many MaintenanceMaterials.
     * @example
     * // Create many MaintenanceMaterials
     * const maintenanceMaterial = await prisma.maintenanceMaterial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceMaterialCreateManyArgs>(args?: SelectSubset<T, MaintenanceMaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceMaterials and returns the data saved in the database.
     * @param {MaintenanceMaterialCreateManyAndReturnArgs} args - Arguments to create many MaintenanceMaterials.
     * @example
     * // Create many MaintenanceMaterials
     * const maintenanceMaterial = await prisma.maintenanceMaterial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceMaterials and only return the `id`
     * const maintenanceMaterialWithIdOnly = await prisma.maintenanceMaterial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceMaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceMaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceMaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaintenanceMaterial.
     * @param {MaintenanceMaterialDeleteArgs} args - Arguments to delete one MaintenanceMaterial.
     * @example
     * // Delete one MaintenanceMaterial
     * const MaintenanceMaterial = await prisma.maintenanceMaterial.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceMaterial
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceMaterialDeleteArgs>(args: SelectSubset<T, MaintenanceMaterialDeleteArgs<ExtArgs>>): Prisma__MaintenanceMaterialClient<$Result.GetResult<Prisma.$MaintenanceMaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaintenanceMaterial.
     * @param {MaintenanceMaterialUpdateArgs} args - Arguments to update one MaintenanceMaterial.
     * @example
     * // Update one MaintenanceMaterial
     * const maintenanceMaterial = await prisma.maintenanceMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceMaterialUpdateArgs>(args: SelectSubset<T, MaintenanceMaterialUpdateArgs<ExtArgs>>): Prisma__MaintenanceMaterialClient<$Result.GetResult<Prisma.$MaintenanceMaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaintenanceMaterials.
     * @param {MaintenanceMaterialDeleteManyArgs} args - Arguments to filter MaintenanceMaterials to delete.
     * @example
     * // Delete a few MaintenanceMaterials
     * const { count } = await prisma.maintenanceMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceMaterialDeleteManyArgs>(args?: SelectSubset<T, MaintenanceMaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceMaterials
     * const maintenanceMaterial = await prisma.maintenanceMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceMaterialUpdateManyArgs>(args: SelectSubset<T, MaintenanceMaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceMaterials and returns the data updated in the database.
     * @param {MaintenanceMaterialUpdateManyAndReturnArgs} args - Arguments to update many MaintenanceMaterials.
     * @example
     * // Update many MaintenanceMaterials
     * const maintenanceMaterial = await prisma.maintenanceMaterial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaintenanceMaterials and only return the `id`
     * const maintenanceMaterialWithIdOnly = await prisma.maintenanceMaterial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintenanceMaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintenanceMaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceMaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaintenanceMaterial.
     * @param {MaintenanceMaterialUpsertArgs} args - Arguments to update or create a MaintenanceMaterial.
     * @example
     * // Update or create a MaintenanceMaterial
     * const maintenanceMaterial = await prisma.maintenanceMaterial.upsert({
     *   create: {
     *     // ... data to create a MaintenanceMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceMaterial we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceMaterialUpsertArgs>(args: SelectSubset<T, MaintenanceMaterialUpsertArgs<ExtArgs>>): Prisma__MaintenanceMaterialClient<$Result.GetResult<Prisma.$MaintenanceMaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaintenanceMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceMaterialCountArgs} args - Arguments to filter MaintenanceMaterials to count.
     * @example
     * // Count the number of MaintenanceMaterials
     * const count = await prisma.maintenanceMaterial.count({
     *   where: {
     *     // ... the filter for the MaintenanceMaterials we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceMaterialCountArgs>(
      args?: Subset<T, MaintenanceMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceMaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceMaterialAggregateArgs>(args: Subset<T, MaintenanceMaterialAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceMaterialAggregateType<T>>

    /**
     * Group by MaintenanceMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceMaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceMaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceMaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceMaterial model
   */
  readonly fields: MaintenanceMaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceMaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    maintenanceSession<T extends MaintenanceSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceSessionDefaultArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceMaterial model
   */
  interface MaintenanceMaterialFieldRefs {
    readonly id: FieldRef<"MaintenanceMaterial", 'String'>
    readonly name: FieldRef<"MaintenanceMaterial", 'String'>
    readonly quantity: FieldRef<"MaintenanceMaterial", 'Float'>
    readonly unit: FieldRef<"MaintenanceMaterial", 'String'>
    readonly unitPrice: FieldRef<"MaintenanceMaterial", 'Float'>
    readonly totalPrice: FieldRef<"MaintenanceMaterial", 'Float'>
    readonly supplier: FieldRef<"MaintenanceMaterial", 'String'>
    readonly maintenanceSessionId: FieldRef<"MaintenanceMaterial", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceMaterial findUnique
   */
  export type MaintenanceMaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceMaterial
     */
    select?: MaintenanceMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceMaterial
     */
    omit?: MaintenanceMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceMaterialInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceMaterial to fetch.
     */
    where: MaintenanceMaterialWhereUniqueInput
  }

  /**
   * MaintenanceMaterial findUniqueOrThrow
   */
  export type MaintenanceMaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceMaterial
     */
    select?: MaintenanceMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceMaterial
     */
    omit?: MaintenanceMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceMaterialInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceMaterial to fetch.
     */
    where: MaintenanceMaterialWhereUniqueInput
  }

  /**
   * MaintenanceMaterial findFirst
   */
  export type MaintenanceMaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceMaterial
     */
    select?: MaintenanceMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceMaterial
     */
    omit?: MaintenanceMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceMaterialInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceMaterial to fetch.
     */
    where?: MaintenanceMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceMaterials to fetch.
     */
    orderBy?: MaintenanceMaterialOrderByWithRelationInput | MaintenanceMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceMaterials.
     */
    cursor?: MaintenanceMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceMaterials.
     */
    distinct?: MaintenanceMaterialScalarFieldEnum | MaintenanceMaterialScalarFieldEnum[]
  }

  /**
   * MaintenanceMaterial findFirstOrThrow
   */
  export type MaintenanceMaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceMaterial
     */
    select?: MaintenanceMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceMaterial
     */
    omit?: MaintenanceMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceMaterialInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceMaterial to fetch.
     */
    where?: MaintenanceMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceMaterials to fetch.
     */
    orderBy?: MaintenanceMaterialOrderByWithRelationInput | MaintenanceMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceMaterials.
     */
    cursor?: MaintenanceMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceMaterials.
     */
    distinct?: MaintenanceMaterialScalarFieldEnum | MaintenanceMaterialScalarFieldEnum[]
  }

  /**
   * MaintenanceMaterial findMany
   */
  export type MaintenanceMaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceMaterial
     */
    select?: MaintenanceMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceMaterial
     */
    omit?: MaintenanceMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceMaterialInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceMaterials to fetch.
     */
    where?: MaintenanceMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceMaterials to fetch.
     */
    orderBy?: MaintenanceMaterialOrderByWithRelationInput | MaintenanceMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceMaterials.
     */
    cursor?: MaintenanceMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceMaterials.
     */
    skip?: number
    distinct?: MaintenanceMaterialScalarFieldEnum | MaintenanceMaterialScalarFieldEnum[]
  }

  /**
   * MaintenanceMaterial create
   */
  export type MaintenanceMaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceMaterial
     */
    select?: MaintenanceMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceMaterial
     */
    omit?: MaintenanceMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceMaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceMaterial.
     */
    data: XOR<MaintenanceMaterialCreateInput, MaintenanceMaterialUncheckedCreateInput>
  }

  /**
   * MaintenanceMaterial createMany
   */
  export type MaintenanceMaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceMaterials.
     */
    data: MaintenanceMaterialCreateManyInput | MaintenanceMaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaintenanceMaterial createManyAndReturn
   */
  export type MaintenanceMaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceMaterial
     */
    select?: MaintenanceMaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceMaterial
     */
    omit?: MaintenanceMaterialOmit<ExtArgs> | null
    /**
     * The data used to create many MaintenanceMaterials.
     */
    data: MaintenanceMaterialCreateManyInput | MaintenanceMaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceMaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceMaterial update
   */
  export type MaintenanceMaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceMaterial
     */
    select?: MaintenanceMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceMaterial
     */
    omit?: MaintenanceMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceMaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceMaterial.
     */
    data: XOR<MaintenanceMaterialUpdateInput, MaintenanceMaterialUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceMaterial to update.
     */
    where: MaintenanceMaterialWhereUniqueInput
  }

  /**
   * MaintenanceMaterial updateMany
   */
  export type MaintenanceMaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceMaterials.
     */
    data: XOR<MaintenanceMaterialUpdateManyMutationInput, MaintenanceMaterialUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceMaterials to update
     */
    where?: MaintenanceMaterialWhereInput
    /**
     * Limit how many MaintenanceMaterials to update.
     */
    limit?: number
  }

  /**
   * MaintenanceMaterial updateManyAndReturn
   */
  export type MaintenanceMaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceMaterial
     */
    select?: MaintenanceMaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceMaterial
     */
    omit?: MaintenanceMaterialOmit<ExtArgs> | null
    /**
     * The data used to update MaintenanceMaterials.
     */
    data: XOR<MaintenanceMaterialUpdateManyMutationInput, MaintenanceMaterialUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceMaterials to update
     */
    where?: MaintenanceMaterialWhereInput
    /**
     * Limit how many MaintenanceMaterials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceMaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceMaterial upsert
   */
  export type MaintenanceMaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceMaterial
     */
    select?: MaintenanceMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceMaterial
     */
    omit?: MaintenanceMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceMaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceMaterial to update in case it exists.
     */
    where: MaintenanceMaterialWhereUniqueInput
    /**
     * In case the MaintenanceMaterial found by the `where` argument doesn't exist, create a new MaintenanceMaterial with this data.
     */
    create: XOR<MaintenanceMaterialCreateInput, MaintenanceMaterialUncheckedCreateInput>
    /**
     * In case the MaintenanceMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceMaterialUpdateInput, MaintenanceMaterialUncheckedUpdateInput>
  }

  /**
   * MaintenanceMaterial delete
   */
  export type MaintenanceMaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceMaterial
     */
    select?: MaintenanceMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceMaterial
     */
    omit?: MaintenanceMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceMaterialInclude<ExtArgs> | null
    /**
     * Filter which MaintenanceMaterial to delete.
     */
    where: MaintenanceMaterialWhereUniqueInput
  }

  /**
   * MaintenanceMaterial deleteMany
   */
  export type MaintenanceMaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceMaterials to delete
     */
    where?: MaintenanceMaterialWhereInput
    /**
     * Limit how many MaintenanceMaterials to delete.
     */
    limit?: number
  }

  /**
   * MaintenanceMaterial without action
   */
  export type MaintenanceMaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceMaterial
     */
    select?: MaintenanceMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceMaterial
     */
    omit?: MaintenanceMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceMaterialInclude<ExtArgs> | null
  }


  /**
   * Model MaintenancePhoto
   */

  export type AggregateMaintenancePhoto = {
    _count: MaintenancePhotoCountAggregateOutputType | null
    _min: MaintenancePhotoMinAggregateOutputType | null
    _max: MaintenancePhotoMaxAggregateOutputType | null
  }

  export type MaintenancePhotoMinAggregateOutputType = {
    id: string | null
    url: string | null
    type: string | null
    caption: string | null
    maintenanceSessionId: string | null
    createdAt: Date | null
  }

  export type MaintenancePhotoMaxAggregateOutputType = {
    id: string | null
    url: string | null
    type: string | null
    caption: string | null
    maintenanceSessionId: string | null
    createdAt: Date | null
  }

  export type MaintenancePhotoCountAggregateOutputType = {
    id: number
    url: number
    type: number
    caption: number
    maintenanceSessionId: number
    createdAt: number
    _all: number
  }


  export type MaintenancePhotoMinAggregateInputType = {
    id?: true
    url?: true
    type?: true
    caption?: true
    maintenanceSessionId?: true
    createdAt?: true
  }

  export type MaintenancePhotoMaxAggregateInputType = {
    id?: true
    url?: true
    type?: true
    caption?: true
    maintenanceSessionId?: true
    createdAt?: true
  }

  export type MaintenancePhotoCountAggregateInputType = {
    id?: true
    url?: true
    type?: true
    caption?: true
    maintenanceSessionId?: true
    createdAt?: true
    _all?: true
  }

  export type MaintenancePhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenancePhoto to aggregate.
     */
    where?: MaintenancePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenancePhotos to fetch.
     */
    orderBy?: MaintenancePhotoOrderByWithRelationInput | MaintenancePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenancePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenancePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenancePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenancePhotos
    **/
    _count?: true | MaintenancePhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenancePhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenancePhotoMaxAggregateInputType
  }

  export type GetMaintenancePhotoAggregateType<T extends MaintenancePhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenancePhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenancePhoto[P]>
      : GetScalarType<T[P], AggregateMaintenancePhoto[P]>
  }




  export type MaintenancePhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenancePhotoWhereInput
    orderBy?: MaintenancePhotoOrderByWithAggregationInput | MaintenancePhotoOrderByWithAggregationInput[]
    by: MaintenancePhotoScalarFieldEnum[] | MaintenancePhotoScalarFieldEnum
    having?: MaintenancePhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenancePhotoCountAggregateInputType | true
    _min?: MaintenancePhotoMinAggregateInputType
    _max?: MaintenancePhotoMaxAggregateInputType
  }

  export type MaintenancePhotoGroupByOutputType = {
    id: string
    url: string
    type: string | null
    caption: string | null
    maintenanceSessionId: string
    createdAt: Date
    _count: MaintenancePhotoCountAggregateOutputType | null
    _min: MaintenancePhotoMinAggregateOutputType | null
    _max: MaintenancePhotoMaxAggregateOutputType | null
  }

  type GetMaintenancePhotoGroupByPayload<T extends MaintenancePhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenancePhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenancePhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenancePhotoGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenancePhotoGroupByOutputType[P]>
        }
      >
    >


  export type MaintenancePhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    caption?: boolean
    maintenanceSessionId?: boolean
    createdAt?: boolean
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenancePhoto"]>

  export type MaintenancePhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    caption?: boolean
    maintenanceSessionId?: boolean
    createdAt?: boolean
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenancePhoto"]>

  export type MaintenancePhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    caption?: boolean
    maintenanceSessionId?: boolean
    createdAt?: boolean
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenancePhoto"]>

  export type MaintenancePhotoSelectScalar = {
    id?: boolean
    url?: boolean
    type?: boolean
    caption?: boolean
    maintenanceSessionId?: boolean
    createdAt?: boolean
  }

  export type MaintenancePhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "type" | "caption" | "maintenanceSessionId" | "createdAt", ExtArgs["result"]["maintenancePhoto"]>
  export type MaintenancePhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }
  export type MaintenancePhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }
  export type MaintenancePhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenanceSession?: boolean | MaintenanceSessionDefaultArgs<ExtArgs>
  }

  export type $MaintenancePhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenancePhoto"
    objects: {
      maintenanceSession: Prisma.$MaintenanceSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      type: string | null
      caption: string | null
      maintenanceSessionId: string
      createdAt: Date
    }, ExtArgs["result"]["maintenancePhoto"]>
    composites: {}
  }

  type MaintenancePhotoGetPayload<S extends boolean | null | undefined | MaintenancePhotoDefaultArgs> = $Result.GetResult<Prisma.$MaintenancePhotoPayload, S>

  type MaintenancePhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenancePhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenancePhotoCountAggregateInputType | true
    }

  export interface MaintenancePhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenancePhoto'], meta: { name: 'MaintenancePhoto' } }
    /**
     * Find zero or one MaintenancePhoto that matches the filter.
     * @param {MaintenancePhotoFindUniqueArgs} args - Arguments to find a MaintenancePhoto
     * @example
     * // Get one MaintenancePhoto
     * const maintenancePhoto = await prisma.maintenancePhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenancePhotoFindUniqueArgs>(args: SelectSubset<T, MaintenancePhotoFindUniqueArgs<ExtArgs>>): Prisma__MaintenancePhotoClient<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaintenancePhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenancePhotoFindUniqueOrThrowArgs} args - Arguments to find a MaintenancePhoto
     * @example
     * // Get one MaintenancePhoto
     * const maintenancePhoto = await prisma.maintenancePhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenancePhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenancePhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenancePhotoClient<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenancePhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenancePhotoFindFirstArgs} args - Arguments to find a MaintenancePhoto
     * @example
     * // Get one MaintenancePhoto
     * const maintenancePhoto = await prisma.maintenancePhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenancePhotoFindFirstArgs>(args?: SelectSubset<T, MaintenancePhotoFindFirstArgs<ExtArgs>>): Prisma__MaintenancePhotoClient<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenancePhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenancePhotoFindFirstOrThrowArgs} args - Arguments to find a MaintenancePhoto
     * @example
     * // Get one MaintenancePhoto
     * const maintenancePhoto = await prisma.maintenancePhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenancePhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenancePhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenancePhotoClient<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaintenancePhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenancePhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenancePhotos
     * const maintenancePhotos = await prisma.maintenancePhoto.findMany()
     * 
     * // Get first 10 MaintenancePhotos
     * const maintenancePhotos = await prisma.maintenancePhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenancePhotoWithIdOnly = await prisma.maintenancePhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenancePhotoFindManyArgs>(args?: SelectSubset<T, MaintenancePhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaintenancePhoto.
     * @param {MaintenancePhotoCreateArgs} args - Arguments to create a MaintenancePhoto.
     * @example
     * // Create one MaintenancePhoto
     * const MaintenancePhoto = await prisma.maintenancePhoto.create({
     *   data: {
     *     // ... data to create a MaintenancePhoto
     *   }
     * })
     * 
     */
    create<T extends MaintenancePhotoCreateArgs>(args: SelectSubset<T, MaintenancePhotoCreateArgs<ExtArgs>>): Prisma__MaintenancePhotoClient<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaintenancePhotos.
     * @param {MaintenancePhotoCreateManyArgs} args - Arguments to create many MaintenancePhotos.
     * @example
     * // Create many MaintenancePhotos
     * const maintenancePhoto = await prisma.maintenancePhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenancePhotoCreateManyArgs>(args?: SelectSubset<T, MaintenancePhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenancePhotos and returns the data saved in the database.
     * @param {MaintenancePhotoCreateManyAndReturnArgs} args - Arguments to create many MaintenancePhotos.
     * @example
     * // Create many MaintenancePhotos
     * const maintenancePhoto = await prisma.maintenancePhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenancePhotos and only return the `id`
     * const maintenancePhotoWithIdOnly = await prisma.maintenancePhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenancePhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenancePhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaintenancePhoto.
     * @param {MaintenancePhotoDeleteArgs} args - Arguments to delete one MaintenancePhoto.
     * @example
     * // Delete one MaintenancePhoto
     * const MaintenancePhoto = await prisma.maintenancePhoto.delete({
     *   where: {
     *     // ... filter to delete one MaintenancePhoto
     *   }
     * })
     * 
     */
    delete<T extends MaintenancePhotoDeleteArgs>(args: SelectSubset<T, MaintenancePhotoDeleteArgs<ExtArgs>>): Prisma__MaintenancePhotoClient<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaintenancePhoto.
     * @param {MaintenancePhotoUpdateArgs} args - Arguments to update one MaintenancePhoto.
     * @example
     * // Update one MaintenancePhoto
     * const maintenancePhoto = await prisma.maintenancePhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenancePhotoUpdateArgs>(args: SelectSubset<T, MaintenancePhotoUpdateArgs<ExtArgs>>): Prisma__MaintenancePhotoClient<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaintenancePhotos.
     * @param {MaintenancePhotoDeleteManyArgs} args - Arguments to filter MaintenancePhotos to delete.
     * @example
     * // Delete a few MaintenancePhotos
     * const { count } = await prisma.maintenancePhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenancePhotoDeleteManyArgs>(args?: SelectSubset<T, MaintenancePhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenancePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenancePhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenancePhotos
     * const maintenancePhoto = await prisma.maintenancePhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenancePhotoUpdateManyArgs>(args: SelectSubset<T, MaintenancePhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenancePhotos and returns the data updated in the database.
     * @param {MaintenancePhotoUpdateManyAndReturnArgs} args - Arguments to update many MaintenancePhotos.
     * @example
     * // Update many MaintenancePhotos
     * const maintenancePhoto = await prisma.maintenancePhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaintenancePhotos and only return the `id`
     * const maintenancePhotoWithIdOnly = await prisma.maintenancePhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintenancePhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintenancePhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaintenancePhoto.
     * @param {MaintenancePhotoUpsertArgs} args - Arguments to update or create a MaintenancePhoto.
     * @example
     * // Update or create a MaintenancePhoto
     * const maintenancePhoto = await prisma.maintenancePhoto.upsert({
     *   create: {
     *     // ... data to create a MaintenancePhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenancePhoto we want to update
     *   }
     * })
     */
    upsert<T extends MaintenancePhotoUpsertArgs>(args: SelectSubset<T, MaintenancePhotoUpsertArgs<ExtArgs>>): Prisma__MaintenancePhotoClient<$Result.GetResult<Prisma.$MaintenancePhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaintenancePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenancePhotoCountArgs} args - Arguments to filter MaintenancePhotos to count.
     * @example
     * // Count the number of MaintenancePhotos
     * const count = await prisma.maintenancePhoto.count({
     *   where: {
     *     // ... the filter for the MaintenancePhotos we want to count
     *   }
     * })
    **/
    count<T extends MaintenancePhotoCountArgs>(
      args?: Subset<T, MaintenancePhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenancePhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenancePhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenancePhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenancePhotoAggregateArgs>(args: Subset<T, MaintenancePhotoAggregateArgs>): Prisma.PrismaPromise<GetMaintenancePhotoAggregateType<T>>

    /**
     * Group by MaintenancePhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenancePhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenancePhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenancePhotoGroupByArgs['orderBy'] }
        : { orderBy?: MaintenancePhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenancePhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenancePhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenancePhoto model
   */
  readonly fields: MaintenancePhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenancePhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenancePhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    maintenanceSession<T extends MaintenanceSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceSessionDefaultArgs<ExtArgs>>): Prisma__MaintenanceSessionClient<$Result.GetResult<Prisma.$MaintenanceSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenancePhoto model
   */
  interface MaintenancePhotoFieldRefs {
    readonly id: FieldRef<"MaintenancePhoto", 'String'>
    readonly url: FieldRef<"MaintenancePhoto", 'String'>
    readonly type: FieldRef<"MaintenancePhoto", 'String'>
    readonly caption: FieldRef<"MaintenancePhoto", 'String'>
    readonly maintenanceSessionId: FieldRef<"MaintenancePhoto", 'String'>
    readonly createdAt: FieldRef<"MaintenancePhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaintenancePhoto findUnique
   */
  export type MaintenancePhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * Filter, which MaintenancePhoto to fetch.
     */
    where: MaintenancePhotoWhereUniqueInput
  }

  /**
   * MaintenancePhoto findUniqueOrThrow
   */
  export type MaintenancePhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * Filter, which MaintenancePhoto to fetch.
     */
    where: MaintenancePhotoWhereUniqueInput
  }

  /**
   * MaintenancePhoto findFirst
   */
  export type MaintenancePhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * Filter, which MaintenancePhoto to fetch.
     */
    where?: MaintenancePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenancePhotos to fetch.
     */
    orderBy?: MaintenancePhotoOrderByWithRelationInput | MaintenancePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenancePhotos.
     */
    cursor?: MaintenancePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenancePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenancePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenancePhotos.
     */
    distinct?: MaintenancePhotoScalarFieldEnum | MaintenancePhotoScalarFieldEnum[]
  }

  /**
   * MaintenancePhoto findFirstOrThrow
   */
  export type MaintenancePhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * Filter, which MaintenancePhoto to fetch.
     */
    where?: MaintenancePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenancePhotos to fetch.
     */
    orderBy?: MaintenancePhotoOrderByWithRelationInput | MaintenancePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenancePhotos.
     */
    cursor?: MaintenancePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenancePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenancePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenancePhotos.
     */
    distinct?: MaintenancePhotoScalarFieldEnum | MaintenancePhotoScalarFieldEnum[]
  }

  /**
   * MaintenancePhoto findMany
   */
  export type MaintenancePhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * Filter, which MaintenancePhotos to fetch.
     */
    where?: MaintenancePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenancePhotos to fetch.
     */
    orderBy?: MaintenancePhotoOrderByWithRelationInput | MaintenancePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenancePhotos.
     */
    cursor?: MaintenancePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenancePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenancePhotos.
     */
    skip?: number
    distinct?: MaintenancePhotoScalarFieldEnum | MaintenancePhotoScalarFieldEnum[]
  }

  /**
   * MaintenancePhoto create
   */
  export type MaintenancePhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenancePhoto.
     */
    data: XOR<MaintenancePhotoCreateInput, MaintenancePhotoUncheckedCreateInput>
  }

  /**
   * MaintenancePhoto createMany
   */
  export type MaintenancePhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenancePhotos.
     */
    data: MaintenancePhotoCreateManyInput | MaintenancePhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaintenancePhoto createManyAndReturn
   */
  export type MaintenancePhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * The data used to create many MaintenancePhotos.
     */
    data: MaintenancePhotoCreateManyInput | MaintenancePhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenancePhoto update
   */
  export type MaintenancePhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenancePhoto.
     */
    data: XOR<MaintenancePhotoUpdateInput, MaintenancePhotoUncheckedUpdateInput>
    /**
     * Choose, which MaintenancePhoto to update.
     */
    where: MaintenancePhotoWhereUniqueInput
  }

  /**
   * MaintenancePhoto updateMany
   */
  export type MaintenancePhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenancePhotos.
     */
    data: XOR<MaintenancePhotoUpdateManyMutationInput, MaintenancePhotoUncheckedUpdateManyInput>
    /**
     * Filter which MaintenancePhotos to update
     */
    where?: MaintenancePhotoWhereInput
    /**
     * Limit how many MaintenancePhotos to update.
     */
    limit?: number
  }

  /**
   * MaintenancePhoto updateManyAndReturn
   */
  export type MaintenancePhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * The data used to update MaintenancePhotos.
     */
    data: XOR<MaintenancePhotoUpdateManyMutationInput, MaintenancePhotoUncheckedUpdateManyInput>
    /**
     * Filter which MaintenancePhotos to update
     */
    where?: MaintenancePhotoWhereInput
    /**
     * Limit how many MaintenancePhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenancePhoto upsert
   */
  export type MaintenancePhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenancePhoto to update in case it exists.
     */
    where: MaintenancePhotoWhereUniqueInput
    /**
     * In case the MaintenancePhoto found by the `where` argument doesn't exist, create a new MaintenancePhoto with this data.
     */
    create: XOR<MaintenancePhotoCreateInput, MaintenancePhotoUncheckedCreateInput>
    /**
     * In case the MaintenancePhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenancePhotoUpdateInput, MaintenancePhotoUncheckedUpdateInput>
  }

  /**
   * MaintenancePhoto delete
   */
  export type MaintenancePhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
    /**
     * Filter which MaintenancePhoto to delete.
     */
    where: MaintenancePhotoWhereUniqueInput
  }

  /**
   * MaintenancePhoto deleteMany
   */
  export type MaintenancePhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenancePhotos to delete
     */
    where?: MaintenancePhotoWhereInput
    /**
     * Limit how many MaintenancePhotos to delete.
     */
    limit?: number
  }

  /**
   * MaintenancePhoto without action
   */
  export type MaintenancePhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenancePhoto
     */
    select?: MaintenancePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenancePhoto
     */
    omit?: MaintenancePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenancePhotoInclude<ExtArgs> | null
  }


  /**
   * Model LaundryProduct
   */

  export type AggregateLaundryProduct = {
    _count: LaundryProductCountAggregateOutputType | null
    _avg: LaundryProductAvgAggregateOutputType | null
    _sum: LaundryProductSumAggregateOutputType | null
    _min: LaundryProductMinAggregateOutputType | null
    _max: LaundryProductMaxAggregateOutputType | null
  }

  export type LaundryProductAvgAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type LaundryProductSumAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type LaundryProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    stock: number | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    stock: number | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    stock: number
    category: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaundryProductAvgAggregateInputType = {
    price?: true
    stock?: true
  }

  export type LaundryProductSumAggregateInputType = {
    price?: true
    stock?: true
  }

  export type LaundryProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    stock?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    stock?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    stock?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaundryProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaundryProduct to aggregate.
     */
    where?: LaundryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryProducts to fetch.
     */
    orderBy?: LaundryProductOrderByWithRelationInput | LaundryProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaundryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaundryProducts
    **/
    _count?: true | LaundryProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaundryProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaundryProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaundryProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaundryProductMaxAggregateInputType
  }

  export type GetLaundryProductAggregateType<T extends LaundryProductAggregateArgs> = {
        [P in keyof T & keyof AggregateLaundryProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaundryProduct[P]>
      : GetScalarType<T[P], AggregateLaundryProduct[P]>
  }




  export type LaundryProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaundryProductWhereInput
    orderBy?: LaundryProductOrderByWithAggregationInput | LaundryProductOrderByWithAggregationInput[]
    by: LaundryProductScalarFieldEnum[] | LaundryProductScalarFieldEnum
    having?: LaundryProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaundryProductCountAggregateInputType | true
    _avg?: LaundryProductAvgAggregateInputType
    _sum?: LaundryProductSumAggregateInputType
    _min?: LaundryProductMinAggregateInputType
    _max?: LaundryProductMaxAggregateInputType
  }

  export type LaundryProductGroupByOutputType = {
    id: string
    name: string
    description: string
    price: number
    stock: number
    category: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: LaundryProductCountAggregateOutputType | null
    _avg: LaundryProductAvgAggregateOutputType | null
    _sum: LaundryProductSumAggregateOutputType | null
    _min: LaundryProductMinAggregateOutputType | null
    _max: LaundryProductMaxAggregateOutputType | null
  }

  type GetLaundryProductGroupByPayload<T extends LaundryProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LaundryProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaundryProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaundryProductGroupByOutputType[P]>
            : GetScalarType<T[P], LaundryProductGroupByOutputType[P]>
        }
      >
    >


  export type LaundryProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItems?: boolean | LaundryProduct$orderItemsArgs<ExtArgs>
    _count?: boolean | LaundryProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laundryProduct"]>

  export type LaundryProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["laundryProduct"]>

  export type LaundryProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["laundryProduct"]>

  export type LaundryProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LaundryProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "stock" | "category" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["laundryProduct"]>
  export type LaundryProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | LaundryProduct$orderItemsArgs<ExtArgs>
    _count?: boolean | LaundryProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LaundryProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LaundryProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LaundryProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LaundryProduct"
    objects: {
      orderItems: Prisma.$LaundryOrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      price: number
      stock: number
      category: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["laundryProduct"]>
    composites: {}
  }

  type LaundryProductGetPayload<S extends boolean | null | undefined | LaundryProductDefaultArgs> = $Result.GetResult<Prisma.$LaundryProductPayload, S>

  type LaundryProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LaundryProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LaundryProductCountAggregateInputType | true
    }

  export interface LaundryProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LaundryProduct'], meta: { name: 'LaundryProduct' } }
    /**
     * Find zero or one LaundryProduct that matches the filter.
     * @param {LaundryProductFindUniqueArgs} args - Arguments to find a LaundryProduct
     * @example
     * // Get one LaundryProduct
     * const laundryProduct = await prisma.laundryProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LaundryProductFindUniqueArgs>(args: SelectSubset<T, LaundryProductFindUniqueArgs<ExtArgs>>): Prisma__LaundryProductClient<$Result.GetResult<Prisma.$LaundryProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LaundryProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LaundryProductFindUniqueOrThrowArgs} args - Arguments to find a LaundryProduct
     * @example
     * // Get one LaundryProduct
     * const laundryProduct = await prisma.laundryProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LaundryProductFindUniqueOrThrowArgs>(args: SelectSubset<T, LaundryProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LaundryProductClient<$Result.GetResult<Prisma.$LaundryProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LaundryProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryProductFindFirstArgs} args - Arguments to find a LaundryProduct
     * @example
     * // Get one LaundryProduct
     * const laundryProduct = await prisma.laundryProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LaundryProductFindFirstArgs>(args?: SelectSubset<T, LaundryProductFindFirstArgs<ExtArgs>>): Prisma__LaundryProductClient<$Result.GetResult<Prisma.$LaundryProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LaundryProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryProductFindFirstOrThrowArgs} args - Arguments to find a LaundryProduct
     * @example
     * // Get one LaundryProduct
     * const laundryProduct = await prisma.laundryProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LaundryProductFindFirstOrThrowArgs>(args?: SelectSubset<T, LaundryProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__LaundryProductClient<$Result.GetResult<Prisma.$LaundryProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LaundryProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaundryProducts
     * const laundryProducts = await prisma.laundryProduct.findMany()
     * 
     * // Get first 10 LaundryProducts
     * const laundryProducts = await prisma.laundryProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laundryProductWithIdOnly = await prisma.laundryProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LaundryProductFindManyArgs>(args?: SelectSubset<T, LaundryProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LaundryProduct.
     * @param {LaundryProductCreateArgs} args - Arguments to create a LaundryProduct.
     * @example
     * // Create one LaundryProduct
     * const LaundryProduct = await prisma.laundryProduct.create({
     *   data: {
     *     // ... data to create a LaundryProduct
     *   }
     * })
     * 
     */
    create<T extends LaundryProductCreateArgs>(args: SelectSubset<T, LaundryProductCreateArgs<ExtArgs>>): Prisma__LaundryProductClient<$Result.GetResult<Prisma.$LaundryProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LaundryProducts.
     * @param {LaundryProductCreateManyArgs} args - Arguments to create many LaundryProducts.
     * @example
     * // Create many LaundryProducts
     * const laundryProduct = await prisma.laundryProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LaundryProductCreateManyArgs>(args?: SelectSubset<T, LaundryProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LaundryProducts and returns the data saved in the database.
     * @param {LaundryProductCreateManyAndReturnArgs} args - Arguments to create many LaundryProducts.
     * @example
     * // Create many LaundryProducts
     * const laundryProduct = await prisma.laundryProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LaundryProducts and only return the `id`
     * const laundryProductWithIdOnly = await prisma.laundryProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LaundryProductCreateManyAndReturnArgs>(args?: SelectSubset<T, LaundryProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LaundryProduct.
     * @param {LaundryProductDeleteArgs} args - Arguments to delete one LaundryProduct.
     * @example
     * // Delete one LaundryProduct
     * const LaundryProduct = await prisma.laundryProduct.delete({
     *   where: {
     *     // ... filter to delete one LaundryProduct
     *   }
     * })
     * 
     */
    delete<T extends LaundryProductDeleteArgs>(args: SelectSubset<T, LaundryProductDeleteArgs<ExtArgs>>): Prisma__LaundryProductClient<$Result.GetResult<Prisma.$LaundryProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LaundryProduct.
     * @param {LaundryProductUpdateArgs} args - Arguments to update one LaundryProduct.
     * @example
     * // Update one LaundryProduct
     * const laundryProduct = await prisma.laundryProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LaundryProductUpdateArgs>(args: SelectSubset<T, LaundryProductUpdateArgs<ExtArgs>>): Prisma__LaundryProductClient<$Result.GetResult<Prisma.$LaundryProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LaundryProducts.
     * @param {LaundryProductDeleteManyArgs} args - Arguments to filter LaundryProducts to delete.
     * @example
     * // Delete a few LaundryProducts
     * const { count } = await prisma.laundryProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LaundryProductDeleteManyArgs>(args?: SelectSubset<T, LaundryProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaundryProducts
     * const laundryProduct = await prisma.laundryProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LaundryProductUpdateManyArgs>(args: SelectSubset<T, LaundryProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryProducts and returns the data updated in the database.
     * @param {LaundryProductUpdateManyAndReturnArgs} args - Arguments to update many LaundryProducts.
     * @example
     * // Update many LaundryProducts
     * const laundryProduct = await prisma.laundryProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LaundryProducts and only return the `id`
     * const laundryProductWithIdOnly = await prisma.laundryProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LaundryProductUpdateManyAndReturnArgs>(args: SelectSubset<T, LaundryProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LaundryProduct.
     * @param {LaundryProductUpsertArgs} args - Arguments to update or create a LaundryProduct.
     * @example
     * // Update or create a LaundryProduct
     * const laundryProduct = await prisma.laundryProduct.upsert({
     *   create: {
     *     // ... data to create a LaundryProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaundryProduct we want to update
     *   }
     * })
     */
    upsert<T extends LaundryProductUpsertArgs>(args: SelectSubset<T, LaundryProductUpsertArgs<ExtArgs>>): Prisma__LaundryProductClient<$Result.GetResult<Prisma.$LaundryProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LaundryProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryProductCountArgs} args - Arguments to filter LaundryProducts to count.
     * @example
     * // Count the number of LaundryProducts
     * const count = await prisma.laundryProduct.count({
     *   where: {
     *     // ... the filter for the LaundryProducts we want to count
     *   }
     * })
    **/
    count<T extends LaundryProductCountArgs>(
      args?: Subset<T, LaundryProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaundryProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaundryProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaundryProductAggregateArgs>(args: Subset<T, LaundryProductAggregateArgs>): Prisma.PrismaPromise<GetLaundryProductAggregateType<T>>

    /**
     * Group by LaundryProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaundryProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaundryProductGroupByArgs['orderBy'] }
        : { orderBy?: LaundryProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaundryProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaundryProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LaundryProduct model
   */
  readonly fields: LaundryProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LaundryProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LaundryProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends LaundryProduct$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, LaundryProduct$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LaundryProduct model
   */
  interface LaundryProductFieldRefs {
    readonly id: FieldRef<"LaundryProduct", 'String'>
    readonly name: FieldRef<"LaundryProduct", 'String'>
    readonly description: FieldRef<"LaundryProduct", 'String'>
    readonly price: FieldRef<"LaundryProduct", 'Float'>
    readonly stock: FieldRef<"LaundryProduct", 'Int'>
    readonly category: FieldRef<"LaundryProduct", 'String'>
    readonly isActive: FieldRef<"LaundryProduct", 'Boolean'>
    readonly createdAt: FieldRef<"LaundryProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"LaundryProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LaundryProduct findUnique
   */
  export type LaundryProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryProduct
     */
    select?: LaundryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryProduct
     */
    omit?: LaundryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryProductInclude<ExtArgs> | null
    /**
     * Filter, which LaundryProduct to fetch.
     */
    where: LaundryProductWhereUniqueInput
  }

  /**
   * LaundryProduct findUniqueOrThrow
   */
  export type LaundryProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryProduct
     */
    select?: LaundryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryProduct
     */
    omit?: LaundryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryProductInclude<ExtArgs> | null
    /**
     * Filter, which LaundryProduct to fetch.
     */
    where: LaundryProductWhereUniqueInput
  }

  /**
   * LaundryProduct findFirst
   */
  export type LaundryProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryProduct
     */
    select?: LaundryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryProduct
     */
    omit?: LaundryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryProductInclude<ExtArgs> | null
    /**
     * Filter, which LaundryProduct to fetch.
     */
    where?: LaundryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryProducts to fetch.
     */
    orderBy?: LaundryProductOrderByWithRelationInput | LaundryProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryProducts.
     */
    cursor?: LaundryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryProducts.
     */
    distinct?: LaundryProductScalarFieldEnum | LaundryProductScalarFieldEnum[]
  }

  /**
   * LaundryProduct findFirstOrThrow
   */
  export type LaundryProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryProduct
     */
    select?: LaundryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryProduct
     */
    omit?: LaundryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryProductInclude<ExtArgs> | null
    /**
     * Filter, which LaundryProduct to fetch.
     */
    where?: LaundryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryProducts to fetch.
     */
    orderBy?: LaundryProductOrderByWithRelationInput | LaundryProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryProducts.
     */
    cursor?: LaundryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryProducts.
     */
    distinct?: LaundryProductScalarFieldEnum | LaundryProductScalarFieldEnum[]
  }

  /**
   * LaundryProduct findMany
   */
  export type LaundryProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryProduct
     */
    select?: LaundryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryProduct
     */
    omit?: LaundryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryProductInclude<ExtArgs> | null
    /**
     * Filter, which LaundryProducts to fetch.
     */
    where?: LaundryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryProducts to fetch.
     */
    orderBy?: LaundryProductOrderByWithRelationInput | LaundryProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaundryProducts.
     */
    cursor?: LaundryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryProducts.
     */
    skip?: number
    distinct?: LaundryProductScalarFieldEnum | LaundryProductScalarFieldEnum[]
  }

  /**
   * LaundryProduct create
   */
  export type LaundryProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryProduct
     */
    select?: LaundryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryProduct
     */
    omit?: LaundryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryProductInclude<ExtArgs> | null
    /**
     * The data needed to create a LaundryProduct.
     */
    data: XOR<LaundryProductCreateInput, LaundryProductUncheckedCreateInput>
  }

  /**
   * LaundryProduct createMany
   */
  export type LaundryProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LaundryProducts.
     */
    data: LaundryProductCreateManyInput | LaundryProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LaundryProduct createManyAndReturn
   */
  export type LaundryProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryProduct
     */
    select?: LaundryProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryProduct
     */
    omit?: LaundryProductOmit<ExtArgs> | null
    /**
     * The data used to create many LaundryProducts.
     */
    data: LaundryProductCreateManyInput | LaundryProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LaundryProduct update
   */
  export type LaundryProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryProduct
     */
    select?: LaundryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryProduct
     */
    omit?: LaundryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryProductInclude<ExtArgs> | null
    /**
     * The data needed to update a LaundryProduct.
     */
    data: XOR<LaundryProductUpdateInput, LaundryProductUncheckedUpdateInput>
    /**
     * Choose, which LaundryProduct to update.
     */
    where: LaundryProductWhereUniqueInput
  }

  /**
   * LaundryProduct updateMany
   */
  export type LaundryProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LaundryProducts.
     */
    data: XOR<LaundryProductUpdateManyMutationInput, LaundryProductUncheckedUpdateManyInput>
    /**
     * Filter which LaundryProducts to update
     */
    where?: LaundryProductWhereInput
    /**
     * Limit how many LaundryProducts to update.
     */
    limit?: number
  }

  /**
   * LaundryProduct updateManyAndReturn
   */
  export type LaundryProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryProduct
     */
    select?: LaundryProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryProduct
     */
    omit?: LaundryProductOmit<ExtArgs> | null
    /**
     * The data used to update LaundryProducts.
     */
    data: XOR<LaundryProductUpdateManyMutationInput, LaundryProductUncheckedUpdateManyInput>
    /**
     * Filter which LaundryProducts to update
     */
    where?: LaundryProductWhereInput
    /**
     * Limit how many LaundryProducts to update.
     */
    limit?: number
  }

  /**
   * LaundryProduct upsert
   */
  export type LaundryProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryProduct
     */
    select?: LaundryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryProduct
     */
    omit?: LaundryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryProductInclude<ExtArgs> | null
    /**
     * The filter to search for the LaundryProduct to update in case it exists.
     */
    where: LaundryProductWhereUniqueInput
    /**
     * In case the LaundryProduct found by the `where` argument doesn't exist, create a new LaundryProduct with this data.
     */
    create: XOR<LaundryProductCreateInput, LaundryProductUncheckedCreateInput>
    /**
     * In case the LaundryProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaundryProductUpdateInput, LaundryProductUncheckedUpdateInput>
  }

  /**
   * LaundryProduct delete
   */
  export type LaundryProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryProduct
     */
    select?: LaundryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryProduct
     */
    omit?: LaundryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryProductInclude<ExtArgs> | null
    /**
     * Filter which LaundryProduct to delete.
     */
    where: LaundryProductWhereUniqueInput
  }

  /**
   * LaundryProduct deleteMany
   */
  export type LaundryProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaundryProducts to delete
     */
    where?: LaundryProductWhereInput
    /**
     * Limit how many LaundryProducts to delete.
     */
    limit?: number
  }

  /**
   * LaundryProduct.orderItems
   */
  export type LaundryProduct$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrderItem
     */
    select?: LaundryOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrderItem
     */
    omit?: LaundryOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderItemInclude<ExtArgs> | null
    where?: LaundryOrderItemWhereInput
    orderBy?: LaundryOrderItemOrderByWithRelationInput | LaundryOrderItemOrderByWithRelationInput[]
    cursor?: LaundryOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaundryOrderItemScalarFieldEnum | LaundryOrderItemScalarFieldEnum[]
  }

  /**
   * LaundryProduct without action
   */
  export type LaundryProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryProduct
     */
    select?: LaundryProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryProduct
     */
    omit?: LaundryProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryProductInclude<ExtArgs> | null
  }


  /**
   * Model LaundryOrder
   */

  export type AggregateLaundryOrder = {
    _count: LaundryOrderCountAggregateOutputType | null
    _avg: LaundryOrderAvgAggregateOutputType | null
    _sum: LaundryOrderSumAggregateOutputType | null
    _min: LaundryOrderMinAggregateOutputType | null
    _max: LaundryOrderMaxAggregateOutputType | null
  }

  export type LaundryOrderAvgAggregateOutputType = {
    subtotal: number | null
    taxes: number | null
    deliveryFee: number | null
    totalAmount: number | null
  }

  export type LaundryOrderSumAggregateOutputType = {
    subtotal: number | null
    taxes: number | null
    deliveryFee: number | null
    totalAmount: number | null
  }

  export type LaundryOrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    status: $Enums.OrderStatus | null
    receivedDate: Date | null
    processedDate: Date | null
    readyDate: Date | null
    deliveryDate: Date | null
    pickupAddress: string | null
    deliveryAddress: string | null
    instructions: string | null
    subtotal: number | null
    taxes: number | null
    deliveryFee: number | null
    totalAmount: number | null
    notes: string | null
    receivedByClient: boolean | null
    receivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    managerId: string | null
    clientId: string | null
  }

  export type LaundryOrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    status: $Enums.OrderStatus | null
    receivedDate: Date | null
    processedDate: Date | null
    readyDate: Date | null
    deliveryDate: Date | null
    pickupAddress: string | null
    deliveryAddress: string | null
    instructions: string | null
    subtotal: number | null
    taxes: number | null
    deliveryFee: number | null
    totalAmount: number | null
    notes: string | null
    receivedByClient: boolean | null
    receivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    managerId: string | null
    clientId: string | null
  }

  export type LaundryOrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    status: number
    receivedDate: number
    processedDate: number
    readyDate: number
    deliveryDate: number
    pickupAddress: number
    deliveryAddress: number
    instructions: number
    subtotal: number
    taxes: number
    deliveryFee: number
    totalAmount: number
    notes: number
    receivedByClient: number
    receivedAt: number
    createdAt: number
    updatedAt: number
    managerId: number
    clientId: number
    _all: number
  }


  export type LaundryOrderAvgAggregateInputType = {
    subtotal?: true
    taxes?: true
    deliveryFee?: true
    totalAmount?: true
  }

  export type LaundryOrderSumAggregateInputType = {
    subtotal?: true
    taxes?: true
    deliveryFee?: true
    totalAmount?: true
  }

  export type LaundryOrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    status?: true
    receivedDate?: true
    processedDate?: true
    readyDate?: true
    deliveryDate?: true
    pickupAddress?: true
    deliveryAddress?: true
    instructions?: true
    subtotal?: true
    taxes?: true
    deliveryFee?: true
    totalAmount?: true
    notes?: true
    receivedByClient?: true
    receivedAt?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
    clientId?: true
  }

  export type LaundryOrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    status?: true
    receivedDate?: true
    processedDate?: true
    readyDate?: true
    deliveryDate?: true
    pickupAddress?: true
    deliveryAddress?: true
    instructions?: true
    subtotal?: true
    taxes?: true
    deliveryFee?: true
    totalAmount?: true
    notes?: true
    receivedByClient?: true
    receivedAt?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
    clientId?: true
  }

  export type LaundryOrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    status?: true
    receivedDate?: true
    processedDate?: true
    readyDate?: true
    deliveryDate?: true
    pickupAddress?: true
    deliveryAddress?: true
    instructions?: true
    subtotal?: true
    taxes?: true
    deliveryFee?: true
    totalAmount?: true
    notes?: true
    receivedByClient?: true
    receivedAt?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
    clientId?: true
    _all?: true
  }

  export type LaundryOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaundryOrder to aggregate.
     */
    where?: LaundryOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryOrders to fetch.
     */
    orderBy?: LaundryOrderOrderByWithRelationInput | LaundryOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaundryOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaundryOrders
    **/
    _count?: true | LaundryOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaundryOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaundryOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaundryOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaundryOrderMaxAggregateInputType
  }

  export type GetLaundryOrderAggregateType<T extends LaundryOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateLaundryOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaundryOrder[P]>
      : GetScalarType<T[P], AggregateLaundryOrder[P]>
  }




  export type LaundryOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaundryOrderWhereInput
    orderBy?: LaundryOrderOrderByWithAggregationInput | LaundryOrderOrderByWithAggregationInput[]
    by: LaundryOrderScalarFieldEnum[] | LaundryOrderScalarFieldEnum
    having?: LaundryOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaundryOrderCountAggregateInputType | true
    _avg?: LaundryOrderAvgAggregateInputType
    _sum?: LaundryOrderSumAggregateInputType
    _min?: LaundryOrderMinAggregateInputType
    _max?: LaundryOrderMaxAggregateInputType
  }

  export type LaundryOrderGroupByOutputType = {
    id: string
    orderNumber: string
    status: $Enums.OrderStatus
    receivedDate: Date | null
    processedDate: Date | null
    readyDate: Date | null
    deliveryDate: Date | null
    pickupAddress: string | null
    deliveryAddress: string
    instructions: string | null
    subtotal: number
    taxes: number | null
    deliveryFee: number | null
    totalAmount: number
    notes: string | null
    receivedByClient: boolean
    receivedAt: Date | null
    createdAt: Date
    updatedAt: Date
    managerId: string
    clientId: string
    _count: LaundryOrderCountAggregateOutputType | null
    _avg: LaundryOrderAvgAggregateOutputType | null
    _sum: LaundryOrderSumAggregateOutputType | null
    _min: LaundryOrderMinAggregateOutputType | null
    _max: LaundryOrderMaxAggregateOutputType | null
  }

  type GetLaundryOrderGroupByPayload<T extends LaundryOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LaundryOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaundryOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaundryOrderGroupByOutputType[P]>
            : GetScalarType<T[P], LaundryOrderGroupByOutputType[P]>
        }
      >
    >


  export type LaundryOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    status?: boolean
    receivedDate?: boolean
    processedDate?: boolean
    readyDate?: boolean
    deliveryDate?: boolean
    pickupAddress?: boolean
    deliveryAddress?: boolean
    instructions?: boolean
    subtotal?: boolean
    taxes?: boolean
    deliveryFee?: boolean
    totalAmount?: boolean
    notes?: boolean
    receivedByClient?: boolean
    receivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    clientId?: boolean
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
    client?: boolean | LaundryClientProfileDefaultArgs<ExtArgs>
    items?: boolean | LaundryOrder$itemsArgs<ExtArgs>
    deliveryNotes?: boolean | LaundryOrder$deliveryNotesArgs<ExtArgs>
    _count?: boolean | LaundryOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laundryOrder"]>

  export type LaundryOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    status?: boolean
    receivedDate?: boolean
    processedDate?: boolean
    readyDate?: boolean
    deliveryDate?: boolean
    pickupAddress?: boolean
    deliveryAddress?: boolean
    instructions?: boolean
    subtotal?: boolean
    taxes?: boolean
    deliveryFee?: boolean
    totalAmount?: boolean
    notes?: boolean
    receivedByClient?: boolean
    receivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    clientId?: boolean
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
    client?: boolean | LaundryClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laundryOrder"]>

  export type LaundryOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    status?: boolean
    receivedDate?: boolean
    processedDate?: boolean
    readyDate?: boolean
    deliveryDate?: boolean
    pickupAddress?: boolean
    deliveryAddress?: boolean
    instructions?: boolean
    subtotal?: boolean
    taxes?: boolean
    deliveryFee?: boolean
    totalAmount?: boolean
    notes?: boolean
    receivedByClient?: boolean
    receivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    clientId?: boolean
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
    client?: boolean | LaundryClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laundryOrder"]>

  export type LaundryOrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    status?: boolean
    receivedDate?: boolean
    processedDate?: boolean
    readyDate?: boolean
    deliveryDate?: boolean
    pickupAddress?: boolean
    deliveryAddress?: boolean
    instructions?: boolean
    subtotal?: boolean
    taxes?: boolean
    deliveryFee?: boolean
    totalAmount?: boolean
    notes?: boolean
    receivedByClient?: boolean
    receivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    clientId?: boolean
  }

  export type LaundryOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "status" | "receivedDate" | "processedDate" | "readyDate" | "deliveryDate" | "pickupAddress" | "deliveryAddress" | "instructions" | "subtotal" | "taxes" | "deliveryFee" | "totalAmount" | "notes" | "receivedByClient" | "receivedAt" | "createdAt" | "updatedAt" | "managerId" | "clientId", ExtArgs["result"]["laundryOrder"]>
  export type LaundryOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
    client?: boolean | LaundryClientProfileDefaultArgs<ExtArgs>
    items?: boolean | LaundryOrder$itemsArgs<ExtArgs>
    deliveryNotes?: boolean | LaundryOrder$deliveryNotesArgs<ExtArgs>
    _count?: boolean | LaundryOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LaundryOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
    client?: boolean | LaundryClientProfileDefaultArgs<ExtArgs>
  }
  export type LaundryOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | PoleManagerProfileDefaultArgs<ExtArgs>
    client?: boolean | LaundryClientProfileDefaultArgs<ExtArgs>
  }

  export type $LaundryOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LaundryOrder"
    objects: {
      manager: Prisma.$PoleManagerProfilePayload<ExtArgs>
      client: Prisma.$LaundryClientProfilePayload<ExtArgs>
      items: Prisma.$LaundryOrderItemPayload<ExtArgs>[]
      deliveryNotes: Prisma.$DeliveryNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      status: $Enums.OrderStatus
      receivedDate: Date | null
      processedDate: Date | null
      readyDate: Date | null
      deliveryDate: Date | null
      pickupAddress: string | null
      deliveryAddress: string
      instructions: string | null
      subtotal: number
      taxes: number | null
      deliveryFee: number | null
      totalAmount: number
      notes: string | null
      receivedByClient: boolean
      receivedAt: Date | null
      createdAt: Date
      updatedAt: Date
      managerId: string
      clientId: string
    }, ExtArgs["result"]["laundryOrder"]>
    composites: {}
  }

  type LaundryOrderGetPayload<S extends boolean | null | undefined | LaundryOrderDefaultArgs> = $Result.GetResult<Prisma.$LaundryOrderPayload, S>

  type LaundryOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LaundryOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LaundryOrderCountAggregateInputType | true
    }

  export interface LaundryOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LaundryOrder'], meta: { name: 'LaundryOrder' } }
    /**
     * Find zero or one LaundryOrder that matches the filter.
     * @param {LaundryOrderFindUniqueArgs} args - Arguments to find a LaundryOrder
     * @example
     * // Get one LaundryOrder
     * const laundryOrder = await prisma.laundryOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LaundryOrderFindUniqueArgs>(args: SelectSubset<T, LaundryOrderFindUniqueArgs<ExtArgs>>): Prisma__LaundryOrderClient<$Result.GetResult<Prisma.$LaundryOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LaundryOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LaundryOrderFindUniqueOrThrowArgs} args - Arguments to find a LaundryOrder
     * @example
     * // Get one LaundryOrder
     * const laundryOrder = await prisma.laundryOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LaundryOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, LaundryOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LaundryOrderClient<$Result.GetResult<Prisma.$LaundryOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LaundryOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryOrderFindFirstArgs} args - Arguments to find a LaundryOrder
     * @example
     * // Get one LaundryOrder
     * const laundryOrder = await prisma.laundryOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LaundryOrderFindFirstArgs>(args?: SelectSubset<T, LaundryOrderFindFirstArgs<ExtArgs>>): Prisma__LaundryOrderClient<$Result.GetResult<Prisma.$LaundryOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LaundryOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryOrderFindFirstOrThrowArgs} args - Arguments to find a LaundryOrder
     * @example
     * // Get one LaundryOrder
     * const laundryOrder = await prisma.laundryOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LaundryOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, LaundryOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__LaundryOrderClient<$Result.GetResult<Prisma.$LaundryOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LaundryOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaundryOrders
     * const laundryOrders = await prisma.laundryOrder.findMany()
     * 
     * // Get first 10 LaundryOrders
     * const laundryOrders = await prisma.laundryOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laundryOrderWithIdOnly = await prisma.laundryOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LaundryOrderFindManyArgs>(args?: SelectSubset<T, LaundryOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LaundryOrder.
     * @param {LaundryOrderCreateArgs} args - Arguments to create a LaundryOrder.
     * @example
     * // Create one LaundryOrder
     * const LaundryOrder = await prisma.laundryOrder.create({
     *   data: {
     *     // ... data to create a LaundryOrder
     *   }
     * })
     * 
     */
    create<T extends LaundryOrderCreateArgs>(args: SelectSubset<T, LaundryOrderCreateArgs<ExtArgs>>): Prisma__LaundryOrderClient<$Result.GetResult<Prisma.$LaundryOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LaundryOrders.
     * @param {LaundryOrderCreateManyArgs} args - Arguments to create many LaundryOrders.
     * @example
     * // Create many LaundryOrders
     * const laundryOrder = await prisma.laundryOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LaundryOrderCreateManyArgs>(args?: SelectSubset<T, LaundryOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LaundryOrders and returns the data saved in the database.
     * @param {LaundryOrderCreateManyAndReturnArgs} args - Arguments to create many LaundryOrders.
     * @example
     * // Create many LaundryOrders
     * const laundryOrder = await prisma.laundryOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LaundryOrders and only return the `id`
     * const laundryOrderWithIdOnly = await prisma.laundryOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LaundryOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, LaundryOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LaundryOrder.
     * @param {LaundryOrderDeleteArgs} args - Arguments to delete one LaundryOrder.
     * @example
     * // Delete one LaundryOrder
     * const LaundryOrder = await prisma.laundryOrder.delete({
     *   where: {
     *     // ... filter to delete one LaundryOrder
     *   }
     * })
     * 
     */
    delete<T extends LaundryOrderDeleteArgs>(args: SelectSubset<T, LaundryOrderDeleteArgs<ExtArgs>>): Prisma__LaundryOrderClient<$Result.GetResult<Prisma.$LaundryOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LaundryOrder.
     * @param {LaundryOrderUpdateArgs} args - Arguments to update one LaundryOrder.
     * @example
     * // Update one LaundryOrder
     * const laundryOrder = await prisma.laundryOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LaundryOrderUpdateArgs>(args: SelectSubset<T, LaundryOrderUpdateArgs<ExtArgs>>): Prisma__LaundryOrderClient<$Result.GetResult<Prisma.$LaundryOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LaundryOrders.
     * @param {LaundryOrderDeleteManyArgs} args - Arguments to filter LaundryOrders to delete.
     * @example
     * // Delete a few LaundryOrders
     * const { count } = await prisma.laundryOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LaundryOrderDeleteManyArgs>(args?: SelectSubset<T, LaundryOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaundryOrders
     * const laundryOrder = await prisma.laundryOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LaundryOrderUpdateManyArgs>(args: SelectSubset<T, LaundryOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryOrders and returns the data updated in the database.
     * @param {LaundryOrderUpdateManyAndReturnArgs} args - Arguments to update many LaundryOrders.
     * @example
     * // Update many LaundryOrders
     * const laundryOrder = await prisma.laundryOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LaundryOrders and only return the `id`
     * const laundryOrderWithIdOnly = await prisma.laundryOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LaundryOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, LaundryOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LaundryOrder.
     * @param {LaundryOrderUpsertArgs} args - Arguments to update or create a LaundryOrder.
     * @example
     * // Update or create a LaundryOrder
     * const laundryOrder = await prisma.laundryOrder.upsert({
     *   create: {
     *     // ... data to create a LaundryOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaundryOrder we want to update
     *   }
     * })
     */
    upsert<T extends LaundryOrderUpsertArgs>(args: SelectSubset<T, LaundryOrderUpsertArgs<ExtArgs>>): Prisma__LaundryOrderClient<$Result.GetResult<Prisma.$LaundryOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LaundryOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryOrderCountArgs} args - Arguments to filter LaundryOrders to count.
     * @example
     * // Count the number of LaundryOrders
     * const count = await prisma.laundryOrder.count({
     *   where: {
     *     // ... the filter for the LaundryOrders we want to count
     *   }
     * })
    **/
    count<T extends LaundryOrderCountArgs>(
      args?: Subset<T, LaundryOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaundryOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaundryOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaundryOrderAggregateArgs>(args: Subset<T, LaundryOrderAggregateArgs>): Prisma.PrismaPromise<GetLaundryOrderAggregateType<T>>

    /**
     * Group by LaundryOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaundryOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaundryOrderGroupByArgs['orderBy'] }
        : { orderBy?: LaundryOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaundryOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaundryOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LaundryOrder model
   */
  readonly fields: LaundryOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LaundryOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LaundryOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    manager<T extends PoleManagerProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PoleManagerProfileDefaultArgs<ExtArgs>>): Prisma__PoleManagerProfileClient<$Result.GetResult<Prisma.$PoleManagerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends LaundryClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LaundryClientProfileDefaultArgs<ExtArgs>>): Prisma__LaundryClientProfileClient<$Result.GetResult<Prisma.$LaundryClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends LaundryOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, LaundryOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryNotes<T extends LaundryOrder$deliveryNotesArgs<ExtArgs> = {}>(args?: Subset<T, LaundryOrder$deliveryNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LaundryOrder model
   */
  interface LaundryOrderFieldRefs {
    readonly id: FieldRef<"LaundryOrder", 'String'>
    readonly orderNumber: FieldRef<"LaundryOrder", 'String'>
    readonly status: FieldRef<"LaundryOrder", 'OrderStatus'>
    readonly receivedDate: FieldRef<"LaundryOrder", 'DateTime'>
    readonly processedDate: FieldRef<"LaundryOrder", 'DateTime'>
    readonly readyDate: FieldRef<"LaundryOrder", 'DateTime'>
    readonly deliveryDate: FieldRef<"LaundryOrder", 'DateTime'>
    readonly pickupAddress: FieldRef<"LaundryOrder", 'String'>
    readonly deliveryAddress: FieldRef<"LaundryOrder", 'String'>
    readonly instructions: FieldRef<"LaundryOrder", 'String'>
    readonly subtotal: FieldRef<"LaundryOrder", 'Float'>
    readonly taxes: FieldRef<"LaundryOrder", 'Float'>
    readonly deliveryFee: FieldRef<"LaundryOrder", 'Float'>
    readonly totalAmount: FieldRef<"LaundryOrder", 'Float'>
    readonly notes: FieldRef<"LaundryOrder", 'String'>
    readonly receivedByClient: FieldRef<"LaundryOrder", 'Boolean'>
    readonly receivedAt: FieldRef<"LaundryOrder", 'DateTime'>
    readonly createdAt: FieldRef<"LaundryOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"LaundryOrder", 'DateTime'>
    readonly managerId: FieldRef<"LaundryOrder", 'String'>
    readonly clientId: FieldRef<"LaundryOrder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LaundryOrder findUnique
   */
  export type LaundryOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrder
     */
    select?: LaundryOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrder
     */
    omit?: LaundryOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderInclude<ExtArgs> | null
    /**
     * Filter, which LaundryOrder to fetch.
     */
    where: LaundryOrderWhereUniqueInput
  }

  /**
   * LaundryOrder findUniqueOrThrow
   */
  export type LaundryOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrder
     */
    select?: LaundryOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrder
     */
    omit?: LaundryOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderInclude<ExtArgs> | null
    /**
     * Filter, which LaundryOrder to fetch.
     */
    where: LaundryOrderWhereUniqueInput
  }

  /**
   * LaundryOrder findFirst
   */
  export type LaundryOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrder
     */
    select?: LaundryOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrder
     */
    omit?: LaundryOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderInclude<ExtArgs> | null
    /**
     * Filter, which LaundryOrder to fetch.
     */
    where?: LaundryOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryOrders to fetch.
     */
    orderBy?: LaundryOrderOrderByWithRelationInput | LaundryOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryOrders.
     */
    cursor?: LaundryOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryOrders.
     */
    distinct?: LaundryOrderScalarFieldEnum | LaundryOrderScalarFieldEnum[]
  }

  /**
   * LaundryOrder findFirstOrThrow
   */
  export type LaundryOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrder
     */
    select?: LaundryOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrder
     */
    omit?: LaundryOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderInclude<ExtArgs> | null
    /**
     * Filter, which LaundryOrder to fetch.
     */
    where?: LaundryOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryOrders to fetch.
     */
    orderBy?: LaundryOrderOrderByWithRelationInput | LaundryOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryOrders.
     */
    cursor?: LaundryOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryOrders.
     */
    distinct?: LaundryOrderScalarFieldEnum | LaundryOrderScalarFieldEnum[]
  }

  /**
   * LaundryOrder findMany
   */
  export type LaundryOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrder
     */
    select?: LaundryOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrder
     */
    omit?: LaundryOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderInclude<ExtArgs> | null
    /**
     * Filter, which LaundryOrders to fetch.
     */
    where?: LaundryOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryOrders to fetch.
     */
    orderBy?: LaundryOrderOrderByWithRelationInput | LaundryOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaundryOrders.
     */
    cursor?: LaundryOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryOrders.
     */
    skip?: number
    distinct?: LaundryOrderScalarFieldEnum | LaundryOrderScalarFieldEnum[]
  }

  /**
   * LaundryOrder create
   */
  export type LaundryOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrder
     */
    select?: LaundryOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrder
     */
    omit?: LaundryOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a LaundryOrder.
     */
    data: XOR<LaundryOrderCreateInput, LaundryOrderUncheckedCreateInput>
  }

  /**
   * LaundryOrder createMany
   */
  export type LaundryOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LaundryOrders.
     */
    data: LaundryOrderCreateManyInput | LaundryOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LaundryOrder createManyAndReturn
   */
  export type LaundryOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrder
     */
    select?: LaundryOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrder
     */
    omit?: LaundryOrderOmit<ExtArgs> | null
    /**
     * The data used to create many LaundryOrders.
     */
    data: LaundryOrderCreateManyInput | LaundryOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LaundryOrder update
   */
  export type LaundryOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrder
     */
    select?: LaundryOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrder
     */
    omit?: LaundryOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a LaundryOrder.
     */
    data: XOR<LaundryOrderUpdateInput, LaundryOrderUncheckedUpdateInput>
    /**
     * Choose, which LaundryOrder to update.
     */
    where: LaundryOrderWhereUniqueInput
  }

  /**
   * LaundryOrder updateMany
   */
  export type LaundryOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LaundryOrders.
     */
    data: XOR<LaundryOrderUpdateManyMutationInput, LaundryOrderUncheckedUpdateManyInput>
    /**
     * Filter which LaundryOrders to update
     */
    where?: LaundryOrderWhereInput
    /**
     * Limit how many LaundryOrders to update.
     */
    limit?: number
  }

  /**
   * LaundryOrder updateManyAndReturn
   */
  export type LaundryOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrder
     */
    select?: LaundryOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrder
     */
    omit?: LaundryOrderOmit<ExtArgs> | null
    /**
     * The data used to update LaundryOrders.
     */
    data: XOR<LaundryOrderUpdateManyMutationInput, LaundryOrderUncheckedUpdateManyInput>
    /**
     * Filter which LaundryOrders to update
     */
    where?: LaundryOrderWhereInput
    /**
     * Limit how many LaundryOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LaundryOrder upsert
   */
  export type LaundryOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrder
     */
    select?: LaundryOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrder
     */
    omit?: LaundryOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the LaundryOrder to update in case it exists.
     */
    where: LaundryOrderWhereUniqueInput
    /**
     * In case the LaundryOrder found by the `where` argument doesn't exist, create a new LaundryOrder with this data.
     */
    create: XOR<LaundryOrderCreateInput, LaundryOrderUncheckedCreateInput>
    /**
     * In case the LaundryOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaundryOrderUpdateInput, LaundryOrderUncheckedUpdateInput>
  }

  /**
   * LaundryOrder delete
   */
  export type LaundryOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrder
     */
    select?: LaundryOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrder
     */
    omit?: LaundryOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderInclude<ExtArgs> | null
    /**
     * Filter which LaundryOrder to delete.
     */
    where: LaundryOrderWhereUniqueInput
  }

  /**
   * LaundryOrder deleteMany
   */
  export type LaundryOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaundryOrders to delete
     */
    where?: LaundryOrderWhereInput
    /**
     * Limit how many LaundryOrders to delete.
     */
    limit?: number
  }

  /**
   * LaundryOrder.items
   */
  export type LaundryOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrderItem
     */
    select?: LaundryOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrderItem
     */
    omit?: LaundryOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderItemInclude<ExtArgs> | null
    where?: LaundryOrderItemWhereInput
    orderBy?: LaundryOrderItemOrderByWithRelationInput | LaundryOrderItemOrderByWithRelationInput[]
    cursor?: LaundryOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaundryOrderItemScalarFieldEnum | LaundryOrderItemScalarFieldEnum[]
  }

  /**
   * LaundryOrder.deliveryNotes
   */
  export type LaundryOrder$deliveryNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    where?: DeliveryNoteWhereInput
    orderBy?: DeliveryNoteOrderByWithRelationInput | DeliveryNoteOrderByWithRelationInput[]
    cursor?: DeliveryNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryNoteScalarFieldEnum | DeliveryNoteScalarFieldEnum[]
  }

  /**
   * LaundryOrder without action
   */
  export type LaundryOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrder
     */
    select?: LaundryOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrder
     */
    omit?: LaundryOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderInclude<ExtArgs> | null
  }


  /**
   * Model LaundryOrderItem
   */

  export type AggregateLaundryOrderItem = {
    _count: LaundryOrderItemCountAggregateOutputType | null
    _avg: LaundryOrderItemAvgAggregateOutputType | null
    _sum: LaundryOrderItemSumAggregateOutputType | null
    _min: LaundryOrderItemMinAggregateOutputType | null
    _max: LaundryOrderItemMaxAggregateOutputType | null
  }

  export type LaundryOrderItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
  }

  export type LaundryOrderItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
  }

  export type LaundryOrderItemMinAggregateOutputType = {
    id: string | null
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
    notes: string | null
    orderId: string | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryOrderItemMaxAggregateOutputType = {
    id: string | null
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
    notes: string | null
    orderId: string | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryOrderItemCountAggregateOutputType = {
    id: number
    quantity: number
    unitPrice: number
    subtotal: number
    notes: number
    orderId: number
    productId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaundryOrderItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    subtotal?: true
  }

  export type LaundryOrderItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    subtotal?: true
  }

  export type LaundryOrderItemMinAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
    notes?: true
    orderId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryOrderItemMaxAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
    notes?: true
    orderId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryOrderItemCountAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
    notes?: true
    orderId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaundryOrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaundryOrderItem to aggregate.
     */
    where?: LaundryOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryOrderItems to fetch.
     */
    orderBy?: LaundryOrderItemOrderByWithRelationInput | LaundryOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaundryOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaundryOrderItems
    **/
    _count?: true | LaundryOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaundryOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaundryOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaundryOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaundryOrderItemMaxAggregateInputType
  }

  export type GetLaundryOrderItemAggregateType<T extends LaundryOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateLaundryOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaundryOrderItem[P]>
      : GetScalarType<T[P], AggregateLaundryOrderItem[P]>
  }




  export type LaundryOrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaundryOrderItemWhereInput
    orderBy?: LaundryOrderItemOrderByWithAggregationInput | LaundryOrderItemOrderByWithAggregationInput[]
    by: LaundryOrderItemScalarFieldEnum[] | LaundryOrderItemScalarFieldEnum
    having?: LaundryOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaundryOrderItemCountAggregateInputType | true
    _avg?: LaundryOrderItemAvgAggregateInputType
    _sum?: LaundryOrderItemSumAggregateInputType
    _min?: LaundryOrderItemMinAggregateInputType
    _max?: LaundryOrderItemMaxAggregateInputType
  }

  export type LaundryOrderItemGroupByOutputType = {
    id: string
    quantity: number
    unitPrice: number
    subtotal: number
    notes: string | null
    orderId: string
    productId: string
    createdAt: Date
    updatedAt: Date
    _count: LaundryOrderItemCountAggregateOutputType | null
    _avg: LaundryOrderItemAvgAggregateOutputType | null
    _sum: LaundryOrderItemSumAggregateOutputType | null
    _min: LaundryOrderItemMinAggregateOutputType | null
    _max: LaundryOrderItemMaxAggregateOutputType | null
  }

  type GetLaundryOrderItemGroupByPayload<T extends LaundryOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LaundryOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaundryOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaundryOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], LaundryOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type LaundryOrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    notes?: boolean
    orderId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | LaundryOrderDefaultArgs<ExtArgs>
    product?: boolean | LaundryProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laundryOrderItem"]>

  export type LaundryOrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    notes?: boolean
    orderId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | LaundryOrderDefaultArgs<ExtArgs>
    product?: boolean | LaundryProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laundryOrderItem"]>

  export type LaundryOrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    notes?: boolean
    orderId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | LaundryOrderDefaultArgs<ExtArgs>
    product?: boolean | LaundryProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laundryOrderItem"]>

  export type LaundryOrderItemSelectScalar = {
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    notes?: boolean
    orderId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LaundryOrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantity" | "unitPrice" | "subtotal" | "notes" | "orderId" | "productId" | "createdAt" | "updatedAt", ExtArgs["result"]["laundryOrderItem"]>
  export type LaundryOrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | LaundryOrderDefaultArgs<ExtArgs>
    product?: boolean | LaundryProductDefaultArgs<ExtArgs>
  }
  export type LaundryOrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | LaundryOrderDefaultArgs<ExtArgs>
    product?: boolean | LaundryProductDefaultArgs<ExtArgs>
  }
  export type LaundryOrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | LaundryOrderDefaultArgs<ExtArgs>
    product?: boolean | LaundryProductDefaultArgs<ExtArgs>
  }

  export type $LaundryOrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LaundryOrderItem"
    objects: {
      order: Prisma.$LaundryOrderPayload<ExtArgs>
      product: Prisma.$LaundryProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quantity: number
      unitPrice: number
      subtotal: number
      notes: string | null
      orderId: string
      productId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["laundryOrderItem"]>
    composites: {}
  }

  type LaundryOrderItemGetPayload<S extends boolean | null | undefined | LaundryOrderItemDefaultArgs> = $Result.GetResult<Prisma.$LaundryOrderItemPayload, S>

  type LaundryOrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LaundryOrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LaundryOrderItemCountAggregateInputType | true
    }

  export interface LaundryOrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LaundryOrderItem'], meta: { name: 'LaundryOrderItem' } }
    /**
     * Find zero or one LaundryOrderItem that matches the filter.
     * @param {LaundryOrderItemFindUniqueArgs} args - Arguments to find a LaundryOrderItem
     * @example
     * // Get one LaundryOrderItem
     * const laundryOrderItem = await prisma.laundryOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LaundryOrderItemFindUniqueArgs>(args: SelectSubset<T, LaundryOrderItemFindUniqueArgs<ExtArgs>>): Prisma__LaundryOrderItemClient<$Result.GetResult<Prisma.$LaundryOrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LaundryOrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LaundryOrderItemFindUniqueOrThrowArgs} args - Arguments to find a LaundryOrderItem
     * @example
     * // Get one LaundryOrderItem
     * const laundryOrderItem = await prisma.laundryOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LaundryOrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, LaundryOrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LaundryOrderItemClient<$Result.GetResult<Prisma.$LaundryOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LaundryOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryOrderItemFindFirstArgs} args - Arguments to find a LaundryOrderItem
     * @example
     * // Get one LaundryOrderItem
     * const laundryOrderItem = await prisma.laundryOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LaundryOrderItemFindFirstArgs>(args?: SelectSubset<T, LaundryOrderItemFindFirstArgs<ExtArgs>>): Prisma__LaundryOrderItemClient<$Result.GetResult<Prisma.$LaundryOrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LaundryOrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryOrderItemFindFirstOrThrowArgs} args - Arguments to find a LaundryOrderItem
     * @example
     * // Get one LaundryOrderItem
     * const laundryOrderItem = await prisma.laundryOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LaundryOrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, LaundryOrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__LaundryOrderItemClient<$Result.GetResult<Prisma.$LaundryOrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LaundryOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryOrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaundryOrderItems
     * const laundryOrderItems = await prisma.laundryOrderItem.findMany()
     * 
     * // Get first 10 LaundryOrderItems
     * const laundryOrderItems = await prisma.laundryOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laundryOrderItemWithIdOnly = await prisma.laundryOrderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LaundryOrderItemFindManyArgs>(args?: SelectSubset<T, LaundryOrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LaundryOrderItem.
     * @param {LaundryOrderItemCreateArgs} args - Arguments to create a LaundryOrderItem.
     * @example
     * // Create one LaundryOrderItem
     * const LaundryOrderItem = await prisma.laundryOrderItem.create({
     *   data: {
     *     // ... data to create a LaundryOrderItem
     *   }
     * })
     * 
     */
    create<T extends LaundryOrderItemCreateArgs>(args: SelectSubset<T, LaundryOrderItemCreateArgs<ExtArgs>>): Prisma__LaundryOrderItemClient<$Result.GetResult<Prisma.$LaundryOrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LaundryOrderItems.
     * @param {LaundryOrderItemCreateManyArgs} args - Arguments to create many LaundryOrderItems.
     * @example
     * // Create many LaundryOrderItems
     * const laundryOrderItem = await prisma.laundryOrderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LaundryOrderItemCreateManyArgs>(args?: SelectSubset<T, LaundryOrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LaundryOrderItems and returns the data saved in the database.
     * @param {LaundryOrderItemCreateManyAndReturnArgs} args - Arguments to create many LaundryOrderItems.
     * @example
     * // Create many LaundryOrderItems
     * const laundryOrderItem = await prisma.laundryOrderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LaundryOrderItems and only return the `id`
     * const laundryOrderItemWithIdOnly = await prisma.laundryOrderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LaundryOrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, LaundryOrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryOrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LaundryOrderItem.
     * @param {LaundryOrderItemDeleteArgs} args - Arguments to delete one LaundryOrderItem.
     * @example
     * // Delete one LaundryOrderItem
     * const LaundryOrderItem = await prisma.laundryOrderItem.delete({
     *   where: {
     *     // ... filter to delete one LaundryOrderItem
     *   }
     * })
     * 
     */
    delete<T extends LaundryOrderItemDeleteArgs>(args: SelectSubset<T, LaundryOrderItemDeleteArgs<ExtArgs>>): Prisma__LaundryOrderItemClient<$Result.GetResult<Prisma.$LaundryOrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LaundryOrderItem.
     * @param {LaundryOrderItemUpdateArgs} args - Arguments to update one LaundryOrderItem.
     * @example
     * // Update one LaundryOrderItem
     * const laundryOrderItem = await prisma.laundryOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LaundryOrderItemUpdateArgs>(args: SelectSubset<T, LaundryOrderItemUpdateArgs<ExtArgs>>): Prisma__LaundryOrderItemClient<$Result.GetResult<Prisma.$LaundryOrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LaundryOrderItems.
     * @param {LaundryOrderItemDeleteManyArgs} args - Arguments to filter LaundryOrderItems to delete.
     * @example
     * // Delete a few LaundryOrderItems
     * const { count } = await prisma.laundryOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LaundryOrderItemDeleteManyArgs>(args?: SelectSubset<T, LaundryOrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaundryOrderItems
     * const laundryOrderItem = await prisma.laundryOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LaundryOrderItemUpdateManyArgs>(args: SelectSubset<T, LaundryOrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryOrderItems and returns the data updated in the database.
     * @param {LaundryOrderItemUpdateManyAndReturnArgs} args - Arguments to update many LaundryOrderItems.
     * @example
     * // Update many LaundryOrderItems
     * const laundryOrderItem = await prisma.laundryOrderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LaundryOrderItems and only return the `id`
     * const laundryOrderItemWithIdOnly = await prisma.laundryOrderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LaundryOrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, LaundryOrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryOrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LaundryOrderItem.
     * @param {LaundryOrderItemUpsertArgs} args - Arguments to update or create a LaundryOrderItem.
     * @example
     * // Update or create a LaundryOrderItem
     * const laundryOrderItem = await prisma.laundryOrderItem.upsert({
     *   create: {
     *     // ... data to create a LaundryOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaundryOrderItem we want to update
     *   }
     * })
     */
    upsert<T extends LaundryOrderItemUpsertArgs>(args: SelectSubset<T, LaundryOrderItemUpsertArgs<ExtArgs>>): Prisma__LaundryOrderItemClient<$Result.GetResult<Prisma.$LaundryOrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LaundryOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryOrderItemCountArgs} args - Arguments to filter LaundryOrderItems to count.
     * @example
     * // Count the number of LaundryOrderItems
     * const count = await prisma.laundryOrderItem.count({
     *   where: {
     *     // ... the filter for the LaundryOrderItems we want to count
     *   }
     * })
    **/
    count<T extends LaundryOrderItemCountArgs>(
      args?: Subset<T, LaundryOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaundryOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaundryOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaundryOrderItemAggregateArgs>(args: Subset<T, LaundryOrderItemAggregateArgs>): Prisma.PrismaPromise<GetLaundryOrderItemAggregateType<T>>

    /**
     * Group by LaundryOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaundryOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaundryOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: LaundryOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaundryOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaundryOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LaundryOrderItem model
   */
  readonly fields: LaundryOrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LaundryOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LaundryOrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends LaundryOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LaundryOrderDefaultArgs<ExtArgs>>): Prisma__LaundryOrderClient<$Result.GetResult<Prisma.$LaundryOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends LaundryProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LaundryProductDefaultArgs<ExtArgs>>): Prisma__LaundryProductClient<$Result.GetResult<Prisma.$LaundryProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LaundryOrderItem model
   */
  interface LaundryOrderItemFieldRefs {
    readonly id: FieldRef<"LaundryOrderItem", 'String'>
    readonly quantity: FieldRef<"LaundryOrderItem", 'Int'>
    readonly unitPrice: FieldRef<"LaundryOrderItem", 'Float'>
    readonly subtotal: FieldRef<"LaundryOrderItem", 'Float'>
    readonly notes: FieldRef<"LaundryOrderItem", 'String'>
    readonly orderId: FieldRef<"LaundryOrderItem", 'String'>
    readonly productId: FieldRef<"LaundryOrderItem", 'String'>
    readonly createdAt: FieldRef<"LaundryOrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"LaundryOrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LaundryOrderItem findUnique
   */
  export type LaundryOrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrderItem
     */
    select?: LaundryOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrderItem
     */
    omit?: LaundryOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which LaundryOrderItem to fetch.
     */
    where: LaundryOrderItemWhereUniqueInput
  }

  /**
   * LaundryOrderItem findUniqueOrThrow
   */
  export type LaundryOrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrderItem
     */
    select?: LaundryOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrderItem
     */
    omit?: LaundryOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which LaundryOrderItem to fetch.
     */
    where: LaundryOrderItemWhereUniqueInput
  }

  /**
   * LaundryOrderItem findFirst
   */
  export type LaundryOrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrderItem
     */
    select?: LaundryOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrderItem
     */
    omit?: LaundryOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which LaundryOrderItem to fetch.
     */
    where?: LaundryOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryOrderItems to fetch.
     */
    orderBy?: LaundryOrderItemOrderByWithRelationInput | LaundryOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryOrderItems.
     */
    cursor?: LaundryOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryOrderItems.
     */
    distinct?: LaundryOrderItemScalarFieldEnum | LaundryOrderItemScalarFieldEnum[]
  }

  /**
   * LaundryOrderItem findFirstOrThrow
   */
  export type LaundryOrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrderItem
     */
    select?: LaundryOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrderItem
     */
    omit?: LaundryOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which LaundryOrderItem to fetch.
     */
    where?: LaundryOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryOrderItems to fetch.
     */
    orderBy?: LaundryOrderItemOrderByWithRelationInput | LaundryOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryOrderItems.
     */
    cursor?: LaundryOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryOrderItems.
     */
    distinct?: LaundryOrderItemScalarFieldEnum | LaundryOrderItemScalarFieldEnum[]
  }

  /**
   * LaundryOrderItem findMany
   */
  export type LaundryOrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrderItem
     */
    select?: LaundryOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrderItem
     */
    omit?: LaundryOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which LaundryOrderItems to fetch.
     */
    where?: LaundryOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryOrderItems to fetch.
     */
    orderBy?: LaundryOrderItemOrderByWithRelationInput | LaundryOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaundryOrderItems.
     */
    cursor?: LaundryOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryOrderItems.
     */
    skip?: number
    distinct?: LaundryOrderItemScalarFieldEnum | LaundryOrderItemScalarFieldEnum[]
  }

  /**
   * LaundryOrderItem create
   */
  export type LaundryOrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrderItem
     */
    select?: LaundryOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrderItem
     */
    omit?: LaundryOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a LaundryOrderItem.
     */
    data: XOR<LaundryOrderItemCreateInput, LaundryOrderItemUncheckedCreateInput>
  }

  /**
   * LaundryOrderItem createMany
   */
  export type LaundryOrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LaundryOrderItems.
     */
    data: LaundryOrderItemCreateManyInput | LaundryOrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LaundryOrderItem createManyAndReturn
   */
  export type LaundryOrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrderItem
     */
    select?: LaundryOrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrderItem
     */
    omit?: LaundryOrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many LaundryOrderItems.
     */
    data: LaundryOrderItemCreateManyInput | LaundryOrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LaundryOrderItem update
   */
  export type LaundryOrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrderItem
     */
    select?: LaundryOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrderItem
     */
    omit?: LaundryOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a LaundryOrderItem.
     */
    data: XOR<LaundryOrderItemUpdateInput, LaundryOrderItemUncheckedUpdateInput>
    /**
     * Choose, which LaundryOrderItem to update.
     */
    where: LaundryOrderItemWhereUniqueInput
  }

  /**
   * LaundryOrderItem updateMany
   */
  export type LaundryOrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LaundryOrderItems.
     */
    data: XOR<LaundryOrderItemUpdateManyMutationInput, LaundryOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which LaundryOrderItems to update
     */
    where?: LaundryOrderItemWhereInput
    /**
     * Limit how many LaundryOrderItems to update.
     */
    limit?: number
  }

  /**
   * LaundryOrderItem updateManyAndReturn
   */
  export type LaundryOrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrderItem
     */
    select?: LaundryOrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrderItem
     */
    omit?: LaundryOrderItemOmit<ExtArgs> | null
    /**
     * The data used to update LaundryOrderItems.
     */
    data: XOR<LaundryOrderItemUpdateManyMutationInput, LaundryOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which LaundryOrderItems to update
     */
    where?: LaundryOrderItemWhereInput
    /**
     * Limit how many LaundryOrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LaundryOrderItem upsert
   */
  export type LaundryOrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrderItem
     */
    select?: LaundryOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrderItem
     */
    omit?: LaundryOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the LaundryOrderItem to update in case it exists.
     */
    where: LaundryOrderItemWhereUniqueInput
    /**
     * In case the LaundryOrderItem found by the `where` argument doesn't exist, create a new LaundryOrderItem with this data.
     */
    create: XOR<LaundryOrderItemCreateInput, LaundryOrderItemUncheckedCreateInput>
    /**
     * In case the LaundryOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaundryOrderItemUpdateInput, LaundryOrderItemUncheckedUpdateInput>
  }

  /**
   * LaundryOrderItem delete
   */
  export type LaundryOrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrderItem
     */
    select?: LaundryOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrderItem
     */
    omit?: LaundryOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderItemInclude<ExtArgs> | null
    /**
     * Filter which LaundryOrderItem to delete.
     */
    where: LaundryOrderItemWhereUniqueInput
  }

  /**
   * LaundryOrderItem deleteMany
   */
  export type LaundryOrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaundryOrderItems to delete
     */
    where?: LaundryOrderItemWhereInput
    /**
     * Limit how many LaundryOrderItems to delete.
     */
    limit?: number
  }

  /**
   * LaundryOrderItem without action
   */
  export type LaundryOrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryOrderItem
     */
    select?: LaundryOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryOrderItem
     */
    omit?: LaundryOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryOrderItemInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryNote
   */

  export type AggregateDeliveryNote = {
    _count: DeliveryNoteCountAggregateOutputType | null
    _min: DeliveryNoteMinAggregateOutputType | null
    _max: DeliveryNoteMaxAggregateOutputType | null
  }

  export type DeliveryNoteMinAggregateOutputType = {
    id: string | null
    number: string | null
    date: Date | null
    notes: string | null
    orderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryNoteMaxAggregateOutputType = {
    id: string | null
    number: string | null
    date: Date | null
    notes: string | null
    orderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryNoteCountAggregateOutputType = {
    id: number
    number: number
    date: number
    notes: number
    orderId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeliveryNoteMinAggregateInputType = {
    id?: true
    number?: true
    date?: true
    notes?: true
    orderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryNoteMaxAggregateInputType = {
    id?: true
    number?: true
    date?: true
    notes?: true
    orderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryNoteCountAggregateInputType = {
    id?: true
    number?: true
    date?: true
    notes?: true
    orderId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeliveryNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryNote to aggregate.
     */
    where?: DeliveryNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryNotes to fetch.
     */
    orderBy?: DeliveryNoteOrderByWithRelationInput | DeliveryNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryNotes
    **/
    _count?: true | DeliveryNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryNoteMaxAggregateInputType
  }

  export type GetDeliveryNoteAggregateType<T extends DeliveryNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryNote[P]>
      : GetScalarType<T[P], AggregateDeliveryNote[P]>
  }




  export type DeliveryNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryNoteWhereInput
    orderBy?: DeliveryNoteOrderByWithAggregationInput | DeliveryNoteOrderByWithAggregationInput[]
    by: DeliveryNoteScalarFieldEnum[] | DeliveryNoteScalarFieldEnum
    having?: DeliveryNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryNoteCountAggregateInputType | true
    _min?: DeliveryNoteMinAggregateInputType
    _max?: DeliveryNoteMaxAggregateInputType
  }

  export type DeliveryNoteGroupByOutputType = {
    id: string
    number: string
    date: Date
    notes: string | null
    orderId: string
    createdAt: Date
    updatedAt: Date
    _count: DeliveryNoteCountAggregateOutputType | null
    _min: DeliveryNoteMinAggregateOutputType | null
    _max: DeliveryNoteMaxAggregateOutputType | null
  }

  type GetDeliveryNoteGroupByPayload<T extends DeliveryNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryNoteGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryNoteGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    notes?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | LaundryOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryNote"]>

  export type DeliveryNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    notes?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | LaundryOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryNote"]>

  export type DeliveryNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    notes?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | LaundryOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryNote"]>

  export type DeliveryNoteSelectScalar = {
    id?: boolean
    number?: boolean
    date?: boolean
    notes?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeliveryNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number" | "date" | "notes" | "orderId" | "createdAt" | "updatedAt", ExtArgs["result"]["deliveryNote"]>
  export type DeliveryNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | LaundryOrderDefaultArgs<ExtArgs>
  }
  export type DeliveryNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | LaundryOrderDefaultArgs<ExtArgs>
  }
  export type DeliveryNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | LaundryOrderDefaultArgs<ExtArgs>
  }

  export type $DeliveryNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryNote"
    objects: {
      order: Prisma.$LaundryOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number: string
      date: Date
      notes: string | null
      orderId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deliveryNote"]>
    composites: {}
  }

  type DeliveryNoteGetPayload<S extends boolean | null | undefined | DeliveryNoteDefaultArgs> = $Result.GetResult<Prisma.$DeliveryNotePayload, S>

  type DeliveryNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryNoteCountAggregateInputType | true
    }

  export interface DeliveryNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryNote'], meta: { name: 'DeliveryNote' } }
    /**
     * Find zero or one DeliveryNote that matches the filter.
     * @param {DeliveryNoteFindUniqueArgs} args - Arguments to find a DeliveryNote
     * @example
     * // Get one DeliveryNote
     * const deliveryNote = await prisma.deliveryNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryNoteFindUniqueArgs>(args: SelectSubset<T, DeliveryNoteFindUniqueArgs<ExtArgs>>): Prisma__DeliveryNoteClient<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryNoteFindUniqueOrThrowArgs} args - Arguments to find a DeliveryNote
     * @example
     * // Get one DeliveryNote
     * const deliveryNote = await prisma.deliveryNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryNoteClient<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryNoteFindFirstArgs} args - Arguments to find a DeliveryNote
     * @example
     * // Get one DeliveryNote
     * const deliveryNote = await prisma.deliveryNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryNoteFindFirstArgs>(args?: SelectSubset<T, DeliveryNoteFindFirstArgs<ExtArgs>>): Prisma__DeliveryNoteClient<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryNoteFindFirstOrThrowArgs} args - Arguments to find a DeliveryNote
     * @example
     * // Get one DeliveryNote
     * const deliveryNote = await prisma.deliveryNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryNoteClient<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryNotes
     * const deliveryNotes = await prisma.deliveryNote.findMany()
     * 
     * // Get first 10 DeliveryNotes
     * const deliveryNotes = await prisma.deliveryNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryNoteWithIdOnly = await prisma.deliveryNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryNoteFindManyArgs>(args?: SelectSubset<T, DeliveryNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryNote.
     * @param {DeliveryNoteCreateArgs} args - Arguments to create a DeliveryNote.
     * @example
     * // Create one DeliveryNote
     * const DeliveryNote = await prisma.deliveryNote.create({
     *   data: {
     *     // ... data to create a DeliveryNote
     *   }
     * })
     * 
     */
    create<T extends DeliveryNoteCreateArgs>(args: SelectSubset<T, DeliveryNoteCreateArgs<ExtArgs>>): Prisma__DeliveryNoteClient<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryNotes.
     * @param {DeliveryNoteCreateManyArgs} args - Arguments to create many DeliveryNotes.
     * @example
     * // Create many DeliveryNotes
     * const deliveryNote = await prisma.deliveryNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryNoteCreateManyArgs>(args?: SelectSubset<T, DeliveryNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryNotes and returns the data saved in the database.
     * @param {DeliveryNoteCreateManyAndReturnArgs} args - Arguments to create many DeliveryNotes.
     * @example
     * // Create many DeliveryNotes
     * const deliveryNote = await prisma.deliveryNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryNotes and only return the `id`
     * const deliveryNoteWithIdOnly = await prisma.deliveryNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryNote.
     * @param {DeliveryNoteDeleteArgs} args - Arguments to delete one DeliveryNote.
     * @example
     * // Delete one DeliveryNote
     * const DeliveryNote = await prisma.deliveryNote.delete({
     *   where: {
     *     // ... filter to delete one DeliveryNote
     *   }
     * })
     * 
     */
    delete<T extends DeliveryNoteDeleteArgs>(args: SelectSubset<T, DeliveryNoteDeleteArgs<ExtArgs>>): Prisma__DeliveryNoteClient<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryNote.
     * @param {DeliveryNoteUpdateArgs} args - Arguments to update one DeliveryNote.
     * @example
     * // Update one DeliveryNote
     * const deliveryNote = await prisma.deliveryNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryNoteUpdateArgs>(args: SelectSubset<T, DeliveryNoteUpdateArgs<ExtArgs>>): Prisma__DeliveryNoteClient<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryNotes.
     * @param {DeliveryNoteDeleteManyArgs} args - Arguments to filter DeliveryNotes to delete.
     * @example
     * // Delete a few DeliveryNotes
     * const { count } = await prisma.deliveryNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryNoteDeleteManyArgs>(args?: SelectSubset<T, DeliveryNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryNotes
     * const deliveryNote = await prisma.deliveryNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryNoteUpdateManyArgs>(args: SelectSubset<T, DeliveryNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryNotes and returns the data updated in the database.
     * @param {DeliveryNoteUpdateManyAndReturnArgs} args - Arguments to update many DeliveryNotes.
     * @example
     * // Update many DeliveryNotes
     * const deliveryNote = await prisma.deliveryNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryNotes and only return the `id`
     * const deliveryNoteWithIdOnly = await prisma.deliveryNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryNote.
     * @param {DeliveryNoteUpsertArgs} args - Arguments to update or create a DeliveryNote.
     * @example
     * // Update or create a DeliveryNote
     * const deliveryNote = await prisma.deliveryNote.upsert({
     *   create: {
     *     // ... data to create a DeliveryNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryNote we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryNoteUpsertArgs>(args: SelectSubset<T, DeliveryNoteUpsertArgs<ExtArgs>>): Prisma__DeliveryNoteClient<$Result.GetResult<Prisma.$DeliveryNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryNoteCountArgs} args - Arguments to filter DeliveryNotes to count.
     * @example
     * // Count the number of DeliveryNotes
     * const count = await prisma.deliveryNote.count({
     *   where: {
     *     // ... the filter for the DeliveryNotes we want to count
     *   }
     * })
    **/
    count<T extends DeliveryNoteCountArgs>(
      args?: Subset<T, DeliveryNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryNoteAggregateArgs>(args: Subset<T, DeliveryNoteAggregateArgs>): Prisma.PrismaPromise<GetDeliveryNoteAggregateType<T>>

    /**
     * Group by DeliveryNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryNoteGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryNote model
   */
  readonly fields: DeliveryNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends LaundryOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LaundryOrderDefaultArgs<ExtArgs>>): Prisma__LaundryOrderClient<$Result.GetResult<Prisma.$LaundryOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryNote model
   */
  interface DeliveryNoteFieldRefs {
    readonly id: FieldRef<"DeliveryNote", 'String'>
    readonly number: FieldRef<"DeliveryNote", 'String'>
    readonly date: FieldRef<"DeliveryNote", 'DateTime'>
    readonly notes: FieldRef<"DeliveryNote", 'String'>
    readonly orderId: FieldRef<"DeliveryNote", 'String'>
    readonly createdAt: FieldRef<"DeliveryNote", 'DateTime'>
    readonly updatedAt: FieldRef<"DeliveryNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryNote findUnique
   */
  export type DeliveryNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryNote to fetch.
     */
    where: DeliveryNoteWhereUniqueInput
  }

  /**
   * DeliveryNote findUniqueOrThrow
   */
  export type DeliveryNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryNote to fetch.
     */
    where: DeliveryNoteWhereUniqueInput
  }

  /**
   * DeliveryNote findFirst
   */
  export type DeliveryNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryNote to fetch.
     */
    where?: DeliveryNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryNotes to fetch.
     */
    orderBy?: DeliveryNoteOrderByWithRelationInput | DeliveryNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryNotes.
     */
    cursor?: DeliveryNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryNotes.
     */
    distinct?: DeliveryNoteScalarFieldEnum | DeliveryNoteScalarFieldEnum[]
  }

  /**
   * DeliveryNote findFirstOrThrow
   */
  export type DeliveryNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryNote to fetch.
     */
    where?: DeliveryNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryNotes to fetch.
     */
    orderBy?: DeliveryNoteOrderByWithRelationInput | DeliveryNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryNotes.
     */
    cursor?: DeliveryNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryNotes.
     */
    distinct?: DeliveryNoteScalarFieldEnum | DeliveryNoteScalarFieldEnum[]
  }

  /**
   * DeliveryNote findMany
   */
  export type DeliveryNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryNotes to fetch.
     */
    where?: DeliveryNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryNotes to fetch.
     */
    orderBy?: DeliveryNoteOrderByWithRelationInput | DeliveryNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryNotes.
     */
    cursor?: DeliveryNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryNotes.
     */
    skip?: number
    distinct?: DeliveryNoteScalarFieldEnum | DeliveryNoteScalarFieldEnum[]
  }

  /**
   * DeliveryNote create
   */
  export type DeliveryNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryNote.
     */
    data: XOR<DeliveryNoteCreateInput, DeliveryNoteUncheckedCreateInput>
  }

  /**
   * DeliveryNote createMany
   */
  export type DeliveryNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryNotes.
     */
    data: DeliveryNoteCreateManyInput | DeliveryNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryNote createManyAndReturn
   */
  export type DeliveryNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryNotes.
     */
    data: DeliveryNoteCreateManyInput | DeliveryNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryNote update
   */
  export type DeliveryNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryNote.
     */
    data: XOR<DeliveryNoteUpdateInput, DeliveryNoteUncheckedUpdateInput>
    /**
     * Choose, which DeliveryNote to update.
     */
    where: DeliveryNoteWhereUniqueInput
  }

  /**
   * DeliveryNote updateMany
   */
  export type DeliveryNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryNotes.
     */
    data: XOR<DeliveryNoteUpdateManyMutationInput, DeliveryNoteUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryNotes to update
     */
    where?: DeliveryNoteWhereInput
    /**
     * Limit how many DeliveryNotes to update.
     */
    limit?: number
  }

  /**
   * DeliveryNote updateManyAndReturn
   */
  export type DeliveryNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryNotes.
     */
    data: XOR<DeliveryNoteUpdateManyMutationInput, DeliveryNoteUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryNotes to update
     */
    where?: DeliveryNoteWhereInput
    /**
     * Limit how many DeliveryNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryNote upsert
   */
  export type DeliveryNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryNote to update in case it exists.
     */
    where: DeliveryNoteWhereUniqueInput
    /**
     * In case the DeliveryNote found by the `where` argument doesn't exist, create a new DeliveryNote with this data.
     */
    create: XOR<DeliveryNoteCreateInput, DeliveryNoteUncheckedCreateInput>
    /**
     * In case the DeliveryNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryNoteUpdateInput, DeliveryNoteUncheckedUpdateInput>
  }

  /**
   * DeliveryNote delete
   */
  export type DeliveryNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
    /**
     * Filter which DeliveryNote to delete.
     */
    where: DeliveryNoteWhereUniqueInput
  }

  /**
   * DeliveryNote deleteMany
   */
  export type DeliveryNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryNotes to delete
     */
    where?: DeliveryNoteWhereInput
    /**
     * Limit how many DeliveryNotes to delete.
     */
    limit?: number
  }

  /**
   * DeliveryNote without action
   */
  export type DeliveryNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryNote
     */
    select?: DeliveryNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryNote
     */
    omit?: DeliveryNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryNoteInclude<ExtArgs> | null
  }


  /**
   * Model TaskAssignment
   */

  export type AggregateTaskAssignment = {
    _count: TaskAssignmentCountAggregateOutputType | null
    _avg: TaskAssignmentAvgAggregateOutputType | null
    _sum: TaskAssignmentSumAggregateOutputType | null
    _min: TaskAssignmentMinAggregateOutputType | null
    _max: TaskAssignmentMaxAggregateOutputType | null
  }

  export type TaskAssignmentAvgAggregateOutputType = {
    estimatedDuration: number | null
    actualDuration: number | null
  }

  export type TaskAssignmentSumAggregateOutputType = {
    estimatedDuration: number | null
    actualDuration: number | null
  }

  export type TaskAssignmentMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    priority: string | null
    status: string | null
    assignedAt: Date | null
    dueDate: Date | null
    startedAt: Date | null
    completedAt: Date | null
    agentId: string | null
    propertyId: string | null
    reservationId: string | null
    cleaningSessionId: string | null
    maintenanceSessionId: string | null
    ticketId: string | null
    estimatedDuration: number | null
    actualDuration: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskAssignmentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    priority: string | null
    status: string | null
    assignedAt: Date | null
    dueDate: Date | null
    startedAt: Date | null
    completedAt: Date | null
    agentId: string | null
    propertyId: string | null
    reservationId: string | null
    cleaningSessionId: string | null
    maintenanceSessionId: string | null
    ticketId: string | null
    estimatedDuration: number | null
    actualDuration: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskAssignmentCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    priority: number
    status: number
    assignedAt: number
    dueDate: number
    startedAt: number
    completedAt: number
    agentId: number
    propertyId: number
    reservationId: number
    cleaningSessionId: number
    maintenanceSessionId: number
    ticketId: number
    estimatedDuration: number
    actualDuration: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskAssignmentAvgAggregateInputType = {
    estimatedDuration?: true
    actualDuration?: true
  }

  export type TaskAssignmentSumAggregateInputType = {
    estimatedDuration?: true
    actualDuration?: true
  }

  export type TaskAssignmentMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    priority?: true
    status?: true
    assignedAt?: true
    dueDate?: true
    startedAt?: true
    completedAt?: true
    agentId?: true
    propertyId?: true
    reservationId?: true
    cleaningSessionId?: true
    maintenanceSessionId?: true
    ticketId?: true
    estimatedDuration?: true
    actualDuration?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskAssignmentMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    priority?: true
    status?: true
    assignedAt?: true
    dueDate?: true
    startedAt?: true
    completedAt?: true
    agentId?: true
    propertyId?: true
    reservationId?: true
    cleaningSessionId?: true
    maintenanceSessionId?: true
    ticketId?: true
    estimatedDuration?: true
    actualDuration?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskAssignmentCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    priority?: true
    status?: true
    assignedAt?: true
    dueDate?: true
    startedAt?: true
    completedAt?: true
    agentId?: true
    propertyId?: true
    reservationId?: true
    cleaningSessionId?: true
    maintenanceSessionId?: true
    ticketId?: true
    estimatedDuration?: true
    actualDuration?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignment to aggregate.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskAssignments
    **/
    _count?: true | TaskAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskAssignmentMaxAggregateInputType
  }

  export type GetTaskAssignmentAggregateType<T extends TaskAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskAssignment[P]>
      : GetScalarType<T[P], AggregateTaskAssignment[P]>
  }




  export type TaskAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssignmentWhereInput
    orderBy?: TaskAssignmentOrderByWithAggregationInput | TaskAssignmentOrderByWithAggregationInput[]
    by: TaskAssignmentScalarFieldEnum[] | TaskAssignmentScalarFieldEnum
    having?: TaskAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskAssignmentCountAggregateInputType | true
    _avg?: TaskAssignmentAvgAggregateInputType
    _sum?: TaskAssignmentSumAggregateInputType
    _min?: TaskAssignmentMinAggregateInputType
    _max?: TaskAssignmentMaxAggregateInputType
  }

  export type TaskAssignmentGroupByOutputType = {
    id: string
    title: string
    description: string | null
    type: string
    priority: string
    status: string
    assignedAt: Date
    dueDate: Date | null
    startedAt: Date | null
    completedAt: Date | null
    agentId: string
    propertyId: string | null
    reservationId: string | null
    cleaningSessionId: string | null
    maintenanceSessionId: string | null
    ticketId: string | null
    estimatedDuration: number | null
    actualDuration: number | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: TaskAssignmentCountAggregateOutputType | null
    _avg: TaskAssignmentAvgAggregateOutputType | null
    _sum: TaskAssignmentSumAggregateOutputType | null
    _min: TaskAssignmentMinAggregateOutputType | null
    _max: TaskAssignmentMaxAggregateOutputType | null
  }

  type GetTaskAssignmentGroupByPayload<T extends TaskAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], TaskAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type TaskAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    assignedAt?: boolean
    dueDate?: boolean
    startedAt?: boolean
    completedAt?: boolean
    agentId?: boolean
    propertyId?: boolean
    reservationId?: boolean
    cleaningSessionId?: boolean
    maintenanceSessionId?: boolean
    ticketId?: boolean
    estimatedDuration?: boolean
    actualDuration?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignment"]>

  export type TaskAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    assignedAt?: boolean
    dueDate?: boolean
    startedAt?: boolean
    completedAt?: boolean
    agentId?: boolean
    propertyId?: boolean
    reservationId?: boolean
    cleaningSessionId?: boolean
    maintenanceSessionId?: boolean
    ticketId?: boolean
    estimatedDuration?: boolean
    actualDuration?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignment"]>

  export type TaskAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    assignedAt?: boolean
    dueDate?: boolean
    startedAt?: boolean
    completedAt?: boolean
    agentId?: boolean
    propertyId?: boolean
    reservationId?: boolean
    cleaningSessionId?: boolean
    maintenanceSessionId?: boolean
    ticketId?: boolean
    estimatedDuration?: boolean
    actualDuration?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignment"]>

  export type TaskAssignmentSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    assignedAt?: boolean
    dueDate?: boolean
    startedAt?: boolean
    completedAt?: boolean
    agentId?: boolean
    propertyId?: boolean
    reservationId?: boolean
    cleaningSessionId?: boolean
    maintenanceSessionId?: boolean
    ticketId?: boolean
    estimatedDuration?: boolean
    actualDuration?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "type" | "priority" | "status" | "assignedAt" | "dueDate" | "startedAt" | "completedAt" | "agentId" | "propertyId" | "reservationId" | "cleaningSessionId" | "maintenanceSessionId" | "ticketId" | "estimatedDuration" | "actualDuration" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["taskAssignment"]>
  export type TaskAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
  }
  export type TaskAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
  }
  export type TaskAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentProfileDefaultArgs<ExtArgs>
  }

  export type $TaskAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskAssignment"
    objects: {
      agent: Prisma.$AgentProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      type: string
      priority: string
      status: string
      assignedAt: Date
      dueDate: Date | null
      startedAt: Date | null
      completedAt: Date | null
      agentId: string
      propertyId: string | null
      reservationId: string | null
      cleaningSessionId: string | null
      maintenanceSessionId: string | null
      ticketId: string | null
      estimatedDuration: number | null
      actualDuration: number | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taskAssignment"]>
    composites: {}
  }

  type TaskAssignmentGetPayload<S extends boolean | null | undefined | TaskAssignmentDefaultArgs> = $Result.GetResult<Prisma.$TaskAssignmentPayload, S>

  type TaskAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskAssignmentCountAggregateInputType | true
    }

  export interface TaskAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskAssignment'], meta: { name: 'TaskAssignment' } }
    /**
     * Find zero or one TaskAssignment that matches the filter.
     * @param {TaskAssignmentFindUniqueArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskAssignmentFindUniqueArgs>(args: SelectSubset<T, TaskAssignmentFindUniqueArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskAssignmentFindUniqueOrThrowArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentFindFirstArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskAssignmentFindFirstArgs>(args?: SelectSubset<T, TaskAssignmentFindFirstArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentFindFirstOrThrowArgs} args - Arguments to find a TaskAssignment
     * @example
     * // Get one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskAssignments
     * const taskAssignments = await prisma.taskAssignment.findMany()
     * 
     * // Get first 10 TaskAssignments
     * const taskAssignments = await prisma.taskAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskAssignmentWithIdOnly = await prisma.taskAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskAssignmentFindManyArgs>(args?: SelectSubset<T, TaskAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskAssignment.
     * @param {TaskAssignmentCreateArgs} args - Arguments to create a TaskAssignment.
     * @example
     * // Create one TaskAssignment
     * const TaskAssignment = await prisma.taskAssignment.create({
     *   data: {
     *     // ... data to create a TaskAssignment
     *   }
     * })
     * 
     */
    create<T extends TaskAssignmentCreateArgs>(args: SelectSubset<T, TaskAssignmentCreateArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskAssignments.
     * @param {TaskAssignmentCreateManyArgs} args - Arguments to create many TaskAssignments.
     * @example
     * // Create many TaskAssignments
     * const taskAssignment = await prisma.taskAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskAssignmentCreateManyArgs>(args?: SelectSubset<T, TaskAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskAssignments and returns the data saved in the database.
     * @param {TaskAssignmentCreateManyAndReturnArgs} args - Arguments to create many TaskAssignments.
     * @example
     * // Create many TaskAssignments
     * const taskAssignment = await prisma.taskAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskAssignments and only return the `id`
     * const taskAssignmentWithIdOnly = await prisma.taskAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskAssignment.
     * @param {TaskAssignmentDeleteArgs} args - Arguments to delete one TaskAssignment.
     * @example
     * // Delete one TaskAssignment
     * const TaskAssignment = await prisma.taskAssignment.delete({
     *   where: {
     *     // ... filter to delete one TaskAssignment
     *   }
     * })
     * 
     */
    delete<T extends TaskAssignmentDeleteArgs>(args: SelectSubset<T, TaskAssignmentDeleteArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskAssignment.
     * @param {TaskAssignmentUpdateArgs} args - Arguments to update one TaskAssignment.
     * @example
     * // Update one TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskAssignmentUpdateArgs>(args: SelectSubset<T, TaskAssignmentUpdateArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskAssignments.
     * @param {TaskAssignmentDeleteManyArgs} args - Arguments to filter TaskAssignments to delete.
     * @example
     * // Delete a few TaskAssignments
     * const { count } = await prisma.taskAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskAssignmentDeleteManyArgs>(args?: SelectSubset<T, TaskAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskAssignments
     * const taskAssignment = await prisma.taskAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskAssignmentUpdateManyArgs>(args: SelectSubset<T, TaskAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAssignments and returns the data updated in the database.
     * @param {TaskAssignmentUpdateManyAndReturnArgs} args - Arguments to update many TaskAssignments.
     * @example
     * // Update many TaskAssignments
     * const taskAssignment = await prisma.taskAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskAssignments and only return the `id`
     * const taskAssignmentWithIdOnly = await prisma.taskAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskAssignment.
     * @param {TaskAssignmentUpsertArgs} args - Arguments to update or create a TaskAssignment.
     * @example
     * // Update or create a TaskAssignment
     * const taskAssignment = await prisma.taskAssignment.upsert({
     *   create: {
     *     // ... data to create a TaskAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskAssignment we want to update
     *   }
     * })
     */
    upsert<T extends TaskAssignmentUpsertArgs>(args: SelectSubset<T, TaskAssignmentUpsertArgs<ExtArgs>>): Prisma__TaskAssignmentClient<$Result.GetResult<Prisma.$TaskAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentCountArgs} args - Arguments to filter TaskAssignments to count.
     * @example
     * // Count the number of TaskAssignments
     * const count = await prisma.taskAssignment.count({
     *   where: {
     *     // ... the filter for the TaskAssignments we want to count
     *   }
     * })
    **/
    count<T extends TaskAssignmentCountArgs>(
      args?: Subset<T, TaskAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAssignmentAggregateArgs>(args: Subset<T, TaskAssignmentAggregateArgs>): Prisma.PrismaPromise<GetTaskAssignmentAggregateType<T>>

    /**
     * Group by TaskAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: TaskAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskAssignment model
   */
  readonly fields: TaskAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentProfileDefaultArgs<ExtArgs>>): Prisma__AgentProfileClient<$Result.GetResult<Prisma.$AgentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskAssignment model
   */
  interface TaskAssignmentFieldRefs {
    readonly id: FieldRef<"TaskAssignment", 'String'>
    readonly title: FieldRef<"TaskAssignment", 'String'>
    readonly description: FieldRef<"TaskAssignment", 'String'>
    readonly type: FieldRef<"TaskAssignment", 'String'>
    readonly priority: FieldRef<"TaskAssignment", 'String'>
    readonly status: FieldRef<"TaskAssignment", 'String'>
    readonly assignedAt: FieldRef<"TaskAssignment", 'DateTime'>
    readonly dueDate: FieldRef<"TaskAssignment", 'DateTime'>
    readonly startedAt: FieldRef<"TaskAssignment", 'DateTime'>
    readonly completedAt: FieldRef<"TaskAssignment", 'DateTime'>
    readonly agentId: FieldRef<"TaskAssignment", 'String'>
    readonly propertyId: FieldRef<"TaskAssignment", 'String'>
    readonly reservationId: FieldRef<"TaskAssignment", 'String'>
    readonly cleaningSessionId: FieldRef<"TaskAssignment", 'String'>
    readonly maintenanceSessionId: FieldRef<"TaskAssignment", 'String'>
    readonly ticketId: FieldRef<"TaskAssignment", 'String'>
    readonly estimatedDuration: FieldRef<"TaskAssignment", 'Int'>
    readonly actualDuration: FieldRef<"TaskAssignment", 'Int'>
    readonly notes: FieldRef<"TaskAssignment", 'String'>
    readonly createdAt: FieldRef<"TaskAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"TaskAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskAssignment findUnique
   */
  export type TaskAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment findUniqueOrThrow
   */
  export type TaskAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment findFirst
   */
  export type TaskAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignments.
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignments.
     */
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * TaskAssignment findFirstOrThrow
   */
  export type TaskAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignment to fetch.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignments.
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignments.
     */
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * TaskAssignment findMany
   */
  export type TaskAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignments to fetch.
     */
    where?: TaskAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignments to fetch.
     */
    orderBy?: TaskAssignmentOrderByWithRelationInput | TaskAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskAssignments.
     */
    cursor?: TaskAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignments.
     */
    skip?: number
    distinct?: TaskAssignmentScalarFieldEnum | TaskAssignmentScalarFieldEnum[]
  }

  /**
   * TaskAssignment create
   */
  export type TaskAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskAssignment.
     */
    data: XOR<TaskAssignmentCreateInput, TaskAssignmentUncheckedCreateInput>
  }

  /**
   * TaskAssignment createMany
   */
  export type TaskAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskAssignments.
     */
    data: TaskAssignmentCreateManyInput | TaskAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskAssignment createManyAndReturn
   */
  export type TaskAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many TaskAssignments.
     */
    data: TaskAssignmentCreateManyInput | TaskAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAssignment update
   */
  export type TaskAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskAssignment.
     */
    data: XOR<TaskAssignmentUpdateInput, TaskAssignmentUncheckedUpdateInput>
    /**
     * Choose, which TaskAssignment to update.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment updateMany
   */
  export type TaskAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskAssignments.
     */
    data: XOR<TaskAssignmentUpdateManyMutationInput, TaskAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which TaskAssignments to update
     */
    where?: TaskAssignmentWhereInput
    /**
     * Limit how many TaskAssignments to update.
     */
    limit?: number
  }

  /**
   * TaskAssignment updateManyAndReturn
   */
  export type TaskAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update TaskAssignments.
     */
    data: XOR<TaskAssignmentUpdateManyMutationInput, TaskAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which TaskAssignments to update
     */
    where?: TaskAssignmentWhereInput
    /**
     * Limit how many TaskAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAssignment upsert
   */
  export type TaskAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskAssignment to update in case it exists.
     */
    where: TaskAssignmentWhereUniqueInput
    /**
     * In case the TaskAssignment found by the `where` argument doesn't exist, create a new TaskAssignment with this data.
     */
    create: XOR<TaskAssignmentCreateInput, TaskAssignmentUncheckedCreateInput>
    /**
     * In case the TaskAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskAssignmentUpdateInput, TaskAssignmentUncheckedUpdateInput>
  }

  /**
   * TaskAssignment delete
   */
  export type TaskAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
    /**
     * Filter which TaskAssignment to delete.
     */
    where: TaskAssignmentWhereUniqueInput
  }

  /**
   * TaskAssignment deleteMany
   */
  export type TaskAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignments to delete
     */
    where?: TaskAssignmentWhereInput
    /**
     * Limit how many TaskAssignments to delete.
     */
    limit?: number
  }

  /**
   * TaskAssignment without action
   */
  export type TaskAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignment
     */
    select?: TaskAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignment
     */
    omit?: TaskAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model PropertyContract
   */

  export type AggregatePropertyContract = {
    _count: PropertyContractCountAggregateOutputType | null
    _avg: PropertyContractAvgAggregateOutputType | null
    _sum: PropertyContractSumAggregateOutputType | null
    _min: PropertyContractMinAggregateOutputType | null
    _max: PropertyContractMaxAggregateOutputType | null
  }

  export type PropertyContractAvgAggregateOutputType = {
    monthlyFee: number | null
    commissionRate: number | null
  }

  export type PropertyContractSumAggregateOutputType = {
    monthlyFee: number | null
    commissionRate: number | null
  }

  export type PropertyContractMinAggregateOutputType = {
    id: string | null
    contractNumber: string | null
    type: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    propertyId: string | null
    propertyOwnerId: string | null
    monthlyFee: number | null
    commissionRate: number | null
    documentUrl: string | null
    signedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyContractMaxAggregateOutputType = {
    id: string | null
    contractNumber: string | null
    type: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    propertyId: string | null
    propertyOwnerId: string | null
    monthlyFee: number | null
    commissionRate: number | null
    documentUrl: string | null
    signedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyContractCountAggregateOutputType = {
    id: number
    contractNumber: number
    type: number
    status: number
    startDate: number
    endDate: number
    propertyId: number
    propertyOwnerId: number
    monthlyFee: number
    commissionRate: number
    documentUrl: number
    signedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyContractAvgAggregateInputType = {
    monthlyFee?: true
    commissionRate?: true
  }

  export type PropertyContractSumAggregateInputType = {
    monthlyFee?: true
    commissionRate?: true
  }

  export type PropertyContractMinAggregateInputType = {
    id?: true
    contractNumber?: true
    type?: true
    status?: true
    startDate?: true
    endDate?: true
    propertyId?: true
    propertyOwnerId?: true
    monthlyFee?: true
    commissionRate?: true
    documentUrl?: true
    signedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyContractMaxAggregateInputType = {
    id?: true
    contractNumber?: true
    type?: true
    status?: true
    startDate?: true
    endDate?: true
    propertyId?: true
    propertyOwnerId?: true
    monthlyFee?: true
    commissionRate?: true
    documentUrl?: true
    signedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyContractCountAggregateInputType = {
    id?: true
    contractNumber?: true
    type?: true
    status?: true
    startDate?: true
    endDate?: true
    propertyId?: true
    propertyOwnerId?: true
    monthlyFee?: true
    commissionRate?: true
    documentUrl?: true
    signedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyContract to aggregate.
     */
    where?: PropertyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyContracts to fetch.
     */
    orderBy?: PropertyContractOrderByWithRelationInput | PropertyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyContracts
    **/
    _count?: true | PropertyContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyContractMaxAggregateInputType
  }

  export type GetPropertyContractAggregateType<T extends PropertyContractAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyContract[P]>
      : GetScalarType<T[P], AggregatePropertyContract[P]>
  }




  export type PropertyContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyContractWhereInput
    orderBy?: PropertyContractOrderByWithAggregationInput | PropertyContractOrderByWithAggregationInput[]
    by: PropertyContractScalarFieldEnum[] | PropertyContractScalarFieldEnum
    having?: PropertyContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyContractCountAggregateInputType | true
    _avg?: PropertyContractAvgAggregateInputType
    _sum?: PropertyContractSumAggregateInputType
    _min?: PropertyContractMinAggregateInputType
    _max?: PropertyContractMaxAggregateInputType
  }

  export type PropertyContractGroupByOutputType = {
    id: string
    contractNumber: string
    type: string
    status: string
    startDate: Date
    endDate: Date | null
    propertyId: string
    propertyOwnerId: string
    monthlyFee: number | null
    commissionRate: number | null
    documentUrl: string | null
    signedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PropertyContractCountAggregateOutputType | null
    _avg: PropertyContractAvgAggregateOutputType | null
    _sum: PropertyContractSumAggregateOutputType | null
    _min: PropertyContractMinAggregateOutputType | null
    _max: PropertyContractMaxAggregateOutputType | null
  }

  type GetPropertyContractGroupByPayload<T extends PropertyContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyContractGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyContractGroupByOutputType[P]>
        }
      >
    >


  export type PropertyContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractNumber?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    propertyId?: boolean
    propertyOwnerId?: boolean
    monthlyFee?: boolean
    commissionRate?: boolean
    documentUrl?: boolean
    signedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    propertyOwner?: boolean | PropertyOwnerProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyContract"]>

  export type PropertyContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractNumber?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    propertyId?: boolean
    propertyOwnerId?: boolean
    monthlyFee?: boolean
    commissionRate?: boolean
    documentUrl?: boolean
    signedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    propertyOwner?: boolean | PropertyOwnerProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyContract"]>

  export type PropertyContractSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractNumber?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    propertyId?: boolean
    propertyOwnerId?: boolean
    monthlyFee?: boolean
    commissionRate?: boolean
    documentUrl?: boolean
    signedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    propertyOwner?: boolean | PropertyOwnerProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyContract"]>

  export type PropertyContractSelectScalar = {
    id?: boolean
    contractNumber?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    propertyId?: boolean
    propertyOwnerId?: boolean
    monthlyFee?: boolean
    commissionRate?: boolean
    documentUrl?: boolean
    signedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyContractOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractNumber" | "type" | "status" | "startDate" | "endDate" | "propertyId" | "propertyOwnerId" | "monthlyFee" | "commissionRate" | "documentUrl" | "signedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["propertyContract"]>
  export type PropertyContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    propertyOwner?: boolean | PropertyOwnerProfileDefaultArgs<ExtArgs>
  }
  export type PropertyContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    propertyOwner?: boolean | PropertyOwnerProfileDefaultArgs<ExtArgs>
  }
  export type PropertyContractIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    propertyOwner?: boolean | PropertyOwnerProfileDefaultArgs<ExtArgs>
  }

  export type $PropertyContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyContract"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      propertyOwner: Prisma.$PropertyOwnerProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractNumber: string
      type: string
      status: string
      startDate: Date
      endDate: Date | null
      propertyId: string
      propertyOwnerId: string
      monthlyFee: number | null
      commissionRate: number | null
      documentUrl: string | null
      signedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyContract"]>
    composites: {}
  }

  type PropertyContractGetPayload<S extends boolean | null | undefined | PropertyContractDefaultArgs> = $Result.GetResult<Prisma.$PropertyContractPayload, S>

  type PropertyContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyContractFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyContractCountAggregateInputType | true
    }

  export interface PropertyContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyContract'], meta: { name: 'PropertyContract' } }
    /**
     * Find zero or one PropertyContract that matches the filter.
     * @param {PropertyContractFindUniqueArgs} args - Arguments to find a PropertyContract
     * @example
     * // Get one PropertyContract
     * const propertyContract = await prisma.propertyContract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyContractFindUniqueArgs>(args: SelectSubset<T, PropertyContractFindUniqueArgs<ExtArgs>>): Prisma__PropertyContractClient<$Result.GetResult<Prisma.$PropertyContractPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyContract that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyContractFindUniqueOrThrowArgs} args - Arguments to find a PropertyContract
     * @example
     * // Get one PropertyContract
     * const propertyContract = await prisma.propertyContract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyContractFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyContractClient<$Result.GetResult<Prisma.$PropertyContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyContract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyContractFindFirstArgs} args - Arguments to find a PropertyContract
     * @example
     * // Get one PropertyContract
     * const propertyContract = await prisma.propertyContract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyContractFindFirstArgs>(args?: SelectSubset<T, PropertyContractFindFirstArgs<ExtArgs>>): Prisma__PropertyContractClient<$Result.GetResult<Prisma.$PropertyContractPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyContract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyContractFindFirstOrThrowArgs} args - Arguments to find a PropertyContract
     * @example
     * // Get one PropertyContract
     * const propertyContract = await prisma.propertyContract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyContractFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyContractClient<$Result.GetResult<Prisma.$PropertyContractPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyContracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyContracts
     * const propertyContracts = await prisma.propertyContract.findMany()
     * 
     * // Get first 10 PropertyContracts
     * const propertyContracts = await prisma.propertyContract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyContractWithIdOnly = await prisma.propertyContract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyContractFindManyArgs>(args?: SelectSubset<T, PropertyContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyContract.
     * @param {PropertyContractCreateArgs} args - Arguments to create a PropertyContract.
     * @example
     * // Create one PropertyContract
     * const PropertyContract = await prisma.propertyContract.create({
     *   data: {
     *     // ... data to create a PropertyContract
     *   }
     * })
     * 
     */
    create<T extends PropertyContractCreateArgs>(args: SelectSubset<T, PropertyContractCreateArgs<ExtArgs>>): Prisma__PropertyContractClient<$Result.GetResult<Prisma.$PropertyContractPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyContracts.
     * @param {PropertyContractCreateManyArgs} args - Arguments to create many PropertyContracts.
     * @example
     * // Create many PropertyContracts
     * const propertyContract = await prisma.propertyContract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyContractCreateManyArgs>(args?: SelectSubset<T, PropertyContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyContracts and returns the data saved in the database.
     * @param {PropertyContractCreateManyAndReturnArgs} args - Arguments to create many PropertyContracts.
     * @example
     * // Create many PropertyContracts
     * const propertyContract = await prisma.propertyContract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyContracts and only return the `id`
     * const propertyContractWithIdOnly = await prisma.propertyContract.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyContractCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyContractPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyContract.
     * @param {PropertyContractDeleteArgs} args - Arguments to delete one PropertyContract.
     * @example
     * // Delete one PropertyContract
     * const PropertyContract = await prisma.propertyContract.delete({
     *   where: {
     *     // ... filter to delete one PropertyContract
     *   }
     * })
     * 
     */
    delete<T extends PropertyContractDeleteArgs>(args: SelectSubset<T, PropertyContractDeleteArgs<ExtArgs>>): Prisma__PropertyContractClient<$Result.GetResult<Prisma.$PropertyContractPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyContract.
     * @param {PropertyContractUpdateArgs} args - Arguments to update one PropertyContract.
     * @example
     * // Update one PropertyContract
     * const propertyContract = await prisma.propertyContract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyContractUpdateArgs>(args: SelectSubset<T, PropertyContractUpdateArgs<ExtArgs>>): Prisma__PropertyContractClient<$Result.GetResult<Prisma.$PropertyContractPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyContracts.
     * @param {PropertyContractDeleteManyArgs} args - Arguments to filter PropertyContracts to delete.
     * @example
     * // Delete a few PropertyContracts
     * const { count } = await prisma.propertyContract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyContractDeleteManyArgs>(args?: SelectSubset<T, PropertyContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyContracts
     * const propertyContract = await prisma.propertyContract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyContractUpdateManyArgs>(args: SelectSubset<T, PropertyContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyContracts and returns the data updated in the database.
     * @param {PropertyContractUpdateManyAndReturnArgs} args - Arguments to update many PropertyContracts.
     * @example
     * // Update many PropertyContracts
     * const propertyContract = await prisma.propertyContract.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyContracts and only return the `id`
     * const propertyContractWithIdOnly = await prisma.propertyContract.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyContractUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyContractUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyContractPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyContract.
     * @param {PropertyContractUpsertArgs} args - Arguments to update or create a PropertyContract.
     * @example
     * // Update or create a PropertyContract
     * const propertyContract = await prisma.propertyContract.upsert({
     *   create: {
     *     // ... data to create a PropertyContract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyContract we want to update
     *   }
     * })
     */
    upsert<T extends PropertyContractUpsertArgs>(args: SelectSubset<T, PropertyContractUpsertArgs<ExtArgs>>): Prisma__PropertyContractClient<$Result.GetResult<Prisma.$PropertyContractPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyContractCountArgs} args - Arguments to filter PropertyContracts to count.
     * @example
     * // Count the number of PropertyContracts
     * const count = await prisma.propertyContract.count({
     *   where: {
     *     // ... the filter for the PropertyContracts we want to count
     *   }
     * })
    **/
    count<T extends PropertyContractCountArgs>(
      args?: Subset<T, PropertyContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyContractAggregateArgs>(args: Subset<T, PropertyContractAggregateArgs>): Prisma.PrismaPromise<GetPropertyContractAggregateType<T>>

    /**
     * Group by PropertyContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyContractGroupByArgs['orderBy'] }
        : { orderBy?: PropertyContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyContract model
   */
  readonly fields: PropertyContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyContract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    propertyOwner<T extends PropertyOwnerProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyOwnerProfileDefaultArgs<ExtArgs>>): Prisma__PropertyOwnerProfileClient<$Result.GetResult<Prisma.$PropertyOwnerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyContract model
   */
  interface PropertyContractFieldRefs {
    readonly id: FieldRef<"PropertyContract", 'String'>
    readonly contractNumber: FieldRef<"PropertyContract", 'String'>
    readonly type: FieldRef<"PropertyContract", 'String'>
    readonly status: FieldRef<"PropertyContract", 'String'>
    readonly startDate: FieldRef<"PropertyContract", 'DateTime'>
    readonly endDate: FieldRef<"PropertyContract", 'DateTime'>
    readonly propertyId: FieldRef<"PropertyContract", 'String'>
    readonly propertyOwnerId: FieldRef<"PropertyContract", 'String'>
    readonly monthlyFee: FieldRef<"PropertyContract", 'Float'>
    readonly commissionRate: FieldRef<"PropertyContract", 'Float'>
    readonly documentUrl: FieldRef<"PropertyContract", 'String'>
    readonly signedAt: FieldRef<"PropertyContract", 'DateTime'>
    readonly createdAt: FieldRef<"PropertyContract", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyContract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyContract findUnique
   */
  export type PropertyContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContract
     */
    select?: PropertyContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContract
     */
    omit?: PropertyContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContractInclude<ExtArgs> | null
    /**
     * Filter, which PropertyContract to fetch.
     */
    where: PropertyContractWhereUniqueInput
  }

  /**
   * PropertyContract findUniqueOrThrow
   */
  export type PropertyContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContract
     */
    select?: PropertyContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContract
     */
    omit?: PropertyContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContractInclude<ExtArgs> | null
    /**
     * Filter, which PropertyContract to fetch.
     */
    where: PropertyContractWhereUniqueInput
  }

  /**
   * PropertyContract findFirst
   */
  export type PropertyContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContract
     */
    select?: PropertyContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContract
     */
    omit?: PropertyContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContractInclude<ExtArgs> | null
    /**
     * Filter, which PropertyContract to fetch.
     */
    where?: PropertyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyContracts to fetch.
     */
    orderBy?: PropertyContractOrderByWithRelationInput | PropertyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyContracts.
     */
    cursor?: PropertyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyContracts.
     */
    distinct?: PropertyContractScalarFieldEnum | PropertyContractScalarFieldEnum[]
  }

  /**
   * PropertyContract findFirstOrThrow
   */
  export type PropertyContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContract
     */
    select?: PropertyContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContract
     */
    omit?: PropertyContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContractInclude<ExtArgs> | null
    /**
     * Filter, which PropertyContract to fetch.
     */
    where?: PropertyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyContracts to fetch.
     */
    orderBy?: PropertyContractOrderByWithRelationInput | PropertyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyContracts.
     */
    cursor?: PropertyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyContracts.
     */
    distinct?: PropertyContractScalarFieldEnum | PropertyContractScalarFieldEnum[]
  }

  /**
   * PropertyContract findMany
   */
  export type PropertyContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContract
     */
    select?: PropertyContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContract
     */
    omit?: PropertyContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContractInclude<ExtArgs> | null
    /**
     * Filter, which PropertyContracts to fetch.
     */
    where?: PropertyContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyContracts to fetch.
     */
    orderBy?: PropertyContractOrderByWithRelationInput | PropertyContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyContracts.
     */
    cursor?: PropertyContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyContracts.
     */
    skip?: number
    distinct?: PropertyContractScalarFieldEnum | PropertyContractScalarFieldEnum[]
  }

  /**
   * PropertyContract create
   */
  export type PropertyContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContract
     */
    select?: PropertyContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContract
     */
    omit?: PropertyContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContractInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyContract.
     */
    data: XOR<PropertyContractCreateInput, PropertyContractUncheckedCreateInput>
  }

  /**
   * PropertyContract createMany
   */
  export type PropertyContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyContracts.
     */
    data: PropertyContractCreateManyInput | PropertyContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyContract createManyAndReturn
   */
  export type PropertyContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContract
     */
    select?: PropertyContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContract
     */
    omit?: PropertyContractOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyContracts.
     */
    data: PropertyContractCreateManyInput | PropertyContractCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyContract update
   */
  export type PropertyContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContract
     */
    select?: PropertyContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContract
     */
    omit?: PropertyContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContractInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyContract.
     */
    data: XOR<PropertyContractUpdateInput, PropertyContractUncheckedUpdateInput>
    /**
     * Choose, which PropertyContract to update.
     */
    where: PropertyContractWhereUniqueInput
  }

  /**
   * PropertyContract updateMany
   */
  export type PropertyContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyContracts.
     */
    data: XOR<PropertyContractUpdateManyMutationInput, PropertyContractUncheckedUpdateManyInput>
    /**
     * Filter which PropertyContracts to update
     */
    where?: PropertyContractWhereInput
    /**
     * Limit how many PropertyContracts to update.
     */
    limit?: number
  }

  /**
   * PropertyContract updateManyAndReturn
   */
  export type PropertyContractUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContract
     */
    select?: PropertyContractSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContract
     */
    omit?: PropertyContractOmit<ExtArgs> | null
    /**
     * The data used to update PropertyContracts.
     */
    data: XOR<PropertyContractUpdateManyMutationInput, PropertyContractUncheckedUpdateManyInput>
    /**
     * Filter which PropertyContracts to update
     */
    where?: PropertyContractWhereInput
    /**
     * Limit how many PropertyContracts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContractIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyContract upsert
   */
  export type PropertyContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContract
     */
    select?: PropertyContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContract
     */
    omit?: PropertyContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContractInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyContract to update in case it exists.
     */
    where: PropertyContractWhereUniqueInput
    /**
     * In case the PropertyContract found by the `where` argument doesn't exist, create a new PropertyContract with this data.
     */
    create: XOR<PropertyContractCreateInput, PropertyContractUncheckedCreateInput>
    /**
     * In case the PropertyContract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyContractUpdateInput, PropertyContractUncheckedUpdateInput>
  }

  /**
   * PropertyContract delete
   */
  export type PropertyContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContract
     */
    select?: PropertyContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContract
     */
    omit?: PropertyContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContractInclude<ExtArgs> | null
    /**
     * Filter which PropertyContract to delete.
     */
    where: PropertyContractWhereUniqueInput
  }

  /**
   * PropertyContract deleteMany
   */
  export type PropertyContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyContracts to delete
     */
    where?: PropertyContractWhereInput
    /**
     * Limit how many PropertyContracts to delete.
     */
    limit?: number
  }

  /**
   * PropertyContract without action
   */
  export type PropertyContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContract
     */
    select?: PropertyContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContract
     */
    omit?: PropertyContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContractInclude<ExtArgs> | null
  }


  /**
   * Model SuperAdminInvoice
   */

  export type AggregateSuperAdminInvoice = {
    _count: SuperAdminInvoiceCountAggregateOutputType | null
    _avg: SuperAdminInvoiceAvgAggregateOutputType | null
    _sum: SuperAdminInvoiceSumAggregateOutputType | null
    _min: SuperAdminInvoiceMinAggregateOutputType | null
    _max: SuperAdminInvoiceMaxAggregateOutputType | null
  }

  export type SuperAdminInvoiceAvgAggregateOutputType = {
    subtotal: number | null
    taxRate: number | null
    taxAmount: number | null
    totalAmount: number | null
    paidAmount: number | null
  }

  export type SuperAdminInvoiceSumAggregateOutputType = {
    subtotal: number | null
    taxRate: number | null
    taxAmount: number | null
    totalAmount: number | null
    paidAmount: number | null
  }

  export type SuperAdminInvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    status: string | null
    issueDate: Date | null
    dueDate: Date | null
    paidAt: Date | null
    subtotal: number | null
    taxRate: number | null
    taxAmount: number | null
    totalAmount: number | null
    paidAmount: number | null
    superAdminId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuperAdminInvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    status: string | null
    issueDate: Date | null
    dueDate: Date | null
    paidAt: Date | null
    subtotal: number | null
    taxRate: number | null
    taxAmount: number | null
    totalAmount: number | null
    paidAmount: number | null
    superAdminId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuperAdminInvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    status: number
    issueDate: number
    dueDate: number
    paidAt: number
    subtotal: number
    taxRate: number
    taxAmount: number
    totalAmount: number
    paidAmount: number
    superAdminId: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SuperAdminInvoiceAvgAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    totalAmount?: true
    paidAmount?: true
  }

  export type SuperAdminInvoiceSumAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    totalAmount?: true
    paidAmount?: true
  }

  export type SuperAdminInvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidAt?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    totalAmount?: true
    paidAmount?: true
    superAdminId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuperAdminInvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidAt?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    totalAmount?: true
    paidAmount?: true
    superAdminId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuperAdminInvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidAt?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    totalAmount?: true
    paidAmount?: true
    superAdminId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SuperAdminInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdminInvoice to aggregate.
     */
    where?: SuperAdminInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdminInvoices to fetch.
     */
    orderBy?: SuperAdminInvoiceOrderByWithRelationInput | SuperAdminInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuperAdminInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdminInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdminInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuperAdminInvoices
    **/
    _count?: true | SuperAdminInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SuperAdminInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SuperAdminInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuperAdminInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuperAdminInvoiceMaxAggregateInputType
  }

  export type GetSuperAdminInvoiceAggregateType<T extends SuperAdminInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateSuperAdminInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperAdminInvoice[P]>
      : GetScalarType<T[P], AggregateSuperAdminInvoice[P]>
  }




  export type SuperAdminInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuperAdminInvoiceWhereInput
    orderBy?: SuperAdminInvoiceOrderByWithAggregationInput | SuperAdminInvoiceOrderByWithAggregationInput[]
    by: SuperAdminInvoiceScalarFieldEnum[] | SuperAdminInvoiceScalarFieldEnum
    having?: SuperAdminInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuperAdminInvoiceCountAggregateInputType | true
    _avg?: SuperAdminInvoiceAvgAggregateInputType
    _sum?: SuperAdminInvoiceSumAggregateInputType
    _min?: SuperAdminInvoiceMinAggregateInputType
    _max?: SuperAdminInvoiceMaxAggregateInputType
  }

  export type SuperAdminInvoiceGroupByOutputType = {
    id: string
    invoiceNumber: string
    status: string
    issueDate: Date
    dueDate: Date
    paidAt: Date | null
    subtotal: number
    taxRate: number
    taxAmount: number
    totalAmount: number
    paidAmount: number
    superAdminId: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: SuperAdminInvoiceCountAggregateOutputType | null
    _avg: SuperAdminInvoiceAvgAggregateOutputType | null
    _sum: SuperAdminInvoiceSumAggregateOutputType | null
    _min: SuperAdminInvoiceMinAggregateOutputType | null
    _max: SuperAdminInvoiceMaxAggregateOutputType | null
  }

  type GetSuperAdminInvoiceGroupByPayload<T extends SuperAdminInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuperAdminInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuperAdminInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuperAdminInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], SuperAdminInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type SuperAdminInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    superAdminId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
    items?: boolean | SuperAdminInvoice$itemsArgs<ExtArgs>
    _count?: boolean | SuperAdminInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdminInvoice"]>

  export type SuperAdminInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    superAdminId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdminInvoice"]>

  export type SuperAdminInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    superAdminId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdminInvoice"]>

  export type SuperAdminInvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    superAdminId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SuperAdminInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNumber" | "status" | "issueDate" | "dueDate" | "paidAt" | "subtotal" | "taxRate" | "taxAmount" | "totalAmount" | "paidAmount" | "superAdminId" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["superAdminInvoice"]>
  export type SuperAdminInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
    items?: boolean | SuperAdminInvoice$itemsArgs<ExtArgs>
    _count?: boolean | SuperAdminInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SuperAdminInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
  }
  export type SuperAdminInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    superAdmin?: boolean | SuperAdminProfileDefaultArgs<ExtArgs>
  }

  export type $SuperAdminInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SuperAdminInvoice"
    objects: {
      superAdmin: Prisma.$SuperAdminProfilePayload<ExtArgs>
      items: Prisma.$SuperAdminInvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNumber: string
      status: string
      issueDate: Date
      dueDate: Date
      paidAt: Date | null
      subtotal: number
      taxRate: number
      taxAmount: number
      totalAmount: number
      paidAmount: number
      superAdminId: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["superAdminInvoice"]>
    composites: {}
  }

  type SuperAdminInvoiceGetPayload<S extends boolean | null | undefined | SuperAdminInvoiceDefaultArgs> = $Result.GetResult<Prisma.$SuperAdminInvoicePayload, S>

  type SuperAdminInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SuperAdminInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuperAdminInvoiceCountAggregateInputType | true
    }

  export interface SuperAdminInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SuperAdminInvoice'], meta: { name: 'SuperAdminInvoice' } }
    /**
     * Find zero or one SuperAdminInvoice that matches the filter.
     * @param {SuperAdminInvoiceFindUniqueArgs} args - Arguments to find a SuperAdminInvoice
     * @example
     * // Get one SuperAdminInvoice
     * const superAdminInvoice = await prisma.superAdminInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuperAdminInvoiceFindUniqueArgs>(args: SelectSubset<T, SuperAdminInvoiceFindUniqueArgs<ExtArgs>>): Prisma__SuperAdminInvoiceClient<$Result.GetResult<Prisma.$SuperAdminInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SuperAdminInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SuperAdminInvoiceFindUniqueOrThrowArgs} args - Arguments to find a SuperAdminInvoice
     * @example
     * // Get one SuperAdminInvoice
     * const superAdminInvoice = await prisma.superAdminInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuperAdminInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, SuperAdminInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuperAdminInvoiceClient<$Result.GetResult<Prisma.$SuperAdminInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdminInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminInvoiceFindFirstArgs} args - Arguments to find a SuperAdminInvoice
     * @example
     * // Get one SuperAdminInvoice
     * const superAdminInvoice = await prisma.superAdminInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuperAdminInvoiceFindFirstArgs>(args?: SelectSubset<T, SuperAdminInvoiceFindFirstArgs<ExtArgs>>): Prisma__SuperAdminInvoiceClient<$Result.GetResult<Prisma.$SuperAdminInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdminInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminInvoiceFindFirstOrThrowArgs} args - Arguments to find a SuperAdminInvoice
     * @example
     * // Get one SuperAdminInvoice
     * const superAdminInvoice = await prisma.superAdminInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuperAdminInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, SuperAdminInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuperAdminInvoiceClient<$Result.GetResult<Prisma.$SuperAdminInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SuperAdminInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuperAdminInvoices
     * const superAdminInvoices = await prisma.superAdminInvoice.findMany()
     * 
     * // Get first 10 SuperAdminInvoices
     * const superAdminInvoices = await prisma.superAdminInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const superAdminInvoiceWithIdOnly = await prisma.superAdminInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuperAdminInvoiceFindManyArgs>(args?: SelectSubset<T, SuperAdminInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SuperAdminInvoice.
     * @param {SuperAdminInvoiceCreateArgs} args - Arguments to create a SuperAdminInvoice.
     * @example
     * // Create one SuperAdminInvoice
     * const SuperAdminInvoice = await prisma.superAdminInvoice.create({
     *   data: {
     *     // ... data to create a SuperAdminInvoice
     *   }
     * })
     * 
     */
    create<T extends SuperAdminInvoiceCreateArgs>(args: SelectSubset<T, SuperAdminInvoiceCreateArgs<ExtArgs>>): Prisma__SuperAdminInvoiceClient<$Result.GetResult<Prisma.$SuperAdminInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SuperAdminInvoices.
     * @param {SuperAdminInvoiceCreateManyArgs} args - Arguments to create many SuperAdminInvoices.
     * @example
     * // Create many SuperAdminInvoices
     * const superAdminInvoice = await prisma.superAdminInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuperAdminInvoiceCreateManyArgs>(args?: SelectSubset<T, SuperAdminInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SuperAdminInvoices and returns the data saved in the database.
     * @param {SuperAdminInvoiceCreateManyAndReturnArgs} args - Arguments to create many SuperAdminInvoices.
     * @example
     * // Create many SuperAdminInvoices
     * const superAdminInvoice = await prisma.superAdminInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SuperAdminInvoices and only return the `id`
     * const superAdminInvoiceWithIdOnly = await prisma.superAdminInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuperAdminInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, SuperAdminInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SuperAdminInvoice.
     * @param {SuperAdminInvoiceDeleteArgs} args - Arguments to delete one SuperAdminInvoice.
     * @example
     * // Delete one SuperAdminInvoice
     * const SuperAdminInvoice = await prisma.superAdminInvoice.delete({
     *   where: {
     *     // ... filter to delete one SuperAdminInvoice
     *   }
     * })
     * 
     */
    delete<T extends SuperAdminInvoiceDeleteArgs>(args: SelectSubset<T, SuperAdminInvoiceDeleteArgs<ExtArgs>>): Prisma__SuperAdminInvoiceClient<$Result.GetResult<Prisma.$SuperAdminInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SuperAdminInvoice.
     * @param {SuperAdminInvoiceUpdateArgs} args - Arguments to update one SuperAdminInvoice.
     * @example
     * // Update one SuperAdminInvoice
     * const superAdminInvoice = await prisma.superAdminInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuperAdminInvoiceUpdateArgs>(args: SelectSubset<T, SuperAdminInvoiceUpdateArgs<ExtArgs>>): Prisma__SuperAdminInvoiceClient<$Result.GetResult<Prisma.$SuperAdminInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SuperAdminInvoices.
     * @param {SuperAdminInvoiceDeleteManyArgs} args - Arguments to filter SuperAdminInvoices to delete.
     * @example
     * // Delete a few SuperAdminInvoices
     * const { count } = await prisma.superAdminInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuperAdminInvoiceDeleteManyArgs>(args?: SelectSubset<T, SuperAdminInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdminInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuperAdminInvoices
     * const superAdminInvoice = await prisma.superAdminInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuperAdminInvoiceUpdateManyArgs>(args: SelectSubset<T, SuperAdminInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdminInvoices and returns the data updated in the database.
     * @param {SuperAdminInvoiceUpdateManyAndReturnArgs} args - Arguments to update many SuperAdminInvoices.
     * @example
     * // Update many SuperAdminInvoices
     * const superAdminInvoice = await prisma.superAdminInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SuperAdminInvoices and only return the `id`
     * const superAdminInvoiceWithIdOnly = await prisma.superAdminInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SuperAdminInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, SuperAdminInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SuperAdminInvoice.
     * @param {SuperAdminInvoiceUpsertArgs} args - Arguments to update or create a SuperAdminInvoice.
     * @example
     * // Update or create a SuperAdminInvoice
     * const superAdminInvoice = await prisma.superAdminInvoice.upsert({
     *   create: {
     *     // ... data to create a SuperAdminInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuperAdminInvoice we want to update
     *   }
     * })
     */
    upsert<T extends SuperAdminInvoiceUpsertArgs>(args: SelectSubset<T, SuperAdminInvoiceUpsertArgs<ExtArgs>>): Prisma__SuperAdminInvoiceClient<$Result.GetResult<Prisma.$SuperAdminInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SuperAdminInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminInvoiceCountArgs} args - Arguments to filter SuperAdminInvoices to count.
     * @example
     * // Count the number of SuperAdminInvoices
     * const count = await prisma.superAdminInvoice.count({
     *   where: {
     *     // ... the filter for the SuperAdminInvoices we want to count
     *   }
     * })
    **/
    count<T extends SuperAdminInvoiceCountArgs>(
      args?: Subset<T, SuperAdminInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuperAdminInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuperAdminInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuperAdminInvoiceAggregateArgs>(args: Subset<T, SuperAdminInvoiceAggregateArgs>): Prisma.PrismaPromise<GetSuperAdminInvoiceAggregateType<T>>

    /**
     * Group by SuperAdminInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuperAdminInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuperAdminInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: SuperAdminInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuperAdminInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuperAdminInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SuperAdminInvoice model
   */
  readonly fields: SuperAdminInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuperAdminInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuperAdminInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    superAdmin<T extends SuperAdminProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdminProfileDefaultArgs<ExtArgs>>): Prisma__SuperAdminProfileClient<$Result.GetResult<Prisma.$SuperAdminProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends SuperAdminInvoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdminInvoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SuperAdminInvoice model
   */
  interface SuperAdminInvoiceFieldRefs {
    readonly id: FieldRef<"SuperAdminInvoice", 'String'>
    readonly invoiceNumber: FieldRef<"SuperAdminInvoice", 'String'>
    readonly status: FieldRef<"SuperAdminInvoice", 'String'>
    readonly issueDate: FieldRef<"SuperAdminInvoice", 'DateTime'>
    readonly dueDate: FieldRef<"SuperAdminInvoice", 'DateTime'>
    readonly paidAt: FieldRef<"SuperAdminInvoice", 'DateTime'>
    readonly subtotal: FieldRef<"SuperAdminInvoice", 'Float'>
    readonly taxRate: FieldRef<"SuperAdminInvoice", 'Float'>
    readonly taxAmount: FieldRef<"SuperAdminInvoice", 'Float'>
    readonly totalAmount: FieldRef<"SuperAdminInvoice", 'Float'>
    readonly paidAmount: FieldRef<"SuperAdminInvoice", 'Float'>
    readonly superAdminId: FieldRef<"SuperAdminInvoice", 'String'>
    readonly notes: FieldRef<"SuperAdminInvoice", 'String'>
    readonly createdAt: FieldRef<"SuperAdminInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"SuperAdminInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SuperAdminInvoice findUnique
   */
  export type SuperAdminInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoice
     */
    select?: SuperAdminInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoice
     */
    omit?: SuperAdminInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminInvoice to fetch.
     */
    where: SuperAdminInvoiceWhereUniqueInput
  }

  /**
   * SuperAdminInvoice findUniqueOrThrow
   */
  export type SuperAdminInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoice
     */
    select?: SuperAdminInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoice
     */
    omit?: SuperAdminInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminInvoice to fetch.
     */
    where: SuperAdminInvoiceWhereUniqueInput
  }

  /**
   * SuperAdminInvoice findFirst
   */
  export type SuperAdminInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoice
     */
    select?: SuperAdminInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoice
     */
    omit?: SuperAdminInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminInvoice to fetch.
     */
    where?: SuperAdminInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdminInvoices to fetch.
     */
    orderBy?: SuperAdminInvoiceOrderByWithRelationInput | SuperAdminInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdminInvoices.
     */
    cursor?: SuperAdminInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdminInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdminInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdminInvoices.
     */
    distinct?: SuperAdminInvoiceScalarFieldEnum | SuperAdminInvoiceScalarFieldEnum[]
  }

  /**
   * SuperAdminInvoice findFirstOrThrow
   */
  export type SuperAdminInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoice
     */
    select?: SuperAdminInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoice
     */
    omit?: SuperAdminInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminInvoice to fetch.
     */
    where?: SuperAdminInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdminInvoices to fetch.
     */
    orderBy?: SuperAdminInvoiceOrderByWithRelationInput | SuperAdminInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdminInvoices.
     */
    cursor?: SuperAdminInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdminInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdminInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdminInvoices.
     */
    distinct?: SuperAdminInvoiceScalarFieldEnum | SuperAdminInvoiceScalarFieldEnum[]
  }

  /**
   * SuperAdminInvoice findMany
   */
  export type SuperAdminInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoice
     */
    select?: SuperAdminInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoice
     */
    omit?: SuperAdminInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminInvoices to fetch.
     */
    where?: SuperAdminInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdminInvoices to fetch.
     */
    orderBy?: SuperAdminInvoiceOrderByWithRelationInput | SuperAdminInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuperAdminInvoices.
     */
    cursor?: SuperAdminInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdminInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdminInvoices.
     */
    skip?: number
    distinct?: SuperAdminInvoiceScalarFieldEnum | SuperAdminInvoiceScalarFieldEnum[]
  }

  /**
   * SuperAdminInvoice create
   */
  export type SuperAdminInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoice
     */
    select?: SuperAdminInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoice
     */
    omit?: SuperAdminInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a SuperAdminInvoice.
     */
    data: XOR<SuperAdminInvoiceCreateInput, SuperAdminInvoiceUncheckedCreateInput>
  }

  /**
   * SuperAdminInvoice createMany
   */
  export type SuperAdminInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SuperAdminInvoices.
     */
    data: SuperAdminInvoiceCreateManyInput | SuperAdminInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuperAdminInvoice createManyAndReturn
   */
  export type SuperAdminInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoice
     */
    select?: SuperAdminInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoice
     */
    omit?: SuperAdminInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many SuperAdminInvoices.
     */
    data: SuperAdminInvoiceCreateManyInput | SuperAdminInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SuperAdminInvoice update
   */
  export type SuperAdminInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoice
     */
    select?: SuperAdminInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoice
     */
    omit?: SuperAdminInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a SuperAdminInvoice.
     */
    data: XOR<SuperAdminInvoiceUpdateInput, SuperAdminInvoiceUncheckedUpdateInput>
    /**
     * Choose, which SuperAdminInvoice to update.
     */
    where: SuperAdminInvoiceWhereUniqueInput
  }

  /**
   * SuperAdminInvoice updateMany
   */
  export type SuperAdminInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SuperAdminInvoices.
     */
    data: XOR<SuperAdminInvoiceUpdateManyMutationInput, SuperAdminInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdminInvoices to update
     */
    where?: SuperAdminInvoiceWhereInput
    /**
     * Limit how many SuperAdminInvoices to update.
     */
    limit?: number
  }

  /**
   * SuperAdminInvoice updateManyAndReturn
   */
  export type SuperAdminInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoice
     */
    select?: SuperAdminInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoice
     */
    omit?: SuperAdminInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update SuperAdminInvoices.
     */
    data: XOR<SuperAdminInvoiceUpdateManyMutationInput, SuperAdminInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdminInvoices to update
     */
    where?: SuperAdminInvoiceWhereInput
    /**
     * Limit how many SuperAdminInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SuperAdminInvoice upsert
   */
  export type SuperAdminInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoice
     */
    select?: SuperAdminInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoice
     */
    omit?: SuperAdminInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the SuperAdminInvoice to update in case it exists.
     */
    where: SuperAdminInvoiceWhereUniqueInput
    /**
     * In case the SuperAdminInvoice found by the `where` argument doesn't exist, create a new SuperAdminInvoice with this data.
     */
    create: XOR<SuperAdminInvoiceCreateInput, SuperAdminInvoiceUncheckedCreateInput>
    /**
     * In case the SuperAdminInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuperAdminInvoiceUpdateInput, SuperAdminInvoiceUncheckedUpdateInput>
  }

  /**
   * SuperAdminInvoice delete
   */
  export type SuperAdminInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoice
     */
    select?: SuperAdminInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoice
     */
    omit?: SuperAdminInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceInclude<ExtArgs> | null
    /**
     * Filter which SuperAdminInvoice to delete.
     */
    where: SuperAdminInvoiceWhereUniqueInput
  }

  /**
   * SuperAdminInvoice deleteMany
   */
  export type SuperAdminInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdminInvoices to delete
     */
    where?: SuperAdminInvoiceWhereInput
    /**
     * Limit how many SuperAdminInvoices to delete.
     */
    limit?: number
  }

  /**
   * SuperAdminInvoice.items
   */
  export type SuperAdminInvoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoiceItem
     */
    select?: SuperAdminInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoiceItem
     */
    omit?: SuperAdminInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceItemInclude<ExtArgs> | null
    where?: SuperAdminInvoiceItemWhereInput
    orderBy?: SuperAdminInvoiceItemOrderByWithRelationInput | SuperAdminInvoiceItemOrderByWithRelationInput[]
    cursor?: SuperAdminInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SuperAdminInvoiceItemScalarFieldEnum | SuperAdminInvoiceItemScalarFieldEnum[]
  }

  /**
   * SuperAdminInvoice without action
   */
  export type SuperAdminInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoice
     */
    select?: SuperAdminInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoice
     */
    omit?: SuperAdminInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model SuperAdminInvoiceItem
   */

  export type AggregateSuperAdminInvoiceItem = {
    _count: SuperAdminInvoiceItemCountAggregateOutputType | null
    _avg: SuperAdminInvoiceItemAvgAggregateOutputType | null
    _sum: SuperAdminInvoiceItemSumAggregateOutputType | null
    _min: SuperAdminInvoiceItemMinAggregateOutputType | null
    _max: SuperAdminInvoiceItemMaxAggregateOutputType | null
  }

  export type SuperAdminInvoiceItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type SuperAdminInvoiceItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type SuperAdminInvoiceItemMinAggregateOutputType = {
    id: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    poleType: $Enums.PoleType | null
    invoiceId: string | null
  }

  export type SuperAdminInvoiceItemMaxAggregateOutputType = {
    id: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    poleType: $Enums.PoleType | null
    invoiceId: string | null
  }

  export type SuperAdminInvoiceItemCountAggregateOutputType = {
    id: number
    description: number
    quantity: number
    unitPrice: number
    totalPrice: number
    poleType: number
    invoiceId: number
    _all: number
  }


  export type SuperAdminInvoiceItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type SuperAdminInvoiceItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type SuperAdminInvoiceItemMinAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    poleType?: true
    invoiceId?: true
  }

  export type SuperAdminInvoiceItemMaxAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    poleType?: true
    invoiceId?: true
  }

  export type SuperAdminInvoiceItemCountAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    poleType?: true
    invoiceId?: true
    _all?: true
  }

  export type SuperAdminInvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdminInvoiceItem to aggregate.
     */
    where?: SuperAdminInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdminInvoiceItems to fetch.
     */
    orderBy?: SuperAdminInvoiceItemOrderByWithRelationInput | SuperAdminInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuperAdminInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdminInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdminInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuperAdminInvoiceItems
    **/
    _count?: true | SuperAdminInvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SuperAdminInvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SuperAdminInvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuperAdminInvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuperAdminInvoiceItemMaxAggregateInputType
  }

  export type GetSuperAdminInvoiceItemAggregateType<T extends SuperAdminInvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSuperAdminInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperAdminInvoiceItem[P]>
      : GetScalarType<T[P], AggregateSuperAdminInvoiceItem[P]>
  }




  export type SuperAdminInvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuperAdminInvoiceItemWhereInput
    orderBy?: SuperAdminInvoiceItemOrderByWithAggregationInput | SuperAdminInvoiceItemOrderByWithAggregationInput[]
    by: SuperAdminInvoiceItemScalarFieldEnum[] | SuperAdminInvoiceItemScalarFieldEnum
    having?: SuperAdminInvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuperAdminInvoiceItemCountAggregateInputType | true
    _avg?: SuperAdminInvoiceItemAvgAggregateInputType
    _sum?: SuperAdminInvoiceItemSumAggregateInputType
    _min?: SuperAdminInvoiceItemMinAggregateInputType
    _max?: SuperAdminInvoiceItemMaxAggregateInputType
  }

  export type SuperAdminInvoiceItemGroupByOutputType = {
    id: string
    description: string
    quantity: number
    unitPrice: number
    totalPrice: number
    poleType: $Enums.PoleType | null
    invoiceId: string
    _count: SuperAdminInvoiceItemCountAggregateOutputType | null
    _avg: SuperAdminInvoiceItemAvgAggregateOutputType | null
    _sum: SuperAdminInvoiceItemSumAggregateOutputType | null
    _min: SuperAdminInvoiceItemMinAggregateOutputType | null
    _max: SuperAdminInvoiceItemMaxAggregateOutputType | null
  }

  type GetSuperAdminInvoiceItemGroupByPayload<T extends SuperAdminInvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuperAdminInvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuperAdminInvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuperAdminInvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], SuperAdminInvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type SuperAdminInvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    poleType?: boolean
    invoiceId?: boolean
    invoice?: boolean | SuperAdminInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdminInvoiceItem"]>

  export type SuperAdminInvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    poleType?: boolean
    invoiceId?: boolean
    invoice?: boolean | SuperAdminInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdminInvoiceItem"]>

  export type SuperAdminInvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    poleType?: boolean
    invoiceId?: boolean
    invoice?: boolean | SuperAdminInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdminInvoiceItem"]>

  export type SuperAdminInvoiceItemSelectScalar = {
    id?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    poleType?: boolean
    invoiceId?: boolean
  }

  export type SuperAdminInvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "quantity" | "unitPrice" | "totalPrice" | "poleType" | "invoiceId", ExtArgs["result"]["superAdminInvoiceItem"]>
  export type SuperAdminInvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | SuperAdminInvoiceDefaultArgs<ExtArgs>
  }
  export type SuperAdminInvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | SuperAdminInvoiceDefaultArgs<ExtArgs>
  }
  export type SuperAdminInvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | SuperAdminInvoiceDefaultArgs<ExtArgs>
  }

  export type $SuperAdminInvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SuperAdminInvoiceItem"
    objects: {
      invoice: Prisma.$SuperAdminInvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      quantity: number
      unitPrice: number
      totalPrice: number
      poleType: $Enums.PoleType | null
      invoiceId: string
    }, ExtArgs["result"]["superAdminInvoiceItem"]>
    composites: {}
  }

  type SuperAdminInvoiceItemGetPayload<S extends boolean | null | undefined | SuperAdminInvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$SuperAdminInvoiceItemPayload, S>

  type SuperAdminInvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SuperAdminInvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuperAdminInvoiceItemCountAggregateInputType | true
    }

  export interface SuperAdminInvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SuperAdminInvoiceItem'], meta: { name: 'SuperAdminInvoiceItem' } }
    /**
     * Find zero or one SuperAdminInvoiceItem that matches the filter.
     * @param {SuperAdminInvoiceItemFindUniqueArgs} args - Arguments to find a SuperAdminInvoiceItem
     * @example
     * // Get one SuperAdminInvoiceItem
     * const superAdminInvoiceItem = await prisma.superAdminInvoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuperAdminInvoiceItemFindUniqueArgs>(args: SelectSubset<T, SuperAdminInvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__SuperAdminInvoiceItemClient<$Result.GetResult<Prisma.$SuperAdminInvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SuperAdminInvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SuperAdminInvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a SuperAdminInvoiceItem
     * @example
     * // Get one SuperAdminInvoiceItem
     * const superAdminInvoiceItem = await prisma.superAdminInvoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuperAdminInvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SuperAdminInvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuperAdminInvoiceItemClient<$Result.GetResult<Prisma.$SuperAdminInvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdminInvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminInvoiceItemFindFirstArgs} args - Arguments to find a SuperAdminInvoiceItem
     * @example
     * // Get one SuperAdminInvoiceItem
     * const superAdminInvoiceItem = await prisma.superAdminInvoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuperAdminInvoiceItemFindFirstArgs>(args?: SelectSubset<T, SuperAdminInvoiceItemFindFirstArgs<ExtArgs>>): Prisma__SuperAdminInvoiceItemClient<$Result.GetResult<Prisma.$SuperAdminInvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdminInvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminInvoiceItemFindFirstOrThrowArgs} args - Arguments to find a SuperAdminInvoiceItem
     * @example
     * // Get one SuperAdminInvoiceItem
     * const superAdminInvoiceItem = await prisma.superAdminInvoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuperAdminInvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SuperAdminInvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuperAdminInvoiceItemClient<$Result.GetResult<Prisma.$SuperAdminInvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SuperAdminInvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminInvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuperAdminInvoiceItems
     * const superAdminInvoiceItems = await prisma.superAdminInvoiceItem.findMany()
     * 
     * // Get first 10 SuperAdminInvoiceItems
     * const superAdminInvoiceItems = await prisma.superAdminInvoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const superAdminInvoiceItemWithIdOnly = await prisma.superAdminInvoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuperAdminInvoiceItemFindManyArgs>(args?: SelectSubset<T, SuperAdminInvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SuperAdminInvoiceItem.
     * @param {SuperAdminInvoiceItemCreateArgs} args - Arguments to create a SuperAdminInvoiceItem.
     * @example
     * // Create one SuperAdminInvoiceItem
     * const SuperAdminInvoiceItem = await prisma.superAdminInvoiceItem.create({
     *   data: {
     *     // ... data to create a SuperAdminInvoiceItem
     *   }
     * })
     * 
     */
    create<T extends SuperAdminInvoiceItemCreateArgs>(args: SelectSubset<T, SuperAdminInvoiceItemCreateArgs<ExtArgs>>): Prisma__SuperAdminInvoiceItemClient<$Result.GetResult<Prisma.$SuperAdminInvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SuperAdminInvoiceItems.
     * @param {SuperAdminInvoiceItemCreateManyArgs} args - Arguments to create many SuperAdminInvoiceItems.
     * @example
     * // Create many SuperAdminInvoiceItems
     * const superAdminInvoiceItem = await prisma.superAdminInvoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuperAdminInvoiceItemCreateManyArgs>(args?: SelectSubset<T, SuperAdminInvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SuperAdminInvoiceItems and returns the data saved in the database.
     * @param {SuperAdminInvoiceItemCreateManyAndReturnArgs} args - Arguments to create many SuperAdminInvoiceItems.
     * @example
     * // Create many SuperAdminInvoiceItems
     * const superAdminInvoiceItem = await prisma.superAdminInvoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SuperAdminInvoiceItems and only return the `id`
     * const superAdminInvoiceItemWithIdOnly = await prisma.superAdminInvoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuperAdminInvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SuperAdminInvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminInvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SuperAdminInvoiceItem.
     * @param {SuperAdminInvoiceItemDeleteArgs} args - Arguments to delete one SuperAdminInvoiceItem.
     * @example
     * // Delete one SuperAdminInvoiceItem
     * const SuperAdminInvoiceItem = await prisma.superAdminInvoiceItem.delete({
     *   where: {
     *     // ... filter to delete one SuperAdminInvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends SuperAdminInvoiceItemDeleteArgs>(args: SelectSubset<T, SuperAdminInvoiceItemDeleteArgs<ExtArgs>>): Prisma__SuperAdminInvoiceItemClient<$Result.GetResult<Prisma.$SuperAdminInvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SuperAdminInvoiceItem.
     * @param {SuperAdminInvoiceItemUpdateArgs} args - Arguments to update one SuperAdminInvoiceItem.
     * @example
     * // Update one SuperAdminInvoiceItem
     * const superAdminInvoiceItem = await prisma.superAdminInvoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuperAdminInvoiceItemUpdateArgs>(args: SelectSubset<T, SuperAdminInvoiceItemUpdateArgs<ExtArgs>>): Prisma__SuperAdminInvoiceItemClient<$Result.GetResult<Prisma.$SuperAdminInvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SuperAdminInvoiceItems.
     * @param {SuperAdminInvoiceItemDeleteManyArgs} args - Arguments to filter SuperAdminInvoiceItems to delete.
     * @example
     * // Delete a few SuperAdminInvoiceItems
     * const { count } = await prisma.superAdminInvoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuperAdminInvoiceItemDeleteManyArgs>(args?: SelectSubset<T, SuperAdminInvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdminInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminInvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuperAdminInvoiceItems
     * const superAdminInvoiceItem = await prisma.superAdminInvoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuperAdminInvoiceItemUpdateManyArgs>(args: SelectSubset<T, SuperAdminInvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdminInvoiceItems and returns the data updated in the database.
     * @param {SuperAdminInvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many SuperAdminInvoiceItems.
     * @example
     * // Update many SuperAdminInvoiceItems
     * const superAdminInvoiceItem = await prisma.superAdminInvoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SuperAdminInvoiceItems and only return the `id`
     * const superAdminInvoiceItemWithIdOnly = await prisma.superAdminInvoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SuperAdminInvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, SuperAdminInvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminInvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SuperAdminInvoiceItem.
     * @param {SuperAdminInvoiceItemUpsertArgs} args - Arguments to update or create a SuperAdminInvoiceItem.
     * @example
     * // Update or create a SuperAdminInvoiceItem
     * const superAdminInvoiceItem = await prisma.superAdminInvoiceItem.upsert({
     *   create: {
     *     // ... data to create a SuperAdminInvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuperAdminInvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends SuperAdminInvoiceItemUpsertArgs>(args: SelectSubset<T, SuperAdminInvoiceItemUpsertArgs<ExtArgs>>): Prisma__SuperAdminInvoiceItemClient<$Result.GetResult<Prisma.$SuperAdminInvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SuperAdminInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminInvoiceItemCountArgs} args - Arguments to filter SuperAdminInvoiceItems to count.
     * @example
     * // Count the number of SuperAdminInvoiceItems
     * const count = await prisma.superAdminInvoiceItem.count({
     *   where: {
     *     // ... the filter for the SuperAdminInvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends SuperAdminInvoiceItemCountArgs>(
      args?: Subset<T, SuperAdminInvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuperAdminInvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuperAdminInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminInvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuperAdminInvoiceItemAggregateArgs>(args: Subset<T, SuperAdminInvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetSuperAdminInvoiceItemAggregateType<T>>

    /**
     * Group by SuperAdminInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminInvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuperAdminInvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuperAdminInvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: SuperAdminInvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuperAdminInvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuperAdminInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SuperAdminInvoiceItem model
   */
  readonly fields: SuperAdminInvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuperAdminInvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuperAdminInvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends SuperAdminInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdminInvoiceDefaultArgs<ExtArgs>>): Prisma__SuperAdminInvoiceClient<$Result.GetResult<Prisma.$SuperAdminInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SuperAdminInvoiceItem model
   */
  interface SuperAdminInvoiceItemFieldRefs {
    readonly id: FieldRef<"SuperAdminInvoiceItem", 'String'>
    readonly description: FieldRef<"SuperAdminInvoiceItem", 'String'>
    readonly quantity: FieldRef<"SuperAdminInvoiceItem", 'Float'>
    readonly unitPrice: FieldRef<"SuperAdminInvoiceItem", 'Float'>
    readonly totalPrice: FieldRef<"SuperAdminInvoiceItem", 'Float'>
    readonly poleType: FieldRef<"SuperAdminInvoiceItem", 'PoleType'>
    readonly invoiceId: FieldRef<"SuperAdminInvoiceItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SuperAdminInvoiceItem findUnique
   */
  export type SuperAdminInvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoiceItem
     */
    select?: SuperAdminInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoiceItem
     */
    omit?: SuperAdminInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminInvoiceItem to fetch.
     */
    where: SuperAdminInvoiceItemWhereUniqueInput
  }

  /**
   * SuperAdminInvoiceItem findUniqueOrThrow
   */
  export type SuperAdminInvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoiceItem
     */
    select?: SuperAdminInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoiceItem
     */
    omit?: SuperAdminInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminInvoiceItem to fetch.
     */
    where: SuperAdminInvoiceItemWhereUniqueInput
  }

  /**
   * SuperAdminInvoiceItem findFirst
   */
  export type SuperAdminInvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoiceItem
     */
    select?: SuperAdminInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoiceItem
     */
    omit?: SuperAdminInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminInvoiceItem to fetch.
     */
    where?: SuperAdminInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdminInvoiceItems to fetch.
     */
    orderBy?: SuperAdminInvoiceItemOrderByWithRelationInput | SuperAdminInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdminInvoiceItems.
     */
    cursor?: SuperAdminInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdminInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdminInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdminInvoiceItems.
     */
    distinct?: SuperAdminInvoiceItemScalarFieldEnum | SuperAdminInvoiceItemScalarFieldEnum[]
  }

  /**
   * SuperAdminInvoiceItem findFirstOrThrow
   */
  export type SuperAdminInvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoiceItem
     */
    select?: SuperAdminInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoiceItem
     */
    omit?: SuperAdminInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminInvoiceItem to fetch.
     */
    where?: SuperAdminInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdminInvoiceItems to fetch.
     */
    orderBy?: SuperAdminInvoiceItemOrderByWithRelationInput | SuperAdminInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdminInvoiceItems.
     */
    cursor?: SuperAdminInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdminInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdminInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdminInvoiceItems.
     */
    distinct?: SuperAdminInvoiceItemScalarFieldEnum | SuperAdminInvoiceItemScalarFieldEnum[]
  }

  /**
   * SuperAdminInvoiceItem findMany
   */
  export type SuperAdminInvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoiceItem
     */
    select?: SuperAdminInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoiceItem
     */
    omit?: SuperAdminInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminInvoiceItems to fetch.
     */
    where?: SuperAdminInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdminInvoiceItems to fetch.
     */
    orderBy?: SuperAdminInvoiceItemOrderByWithRelationInput | SuperAdminInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuperAdminInvoiceItems.
     */
    cursor?: SuperAdminInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdminInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdminInvoiceItems.
     */
    skip?: number
    distinct?: SuperAdminInvoiceItemScalarFieldEnum | SuperAdminInvoiceItemScalarFieldEnum[]
  }

  /**
   * SuperAdminInvoiceItem create
   */
  export type SuperAdminInvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoiceItem
     */
    select?: SuperAdminInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoiceItem
     */
    omit?: SuperAdminInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SuperAdminInvoiceItem.
     */
    data: XOR<SuperAdminInvoiceItemCreateInput, SuperAdminInvoiceItemUncheckedCreateInput>
  }

  /**
   * SuperAdminInvoiceItem createMany
   */
  export type SuperAdminInvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SuperAdminInvoiceItems.
     */
    data: SuperAdminInvoiceItemCreateManyInput | SuperAdminInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuperAdminInvoiceItem createManyAndReturn
   */
  export type SuperAdminInvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoiceItem
     */
    select?: SuperAdminInvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoiceItem
     */
    omit?: SuperAdminInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many SuperAdminInvoiceItems.
     */
    data: SuperAdminInvoiceItemCreateManyInput | SuperAdminInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SuperAdminInvoiceItem update
   */
  export type SuperAdminInvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoiceItem
     */
    select?: SuperAdminInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoiceItem
     */
    omit?: SuperAdminInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SuperAdminInvoiceItem.
     */
    data: XOR<SuperAdminInvoiceItemUpdateInput, SuperAdminInvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which SuperAdminInvoiceItem to update.
     */
    where: SuperAdminInvoiceItemWhereUniqueInput
  }

  /**
   * SuperAdminInvoiceItem updateMany
   */
  export type SuperAdminInvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SuperAdminInvoiceItems.
     */
    data: XOR<SuperAdminInvoiceItemUpdateManyMutationInput, SuperAdminInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdminInvoiceItems to update
     */
    where?: SuperAdminInvoiceItemWhereInput
    /**
     * Limit how many SuperAdminInvoiceItems to update.
     */
    limit?: number
  }

  /**
   * SuperAdminInvoiceItem updateManyAndReturn
   */
  export type SuperAdminInvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoiceItem
     */
    select?: SuperAdminInvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoiceItem
     */
    omit?: SuperAdminInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update SuperAdminInvoiceItems.
     */
    data: XOR<SuperAdminInvoiceItemUpdateManyMutationInput, SuperAdminInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdminInvoiceItems to update
     */
    where?: SuperAdminInvoiceItemWhereInput
    /**
     * Limit how many SuperAdminInvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SuperAdminInvoiceItem upsert
   */
  export type SuperAdminInvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoiceItem
     */
    select?: SuperAdminInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoiceItem
     */
    omit?: SuperAdminInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SuperAdminInvoiceItem to update in case it exists.
     */
    where: SuperAdminInvoiceItemWhereUniqueInput
    /**
     * In case the SuperAdminInvoiceItem found by the `where` argument doesn't exist, create a new SuperAdminInvoiceItem with this data.
     */
    create: XOR<SuperAdminInvoiceItemCreateInput, SuperAdminInvoiceItemUncheckedCreateInput>
    /**
     * In case the SuperAdminInvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuperAdminInvoiceItemUpdateInput, SuperAdminInvoiceItemUncheckedUpdateInput>
  }

  /**
   * SuperAdminInvoiceItem delete
   */
  export type SuperAdminInvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoiceItem
     */
    select?: SuperAdminInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoiceItem
     */
    omit?: SuperAdminInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which SuperAdminInvoiceItem to delete.
     */
    where: SuperAdminInvoiceItemWhereUniqueInput
  }

  /**
   * SuperAdminInvoiceItem deleteMany
   */
  export type SuperAdminInvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdminInvoiceItems to delete
     */
    where?: SuperAdminInvoiceItemWhereInput
    /**
     * Limit how many SuperAdminInvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * SuperAdminInvoiceItem without action
   */
  export type SuperAdminInvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminInvoiceItem
     */
    select?: SuperAdminInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdminInvoiceItem
     */
    omit?: SuperAdminInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model LaundryInvoice
   */

  export type AggregateLaundryInvoice = {
    _count: LaundryInvoiceCountAggregateOutputType | null
    _avg: LaundryInvoiceAvgAggregateOutputType | null
    _sum: LaundryInvoiceSumAggregateOutputType | null
    _min: LaundryInvoiceMinAggregateOutputType | null
    _max: LaundryInvoiceMaxAggregateOutputType | null
  }

  export type LaundryInvoiceAvgAggregateOutputType = {
    subtotal: number | null
    taxRate: number | null
    taxAmount: number | null
    totalAmount: number | null
    paidAmount: number | null
  }

  export type LaundryInvoiceSumAggregateOutputType = {
    subtotal: number | null
    taxRate: number | null
    taxAmount: number | null
    totalAmount: number | null
    paidAmount: number | null
  }

  export type LaundryInvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    status: string | null
    issueDate: Date | null
    dueDate: Date | null
    paidAt: Date | null
    subtotal: number | null
    taxRate: number | null
    taxAmount: number | null
    totalAmount: number | null
    paidAmount: number | null
    clientId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryInvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    status: string | null
    issueDate: Date | null
    dueDate: Date | null
    paidAt: Date | null
    subtotal: number | null
    taxRate: number | null
    taxAmount: number | null
    totalAmount: number | null
    paidAmount: number | null
    clientId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryInvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    status: number
    issueDate: number
    dueDate: number
    paidAt: number
    subtotal: number
    taxRate: number
    taxAmount: number
    totalAmount: number
    paidAmount: number
    clientId: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaundryInvoiceAvgAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    totalAmount?: true
    paidAmount?: true
  }

  export type LaundryInvoiceSumAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    totalAmount?: true
    paidAmount?: true
  }

  export type LaundryInvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidAt?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    totalAmount?: true
    paidAmount?: true
    clientId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryInvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidAt?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    totalAmount?: true
    paidAmount?: true
    clientId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryInvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidAt?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    totalAmount?: true
    paidAmount?: true
    clientId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaundryInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaundryInvoice to aggregate.
     */
    where?: LaundryInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryInvoices to fetch.
     */
    orderBy?: LaundryInvoiceOrderByWithRelationInput | LaundryInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaundryInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaundryInvoices
    **/
    _count?: true | LaundryInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaundryInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaundryInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaundryInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaundryInvoiceMaxAggregateInputType
  }

  export type GetLaundryInvoiceAggregateType<T extends LaundryInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateLaundryInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaundryInvoice[P]>
      : GetScalarType<T[P], AggregateLaundryInvoice[P]>
  }




  export type LaundryInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaundryInvoiceWhereInput
    orderBy?: LaundryInvoiceOrderByWithAggregationInput | LaundryInvoiceOrderByWithAggregationInput[]
    by: LaundryInvoiceScalarFieldEnum[] | LaundryInvoiceScalarFieldEnum
    having?: LaundryInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaundryInvoiceCountAggregateInputType | true
    _avg?: LaundryInvoiceAvgAggregateInputType
    _sum?: LaundryInvoiceSumAggregateInputType
    _min?: LaundryInvoiceMinAggregateInputType
    _max?: LaundryInvoiceMaxAggregateInputType
  }

  export type LaundryInvoiceGroupByOutputType = {
    id: string
    invoiceNumber: string
    status: string
    issueDate: Date
    dueDate: Date
    paidAt: Date | null
    subtotal: number
    taxRate: number
    taxAmount: number
    totalAmount: number
    paidAmount: number
    clientId: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: LaundryInvoiceCountAggregateOutputType | null
    _avg: LaundryInvoiceAvgAggregateOutputType | null
    _sum: LaundryInvoiceSumAggregateOutputType | null
    _min: LaundryInvoiceMinAggregateOutputType | null
    _max: LaundryInvoiceMaxAggregateOutputType | null
  }

  type GetLaundryInvoiceGroupByPayload<T extends LaundryInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LaundryInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaundryInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaundryInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], LaundryInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type LaundryInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    clientId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | LaundryClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laundryInvoice"]>

  export type LaundryInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    clientId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | LaundryClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laundryInvoice"]>

  export type LaundryInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    clientId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | LaundryClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laundryInvoice"]>

  export type LaundryInvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    clientId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LaundryInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNumber" | "status" | "issueDate" | "dueDate" | "paidAt" | "subtotal" | "taxRate" | "taxAmount" | "totalAmount" | "paidAmount" | "clientId" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["laundryInvoice"]>
  export type LaundryInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | LaundryClientProfileDefaultArgs<ExtArgs>
  }
  export type LaundryInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | LaundryClientProfileDefaultArgs<ExtArgs>
  }
  export type LaundryInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | LaundryClientProfileDefaultArgs<ExtArgs>
  }

  export type $LaundryInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LaundryInvoice"
    objects: {
      client: Prisma.$LaundryClientProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNumber: string
      status: string
      issueDate: Date
      dueDate: Date
      paidAt: Date | null
      subtotal: number
      taxRate: number
      taxAmount: number
      totalAmount: number
      paidAmount: number
      clientId: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["laundryInvoice"]>
    composites: {}
  }

  type LaundryInvoiceGetPayload<S extends boolean | null | undefined | LaundryInvoiceDefaultArgs> = $Result.GetResult<Prisma.$LaundryInvoicePayload, S>

  type LaundryInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LaundryInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LaundryInvoiceCountAggregateInputType | true
    }

  export interface LaundryInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LaundryInvoice'], meta: { name: 'LaundryInvoice' } }
    /**
     * Find zero or one LaundryInvoice that matches the filter.
     * @param {LaundryInvoiceFindUniqueArgs} args - Arguments to find a LaundryInvoice
     * @example
     * // Get one LaundryInvoice
     * const laundryInvoice = await prisma.laundryInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LaundryInvoiceFindUniqueArgs>(args: SelectSubset<T, LaundryInvoiceFindUniqueArgs<ExtArgs>>): Prisma__LaundryInvoiceClient<$Result.GetResult<Prisma.$LaundryInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LaundryInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LaundryInvoiceFindUniqueOrThrowArgs} args - Arguments to find a LaundryInvoice
     * @example
     * // Get one LaundryInvoice
     * const laundryInvoice = await prisma.laundryInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LaundryInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, LaundryInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LaundryInvoiceClient<$Result.GetResult<Prisma.$LaundryInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LaundryInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryInvoiceFindFirstArgs} args - Arguments to find a LaundryInvoice
     * @example
     * // Get one LaundryInvoice
     * const laundryInvoice = await prisma.laundryInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LaundryInvoiceFindFirstArgs>(args?: SelectSubset<T, LaundryInvoiceFindFirstArgs<ExtArgs>>): Prisma__LaundryInvoiceClient<$Result.GetResult<Prisma.$LaundryInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LaundryInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryInvoiceFindFirstOrThrowArgs} args - Arguments to find a LaundryInvoice
     * @example
     * // Get one LaundryInvoice
     * const laundryInvoice = await prisma.laundryInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LaundryInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, LaundryInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__LaundryInvoiceClient<$Result.GetResult<Prisma.$LaundryInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LaundryInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaundryInvoices
     * const laundryInvoices = await prisma.laundryInvoice.findMany()
     * 
     * // Get first 10 LaundryInvoices
     * const laundryInvoices = await prisma.laundryInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laundryInvoiceWithIdOnly = await prisma.laundryInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LaundryInvoiceFindManyArgs>(args?: SelectSubset<T, LaundryInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LaundryInvoice.
     * @param {LaundryInvoiceCreateArgs} args - Arguments to create a LaundryInvoice.
     * @example
     * // Create one LaundryInvoice
     * const LaundryInvoice = await prisma.laundryInvoice.create({
     *   data: {
     *     // ... data to create a LaundryInvoice
     *   }
     * })
     * 
     */
    create<T extends LaundryInvoiceCreateArgs>(args: SelectSubset<T, LaundryInvoiceCreateArgs<ExtArgs>>): Prisma__LaundryInvoiceClient<$Result.GetResult<Prisma.$LaundryInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LaundryInvoices.
     * @param {LaundryInvoiceCreateManyArgs} args - Arguments to create many LaundryInvoices.
     * @example
     * // Create many LaundryInvoices
     * const laundryInvoice = await prisma.laundryInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LaundryInvoiceCreateManyArgs>(args?: SelectSubset<T, LaundryInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LaundryInvoices and returns the data saved in the database.
     * @param {LaundryInvoiceCreateManyAndReturnArgs} args - Arguments to create many LaundryInvoices.
     * @example
     * // Create many LaundryInvoices
     * const laundryInvoice = await prisma.laundryInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LaundryInvoices and only return the `id`
     * const laundryInvoiceWithIdOnly = await prisma.laundryInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LaundryInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, LaundryInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LaundryInvoice.
     * @param {LaundryInvoiceDeleteArgs} args - Arguments to delete one LaundryInvoice.
     * @example
     * // Delete one LaundryInvoice
     * const LaundryInvoice = await prisma.laundryInvoice.delete({
     *   where: {
     *     // ... filter to delete one LaundryInvoice
     *   }
     * })
     * 
     */
    delete<T extends LaundryInvoiceDeleteArgs>(args: SelectSubset<T, LaundryInvoiceDeleteArgs<ExtArgs>>): Prisma__LaundryInvoiceClient<$Result.GetResult<Prisma.$LaundryInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LaundryInvoice.
     * @param {LaundryInvoiceUpdateArgs} args - Arguments to update one LaundryInvoice.
     * @example
     * // Update one LaundryInvoice
     * const laundryInvoice = await prisma.laundryInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LaundryInvoiceUpdateArgs>(args: SelectSubset<T, LaundryInvoiceUpdateArgs<ExtArgs>>): Prisma__LaundryInvoiceClient<$Result.GetResult<Prisma.$LaundryInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LaundryInvoices.
     * @param {LaundryInvoiceDeleteManyArgs} args - Arguments to filter LaundryInvoices to delete.
     * @example
     * // Delete a few LaundryInvoices
     * const { count } = await prisma.laundryInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LaundryInvoiceDeleteManyArgs>(args?: SelectSubset<T, LaundryInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaundryInvoices
     * const laundryInvoice = await prisma.laundryInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LaundryInvoiceUpdateManyArgs>(args: SelectSubset<T, LaundryInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryInvoices and returns the data updated in the database.
     * @param {LaundryInvoiceUpdateManyAndReturnArgs} args - Arguments to update many LaundryInvoices.
     * @example
     * // Update many LaundryInvoices
     * const laundryInvoice = await prisma.laundryInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LaundryInvoices and only return the `id`
     * const laundryInvoiceWithIdOnly = await prisma.laundryInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LaundryInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, LaundryInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaundryInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LaundryInvoice.
     * @param {LaundryInvoiceUpsertArgs} args - Arguments to update or create a LaundryInvoice.
     * @example
     * // Update or create a LaundryInvoice
     * const laundryInvoice = await prisma.laundryInvoice.upsert({
     *   create: {
     *     // ... data to create a LaundryInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaundryInvoice we want to update
     *   }
     * })
     */
    upsert<T extends LaundryInvoiceUpsertArgs>(args: SelectSubset<T, LaundryInvoiceUpsertArgs<ExtArgs>>): Prisma__LaundryInvoiceClient<$Result.GetResult<Prisma.$LaundryInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LaundryInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryInvoiceCountArgs} args - Arguments to filter LaundryInvoices to count.
     * @example
     * // Count the number of LaundryInvoices
     * const count = await prisma.laundryInvoice.count({
     *   where: {
     *     // ... the filter for the LaundryInvoices we want to count
     *   }
     * })
    **/
    count<T extends LaundryInvoiceCountArgs>(
      args?: Subset<T, LaundryInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaundryInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaundryInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaundryInvoiceAggregateArgs>(args: Subset<T, LaundryInvoiceAggregateArgs>): Prisma.PrismaPromise<GetLaundryInvoiceAggregateType<T>>

    /**
     * Group by LaundryInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaundryInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaundryInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: LaundryInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaundryInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaundryInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LaundryInvoice model
   */
  readonly fields: LaundryInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LaundryInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LaundryInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends LaundryClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LaundryClientProfileDefaultArgs<ExtArgs>>): Prisma__LaundryClientProfileClient<$Result.GetResult<Prisma.$LaundryClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LaundryInvoice model
   */
  interface LaundryInvoiceFieldRefs {
    readonly id: FieldRef<"LaundryInvoice", 'String'>
    readonly invoiceNumber: FieldRef<"LaundryInvoice", 'String'>
    readonly status: FieldRef<"LaundryInvoice", 'String'>
    readonly issueDate: FieldRef<"LaundryInvoice", 'DateTime'>
    readonly dueDate: FieldRef<"LaundryInvoice", 'DateTime'>
    readonly paidAt: FieldRef<"LaundryInvoice", 'DateTime'>
    readonly subtotal: FieldRef<"LaundryInvoice", 'Float'>
    readonly taxRate: FieldRef<"LaundryInvoice", 'Float'>
    readonly taxAmount: FieldRef<"LaundryInvoice", 'Float'>
    readonly totalAmount: FieldRef<"LaundryInvoice", 'Float'>
    readonly paidAmount: FieldRef<"LaundryInvoice", 'Float'>
    readonly clientId: FieldRef<"LaundryInvoice", 'String'>
    readonly notes: FieldRef<"LaundryInvoice", 'String'>
    readonly createdAt: FieldRef<"LaundryInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"LaundryInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LaundryInvoice findUnique
   */
  export type LaundryInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryInvoice
     */
    select?: LaundryInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryInvoice
     */
    omit?: LaundryInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which LaundryInvoice to fetch.
     */
    where: LaundryInvoiceWhereUniqueInput
  }

  /**
   * LaundryInvoice findUniqueOrThrow
   */
  export type LaundryInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryInvoice
     */
    select?: LaundryInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryInvoice
     */
    omit?: LaundryInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which LaundryInvoice to fetch.
     */
    where: LaundryInvoiceWhereUniqueInput
  }

  /**
   * LaundryInvoice findFirst
   */
  export type LaundryInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryInvoice
     */
    select?: LaundryInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryInvoice
     */
    omit?: LaundryInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which LaundryInvoice to fetch.
     */
    where?: LaundryInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryInvoices to fetch.
     */
    orderBy?: LaundryInvoiceOrderByWithRelationInput | LaundryInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryInvoices.
     */
    cursor?: LaundryInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryInvoices.
     */
    distinct?: LaundryInvoiceScalarFieldEnum | LaundryInvoiceScalarFieldEnum[]
  }

  /**
   * LaundryInvoice findFirstOrThrow
   */
  export type LaundryInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryInvoice
     */
    select?: LaundryInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryInvoice
     */
    omit?: LaundryInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which LaundryInvoice to fetch.
     */
    where?: LaundryInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryInvoices to fetch.
     */
    orderBy?: LaundryInvoiceOrderByWithRelationInput | LaundryInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryInvoices.
     */
    cursor?: LaundryInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryInvoices.
     */
    distinct?: LaundryInvoiceScalarFieldEnum | LaundryInvoiceScalarFieldEnum[]
  }

  /**
   * LaundryInvoice findMany
   */
  export type LaundryInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryInvoice
     */
    select?: LaundryInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryInvoice
     */
    omit?: LaundryInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which LaundryInvoices to fetch.
     */
    where?: LaundryInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryInvoices to fetch.
     */
    orderBy?: LaundryInvoiceOrderByWithRelationInput | LaundryInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaundryInvoices.
     */
    cursor?: LaundryInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryInvoices.
     */
    skip?: number
    distinct?: LaundryInvoiceScalarFieldEnum | LaundryInvoiceScalarFieldEnum[]
  }

  /**
   * LaundryInvoice create
   */
  export type LaundryInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryInvoice
     */
    select?: LaundryInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryInvoice
     */
    omit?: LaundryInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a LaundryInvoice.
     */
    data: XOR<LaundryInvoiceCreateInput, LaundryInvoiceUncheckedCreateInput>
  }

  /**
   * LaundryInvoice createMany
   */
  export type LaundryInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LaundryInvoices.
     */
    data: LaundryInvoiceCreateManyInput | LaundryInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LaundryInvoice createManyAndReturn
   */
  export type LaundryInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryInvoice
     */
    select?: LaundryInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryInvoice
     */
    omit?: LaundryInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many LaundryInvoices.
     */
    data: LaundryInvoiceCreateManyInput | LaundryInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LaundryInvoice update
   */
  export type LaundryInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryInvoice
     */
    select?: LaundryInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryInvoice
     */
    omit?: LaundryInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a LaundryInvoice.
     */
    data: XOR<LaundryInvoiceUpdateInput, LaundryInvoiceUncheckedUpdateInput>
    /**
     * Choose, which LaundryInvoice to update.
     */
    where: LaundryInvoiceWhereUniqueInput
  }

  /**
   * LaundryInvoice updateMany
   */
  export type LaundryInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LaundryInvoices.
     */
    data: XOR<LaundryInvoiceUpdateManyMutationInput, LaundryInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which LaundryInvoices to update
     */
    where?: LaundryInvoiceWhereInput
    /**
     * Limit how many LaundryInvoices to update.
     */
    limit?: number
  }

  /**
   * LaundryInvoice updateManyAndReturn
   */
  export type LaundryInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryInvoice
     */
    select?: LaundryInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryInvoice
     */
    omit?: LaundryInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update LaundryInvoices.
     */
    data: XOR<LaundryInvoiceUpdateManyMutationInput, LaundryInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which LaundryInvoices to update
     */
    where?: LaundryInvoiceWhereInput
    /**
     * Limit how many LaundryInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LaundryInvoice upsert
   */
  export type LaundryInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryInvoice
     */
    select?: LaundryInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryInvoice
     */
    omit?: LaundryInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the LaundryInvoice to update in case it exists.
     */
    where: LaundryInvoiceWhereUniqueInput
    /**
     * In case the LaundryInvoice found by the `where` argument doesn't exist, create a new LaundryInvoice with this data.
     */
    create: XOR<LaundryInvoiceCreateInput, LaundryInvoiceUncheckedCreateInput>
    /**
     * In case the LaundryInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaundryInvoiceUpdateInput, LaundryInvoiceUncheckedUpdateInput>
  }

  /**
   * LaundryInvoice delete
   */
  export type LaundryInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryInvoice
     */
    select?: LaundryInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryInvoice
     */
    omit?: LaundryInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryInvoiceInclude<ExtArgs> | null
    /**
     * Filter which LaundryInvoice to delete.
     */
    where: LaundryInvoiceWhereUniqueInput
  }

  /**
   * LaundryInvoice deleteMany
   */
  export type LaundryInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaundryInvoices to delete
     */
    where?: LaundryInvoiceWhereInput
    /**
     * Limit how many LaundryInvoices to delete.
     */
    limit?: number
  }

  /**
   * LaundryInvoice without action
   */
  export type LaundryInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaundryInvoice
     */
    select?: LaundryInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaundryInvoice
     */
    omit?: LaundryInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaundryInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    priority: string | null
    read: boolean | null
    userId: string | null
    relatedType: string | null
    relatedId: string | null
    actionUrl: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    priority: string | null
    read: boolean | null
    userId: string | null
    relatedType: string | null
    relatedId: string | null
    actionUrl: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    message: number
    type: number
    priority: number
    read: number
    userId: number
    relatedType: number
    relatedId: number
    actionUrl: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    priority?: true
    read?: true
    userId?: true
    relatedType?: true
    relatedId?: true
    actionUrl?: true
    expiresAt?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    priority?: true
    read?: true
    userId?: true
    relatedType?: true
    relatedId?: true
    actionUrl?: true
    expiresAt?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    priority?: true
    read?: true
    userId?: true
    relatedType?: true
    relatedId?: true
    actionUrl?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string
    message: string
    type: $Enums.NotificationType
    priority: string | null
    read: boolean
    userId: string
    relatedType: string | null
    relatedId: string | null
    actionUrl: string | null
    expiresAt: Date | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    read?: boolean
    userId?: boolean
    relatedType?: boolean
    relatedId?: boolean
    actionUrl?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    read?: boolean
    userId?: boolean
    relatedType?: boolean
    relatedId?: boolean
    actionUrl?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    read?: boolean
    userId?: boolean
    relatedType?: boolean
    relatedId?: boolean
    actionUrl?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    read?: boolean
    userId?: boolean
    relatedType?: boolean
    relatedId?: boolean
    actionUrl?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "message" | "type" | "priority" | "read" | "userId" | "relatedType" | "relatedId" | "actionUrl" | "expiresAt" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      message: string
      type: $Enums.NotificationType
      priority: string | null
      read: boolean
      userId: string
      relatedType: string | null
      relatedId: string | null
      actionUrl: string | null
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly priority: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly relatedType: FieldRef<"Notification", 'String'>
    readonly relatedId: FieldRef<"Notification", 'String'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly expiresAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date | null
    updatedAt: Date | null
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    avatar: 'avatar',
    role: 'role',
    status: 'status',
    language: 'language',
    timezone: 'timezone',
    emailVerified: 'emailVerified',
    phoneVerified: 'phoneVerified',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SuperAdminProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyName: 'companyName',
    businessNumber: 'businessNumber',
    vatNumber: 'vatNumber',
    billingAddress: 'billingAddress',
    billingCity: 'billingCity',
    billingCountry: 'billingCountry',
    billingPostal: 'billingPostal',
    subscriptionTier: 'subscriptionTier',
    subscriptionStatus: 'subscriptionStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SuperAdminProfileScalarFieldEnum = (typeof SuperAdminProfileScalarFieldEnum)[keyof typeof SuperAdminProfileScalarFieldEnum]


  export const PoleSubscriptionScalarFieldEnum: {
    id: 'id',
    poleType: 'poleType',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    trialEndDate: 'trialEndDate',
    monthlyPrice: 'monthlyPrice',
    lastBillingDate: 'lastBillingDate',
    nextBillingDate: 'nextBillingDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    superAdminId: 'superAdminId'
  };

  export type PoleSubscriptionScalarFieldEnum = (typeof PoleSubscriptionScalarFieldEnum)[keyof typeof PoleSubscriptionScalarFieldEnum]


  export const PoleManagerProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    poleTypes: 'poleTypes',
    canViewAnalytics: 'canViewAnalytics',
    canManageAgents: 'canManageAgents',
    canManageClients: 'canManageClients',
    canManageBilling: 'canManageBilling',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    superAdminId: 'superAdminId'
  };

  export type PoleManagerProfileScalarFieldEnum = (typeof PoleManagerProfileScalarFieldEnum)[keyof typeof PoleManagerProfileScalarFieldEnum]


  export const PropertyOwnerProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    company: 'company',
    taxNumber: 'taxNumber',
    address: 'address',
    city: 'city',
    country: 'country',
    postal: 'postal',
    preferredContactMethod: 'preferredContactMethod',
    receiveNotifications: 'receiveNotifications',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyOwnerProfileScalarFieldEnum = (typeof PropertyOwnerProfileScalarFieldEnum)[keyof typeof PropertyOwnerProfileScalarFieldEnum]


  export const LaundryClientProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyName: 'companyName',
    contactPerson: 'contactPerson',
    defaultPickupAddress: 'defaultPickupAddress',
    defaultDeliveryAddress: 'defaultDeliveryAddress',
    preferredPickupTime: 'preferredPickupTime',
    specialInstructions: 'specialInstructions',
    creditLimit: 'creditLimit',
    paymentTerms: 'paymentTerms',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaundryClientProfileScalarFieldEnum = (typeof LaundryClientProfileScalarFieldEnum)[keyof typeof LaundryClientProfileScalarFieldEnum]


  export const AgentProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    agentType: 'agentType',
    availability: 'availability',
    employeeId: 'employeeId',
    certifications: 'certifications',
    currentLocation: 'currentLocation',
    serviceZones: 'serviceZones',
    rating: 'rating',
    completedTasks: 'completedTasks',
    averageRating: 'averageRating',
    responseTime: 'responseTime',
    workingHours: 'workingHours',
    availabilityCalendar: 'availabilityCalendar',
    hourlyRate: 'hourlyRate',
    isActive: 'isActive',
    hireDate: 'hireDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    managerId: 'managerId'
  };

  export type AgentProfileScalarFieldEnum = (typeof AgentProfileScalarFieldEnum)[keyof typeof AgentProfileScalarFieldEnum]


  export const AgentSpecialtyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    level: 'level',
    certified: 'certified',
    agentId: 'agentId'
  };

  export type AgentSpecialtyScalarFieldEnum = (typeof AgentSpecialtyScalarFieldEnum)[keyof typeof AgentSpecialtyScalarFieldEnum]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    address: 'address',
    city: 'city',
    country: 'country',
    postalCode: 'postalCode',
    latitude: 'latitude',
    longitude: 'longitude',
    surface: 'surface',
    numberOfRooms: 'numberOfRooms',
    numberOfBedrooms: 'numberOfBedrooms',
    numberOfBathrooms: 'numberOfBathrooms',
    maxGuests: 'maxGuests',
    floor: 'floor',
    hasElevator: 'hasElevator',
    hasParking: 'hasParking',
    hasBalcony: 'hasBalcony',
    pricePerNight: 'pricePerNight',
    cleaningFee: 'cleaningFee',
    serviceFee: 'serviceFee',
    securityDeposit: 'securityDeposit',
    averageRating: 'averageRating',
    totalReviews: 'totalReviews',
    checkInTime: 'checkInTime',
    checkOutTime: 'checkOutTime',
    cancellationPolicy: 'cancellationPolicy',
    houseRules: 'houseRules',
    accessInstructions: 'accessInstructions',
    cleaningInstructions: 'cleaningInstructions',
    maintenanceNotes: 'maintenanceNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ownerId: 'ownerId',
    managerId: 'managerId'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const PropertyFeatureScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    category: 'category',
    propertyId: 'propertyId'
  };

  export type PropertyFeatureScalarFieldEnum = (typeof PropertyFeatureScalarFieldEnum)[keyof typeof PropertyFeatureScalarFieldEnum]


  export const PropertyPhotoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    caption: 'caption',
    isMain: 'isMain',
    order: 'order',
    type: 'type',
    propertyId: 'propertyId',
    createdAt: 'createdAt'
  };

  export type PropertyPhotoScalarFieldEnum = (typeof PropertyPhotoScalarFieldEnum)[keyof typeof PropertyPhotoScalarFieldEnum]


  export const PropertyReviewScalarFieldEnum: {
    id: 'id',
    rating: 'rating',
    comment: 'comment',
    guestName: 'guestName',
    guestEmail: 'guestEmail',
    propertyId: 'propertyId',
    createdAt: 'createdAt'
  };

  export type PropertyReviewScalarFieldEnum = (typeof PropertyReviewScalarFieldEnum)[keyof typeof PropertyReviewScalarFieldEnum]


  export const ReservationScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    guestName: 'guestName',
    guestEmail: 'guestEmail',
    guestPhone: 'guestPhone',
    guestCount: 'guestCount',
    checkIn: 'checkIn',
    checkOut: 'checkOut',
    nights: 'nights',
    basePrice: 'basePrice',
    cleaningFee: 'cleaningFee',
    serviceFee: 'serviceFee',
    taxes: 'taxes',
    totalPrice: 'totalPrice',
    status: 'status',
    notes: 'notes',
    confirmationCode: 'confirmationCode',
    bookingSource: 'bookingSource',
    checkInTime: 'checkInTime',
    checkOutTime: 'checkOutTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    managerId: 'managerId'
  };

  export type ReservationScalarFieldEnum = (typeof ReservationScalarFieldEnum)[keyof typeof ReservationScalarFieldEnum]


  export const CleaningSessionScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    agentId: 'agentId',
    scheduledDate: 'scheduledDate',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    cleaningType: 'cleaningType',
    status: 'status',
    notes: 'notes',
    agentNotes: 'agentNotes',
    ownerRating: 'ownerRating',
    managerRating: 'managerRating',
    feedback: 'feedback',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    managerId: 'managerId'
  };

  export type CleaningSessionScalarFieldEnum = (typeof CleaningSessionScalarFieldEnum)[keyof typeof CleaningSessionScalarFieldEnum]


  export const CleaningChecklistScalarFieldEnum: {
    id: 'id',
    item: 'item',
    completed: 'completed',
    notes: 'notes',
    order: 'order',
    cleaningSessionId: 'cleaningSessionId'
  };

  export type CleaningChecklistScalarFieldEnum = (typeof CleaningChecklistScalarFieldEnum)[keyof typeof CleaningChecklistScalarFieldEnum]


  export const CleaningPhotoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    type: 'type',
    caption: 'caption',
    cleaningSessionId: 'cleaningSessionId',
    createdAt: 'createdAt'
  };

  export type CleaningPhotoScalarFieldEnum = (typeof CleaningPhotoScalarFieldEnum)[keyof typeof CleaningPhotoScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    ticketNumber: 'ticketNumber',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    propertyId: 'propertyId',
    reportedBy: 'reportedBy',
    reportedAt: 'reportedAt',
    agentId: 'agentId',
    assignedAt: 'assignedAt',
    category: 'category',
    issueType: 'issueType',
    roomLocation: 'roomLocation',
    resolution: 'resolution',
    resolvedAt: 'resolvedAt',
    estimatedCost: 'estimatedCost',
    estimatedDuration: 'estimatedDuration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    managerId: 'managerId'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const TicketPhotoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    caption: 'caption',
    ticketId: 'ticketId',
    createdAt: 'createdAt'
  };

  export type TicketPhotoScalarFieldEnum = (typeof TicketPhotoScalarFieldEnum)[keyof typeof TicketPhotoScalarFieldEnum]


  export const MaintenanceSessionScalarFieldEnum: {
    id: 'id',
    sessionNumber: 'sessionNumber',
    ticketId: 'ticketId',
    propertyId: 'propertyId',
    agentId: 'agentId',
    scheduledDate: 'scheduledDate',
    startTime: 'startTime',
    endTime: 'endTime',
    estimatedDuration: 'estimatedDuration',
    actualDuration: 'actualDuration',
    status: 'status',
    notes: 'notes',
    workDescription: 'workDescription',
    agentNotes: 'agentNotes',
    laborCost: 'laborCost',
    materialsCost: 'materialsCost',
    totalCost: 'totalCost',
    ownerApproval: 'ownerApproval',
    managerApproval: 'managerApproval',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    managerId: 'managerId'
  };

  export type MaintenanceSessionScalarFieldEnum = (typeof MaintenanceSessionScalarFieldEnum)[keyof typeof MaintenanceSessionScalarFieldEnum]


  export const MaintenanceMaterialScalarFieldEnum: {
    id: 'id',
    name: 'name',
    quantity: 'quantity',
    unit: 'unit',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    supplier: 'supplier',
    maintenanceSessionId: 'maintenanceSessionId'
  };

  export type MaintenanceMaterialScalarFieldEnum = (typeof MaintenanceMaterialScalarFieldEnum)[keyof typeof MaintenanceMaterialScalarFieldEnum]


  export const MaintenancePhotoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    type: 'type',
    caption: 'caption',
    maintenanceSessionId: 'maintenanceSessionId',
    createdAt: 'createdAt'
  };

  export type MaintenancePhotoScalarFieldEnum = (typeof MaintenancePhotoScalarFieldEnum)[keyof typeof MaintenancePhotoScalarFieldEnum]


  export const LaundryProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    stock: 'stock',
    category: 'category',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaundryProductScalarFieldEnum = (typeof LaundryProductScalarFieldEnum)[keyof typeof LaundryProductScalarFieldEnum]


  export const LaundryOrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    status: 'status',
    receivedDate: 'receivedDate',
    processedDate: 'processedDate',
    readyDate: 'readyDate',
    deliveryDate: 'deliveryDate',
    pickupAddress: 'pickupAddress',
    deliveryAddress: 'deliveryAddress',
    instructions: 'instructions',
    subtotal: 'subtotal',
    taxes: 'taxes',
    deliveryFee: 'deliveryFee',
    totalAmount: 'totalAmount',
    notes: 'notes',
    receivedByClient: 'receivedByClient',
    receivedAt: 'receivedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    managerId: 'managerId',
    clientId: 'clientId'
  };

  export type LaundryOrderScalarFieldEnum = (typeof LaundryOrderScalarFieldEnum)[keyof typeof LaundryOrderScalarFieldEnum]


  export const LaundryOrderItemScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    subtotal: 'subtotal',
    notes: 'notes',
    orderId: 'orderId',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaundryOrderItemScalarFieldEnum = (typeof LaundryOrderItemScalarFieldEnum)[keyof typeof LaundryOrderItemScalarFieldEnum]


  export const DeliveryNoteScalarFieldEnum: {
    id: 'id',
    number: 'number',
    date: 'date',
    notes: 'notes',
    orderId: 'orderId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeliveryNoteScalarFieldEnum = (typeof DeliveryNoteScalarFieldEnum)[keyof typeof DeliveryNoteScalarFieldEnum]


  export const TaskAssignmentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    priority: 'priority',
    status: 'status',
    assignedAt: 'assignedAt',
    dueDate: 'dueDate',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    agentId: 'agentId',
    propertyId: 'propertyId',
    reservationId: 'reservationId',
    cleaningSessionId: 'cleaningSessionId',
    maintenanceSessionId: 'maintenanceSessionId',
    ticketId: 'ticketId',
    estimatedDuration: 'estimatedDuration',
    actualDuration: 'actualDuration',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskAssignmentScalarFieldEnum = (typeof TaskAssignmentScalarFieldEnum)[keyof typeof TaskAssignmentScalarFieldEnum]


  export const PropertyContractScalarFieldEnum: {
    id: 'id',
    contractNumber: 'contractNumber',
    type: 'type',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    propertyId: 'propertyId',
    propertyOwnerId: 'propertyOwnerId',
    monthlyFee: 'monthlyFee',
    commissionRate: 'commissionRate',
    documentUrl: 'documentUrl',
    signedAt: 'signedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyContractScalarFieldEnum = (typeof PropertyContractScalarFieldEnum)[keyof typeof PropertyContractScalarFieldEnum]


  export const SuperAdminInvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    status: 'status',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    paidAt: 'paidAt',
    subtotal: 'subtotal',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    totalAmount: 'totalAmount',
    paidAmount: 'paidAmount',
    superAdminId: 'superAdminId',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SuperAdminInvoiceScalarFieldEnum = (typeof SuperAdminInvoiceScalarFieldEnum)[keyof typeof SuperAdminInvoiceScalarFieldEnum]


  export const SuperAdminInvoiceItemScalarFieldEnum: {
    id: 'id',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    poleType: 'poleType',
    invoiceId: 'invoiceId'
  };

  export type SuperAdminInvoiceItemScalarFieldEnum = (typeof SuperAdminInvoiceItemScalarFieldEnum)[keyof typeof SuperAdminInvoiceItemScalarFieldEnum]


  export const LaundryInvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    status: 'status',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    paidAt: 'paidAt',
    subtotal: 'subtotal',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    totalAmount: 'totalAmount',
    paidAmount: 'paidAmount',
    clientId: 'clientId',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaundryInvoiceScalarFieldEnum = (typeof LaundryInvoiceScalarFieldEnum)[keyof typeof LaundryInvoiceScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    type: 'type',
    priority: 'priority',
    read: 'read',
    userId: 'userId',
    relatedType: 'relatedType',
    relatedId: 'relatedId',
    actionUrl: 'actionUrl',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PoleType'
   */
  export type EnumPoleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoleType'>
    


  /**
   * Reference to a field of type 'PoleType[]'
   */
  export type ListEnumPoleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoleType[]'>
    


  /**
   * Reference to a field of type 'PoleStatus'
   */
  export type EnumPoleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoleStatus'>
    


  /**
   * Reference to a field of type 'PoleStatus[]'
   */
  export type ListEnumPoleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoleStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'AgentType'
   */
  export type EnumAgentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentType'>
    


  /**
   * Reference to a field of type 'AgentType[]'
   */
  export type ListEnumAgentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentType[]'>
    


  /**
   * Reference to a field of type 'AgentAvailability'
   */
  export type EnumAgentAvailabilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentAvailability'>
    


  /**
   * Reference to a field of type 'AgentAvailability[]'
   */
  export type ListEnumAgentAvailabilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentAvailability[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'PropertyStatus'
   */
  export type EnumPropertyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyStatus'>
    


  /**
   * Reference to a field of type 'PropertyStatus[]'
   */
  export type ListEnumPropertyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyStatus[]'>
    


  /**
   * Reference to a field of type 'ReservationStatus'
   */
  export type EnumReservationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReservationStatus'>
    


  /**
   * Reference to a field of type 'ReservationStatus[]'
   */
  export type ListEnumReservationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReservationStatus[]'>
    


  /**
   * Reference to a field of type 'SessionStatus'
   */
  export type EnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus'>
    


  /**
   * Reference to a field of type 'SessionStatus[]'
   */
  export type ListEnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus[]'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    


  /**
   * Reference to a field of type 'TicketStatus[]'
   */
  export type ListEnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus[]'>
    


  /**
   * Reference to a field of type 'TicketPriority'
   */
  export type EnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority'>
    


  /**
   * Reference to a field of type 'TicketPriority[]'
   */
  export type ListEnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    language?: StringNullableFilter<"User"> | string | null
    timezone?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    phoneVerified?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    notifications?: NotificationListRelationFilter
    superAdminProfile?: XOR<SuperAdminProfileNullableScalarRelationFilter, SuperAdminProfileWhereInput> | null
    poleManagerProfile?: XOR<PoleManagerProfileNullableScalarRelationFilter, PoleManagerProfileWhereInput> | null
    propertyOwnerProfile?: XOR<PropertyOwnerProfileNullableScalarRelationFilter, PropertyOwnerProfileWhereInput> | null
    laundryClientProfile?: XOR<LaundryClientProfileNullableScalarRelationFilter, LaundryClientProfileWhereInput> | null
    agentProfile?: XOR<AgentProfileNullableScalarRelationFilter, AgentProfileWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    superAdminProfile?: SuperAdminProfileOrderByWithRelationInput
    poleManagerProfile?: PoleManagerProfileOrderByWithRelationInput
    propertyOwnerProfile?: PropertyOwnerProfileOrderByWithRelationInput
    laundryClientProfile?: LaundryClientProfileOrderByWithRelationInput
    agentProfile?: AgentProfileOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    language?: StringNullableFilter<"User"> | string | null
    timezone?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    phoneVerified?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    notifications?: NotificationListRelationFilter
    superAdminProfile?: XOR<SuperAdminProfileNullableScalarRelationFilter, SuperAdminProfileWhereInput> | null
    poleManagerProfile?: XOR<PoleManagerProfileNullableScalarRelationFilter, PoleManagerProfileWhereInput> | null
    propertyOwnerProfile?: XOR<PropertyOwnerProfileNullableScalarRelationFilter, PropertyOwnerProfileWhereInput> | null
    laundryClientProfile?: XOR<LaundryClientProfileNullableScalarRelationFilter, LaundryClientProfileWhereInput> | null
    agentProfile?: XOR<AgentProfileNullableScalarRelationFilter, AgentProfileWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    language?: StringNullableWithAggregatesFilter<"User"> | string | null
    timezone?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    phoneVerified?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type SuperAdminProfileWhereInput = {
    AND?: SuperAdminProfileWhereInput | SuperAdminProfileWhereInput[]
    OR?: SuperAdminProfileWhereInput[]
    NOT?: SuperAdminProfileWhereInput | SuperAdminProfileWhereInput[]
    id?: StringFilter<"SuperAdminProfile"> | string
    userId?: StringFilter<"SuperAdminProfile"> | string
    companyName?: StringFilter<"SuperAdminProfile"> | string
    businessNumber?: StringNullableFilter<"SuperAdminProfile"> | string | null
    vatNumber?: StringNullableFilter<"SuperAdminProfile"> | string | null
    billingAddress?: StringFilter<"SuperAdminProfile"> | string
    billingCity?: StringFilter<"SuperAdminProfile"> | string
    billingCountry?: StringFilter<"SuperAdminProfile"> | string
    billingPostal?: StringFilter<"SuperAdminProfile"> | string
    subscriptionTier?: StringFilter<"SuperAdminProfile"> | string
    subscriptionStatus?: StringFilter<"SuperAdminProfile"> | string
    createdAt?: DateTimeFilter<"SuperAdminProfile"> | Date | string
    updatedAt?: DateTimeFilter<"SuperAdminProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    poleSubscriptions?: PoleSubscriptionListRelationFilter
    poleManagers?: PoleManagerProfileListRelationFilter
    invoices?: SuperAdminInvoiceListRelationFilter
  }

  export type SuperAdminProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    businessNumber?: SortOrderInput | SortOrder
    vatNumber?: SortOrderInput | SortOrder
    billingAddress?: SortOrder
    billingCity?: SortOrder
    billingCountry?: SortOrder
    billingPostal?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    poleSubscriptions?: PoleSubscriptionOrderByRelationAggregateInput
    poleManagers?: PoleManagerProfileOrderByRelationAggregateInput
    invoices?: SuperAdminInvoiceOrderByRelationAggregateInput
  }

  export type SuperAdminProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SuperAdminProfileWhereInput | SuperAdminProfileWhereInput[]
    OR?: SuperAdminProfileWhereInput[]
    NOT?: SuperAdminProfileWhereInput | SuperAdminProfileWhereInput[]
    companyName?: StringFilter<"SuperAdminProfile"> | string
    businessNumber?: StringNullableFilter<"SuperAdminProfile"> | string | null
    vatNumber?: StringNullableFilter<"SuperAdminProfile"> | string | null
    billingAddress?: StringFilter<"SuperAdminProfile"> | string
    billingCity?: StringFilter<"SuperAdminProfile"> | string
    billingCountry?: StringFilter<"SuperAdminProfile"> | string
    billingPostal?: StringFilter<"SuperAdminProfile"> | string
    subscriptionTier?: StringFilter<"SuperAdminProfile"> | string
    subscriptionStatus?: StringFilter<"SuperAdminProfile"> | string
    createdAt?: DateTimeFilter<"SuperAdminProfile"> | Date | string
    updatedAt?: DateTimeFilter<"SuperAdminProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    poleSubscriptions?: PoleSubscriptionListRelationFilter
    poleManagers?: PoleManagerProfileListRelationFilter
    invoices?: SuperAdminInvoiceListRelationFilter
  }, "id" | "userId">

  export type SuperAdminProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    businessNumber?: SortOrderInput | SortOrder
    vatNumber?: SortOrderInput | SortOrder
    billingAddress?: SortOrder
    billingCity?: SortOrder
    billingCountry?: SortOrder
    billingPostal?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SuperAdminProfileCountOrderByAggregateInput
    _max?: SuperAdminProfileMaxOrderByAggregateInput
    _min?: SuperAdminProfileMinOrderByAggregateInput
  }

  export type SuperAdminProfileScalarWhereWithAggregatesInput = {
    AND?: SuperAdminProfileScalarWhereWithAggregatesInput | SuperAdminProfileScalarWhereWithAggregatesInput[]
    OR?: SuperAdminProfileScalarWhereWithAggregatesInput[]
    NOT?: SuperAdminProfileScalarWhereWithAggregatesInput | SuperAdminProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SuperAdminProfile"> | string
    userId?: StringWithAggregatesFilter<"SuperAdminProfile"> | string
    companyName?: StringWithAggregatesFilter<"SuperAdminProfile"> | string
    businessNumber?: StringNullableWithAggregatesFilter<"SuperAdminProfile"> | string | null
    vatNumber?: StringNullableWithAggregatesFilter<"SuperAdminProfile"> | string | null
    billingAddress?: StringWithAggregatesFilter<"SuperAdminProfile"> | string
    billingCity?: StringWithAggregatesFilter<"SuperAdminProfile"> | string
    billingCountry?: StringWithAggregatesFilter<"SuperAdminProfile"> | string
    billingPostal?: StringWithAggregatesFilter<"SuperAdminProfile"> | string
    subscriptionTier?: StringWithAggregatesFilter<"SuperAdminProfile"> | string
    subscriptionStatus?: StringWithAggregatesFilter<"SuperAdminProfile"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SuperAdminProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SuperAdminProfile"> | Date | string
  }

  export type PoleSubscriptionWhereInput = {
    AND?: PoleSubscriptionWhereInput | PoleSubscriptionWhereInput[]
    OR?: PoleSubscriptionWhereInput[]
    NOT?: PoleSubscriptionWhereInput | PoleSubscriptionWhereInput[]
    id?: StringFilter<"PoleSubscription"> | string
    poleType?: EnumPoleTypeFilter<"PoleSubscription"> | $Enums.PoleType
    status?: EnumPoleStatusFilter<"PoleSubscription"> | $Enums.PoleStatus
    startDate?: DateTimeNullableFilter<"PoleSubscription"> | Date | string | null
    endDate?: DateTimeNullableFilter<"PoleSubscription"> | Date | string | null
    trialEndDate?: DateTimeNullableFilter<"PoleSubscription"> | Date | string | null
    monthlyPrice?: FloatFilter<"PoleSubscription"> | number
    lastBillingDate?: DateTimeNullableFilter<"PoleSubscription"> | Date | string | null
    nextBillingDate?: DateTimeNullableFilter<"PoleSubscription"> | Date | string | null
    createdAt?: DateTimeFilter<"PoleSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PoleSubscription"> | Date | string
    superAdminId?: StringFilter<"PoleSubscription"> | string
    superAdmin?: XOR<SuperAdminProfileScalarRelationFilter, SuperAdminProfileWhereInput>
  }

  export type PoleSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    poleType?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    trialEndDate?: SortOrderInput | SortOrder
    monthlyPrice?: SortOrder
    lastBillingDate?: SortOrderInput | SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    superAdminId?: SortOrder
    superAdmin?: SuperAdminProfileOrderByWithRelationInput
  }

  export type PoleSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    superAdminId_poleType?: PoleSubscriptionSuperAdminIdPoleTypeCompoundUniqueInput
    AND?: PoleSubscriptionWhereInput | PoleSubscriptionWhereInput[]
    OR?: PoleSubscriptionWhereInput[]
    NOT?: PoleSubscriptionWhereInput | PoleSubscriptionWhereInput[]
    poleType?: EnumPoleTypeFilter<"PoleSubscription"> | $Enums.PoleType
    status?: EnumPoleStatusFilter<"PoleSubscription"> | $Enums.PoleStatus
    startDate?: DateTimeNullableFilter<"PoleSubscription"> | Date | string | null
    endDate?: DateTimeNullableFilter<"PoleSubscription"> | Date | string | null
    trialEndDate?: DateTimeNullableFilter<"PoleSubscription"> | Date | string | null
    monthlyPrice?: FloatFilter<"PoleSubscription"> | number
    lastBillingDate?: DateTimeNullableFilter<"PoleSubscription"> | Date | string | null
    nextBillingDate?: DateTimeNullableFilter<"PoleSubscription"> | Date | string | null
    createdAt?: DateTimeFilter<"PoleSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PoleSubscription"> | Date | string
    superAdminId?: StringFilter<"PoleSubscription"> | string
    superAdmin?: XOR<SuperAdminProfileScalarRelationFilter, SuperAdminProfileWhereInput>
  }, "id" | "superAdminId_poleType">

  export type PoleSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    poleType?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    trialEndDate?: SortOrderInput | SortOrder
    monthlyPrice?: SortOrder
    lastBillingDate?: SortOrderInput | SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    superAdminId?: SortOrder
    _count?: PoleSubscriptionCountOrderByAggregateInput
    _avg?: PoleSubscriptionAvgOrderByAggregateInput
    _max?: PoleSubscriptionMaxOrderByAggregateInput
    _min?: PoleSubscriptionMinOrderByAggregateInput
    _sum?: PoleSubscriptionSumOrderByAggregateInput
  }

  export type PoleSubscriptionScalarWhereWithAggregatesInput = {
    AND?: PoleSubscriptionScalarWhereWithAggregatesInput | PoleSubscriptionScalarWhereWithAggregatesInput[]
    OR?: PoleSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: PoleSubscriptionScalarWhereWithAggregatesInput | PoleSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PoleSubscription"> | string
    poleType?: EnumPoleTypeWithAggregatesFilter<"PoleSubscription"> | $Enums.PoleType
    status?: EnumPoleStatusWithAggregatesFilter<"PoleSubscription"> | $Enums.PoleStatus
    startDate?: DateTimeNullableWithAggregatesFilter<"PoleSubscription"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"PoleSubscription"> | Date | string | null
    trialEndDate?: DateTimeNullableWithAggregatesFilter<"PoleSubscription"> | Date | string | null
    monthlyPrice?: FloatWithAggregatesFilter<"PoleSubscription"> | number
    lastBillingDate?: DateTimeNullableWithAggregatesFilter<"PoleSubscription"> | Date | string | null
    nextBillingDate?: DateTimeNullableWithAggregatesFilter<"PoleSubscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PoleSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PoleSubscription"> | Date | string
    superAdminId?: StringWithAggregatesFilter<"PoleSubscription"> | string
  }

  export type PoleManagerProfileWhereInput = {
    AND?: PoleManagerProfileWhereInput | PoleManagerProfileWhereInput[]
    OR?: PoleManagerProfileWhereInput[]
    NOT?: PoleManagerProfileWhereInput | PoleManagerProfileWhereInput[]
    id?: StringFilter<"PoleManagerProfile"> | string
    userId?: StringFilter<"PoleManagerProfile"> | string
    poleTypes?: EnumPoleTypeNullableListFilter<"PoleManagerProfile">
    canViewAnalytics?: BoolFilter<"PoleManagerProfile"> | boolean
    canManageAgents?: BoolFilter<"PoleManagerProfile"> | boolean
    canManageClients?: BoolFilter<"PoleManagerProfile"> | boolean
    canManageBilling?: BoolFilter<"PoleManagerProfile"> | boolean
    createdAt?: DateTimeFilter<"PoleManagerProfile"> | Date | string
    updatedAt?: DateTimeFilter<"PoleManagerProfile"> | Date | string
    superAdminId?: StringFilter<"PoleManagerProfile"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    superAdmin?: XOR<SuperAdminProfileScalarRelationFilter, SuperAdminProfileWhereInput>
    properties?: PropertyListRelationFilter
    reservations?: ReservationListRelationFilter
    cleaningSessions?: CleaningSessionListRelationFilter
    tickets?: TicketListRelationFilter
    maintenanceSessions?: MaintenanceSessionListRelationFilter
    laundryOrders?: LaundryOrderListRelationFilter
    managedAgents?: AgentProfileListRelationFilter
  }

  export type PoleManagerProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    poleTypes?: SortOrder
    canViewAnalytics?: SortOrder
    canManageAgents?: SortOrder
    canManageClients?: SortOrder
    canManageBilling?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    superAdminId?: SortOrder
    user?: UserOrderByWithRelationInput
    superAdmin?: SuperAdminProfileOrderByWithRelationInput
    properties?: PropertyOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
    cleaningSessions?: CleaningSessionOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    maintenanceSessions?: MaintenanceSessionOrderByRelationAggregateInput
    laundryOrders?: LaundryOrderOrderByRelationAggregateInput
    managedAgents?: AgentProfileOrderByRelationAggregateInput
  }

  export type PoleManagerProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PoleManagerProfileWhereInput | PoleManagerProfileWhereInput[]
    OR?: PoleManagerProfileWhereInput[]
    NOT?: PoleManagerProfileWhereInput | PoleManagerProfileWhereInput[]
    poleTypes?: EnumPoleTypeNullableListFilter<"PoleManagerProfile">
    canViewAnalytics?: BoolFilter<"PoleManagerProfile"> | boolean
    canManageAgents?: BoolFilter<"PoleManagerProfile"> | boolean
    canManageClients?: BoolFilter<"PoleManagerProfile"> | boolean
    canManageBilling?: BoolFilter<"PoleManagerProfile"> | boolean
    createdAt?: DateTimeFilter<"PoleManagerProfile"> | Date | string
    updatedAt?: DateTimeFilter<"PoleManagerProfile"> | Date | string
    superAdminId?: StringFilter<"PoleManagerProfile"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    superAdmin?: XOR<SuperAdminProfileScalarRelationFilter, SuperAdminProfileWhereInput>
    properties?: PropertyListRelationFilter
    reservations?: ReservationListRelationFilter
    cleaningSessions?: CleaningSessionListRelationFilter
    tickets?: TicketListRelationFilter
    maintenanceSessions?: MaintenanceSessionListRelationFilter
    laundryOrders?: LaundryOrderListRelationFilter
    managedAgents?: AgentProfileListRelationFilter
  }, "id" | "userId">

  export type PoleManagerProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    poleTypes?: SortOrder
    canViewAnalytics?: SortOrder
    canManageAgents?: SortOrder
    canManageClients?: SortOrder
    canManageBilling?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    superAdminId?: SortOrder
    _count?: PoleManagerProfileCountOrderByAggregateInput
    _max?: PoleManagerProfileMaxOrderByAggregateInput
    _min?: PoleManagerProfileMinOrderByAggregateInput
  }

  export type PoleManagerProfileScalarWhereWithAggregatesInput = {
    AND?: PoleManagerProfileScalarWhereWithAggregatesInput | PoleManagerProfileScalarWhereWithAggregatesInput[]
    OR?: PoleManagerProfileScalarWhereWithAggregatesInput[]
    NOT?: PoleManagerProfileScalarWhereWithAggregatesInput | PoleManagerProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PoleManagerProfile"> | string
    userId?: StringWithAggregatesFilter<"PoleManagerProfile"> | string
    poleTypes?: EnumPoleTypeNullableListFilter<"PoleManagerProfile">
    canViewAnalytics?: BoolWithAggregatesFilter<"PoleManagerProfile"> | boolean
    canManageAgents?: BoolWithAggregatesFilter<"PoleManagerProfile"> | boolean
    canManageClients?: BoolWithAggregatesFilter<"PoleManagerProfile"> | boolean
    canManageBilling?: BoolWithAggregatesFilter<"PoleManagerProfile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PoleManagerProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PoleManagerProfile"> | Date | string
    superAdminId?: StringWithAggregatesFilter<"PoleManagerProfile"> | string
  }

  export type PropertyOwnerProfileWhereInput = {
    AND?: PropertyOwnerProfileWhereInput | PropertyOwnerProfileWhereInput[]
    OR?: PropertyOwnerProfileWhereInput[]
    NOT?: PropertyOwnerProfileWhereInput | PropertyOwnerProfileWhereInput[]
    id?: StringFilter<"PropertyOwnerProfile"> | string
    userId?: StringFilter<"PropertyOwnerProfile"> | string
    company?: StringNullableFilter<"PropertyOwnerProfile"> | string | null
    taxNumber?: StringNullableFilter<"PropertyOwnerProfile"> | string | null
    address?: StringNullableFilter<"PropertyOwnerProfile"> | string | null
    city?: StringNullableFilter<"PropertyOwnerProfile"> | string | null
    country?: StringNullableFilter<"PropertyOwnerProfile"> | string | null
    postal?: StringNullableFilter<"PropertyOwnerProfile"> | string | null
    preferredContactMethod?: StringNullableFilter<"PropertyOwnerProfile"> | string | null
    receiveNotifications?: BoolFilter<"PropertyOwnerProfile"> | boolean
    createdAt?: DateTimeFilter<"PropertyOwnerProfile"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyOwnerProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    properties?: PropertyListRelationFilter
    contracts?: PropertyContractListRelationFilter
  }

  export type PropertyOwnerProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrderInput | SortOrder
    taxNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postal?: SortOrderInput | SortOrder
    preferredContactMethod?: SortOrderInput | SortOrder
    receiveNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    properties?: PropertyOrderByRelationAggregateInput
    contracts?: PropertyContractOrderByRelationAggregateInput
  }

  export type PropertyOwnerProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PropertyOwnerProfileWhereInput | PropertyOwnerProfileWhereInput[]
    OR?: PropertyOwnerProfileWhereInput[]
    NOT?: PropertyOwnerProfileWhereInput | PropertyOwnerProfileWhereInput[]
    company?: StringNullableFilter<"PropertyOwnerProfile"> | string | null
    taxNumber?: StringNullableFilter<"PropertyOwnerProfile"> | string | null
    address?: StringNullableFilter<"PropertyOwnerProfile"> | string | null
    city?: StringNullableFilter<"PropertyOwnerProfile"> | string | null
    country?: StringNullableFilter<"PropertyOwnerProfile"> | string | null
    postal?: StringNullableFilter<"PropertyOwnerProfile"> | string | null
    preferredContactMethod?: StringNullableFilter<"PropertyOwnerProfile"> | string | null
    receiveNotifications?: BoolFilter<"PropertyOwnerProfile"> | boolean
    createdAt?: DateTimeFilter<"PropertyOwnerProfile"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyOwnerProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    properties?: PropertyListRelationFilter
    contracts?: PropertyContractListRelationFilter
  }, "id" | "userId">

  export type PropertyOwnerProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrderInput | SortOrder
    taxNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postal?: SortOrderInput | SortOrder
    preferredContactMethod?: SortOrderInput | SortOrder
    receiveNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyOwnerProfileCountOrderByAggregateInput
    _max?: PropertyOwnerProfileMaxOrderByAggregateInput
    _min?: PropertyOwnerProfileMinOrderByAggregateInput
  }

  export type PropertyOwnerProfileScalarWhereWithAggregatesInput = {
    AND?: PropertyOwnerProfileScalarWhereWithAggregatesInput | PropertyOwnerProfileScalarWhereWithAggregatesInput[]
    OR?: PropertyOwnerProfileScalarWhereWithAggregatesInput[]
    NOT?: PropertyOwnerProfileScalarWhereWithAggregatesInput | PropertyOwnerProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyOwnerProfile"> | string
    userId?: StringWithAggregatesFilter<"PropertyOwnerProfile"> | string
    company?: StringNullableWithAggregatesFilter<"PropertyOwnerProfile"> | string | null
    taxNumber?: StringNullableWithAggregatesFilter<"PropertyOwnerProfile"> | string | null
    address?: StringNullableWithAggregatesFilter<"PropertyOwnerProfile"> | string | null
    city?: StringNullableWithAggregatesFilter<"PropertyOwnerProfile"> | string | null
    country?: StringNullableWithAggregatesFilter<"PropertyOwnerProfile"> | string | null
    postal?: StringNullableWithAggregatesFilter<"PropertyOwnerProfile"> | string | null
    preferredContactMethod?: StringNullableWithAggregatesFilter<"PropertyOwnerProfile"> | string | null
    receiveNotifications?: BoolWithAggregatesFilter<"PropertyOwnerProfile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PropertyOwnerProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyOwnerProfile"> | Date | string
  }

  export type LaundryClientProfileWhereInput = {
    AND?: LaundryClientProfileWhereInput | LaundryClientProfileWhereInput[]
    OR?: LaundryClientProfileWhereInput[]
    NOT?: LaundryClientProfileWhereInput | LaundryClientProfileWhereInput[]
    id?: StringFilter<"LaundryClientProfile"> | string
    userId?: StringFilter<"LaundryClientProfile"> | string
    companyName?: StringNullableFilter<"LaundryClientProfile"> | string | null
    contactPerson?: StringNullableFilter<"LaundryClientProfile"> | string | null
    defaultPickupAddress?: StringNullableFilter<"LaundryClientProfile"> | string | null
    defaultDeliveryAddress?: StringFilter<"LaundryClientProfile"> | string
    preferredPickupTime?: StringNullableFilter<"LaundryClientProfile"> | string | null
    specialInstructions?: StringNullableFilter<"LaundryClientProfile"> | string | null
    creditLimit?: FloatNullableFilter<"LaundryClientProfile"> | number | null
    paymentTerms?: IntNullableFilter<"LaundryClientProfile"> | number | null
    createdAt?: DateTimeFilter<"LaundryClientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LaundryClientProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    laundryOrders?: LaundryOrderListRelationFilter
    laundryInvoices?: LaundryInvoiceListRelationFilter
  }

  export type LaundryClientProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    defaultPickupAddress?: SortOrderInput | SortOrder
    defaultDeliveryAddress?: SortOrder
    preferredPickupTime?: SortOrderInput | SortOrder
    specialInstructions?: SortOrderInput | SortOrder
    creditLimit?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    laundryOrders?: LaundryOrderOrderByRelationAggregateInput
    laundryInvoices?: LaundryInvoiceOrderByRelationAggregateInput
  }

  export type LaundryClientProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: LaundryClientProfileWhereInput | LaundryClientProfileWhereInput[]
    OR?: LaundryClientProfileWhereInput[]
    NOT?: LaundryClientProfileWhereInput | LaundryClientProfileWhereInput[]
    companyName?: StringNullableFilter<"LaundryClientProfile"> | string | null
    contactPerson?: StringNullableFilter<"LaundryClientProfile"> | string | null
    defaultPickupAddress?: StringNullableFilter<"LaundryClientProfile"> | string | null
    defaultDeliveryAddress?: StringFilter<"LaundryClientProfile"> | string
    preferredPickupTime?: StringNullableFilter<"LaundryClientProfile"> | string | null
    specialInstructions?: StringNullableFilter<"LaundryClientProfile"> | string | null
    creditLimit?: FloatNullableFilter<"LaundryClientProfile"> | number | null
    paymentTerms?: IntNullableFilter<"LaundryClientProfile"> | number | null
    createdAt?: DateTimeFilter<"LaundryClientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LaundryClientProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    laundryOrders?: LaundryOrderListRelationFilter
    laundryInvoices?: LaundryInvoiceListRelationFilter
  }, "id" | "userId">

  export type LaundryClientProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    defaultPickupAddress?: SortOrderInput | SortOrder
    defaultDeliveryAddress?: SortOrder
    preferredPickupTime?: SortOrderInput | SortOrder
    specialInstructions?: SortOrderInput | SortOrder
    creditLimit?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaundryClientProfileCountOrderByAggregateInput
    _avg?: LaundryClientProfileAvgOrderByAggregateInput
    _max?: LaundryClientProfileMaxOrderByAggregateInput
    _min?: LaundryClientProfileMinOrderByAggregateInput
    _sum?: LaundryClientProfileSumOrderByAggregateInput
  }

  export type LaundryClientProfileScalarWhereWithAggregatesInput = {
    AND?: LaundryClientProfileScalarWhereWithAggregatesInput | LaundryClientProfileScalarWhereWithAggregatesInput[]
    OR?: LaundryClientProfileScalarWhereWithAggregatesInput[]
    NOT?: LaundryClientProfileScalarWhereWithAggregatesInput | LaundryClientProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LaundryClientProfile"> | string
    userId?: StringWithAggregatesFilter<"LaundryClientProfile"> | string
    companyName?: StringNullableWithAggregatesFilter<"LaundryClientProfile"> | string | null
    contactPerson?: StringNullableWithAggregatesFilter<"LaundryClientProfile"> | string | null
    defaultPickupAddress?: StringNullableWithAggregatesFilter<"LaundryClientProfile"> | string | null
    defaultDeliveryAddress?: StringWithAggregatesFilter<"LaundryClientProfile"> | string
    preferredPickupTime?: StringNullableWithAggregatesFilter<"LaundryClientProfile"> | string | null
    specialInstructions?: StringNullableWithAggregatesFilter<"LaundryClientProfile"> | string | null
    creditLimit?: FloatNullableWithAggregatesFilter<"LaundryClientProfile"> | number | null
    paymentTerms?: IntNullableWithAggregatesFilter<"LaundryClientProfile"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"LaundryClientProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LaundryClientProfile"> | Date | string
  }

  export type AgentProfileWhereInput = {
    AND?: AgentProfileWhereInput | AgentProfileWhereInput[]
    OR?: AgentProfileWhereInput[]
    NOT?: AgentProfileWhereInput | AgentProfileWhereInput[]
    id?: StringFilter<"AgentProfile"> | string
    userId?: StringFilter<"AgentProfile"> | string
    agentType?: EnumAgentTypeFilter<"AgentProfile"> | $Enums.AgentType
    availability?: EnumAgentAvailabilityFilter<"AgentProfile"> | $Enums.AgentAvailability
    employeeId?: StringNullableFilter<"AgentProfile"> | string | null
    certifications?: StringNullableListFilter<"AgentProfile">
    currentLocation?: JsonNullableFilter<"AgentProfile">
    serviceZones?: StringNullableListFilter<"AgentProfile">
    rating?: FloatNullableFilter<"AgentProfile"> | number | null
    completedTasks?: IntFilter<"AgentProfile"> | number
    averageRating?: FloatNullableFilter<"AgentProfile"> | number | null
    responseTime?: IntNullableFilter<"AgentProfile"> | number | null
    workingHours?: JsonNullableFilter<"AgentProfile">
    availabilityCalendar?: JsonNullableFilter<"AgentProfile">
    hourlyRate?: FloatNullableFilter<"AgentProfile"> | number | null
    isActive?: BoolFilter<"AgentProfile"> | boolean
    hireDate?: DateTimeNullableFilter<"AgentProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"AgentProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AgentProfile"> | Date | string
    managerId?: StringFilter<"AgentProfile"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    specialties?: AgentSpecialtyListRelationFilter
    manager?: XOR<PoleManagerProfileScalarRelationFilter, PoleManagerProfileWhereInput>
    cleaningSessions?: CleaningSessionListRelationFilter
    maintenanceSessions?: MaintenanceSessionListRelationFilter
    tickets?: TicketListRelationFilter
    taskAssignments?: TaskAssignmentListRelationFilter
  }

  export type AgentProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    agentType?: SortOrder
    availability?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    certifications?: SortOrder
    currentLocation?: SortOrderInput | SortOrder
    serviceZones?: SortOrder
    rating?: SortOrderInput | SortOrder
    completedTasks?: SortOrder
    averageRating?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    workingHours?: SortOrderInput | SortOrder
    availabilityCalendar?: SortOrderInput | SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    hireDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    user?: UserOrderByWithRelationInput
    specialties?: AgentSpecialtyOrderByRelationAggregateInput
    manager?: PoleManagerProfileOrderByWithRelationInput
    cleaningSessions?: CleaningSessionOrderByRelationAggregateInput
    maintenanceSessions?: MaintenanceSessionOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    taskAssignments?: TaskAssignmentOrderByRelationAggregateInput
  }

  export type AgentProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    employeeId?: string
    AND?: AgentProfileWhereInput | AgentProfileWhereInput[]
    OR?: AgentProfileWhereInput[]
    NOT?: AgentProfileWhereInput | AgentProfileWhereInput[]
    agentType?: EnumAgentTypeFilter<"AgentProfile"> | $Enums.AgentType
    availability?: EnumAgentAvailabilityFilter<"AgentProfile"> | $Enums.AgentAvailability
    certifications?: StringNullableListFilter<"AgentProfile">
    currentLocation?: JsonNullableFilter<"AgentProfile">
    serviceZones?: StringNullableListFilter<"AgentProfile">
    rating?: FloatNullableFilter<"AgentProfile"> | number | null
    completedTasks?: IntFilter<"AgentProfile"> | number
    averageRating?: FloatNullableFilter<"AgentProfile"> | number | null
    responseTime?: IntNullableFilter<"AgentProfile"> | number | null
    workingHours?: JsonNullableFilter<"AgentProfile">
    availabilityCalendar?: JsonNullableFilter<"AgentProfile">
    hourlyRate?: FloatNullableFilter<"AgentProfile"> | number | null
    isActive?: BoolFilter<"AgentProfile"> | boolean
    hireDate?: DateTimeNullableFilter<"AgentProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"AgentProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AgentProfile"> | Date | string
    managerId?: StringFilter<"AgentProfile"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    specialties?: AgentSpecialtyListRelationFilter
    manager?: XOR<PoleManagerProfileScalarRelationFilter, PoleManagerProfileWhereInput>
    cleaningSessions?: CleaningSessionListRelationFilter
    maintenanceSessions?: MaintenanceSessionListRelationFilter
    tickets?: TicketListRelationFilter
    taskAssignments?: TaskAssignmentListRelationFilter
  }, "id" | "userId" | "employeeId">

  export type AgentProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    agentType?: SortOrder
    availability?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    certifications?: SortOrder
    currentLocation?: SortOrderInput | SortOrder
    serviceZones?: SortOrder
    rating?: SortOrderInput | SortOrder
    completedTasks?: SortOrder
    averageRating?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    workingHours?: SortOrderInput | SortOrder
    availabilityCalendar?: SortOrderInput | SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    hireDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    _count?: AgentProfileCountOrderByAggregateInput
    _avg?: AgentProfileAvgOrderByAggregateInput
    _max?: AgentProfileMaxOrderByAggregateInput
    _min?: AgentProfileMinOrderByAggregateInput
    _sum?: AgentProfileSumOrderByAggregateInput
  }

  export type AgentProfileScalarWhereWithAggregatesInput = {
    AND?: AgentProfileScalarWhereWithAggregatesInput | AgentProfileScalarWhereWithAggregatesInput[]
    OR?: AgentProfileScalarWhereWithAggregatesInput[]
    NOT?: AgentProfileScalarWhereWithAggregatesInput | AgentProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentProfile"> | string
    userId?: StringWithAggregatesFilter<"AgentProfile"> | string
    agentType?: EnumAgentTypeWithAggregatesFilter<"AgentProfile"> | $Enums.AgentType
    availability?: EnumAgentAvailabilityWithAggregatesFilter<"AgentProfile"> | $Enums.AgentAvailability
    employeeId?: StringNullableWithAggregatesFilter<"AgentProfile"> | string | null
    certifications?: StringNullableListFilter<"AgentProfile">
    currentLocation?: JsonNullableWithAggregatesFilter<"AgentProfile">
    serviceZones?: StringNullableListFilter<"AgentProfile">
    rating?: FloatNullableWithAggregatesFilter<"AgentProfile"> | number | null
    completedTasks?: IntWithAggregatesFilter<"AgentProfile"> | number
    averageRating?: FloatNullableWithAggregatesFilter<"AgentProfile"> | number | null
    responseTime?: IntNullableWithAggregatesFilter<"AgentProfile"> | number | null
    workingHours?: JsonNullableWithAggregatesFilter<"AgentProfile">
    availabilityCalendar?: JsonNullableWithAggregatesFilter<"AgentProfile">
    hourlyRate?: FloatNullableWithAggregatesFilter<"AgentProfile"> | number | null
    isActive?: BoolWithAggregatesFilter<"AgentProfile"> | boolean
    hireDate?: DateTimeNullableWithAggregatesFilter<"AgentProfile"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AgentProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentProfile"> | Date | string
    managerId?: StringWithAggregatesFilter<"AgentProfile"> | string
  }

  export type AgentSpecialtyWhereInput = {
    AND?: AgentSpecialtyWhereInput | AgentSpecialtyWhereInput[]
    OR?: AgentSpecialtyWhereInput[]
    NOT?: AgentSpecialtyWhereInput | AgentSpecialtyWhereInput[]
    id?: StringFilter<"AgentSpecialty"> | string
    name?: StringFilter<"AgentSpecialty"> | string
    category?: StringNullableFilter<"AgentSpecialty"> | string | null
    level?: StringNullableFilter<"AgentSpecialty"> | string | null
    certified?: BoolFilter<"AgentSpecialty"> | boolean
    agentId?: StringFilter<"AgentSpecialty"> | string
    agent?: XOR<AgentProfileScalarRelationFilter, AgentProfileWhereInput>
  }

  export type AgentSpecialtyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    certified?: SortOrder
    agentId?: SortOrder
    agent?: AgentProfileOrderByWithRelationInput
  }

  export type AgentSpecialtyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentSpecialtyWhereInput | AgentSpecialtyWhereInput[]
    OR?: AgentSpecialtyWhereInput[]
    NOT?: AgentSpecialtyWhereInput | AgentSpecialtyWhereInput[]
    name?: StringFilter<"AgentSpecialty"> | string
    category?: StringNullableFilter<"AgentSpecialty"> | string | null
    level?: StringNullableFilter<"AgentSpecialty"> | string | null
    certified?: BoolFilter<"AgentSpecialty"> | boolean
    agentId?: StringFilter<"AgentSpecialty"> | string
    agent?: XOR<AgentProfileScalarRelationFilter, AgentProfileWhereInput>
  }, "id">

  export type AgentSpecialtyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    certified?: SortOrder
    agentId?: SortOrder
    _count?: AgentSpecialtyCountOrderByAggregateInput
    _max?: AgentSpecialtyMaxOrderByAggregateInput
    _min?: AgentSpecialtyMinOrderByAggregateInput
  }

  export type AgentSpecialtyScalarWhereWithAggregatesInput = {
    AND?: AgentSpecialtyScalarWhereWithAggregatesInput | AgentSpecialtyScalarWhereWithAggregatesInput[]
    OR?: AgentSpecialtyScalarWhereWithAggregatesInput[]
    NOT?: AgentSpecialtyScalarWhereWithAggregatesInput | AgentSpecialtyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentSpecialty"> | string
    name?: StringWithAggregatesFilter<"AgentSpecialty"> | string
    category?: StringNullableWithAggregatesFilter<"AgentSpecialty"> | string | null
    level?: StringNullableWithAggregatesFilter<"AgentSpecialty"> | string | null
    certified?: BoolWithAggregatesFilter<"AgentSpecialty"> | boolean
    agentId?: StringWithAggregatesFilter<"AgentSpecialty"> | string
  }

  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: StringFilter<"Property"> | string
    name?: StringFilter<"Property"> | string
    description?: StringFilter<"Property"> | string
    status?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    address?: StringFilter<"Property"> | string
    city?: StringFilter<"Property"> | string
    country?: StringFilter<"Property"> | string
    postalCode?: StringNullableFilter<"Property"> | string | null
    latitude?: FloatNullableFilter<"Property"> | number | null
    longitude?: FloatNullableFilter<"Property"> | number | null
    surface?: FloatNullableFilter<"Property"> | number | null
    numberOfRooms?: IntNullableFilter<"Property"> | number | null
    numberOfBedrooms?: IntNullableFilter<"Property"> | number | null
    numberOfBathrooms?: IntNullableFilter<"Property"> | number | null
    maxGuests?: IntNullableFilter<"Property"> | number | null
    floor?: IntNullableFilter<"Property"> | number | null
    hasElevator?: BoolNullableFilter<"Property"> | boolean | null
    hasParking?: BoolNullableFilter<"Property"> | boolean | null
    hasBalcony?: BoolNullableFilter<"Property"> | boolean | null
    pricePerNight?: FloatNullableFilter<"Property"> | number | null
    cleaningFee?: FloatNullableFilter<"Property"> | number | null
    serviceFee?: FloatNullableFilter<"Property"> | number | null
    securityDeposit?: FloatNullableFilter<"Property"> | number | null
    averageRating?: FloatNullableFilter<"Property"> | number | null
    totalReviews?: IntFilter<"Property"> | number
    checkInTime?: StringNullableFilter<"Property"> | string | null
    checkOutTime?: StringNullableFilter<"Property"> | string | null
    cancellationPolicy?: StringNullableFilter<"Property"> | string | null
    houseRules?: StringNullableFilter<"Property"> | string | null
    accessInstructions?: StringNullableFilter<"Property"> | string | null
    cleaningInstructions?: StringNullableFilter<"Property"> | string | null
    maintenanceNotes?: StringNullableFilter<"Property"> | string | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    ownerId?: StringFilter<"Property"> | string
    managerId?: StringNullableFilter<"Property"> | string | null
    features?: PropertyFeatureListRelationFilter
    photos?: PropertyPhotoListRelationFilter
    owner?: XOR<PropertyOwnerProfileScalarRelationFilter, PropertyOwnerProfileWhereInput>
    manager?: XOR<PoleManagerProfileNullableScalarRelationFilter, PoleManagerProfileWhereInput> | null
    reservations?: ReservationListRelationFilter
    cleaningSessions?: CleaningSessionListRelationFilter
    maintenanceSessions?: MaintenanceSessionListRelationFilter
    tickets?: TicketListRelationFilter
    reviews?: PropertyReviewListRelationFilter
    contracts?: PropertyContractListRelationFilter
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    surface?: SortOrderInput | SortOrder
    numberOfRooms?: SortOrderInput | SortOrder
    numberOfBedrooms?: SortOrderInput | SortOrder
    numberOfBathrooms?: SortOrderInput | SortOrder
    maxGuests?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    hasElevator?: SortOrderInput | SortOrder
    hasParking?: SortOrderInput | SortOrder
    hasBalcony?: SortOrderInput | SortOrder
    pricePerNight?: SortOrderInput | SortOrder
    cleaningFee?: SortOrderInput | SortOrder
    serviceFee?: SortOrderInput | SortOrder
    securityDeposit?: SortOrderInput | SortOrder
    averageRating?: SortOrderInput | SortOrder
    totalReviews?: SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    cancellationPolicy?: SortOrderInput | SortOrder
    houseRules?: SortOrderInput | SortOrder
    accessInstructions?: SortOrderInput | SortOrder
    cleaningInstructions?: SortOrderInput | SortOrder
    maintenanceNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    managerId?: SortOrderInput | SortOrder
    features?: PropertyFeatureOrderByRelationAggregateInput
    photos?: PropertyPhotoOrderByRelationAggregateInput
    owner?: PropertyOwnerProfileOrderByWithRelationInput
    manager?: PoleManagerProfileOrderByWithRelationInput
    reservations?: ReservationOrderByRelationAggregateInput
    cleaningSessions?: CleaningSessionOrderByRelationAggregateInput
    maintenanceSessions?: MaintenanceSessionOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    reviews?: PropertyReviewOrderByRelationAggregateInput
    contracts?: PropertyContractOrderByRelationAggregateInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    name?: StringFilter<"Property"> | string
    description?: StringFilter<"Property"> | string
    status?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    address?: StringFilter<"Property"> | string
    city?: StringFilter<"Property"> | string
    country?: StringFilter<"Property"> | string
    postalCode?: StringNullableFilter<"Property"> | string | null
    latitude?: FloatNullableFilter<"Property"> | number | null
    longitude?: FloatNullableFilter<"Property"> | number | null
    surface?: FloatNullableFilter<"Property"> | number | null
    numberOfRooms?: IntNullableFilter<"Property"> | number | null
    numberOfBedrooms?: IntNullableFilter<"Property"> | number | null
    numberOfBathrooms?: IntNullableFilter<"Property"> | number | null
    maxGuests?: IntNullableFilter<"Property"> | number | null
    floor?: IntNullableFilter<"Property"> | number | null
    hasElevator?: BoolNullableFilter<"Property"> | boolean | null
    hasParking?: BoolNullableFilter<"Property"> | boolean | null
    hasBalcony?: BoolNullableFilter<"Property"> | boolean | null
    pricePerNight?: FloatNullableFilter<"Property"> | number | null
    cleaningFee?: FloatNullableFilter<"Property"> | number | null
    serviceFee?: FloatNullableFilter<"Property"> | number | null
    securityDeposit?: FloatNullableFilter<"Property"> | number | null
    averageRating?: FloatNullableFilter<"Property"> | number | null
    totalReviews?: IntFilter<"Property"> | number
    checkInTime?: StringNullableFilter<"Property"> | string | null
    checkOutTime?: StringNullableFilter<"Property"> | string | null
    cancellationPolicy?: StringNullableFilter<"Property"> | string | null
    houseRules?: StringNullableFilter<"Property"> | string | null
    accessInstructions?: StringNullableFilter<"Property"> | string | null
    cleaningInstructions?: StringNullableFilter<"Property"> | string | null
    maintenanceNotes?: StringNullableFilter<"Property"> | string | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    ownerId?: StringFilter<"Property"> | string
    managerId?: StringNullableFilter<"Property"> | string | null
    features?: PropertyFeatureListRelationFilter
    photos?: PropertyPhotoListRelationFilter
    owner?: XOR<PropertyOwnerProfileScalarRelationFilter, PropertyOwnerProfileWhereInput>
    manager?: XOR<PoleManagerProfileNullableScalarRelationFilter, PoleManagerProfileWhereInput> | null
    reservations?: ReservationListRelationFilter
    cleaningSessions?: CleaningSessionListRelationFilter
    maintenanceSessions?: MaintenanceSessionListRelationFilter
    tickets?: TicketListRelationFilter
    reviews?: PropertyReviewListRelationFilter
    contracts?: PropertyContractListRelationFilter
  }, "id">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    surface?: SortOrderInput | SortOrder
    numberOfRooms?: SortOrderInput | SortOrder
    numberOfBedrooms?: SortOrderInput | SortOrder
    numberOfBathrooms?: SortOrderInput | SortOrder
    maxGuests?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    hasElevator?: SortOrderInput | SortOrder
    hasParking?: SortOrderInput | SortOrder
    hasBalcony?: SortOrderInput | SortOrder
    pricePerNight?: SortOrderInput | SortOrder
    cleaningFee?: SortOrderInput | SortOrder
    serviceFee?: SortOrderInput | SortOrder
    securityDeposit?: SortOrderInput | SortOrder
    averageRating?: SortOrderInput | SortOrder
    totalReviews?: SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    cancellationPolicy?: SortOrderInput | SortOrder
    houseRules?: SortOrderInput | SortOrder
    accessInstructions?: SortOrderInput | SortOrder
    cleaningInstructions?: SortOrderInput | SortOrder
    maintenanceNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    managerId?: SortOrderInput | SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _avg?: PropertyAvgOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
    _sum?: PropertySumOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Property"> | string
    name?: StringWithAggregatesFilter<"Property"> | string
    description?: StringWithAggregatesFilter<"Property"> | string
    status?: EnumPropertyStatusWithAggregatesFilter<"Property"> | $Enums.PropertyStatus
    address?: StringWithAggregatesFilter<"Property"> | string
    city?: StringWithAggregatesFilter<"Property"> | string
    country?: StringWithAggregatesFilter<"Property"> | string
    postalCode?: StringNullableWithAggregatesFilter<"Property"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    surface?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    numberOfRooms?: IntNullableWithAggregatesFilter<"Property"> | number | null
    numberOfBedrooms?: IntNullableWithAggregatesFilter<"Property"> | number | null
    numberOfBathrooms?: IntNullableWithAggregatesFilter<"Property"> | number | null
    maxGuests?: IntNullableWithAggregatesFilter<"Property"> | number | null
    floor?: IntNullableWithAggregatesFilter<"Property"> | number | null
    hasElevator?: BoolNullableWithAggregatesFilter<"Property"> | boolean | null
    hasParking?: BoolNullableWithAggregatesFilter<"Property"> | boolean | null
    hasBalcony?: BoolNullableWithAggregatesFilter<"Property"> | boolean | null
    pricePerNight?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    cleaningFee?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    serviceFee?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    securityDeposit?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    averageRating?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    totalReviews?: IntWithAggregatesFilter<"Property"> | number
    checkInTime?: StringNullableWithAggregatesFilter<"Property"> | string | null
    checkOutTime?: StringNullableWithAggregatesFilter<"Property"> | string | null
    cancellationPolicy?: StringNullableWithAggregatesFilter<"Property"> | string | null
    houseRules?: StringNullableWithAggregatesFilter<"Property"> | string | null
    accessInstructions?: StringNullableWithAggregatesFilter<"Property"> | string | null
    cleaningInstructions?: StringNullableWithAggregatesFilter<"Property"> | string | null
    maintenanceNotes?: StringNullableWithAggregatesFilter<"Property"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    ownerId?: StringWithAggregatesFilter<"Property"> | string
    managerId?: StringNullableWithAggregatesFilter<"Property"> | string | null
  }

  export type PropertyFeatureWhereInput = {
    AND?: PropertyFeatureWhereInput | PropertyFeatureWhereInput[]
    OR?: PropertyFeatureWhereInput[]
    NOT?: PropertyFeatureWhereInput | PropertyFeatureWhereInput[]
    id?: StringFilter<"PropertyFeature"> | string
    name?: StringFilter<"PropertyFeature"> | string
    icon?: StringNullableFilter<"PropertyFeature"> | string | null
    category?: StringNullableFilter<"PropertyFeature"> | string | null
    propertyId?: StringFilter<"PropertyFeature"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertyFeatureOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyFeatureWhereInput | PropertyFeatureWhereInput[]
    OR?: PropertyFeatureWhereInput[]
    NOT?: PropertyFeatureWhereInput | PropertyFeatureWhereInput[]
    name?: StringFilter<"PropertyFeature"> | string
    icon?: StringNullableFilter<"PropertyFeature"> | string | null
    category?: StringNullableFilter<"PropertyFeature"> | string | null
    propertyId?: StringFilter<"PropertyFeature"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type PropertyFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    _count?: PropertyFeatureCountOrderByAggregateInput
    _max?: PropertyFeatureMaxOrderByAggregateInput
    _min?: PropertyFeatureMinOrderByAggregateInput
  }

  export type PropertyFeatureScalarWhereWithAggregatesInput = {
    AND?: PropertyFeatureScalarWhereWithAggregatesInput | PropertyFeatureScalarWhereWithAggregatesInput[]
    OR?: PropertyFeatureScalarWhereWithAggregatesInput[]
    NOT?: PropertyFeatureScalarWhereWithAggregatesInput | PropertyFeatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyFeature"> | string
    name?: StringWithAggregatesFilter<"PropertyFeature"> | string
    icon?: StringNullableWithAggregatesFilter<"PropertyFeature"> | string | null
    category?: StringNullableWithAggregatesFilter<"PropertyFeature"> | string | null
    propertyId?: StringWithAggregatesFilter<"PropertyFeature"> | string
  }

  export type PropertyPhotoWhereInput = {
    AND?: PropertyPhotoWhereInput | PropertyPhotoWhereInput[]
    OR?: PropertyPhotoWhereInput[]
    NOT?: PropertyPhotoWhereInput | PropertyPhotoWhereInput[]
    id?: StringFilter<"PropertyPhoto"> | string
    url?: StringFilter<"PropertyPhoto"> | string
    caption?: StringNullableFilter<"PropertyPhoto"> | string | null
    isMain?: BoolFilter<"PropertyPhoto"> | boolean
    order?: IntFilter<"PropertyPhoto"> | number
    type?: StringNullableFilter<"PropertyPhoto"> | string | null
    propertyId?: StringFilter<"PropertyPhoto"> | string
    createdAt?: DateTimeFilter<"PropertyPhoto"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertyPhotoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    caption?: SortOrderInput | SortOrder
    isMain?: SortOrder
    order?: SortOrder
    type?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyPhotoWhereInput | PropertyPhotoWhereInput[]
    OR?: PropertyPhotoWhereInput[]
    NOT?: PropertyPhotoWhereInput | PropertyPhotoWhereInput[]
    url?: StringFilter<"PropertyPhoto"> | string
    caption?: StringNullableFilter<"PropertyPhoto"> | string | null
    isMain?: BoolFilter<"PropertyPhoto"> | boolean
    order?: IntFilter<"PropertyPhoto"> | number
    type?: StringNullableFilter<"PropertyPhoto"> | string | null
    propertyId?: StringFilter<"PropertyPhoto"> | string
    createdAt?: DateTimeFilter<"PropertyPhoto"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type PropertyPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    caption?: SortOrderInput | SortOrder
    isMain?: SortOrder
    order?: SortOrder
    type?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    _count?: PropertyPhotoCountOrderByAggregateInput
    _avg?: PropertyPhotoAvgOrderByAggregateInput
    _max?: PropertyPhotoMaxOrderByAggregateInput
    _min?: PropertyPhotoMinOrderByAggregateInput
    _sum?: PropertyPhotoSumOrderByAggregateInput
  }

  export type PropertyPhotoScalarWhereWithAggregatesInput = {
    AND?: PropertyPhotoScalarWhereWithAggregatesInput | PropertyPhotoScalarWhereWithAggregatesInput[]
    OR?: PropertyPhotoScalarWhereWithAggregatesInput[]
    NOT?: PropertyPhotoScalarWhereWithAggregatesInput | PropertyPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyPhoto"> | string
    url?: StringWithAggregatesFilter<"PropertyPhoto"> | string
    caption?: StringNullableWithAggregatesFilter<"PropertyPhoto"> | string | null
    isMain?: BoolWithAggregatesFilter<"PropertyPhoto"> | boolean
    order?: IntWithAggregatesFilter<"PropertyPhoto"> | number
    type?: StringNullableWithAggregatesFilter<"PropertyPhoto"> | string | null
    propertyId?: StringWithAggregatesFilter<"PropertyPhoto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PropertyPhoto"> | Date | string
  }

  export type PropertyReviewWhereInput = {
    AND?: PropertyReviewWhereInput | PropertyReviewWhereInput[]
    OR?: PropertyReviewWhereInput[]
    NOT?: PropertyReviewWhereInput | PropertyReviewWhereInput[]
    id?: StringFilter<"PropertyReview"> | string
    rating?: FloatFilter<"PropertyReview"> | number
    comment?: StringNullableFilter<"PropertyReview"> | string | null
    guestName?: StringFilter<"PropertyReview"> | string
    guestEmail?: StringNullableFilter<"PropertyReview"> | string | null
    propertyId?: StringFilter<"PropertyReview"> | string
    createdAt?: DateTimeFilter<"PropertyReview"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertyReviewOrderByWithRelationInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyReviewWhereInput | PropertyReviewWhereInput[]
    OR?: PropertyReviewWhereInput[]
    NOT?: PropertyReviewWhereInput | PropertyReviewWhereInput[]
    rating?: FloatFilter<"PropertyReview"> | number
    comment?: StringNullableFilter<"PropertyReview"> | string | null
    guestName?: StringFilter<"PropertyReview"> | string
    guestEmail?: StringNullableFilter<"PropertyReview"> | string | null
    propertyId?: StringFilter<"PropertyReview"> | string
    createdAt?: DateTimeFilter<"PropertyReview"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type PropertyReviewOrderByWithAggregationInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    _count?: PropertyReviewCountOrderByAggregateInput
    _avg?: PropertyReviewAvgOrderByAggregateInput
    _max?: PropertyReviewMaxOrderByAggregateInput
    _min?: PropertyReviewMinOrderByAggregateInput
    _sum?: PropertyReviewSumOrderByAggregateInput
  }

  export type PropertyReviewScalarWhereWithAggregatesInput = {
    AND?: PropertyReviewScalarWhereWithAggregatesInput | PropertyReviewScalarWhereWithAggregatesInput[]
    OR?: PropertyReviewScalarWhereWithAggregatesInput[]
    NOT?: PropertyReviewScalarWhereWithAggregatesInput | PropertyReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyReview"> | string
    rating?: FloatWithAggregatesFilter<"PropertyReview"> | number
    comment?: StringNullableWithAggregatesFilter<"PropertyReview"> | string | null
    guestName?: StringWithAggregatesFilter<"PropertyReview"> | string
    guestEmail?: StringNullableWithAggregatesFilter<"PropertyReview"> | string | null
    propertyId?: StringWithAggregatesFilter<"PropertyReview"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PropertyReview"> | Date | string
  }

  export type ReservationWhereInput = {
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    id?: StringFilter<"Reservation"> | string
    propertyId?: StringFilter<"Reservation"> | string
    guestName?: StringFilter<"Reservation"> | string
    guestEmail?: StringFilter<"Reservation"> | string
    guestPhone?: StringNullableFilter<"Reservation"> | string | null
    guestCount?: IntFilter<"Reservation"> | number
    checkIn?: DateTimeFilter<"Reservation"> | Date | string
    checkOut?: DateTimeFilter<"Reservation"> | Date | string
    nights?: IntFilter<"Reservation"> | number
    basePrice?: FloatFilter<"Reservation"> | number
    cleaningFee?: FloatNullableFilter<"Reservation"> | number | null
    serviceFee?: FloatNullableFilter<"Reservation"> | number | null
    taxes?: FloatNullableFilter<"Reservation"> | number | null
    totalPrice?: FloatFilter<"Reservation"> | number
    status?: EnumReservationStatusFilter<"Reservation"> | $Enums.ReservationStatus
    notes?: StringNullableFilter<"Reservation"> | string | null
    confirmationCode?: StringNullableFilter<"Reservation"> | string | null
    bookingSource?: StringNullableFilter<"Reservation"> | string | null
    checkInTime?: DateTimeNullableFilter<"Reservation"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"Reservation"> | Date | string | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
    managerId?: StringFilter<"Reservation"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    manager?: XOR<PoleManagerProfileScalarRelationFilter, PoleManagerProfileWhereInput>
  }

  export type ReservationOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrderInput | SortOrder
    guestCount?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    nights?: SortOrder
    basePrice?: SortOrder
    cleaningFee?: SortOrderInput | SortOrder
    serviceFee?: SortOrderInput | SortOrder
    taxes?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    confirmationCode?: SortOrderInput | SortOrder
    bookingSource?: SortOrderInput | SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    property?: PropertyOrderByWithRelationInput
    manager?: PoleManagerProfileOrderByWithRelationInput
  }

  export type ReservationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    confirmationCode?: string
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    propertyId?: StringFilter<"Reservation"> | string
    guestName?: StringFilter<"Reservation"> | string
    guestEmail?: StringFilter<"Reservation"> | string
    guestPhone?: StringNullableFilter<"Reservation"> | string | null
    guestCount?: IntFilter<"Reservation"> | number
    checkIn?: DateTimeFilter<"Reservation"> | Date | string
    checkOut?: DateTimeFilter<"Reservation"> | Date | string
    nights?: IntFilter<"Reservation"> | number
    basePrice?: FloatFilter<"Reservation"> | number
    cleaningFee?: FloatNullableFilter<"Reservation"> | number | null
    serviceFee?: FloatNullableFilter<"Reservation"> | number | null
    taxes?: FloatNullableFilter<"Reservation"> | number | null
    totalPrice?: FloatFilter<"Reservation"> | number
    status?: EnumReservationStatusFilter<"Reservation"> | $Enums.ReservationStatus
    notes?: StringNullableFilter<"Reservation"> | string | null
    bookingSource?: StringNullableFilter<"Reservation"> | string | null
    checkInTime?: DateTimeNullableFilter<"Reservation"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"Reservation"> | Date | string | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
    managerId?: StringFilter<"Reservation"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    manager?: XOR<PoleManagerProfileScalarRelationFilter, PoleManagerProfileWhereInput>
  }, "id" | "confirmationCode">

  export type ReservationOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrderInput | SortOrder
    guestCount?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    nights?: SortOrder
    basePrice?: SortOrder
    cleaningFee?: SortOrderInput | SortOrder
    serviceFee?: SortOrderInput | SortOrder
    taxes?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    confirmationCode?: SortOrderInput | SortOrder
    bookingSource?: SortOrderInput | SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    _count?: ReservationCountOrderByAggregateInput
    _avg?: ReservationAvgOrderByAggregateInput
    _max?: ReservationMaxOrderByAggregateInput
    _min?: ReservationMinOrderByAggregateInput
    _sum?: ReservationSumOrderByAggregateInput
  }

  export type ReservationScalarWhereWithAggregatesInput = {
    AND?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    OR?: ReservationScalarWhereWithAggregatesInput[]
    NOT?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reservation"> | string
    propertyId?: StringWithAggregatesFilter<"Reservation"> | string
    guestName?: StringWithAggregatesFilter<"Reservation"> | string
    guestEmail?: StringWithAggregatesFilter<"Reservation"> | string
    guestPhone?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    guestCount?: IntWithAggregatesFilter<"Reservation"> | number
    checkIn?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    checkOut?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    nights?: IntWithAggregatesFilter<"Reservation"> | number
    basePrice?: FloatWithAggregatesFilter<"Reservation"> | number
    cleaningFee?: FloatNullableWithAggregatesFilter<"Reservation"> | number | null
    serviceFee?: FloatNullableWithAggregatesFilter<"Reservation"> | number | null
    taxes?: FloatNullableWithAggregatesFilter<"Reservation"> | number | null
    totalPrice?: FloatWithAggregatesFilter<"Reservation"> | number
    status?: EnumReservationStatusWithAggregatesFilter<"Reservation"> | $Enums.ReservationStatus
    notes?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    confirmationCode?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    bookingSource?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    checkInTime?: DateTimeNullableWithAggregatesFilter<"Reservation"> | Date | string | null
    checkOutTime?: DateTimeNullableWithAggregatesFilter<"Reservation"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    managerId?: StringWithAggregatesFilter<"Reservation"> | string
  }

  export type CleaningSessionWhereInput = {
    AND?: CleaningSessionWhereInput | CleaningSessionWhereInput[]
    OR?: CleaningSessionWhereInput[]
    NOT?: CleaningSessionWhereInput | CleaningSessionWhereInput[]
    id?: StringFilter<"CleaningSession"> | string
    propertyId?: StringFilter<"CleaningSession"> | string
    agentId?: StringFilter<"CleaningSession"> | string
    scheduledDate?: DateTimeFilter<"CleaningSession"> | Date | string
    startTime?: DateTimeNullableFilter<"CleaningSession"> | Date | string | null
    endTime?: DateTimeNullableFilter<"CleaningSession"> | Date | string | null
    duration?: IntNullableFilter<"CleaningSession"> | number | null
    cleaningType?: StringFilter<"CleaningSession"> | string
    status?: EnumSessionStatusFilter<"CleaningSession"> | $Enums.SessionStatus
    notes?: StringNullableFilter<"CleaningSession"> | string | null
    agentNotes?: StringNullableFilter<"CleaningSession"> | string | null
    ownerRating?: FloatNullableFilter<"CleaningSession"> | number | null
    managerRating?: FloatNullableFilter<"CleaningSession"> | number | null
    feedback?: StringNullableFilter<"CleaningSession"> | string | null
    createdAt?: DateTimeFilter<"CleaningSession"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningSession"> | Date | string
    managerId?: StringFilter<"CleaningSession"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    agent?: XOR<AgentProfileScalarRelationFilter, AgentProfileWhereInput>
    checklist?: CleaningChecklistListRelationFilter
    photos?: CleaningPhotoListRelationFilter
    manager?: XOR<PoleManagerProfileScalarRelationFilter, PoleManagerProfileWhereInput>
  }

  export type CleaningSessionOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    agentId?: SortOrder
    scheduledDate?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    cleaningType?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    agentNotes?: SortOrderInput | SortOrder
    ownerRating?: SortOrderInput | SortOrder
    managerRating?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    property?: PropertyOrderByWithRelationInput
    agent?: AgentProfileOrderByWithRelationInput
    checklist?: CleaningChecklistOrderByRelationAggregateInput
    photos?: CleaningPhotoOrderByRelationAggregateInput
    manager?: PoleManagerProfileOrderByWithRelationInput
  }

  export type CleaningSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CleaningSessionWhereInput | CleaningSessionWhereInput[]
    OR?: CleaningSessionWhereInput[]
    NOT?: CleaningSessionWhereInput | CleaningSessionWhereInput[]
    propertyId?: StringFilter<"CleaningSession"> | string
    agentId?: StringFilter<"CleaningSession"> | string
    scheduledDate?: DateTimeFilter<"CleaningSession"> | Date | string
    startTime?: DateTimeNullableFilter<"CleaningSession"> | Date | string | null
    endTime?: DateTimeNullableFilter<"CleaningSession"> | Date | string | null
    duration?: IntNullableFilter<"CleaningSession"> | number | null
    cleaningType?: StringFilter<"CleaningSession"> | string
    status?: EnumSessionStatusFilter<"CleaningSession"> | $Enums.SessionStatus
    notes?: StringNullableFilter<"CleaningSession"> | string | null
    agentNotes?: StringNullableFilter<"CleaningSession"> | string | null
    ownerRating?: FloatNullableFilter<"CleaningSession"> | number | null
    managerRating?: FloatNullableFilter<"CleaningSession"> | number | null
    feedback?: StringNullableFilter<"CleaningSession"> | string | null
    createdAt?: DateTimeFilter<"CleaningSession"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningSession"> | Date | string
    managerId?: StringFilter<"CleaningSession"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    agent?: XOR<AgentProfileScalarRelationFilter, AgentProfileWhereInput>
    checklist?: CleaningChecklistListRelationFilter
    photos?: CleaningPhotoListRelationFilter
    manager?: XOR<PoleManagerProfileScalarRelationFilter, PoleManagerProfileWhereInput>
  }, "id">

  export type CleaningSessionOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    agentId?: SortOrder
    scheduledDate?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    cleaningType?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    agentNotes?: SortOrderInput | SortOrder
    ownerRating?: SortOrderInput | SortOrder
    managerRating?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    _count?: CleaningSessionCountOrderByAggregateInput
    _avg?: CleaningSessionAvgOrderByAggregateInput
    _max?: CleaningSessionMaxOrderByAggregateInput
    _min?: CleaningSessionMinOrderByAggregateInput
    _sum?: CleaningSessionSumOrderByAggregateInput
  }

  export type CleaningSessionScalarWhereWithAggregatesInput = {
    AND?: CleaningSessionScalarWhereWithAggregatesInput | CleaningSessionScalarWhereWithAggregatesInput[]
    OR?: CleaningSessionScalarWhereWithAggregatesInput[]
    NOT?: CleaningSessionScalarWhereWithAggregatesInput | CleaningSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CleaningSession"> | string
    propertyId?: StringWithAggregatesFilter<"CleaningSession"> | string
    agentId?: StringWithAggregatesFilter<"CleaningSession"> | string
    scheduledDate?: DateTimeWithAggregatesFilter<"CleaningSession"> | Date | string
    startTime?: DateTimeNullableWithAggregatesFilter<"CleaningSession"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"CleaningSession"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"CleaningSession"> | number | null
    cleaningType?: StringWithAggregatesFilter<"CleaningSession"> | string
    status?: EnumSessionStatusWithAggregatesFilter<"CleaningSession"> | $Enums.SessionStatus
    notes?: StringNullableWithAggregatesFilter<"CleaningSession"> | string | null
    agentNotes?: StringNullableWithAggregatesFilter<"CleaningSession"> | string | null
    ownerRating?: FloatNullableWithAggregatesFilter<"CleaningSession"> | number | null
    managerRating?: FloatNullableWithAggregatesFilter<"CleaningSession"> | number | null
    feedback?: StringNullableWithAggregatesFilter<"CleaningSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CleaningSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CleaningSession"> | Date | string
    managerId?: StringWithAggregatesFilter<"CleaningSession"> | string
  }

  export type CleaningChecklistWhereInput = {
    AND?: CleaningChecklistWhereInput | CleaningChecklistWhereInput[]
    OR?: CleaningChecklistWhereInput[]
    NOT?: CleaningChecklistWhereInput | CleaningChecklistWhereInput[]
    id?: StringFilter<"CleaningChecklist"> | string
    item?: StringFilter<"CleaningChecklist"> | string
    completed?: BoolFilter<"CleaningChecklist"> | boolean
    notes?: StringNullableFilter<"CleaningChecklist"> | string | null
    order?: IntFilter<"CleaningChecklist"> | number
    cleaningSessionId?: StringFilter<"CleaningChecklist"> | string
    cleaningSession?: XOR<CleaningSessionScalarRelationFilter, CleaningSessionWhereInput>
  }

  export type CleaningChecklistOrderByWithRelationInput = {
    id?: SortOrder
    item?: SortOrder
    completed?: SortOrder
    notes?: SortOrderInput | SortOrder
    order?: SortOrder
    cleaningSessionId?: SortOrder
    cleaningSession?: CleaningSessionOrderByWithRelationInput
  }

  export type CleaningChecklistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CleaningChecklistWhereInput | CleaningChecklistWhereInput[]
    OR?: CleaningChecklistWhereInput[]
    NOT?: CleaningChecklistWhereInput | CleaningChecklistWhereInput[]
    item?: StringFilter<"CleaningChecklist"> | string
    completed?: BoolFilter<"CleaningChecklist"> | boolean
    notes?: StringNullableFilter<"CleaningChecklist"> | string | null
    order?: IntFilter<"CleaningChecklist"> | number
    cleaningSessionId?: StringFilter<"CleaningChecklist"> | string
    cleaningSession?: XOR<CleaningSessionScalarRelationFilter, CleaningSessionWhereInput>
  }, "id">

  export type CleaningChecklistOrderByWithAggregationInput = {
    id?: SortOrder
    item?: SortOrder
    completed?: SortOrder
    notes?: SortOrderInput | SortOrder
    order?: SortOrder
    cleaningSessionId?: SortOrder
    _count?: CleaningChecklistCountOrderByAggregateInput
    _avg?: CleaningChecklistAvgOrderByAggregateInput
    _max?: CleaningChecklistMaxOrderByAggregateInput
    _min?: CleaningChecklistMinOrderByAggregateInput
    _sum?: CleaningChecklistSumOrderByAggregateInput
  }

  export type CleaningChecklistScalarWhereWithAggregatesInput = {
    AND?: CleaningChecklistScalarWhereWithAggregatesInput | CleaningChecklistScalarWhereWithAggregatesInput[]
    OR?: CleaningChecklistScalarWhereWithAggregatesInput[]
    NOT?: CleaningChecklistScalarWhereWithAggregatesInput | CleaningChecklistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CleaningChecklist"> | string
    item?: StringWithAggregatesFilter<"CleaningChecklist"> | string
    completed?: BoolWithAggregatesFilter<"CleaningChecklist"> | boolean
    notes?: StringNullableWithAggregatesFilter<"CleaningChecklist"> | string | null
    order?: IntWithAggregatesFilter<"CleaningChecklist"> | number
    cleaningSessionId?: StringWithAggregatesFilter<"CleaningChecklist"> | string
  }

  export type CleaningPhotoWhereInput = {
    AND?: CleaningPhotoWhereInput | CleaningPhotoWhereInput[]
    OR?: CleaningPhotoWhereInput[]
    NOT?: CleaningPhotoWhereInput | CleaningPhotoWhereInput[]
    id?: StringFilter<"CleaningPhoto"> | string
    url?: StringFilter<"CleaningPhoto"> | string
    type?: StringNullableFilter<"CleaningPhoto"> | string | null
    caption?: StringNullableFilter<"CleaningPhoto"> | string | null
    cleaningSessionId?: StringFilter<"CleaningPhoto"> | string
    createdAt?: DateTimeFilter<"CleaningPhoto"> | Date | string
    cleaningSession?: XOR<CleaningSessionScalarRelationFilter, CleaningSessionWhereInput>
  }

  export type CleaningPhotoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    cleaningSessionId?: SortOrder
    createdAt?: SortOrder
    cleaningSession?: CleaningSessionOrderByWithRelationInput
  }

  export type CleaningPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CleaningPhotoWhereInput | CleaningPhotoWhereInput[]
    OR?: CleaningPhotoWhereInput[]
    NOT?: CleaningPhotoWhereInput | CleaningPhotoWhereInput[]
    url?: StringFilter<"CleaningPhoto"> | string
    type?: StringNullableFilter<"CleaningPhoto"> | string | null
    caption?: StringNullableFilter<"CleaningPhoto"> | string | null
    cleaningSessionId?: StringFilter<"CleaningPhoto"> | string
    createdAt?: DateTimeFilter<"CleaningPhoto"> | Date | string
    cleaningSession?: XOR<CleaningSessionScalarRelationFilter, CleaningSessionWhereInput>
  }, "id">

  export type CleaningPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    cleaningSessionId?: SortOrder
    createdAt?: SortOrder
    _count?: CleaningPhotoCountOrderByAggregateInput
    _max?: CleaningPhotoMaxOrderByAggregateInput
    _min?: CleaningPhotoMinOrderByAggregateInput
  }

  export type CleaningPhotoScalarWhereWithAggregatesInput = {
    AND?: CleaningPhotoScalarWhereWithAggregatesInput | CleaningPhotoScalarWhereWithAggregatesInput[]
    OR?: CleaningPhotoScalarWhereWithAggregatesInput[]
    NOT?: CleaningPhotoScalarWhereWithAggregatesInput | CleaningPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CleaningPhoto"> | string
    url?: StringWithAggregatesFilter<"CleaningPhoto"> | string
    type?: StringNullableWithAggregatesFilter<"CleaningPhoto"> | string | null
    caption?: StringNullableWithAggregatesFilter<"CleaningPhoto"> | string | null
    cleaningSessionId?: StringWithAggregatesFilter<"CleaningPhoto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CleaningPhoto"> | Date | string
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: StringFilter<"Ticket"> | string
    ticketNumber?: StringFilter<"Ticket"> | string
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    propertyId?: StringFilter<"Ticket"> | string
    reportedBy?: StringFilter<"Ticket"> | string
    reportedAt?: DateTimeFilter<"Ticket"> | Date | string
    agentId?: StringNullableFilter<"Ticket"> | string | null
    assignedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    category?: StringNullableFilter<"Ticket"> | string | null
    issueType?: StringNullableFilter<"Ticket"> | string | null
    roomLocation?: StringNullableFilter<"Ticket"> | string | null
    resolution?: StringNullableFilter<"Ticket"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    estimatedCost?: FloatNullableFilter<"Ticket"> | number | null
    estimatedDuration?: IntNullableFilter<"Ticket"> | number | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    managerId?: StringFilter<"Ticket"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    agent?: XOR<AgentProfileNullableScalarRelationFilter, AgentProfileWhereInput> | null
    photos?: TicketPhotoListRelationFilter
    manager?: XOR<PoleManagerProfileScalarRelationFilter, PoleManagerProfileWhereInput>
    maintenanceSession?: XOR<MaintenanceSessionNullableScalarRelationFilter, MaintenanceSessionWhereInput> | null
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    propertyId?: SortOrder
    reportedBy?: SortOrder
    reportedAt?: SortOrder
    agentId?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    issueType?: SortOrderInput | SortOrder
    roomLocation?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    property?: PropertyOrderByWithRelationInput
    agent?: AgentProfileOrderByWithRelationInput
    photos?: TicketPhotoOrderByRelationAggregateInput
    manager?: PoleManagerProfileOrderByWithRelationInput
    maintenanceSession?: MaintenanceSessionOrderByWithRelationInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ticketNumber?: string
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    propertyId?: StringFilter<"Ticket"> | string
    reportedBy?: StringFilter<"Ticket"> | string
    reportedAt?: DateTimeFilter<"Ticket"> | Date | string
    agentId?: StringNullableFilter<"Ticket"> | string | null
    assignedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    category?: StringNullableFilter<"Ticket"> | string | null
    issueType?: StringNullableFilter<"Ticket"> | string | null
    roomLocation?: StringNullableFilter<"Ticket"> | string | null
    resolution?: StringNullableFilter<"Ticket"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    estimatedCost?: FloatNullableFilter<"Ticket"> | number | null
    estimatedDuration?: IntNullableFilter<"Ticket"> | number | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    managerId?: StringFilter<"Ticket"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    agent?: XOR<AgentProfileNullableScalarRelationFilter, AgentProfileWhereInput> | null
    photos?: TicketPhotoListRelationFilter
    manager?: XOR<PoleManagerProfileScalarRelationFilter, PoleManagerProfileWhereInput>
    maintenanceSession?: XOR<MaintenanceSessionNullableScalarRelationFilter, MaintenanceSessionWhereInput> | null
  }, "id" | "ticketNumber">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    propertyId?: SortOrder
    reportedBy?: SortOrder
    reportedAt?: SortOrder
    agentId?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    issueType?: SortOrderInput | SortOrder
    roomLocation?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    _count?: TicketCountOrderByAggregateInput
    _avg?: TicketAvgOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
    _sum?: TicketSumOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticket"> | string
    ticketNumber?: StringWithAggregatesFilter<"Ticket"> | string
    title?: StringWithAggregatesFilter<"Ticket"> | string
    description?: StringWithAggregatesFilter<"Ticket"> | string
    status?: EnumTicketStatusWithAggregatesFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityWithAggregatesFilter<"Ticket"> | $Enums.TicketPriority
    propertyId?: StringWithAggregatesFilter<"Ticket"> | string
    reportedBy?: StringWithAggregatesFilter<"Ticket"> | string
    reportedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    agentId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    assignedAt?: DateTimeNullableWithAggregatesFilter<"Ticket"> | Date | string | null
    category?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    issueType?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    roomLocation?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    resolution?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Ticket"> | Date | string | null
    estimatedCost?: FloatNullableWithAggregatesFilter<"Ticket"> | number | null
    estimatedDuration?: IntNullableWithAggregatesFilter<"Ticket"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    managerId?: StringWithAggregatesFilter<"Ticket"> | string
  }

  export type TicketPhotoWhereInput = {
    AND?: TicketPhotoWhereInput | TicketPhotoWhereInput[]
    OR?: TicketPhotoWhereInput[]
    NOT?: TicketPhotoWhereInput | TicketPhotoWhereInput[]
    id?: StringFilter<"TicketPhoto"> | string
    url?: StringFilter<"TicketPhoto"> | string
    caption?: StringNullableFilter<"TicketPhoto"> | string | null
    ticketId?: StringFilter<"TicketPhoto"> | string
    createdAt?: DateTimeFilter<"TicketPhoto"> | Date | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }

  export type TicketPhotoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    caption?: SortOrderInput | SortOrder
    ticketId?: SortOrder
    createdAt?: SortOrder
    ticket?: TicketOrderByWithRelationInput
  }

  export type TicketPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketPhotoWhereInput | TicketPhotoWhereInput[]
    OR?: TicketPhotoWhereInput[]
    NOT?: TicketPhotoWhereInput | TicketPhotoWhereInput[]
    url?: StringFilter<"TicketPhoto"> | string
    caption?: StringNullableFilter<"TicketPhoto"> | string | null
    ticketId?: StringFilter<"TicketPhoto"> | string
    createdAt?: DateTimeFilter<"TicketPhoto"> | Date | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }, "id">

  export type TicketPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    caption?: SortOrderInput | SortOrder
    ticketId?: SortOrder
    createdAt?: SortOrder
    _count?: TicketPhotoCountOrderByAggregateInput
    _max?: TicketPhotoMaxOrderByAggregateInput
    _min?: TicketPhotoMinOrderByAggregateInput
  }

  export type TicketPhotoScalarWhereWithAggregatesInput = {
    AND?: TicketPhotoScalarWhereWithAggregatesInput | TicketPhotoScalarWhereWithAggregatesInput[]
    OR?: TicketPhotoScalarWhereWithAggregatesInput[]
    NOT?: TicketPhotoScalarWhereWithAggregatesInput | TicketPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketPhoto"> | string
    url?: StringWithAggregatesFilter<"TicketPhoto"> | string
    caption?: StringNullableWithAggregatesFilter<"TicketPhoto"> | string | null
    ticketId?: StringWithAggregatesFilter<"TicketPhoto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketPhoto"> | Date | string
  }

  export type MaintenanceSessionWhereInput = {
    AND?: MaintenanceSessionWhereInput | MaintenanceSessionWhereInput[]
    OR?: MaintenanceSessionWhereInput[]
    NOT?: MaintenanceSessionWhereInput | MaintenanceSessionWhereInput[]
    id?: StringFilter<"MaintenanceSession"> | string
    sessionNumber?: StringFilter<"MaintenanceSession"> | string
    ticketId?: StringFilter<"MaintenanceSession"> | string
    propertyId?: StringFilter<"MaintenanceSession"> | string
    agentId?: StringFilter<"MaintenanceSession"> | string
    scheduledDate?: DateTimeFilter<"MaintenanceSession"> | Date | string
    startTime?: DateTimeNullableFilter<"MaintenanceSession"> | Date | string | null
    endTime?: DateTimeNullableFilter<"MaintenanceSession"> | Date | string | null
    estimatedDuration?: IntNullableFilter<"MaintenanceSession"> | number | null
    actualDuration?: IntNullableFilter<"MaintenanceSession"> | number | null
    status?: EnumSessionStatusFilter<"MaintenanceSession"> | $Enums.SessionStatus
    notes?: StringNullableFilter<"MaintenanceSession"> | string | null
    workDescription?: StringNullableFilter<"MaintenanceSession"> | string | null
    agentNotes?: StringNullableFilter<"MaintenanceSession"> | string | null
    laborCost?: FloatNullableFilter<"MaintenanceSession"> | number | null
    materialsCost?: FloatNullableFilter<"MaintenanceSession"> | number | null
    totalCost?: FloatNullableFilter<"MaintenanceSession"> | number | null
    ownerApproval?: BoolNullableFilter<"MaintenanceSession"> | boolean | null
    managerApproval?: BoolNullableFilter<"MaintenanceSession"> | boolean | null
    createdAt?: DateTimeFilter<"MaintenanceSession"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceSession"> | Date | string
    managerId?: StringFilter<"MaintenanceSession"> | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    agent?: XOR<AgentProfileScalarRelationFilter, AgentProfileWhereInput>
    materials?: MaintenanceMaterialListRelationFilter
    photos?: MaintenancePhotoListRelationFilter
    manager?: XOR<PoleManagerProfileScalarRelationFilter, PoleManagerProfileWhereInput>
  }

  export type MaintenanceSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
    ticketId?: SortOrder
    propertyId?: SortOrder
    agentId?: SortOrder
    scheduledDate?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    actualDuration?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    workDescription?: SortOrderInput | SortOrder
    agentNotes?: SortOrderInput | SortOrder
    laborCost?: SortOrderInput | SortOrder
    materialsCost?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    ownerApproval?: SortOrderInput | SortOrder
    managerApproval?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    ticket?: TicketOrderByWithRelationInput
    property?: PropertyOrderByWithRelationInput
    agent?: AgentProfileOrderByWithRelationInput
    materials?: MaintenanceMaterialOrderByRelationAggregateInput
    photos?: MaintenancePhotoOrderByRelationAggregateInput
    manager?: PoleManagerProfileOrderByWithRelationInput
  }

  export type MaintenanceSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionNumber?: string
    ticketId?: string
    AND?: MaintenanceSessionWhereInput | MaintenanceSessionWhereInput[]
    OR?: MaintenanceSessionWhereInput[]
    NOT?: MaintenanceSessionWhereInput | MaintenanceSessionWhereInput[]
    propertyId?: StringFilter<"MaintenanceSession"> | string
    agentId?: StringFilter<"MaintenanceSession"> | string
    scheduledDate?: DateTimeFilter<"MaintenanceSession"> | Date | string
    startTime?: DateTimeNullableFilter<"MaintenanceSession"> | Date | string | null
    endTime?: DateTimeNullableFilter<"MaintenanceSession"> | Date | string | null
    estimatedDuration?: IntNullableFilter<"MaintenanceSession"> | number | null
    actualDuration?: IntNullableFilter<"MaintenanceSession"> | number | null
    status?: EnumSessionStatusFilter<"MaintenanceSession"> | $Enums.SessionStatus
    notes?: StringNullableFilter<"MaintenanceSession"> | string | null
    workDescription?: StringNullableFilter<"MaintenanceSession"> | string | null
    agentNotes?: StringNullableFilter<"MaintenanceSession"> | string | null
    laborCost?: FloatNullableFilter<"MaintenanceSession"> | number | null
    materialsCost?: FloatNullableFilter<"MaintenanceSession"> | number | null
    totalCost?: FloatNullableFilter<"MaintenanceSession"> | number | null
    ownerApproval?: BoolNullableFilter<"MaintenanceSession"> | boolean | null
    managerApproval?: BoolNullableFilter<"MaintenanceSession"> | boolean | null
    createdAt?: DateTimeFilter<"MaintenanceSession"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceSession"> | Date | string
    managerId?: StringFilter<"MaintenanceSession"> | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    agent?: XOR<AgentProfileScalarRelationFilter, AgentProfileWhereInput>
    materials?: MaintenanceMaterialListRelationFilter
    photos?: MaintenancePhotoListRelationFilter
    manager?: XOR<PoleManagerProfileScalarRelationFilter, PoleManagerProfileWhereInput>
  }, "id" | "sessionNumber" | "ticketId">

  export type MaintenanceSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
    ticketId?: SortOrder
    propertyId?: SortOrder
    agentId?: SortOrder
    scheduledDate?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    actualDuration?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    workDescription?: SortOrderInput | SortOrder
    agentNotes?: SortOrderInput | SortOrder
    laborCost?: SortOrderInput | SortOrder
    materialsCost?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    ownerApproval?: SortOrderInput | SortOrder
    managerApproval?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    _count?: MaintenanceSessionCountOrderByAggregateInput
    _avg?: MaintenanceSessionAvgOrderByAggregateInput
    _max?: MaintenanceSessionMaxOrderByAggregateInput
    _min?: MaintenanceSessionMinOrderByAggregateInput
    _sum?: MaintenanceSessionSumOrderByAggregateInput
  }

  export type MaintenanceSessionScalarWhereWithAggregatesInput = {
    AND?: MaintenanceSessionScalarWhereWithAggregatesInput | MaintenanceSessionScalarWhereWithAggregatesInput[]
    OR?: MaintenanceSessionScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceSessionScalarWhereWithAggregatesInput | MaintenanceSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenanceSession"> | string
    sessionNumber?: StringWithAggregatesFilter<"MaintenanceSession"> | string
    ticketId?: StringWithAggregatesFilter<"MaintenanceSession"> | string
    propertyId?: StringWithAggregatesFilter<"MaintenanceSession"> | string
    agentId?: StringWithAggregatesFilter<"MaintenanceSession"> | string
    scheduledDate?: DateTimeWithAggregatesFilter<"MaintenanceSession"> | Date | string
    startTime?: DateTimeNullableWithAggregatesFilter<"MaintenanceSession"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"MaintenanceSession"> | Date | string | null
    estimatedDuration?: IntNullableWithAggregatesFilter<"MaintenanceSession"> | number | null
    actualDuration?: IntNullableWithAggregatesFilter<"MaintenanceSession"> | number | null
    status?: EnumSessionStatusWithAggregatesFilter<"MaintenanceSession"> | $Enums.SessionStatus
    notes?: StringNullableWithAggregatesFilter<"MaintenanceSession"> | string | null
    workDescription?: StringNullableWithAggregatesFilter<"MaintenanceSession"> | string | null
    agentNotes?: StringNullableWithAggregatesFilter<"MaintenanceSession"> | string | null
    laborCost?: FloatNullableWithAggregatesFilter<"MaintenanceSession"> | number | null
    materialsCost?: FloatNullableWithAggregatesFilter<"MaintenanceSession"> | number | null
    totalCost?: FloatNullableWithAggregatesFilter<"MaintenanceSession"> | number | null
    ownerApproval?: BoolNullableWithAggregatesFilter<"MaintenanceSession"> | boolean | null
    managerApproval?: BoolNullableWithAggregatesFilter<"MaintenanceSession"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"MaintenanceSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MaintenanceSession"> | Date | string
    managerId?: StringWithAggregatesFilter<"MaintenanceSession"> | string
  }

  export type MaintenanceMaterialWhereInput = {
    AND?: MaintenanceMaterialWhereInput | MaintenanceMaterialWhereInput[]
    OR?: MaintenanceMaterialWhereInput[]
    NOT?: MaintenanceMaterialWhereInput | MaintenanceMaterialWhereInput[]
    id?: StringFilter<"MaintenanceMaterial"> | string
    name?: StringFilter<"MaintenanceMaterial"> | string
    quantity?: FloatFilter<"MaintenanceMaterial"> | number
    unit?: StringFilter<"MaintenanceMaterial"> | string
    unitPrice?: FloatFilter<"MaintenanceMaterial"> | number
    totalPrice?: FloatFilter<"MaintenanceMaterial"> | number
    supplier?: StringNullableFilter<"MaintenanceMaterial"> | string | null
    maintenanceSessionId?: StringFilter<"MaintenanceMaterial"> | string
    maintenanceSession?: XOR<MaintenanceSessionScalarRelationFilter, MaintenanceSessionWhereInput>
  }

  export type MaintenanceMaterialOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    supplier?: SortOrderInput | SortOrder
    maintenanceSessionId?: SortOrder
    maintenanceSession?: MaintenanceSessionOrderByWithRelationInput
  }

  export type MaintenanceMaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceMaterialWhereInput | MaintenanceMaterialWhereInput[]
    OR?: MaintenanceMaterialWhereInput[]
    NOT?: MaintenanceMaterialWhereInput | MaintenanceMaterialWhereInput[]
    name?: StringFilter<"MaintenanceMaterial"> | string
    quantity?: FloatFilter<"MaintenanceMaterial"> | number
    unit?: StringFilter<"MaintenanceMaterial"> | string
    unitPrice?: FloatFilter<"MaintenanceMaterial"> | number
    totalPrice?: FloatFilter<"MaintenanceMaterial"> | number
    supplier?: StringNullableFilter<"MaintenanceMaterial"> | string | null
    maintenanceSessionId?: StringFilter<"MaintenanceMaterial"> | string
    maintenanceSession?: XOR<MaintenanceSessionScalarRelationFilter, MaintenanceSessionWhereInput>
  }, "id">

  export type MaintenanceMaterialOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    supplier?: SortOrderInput | SortOrder
    maintenanceSessionId?: SortOrder
    _count?: MaintenanceMaterialCountOrderByAggregateInput
    _avg?: MaintenanceMaterialAvgOrderByAggregateInput
    _max?: MaintenanceMaterialMaxOrderByAggregateInput
    _min?: MaintenanceMaterialMinOrderByAggregateInput
    _sum?: MaintenanceMaterialSumOrderByAggregateInput
  }

  export type MaintenanceMaterialScalarWhereWithAggregatesInput = {
    AND?: MaintenanceMaterialScalarWhereWithAggregatesInput | MaintenanceMaterialScalarWhereWithAggregatesInput[]
    OR?: MaintenanceMaterialScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceMaterialScalarWhereWithAggregatesInput | MaintenanceMaterialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenanceMaterial"> | string
    name?: StringWithAggregatesFilter<"MaintenanceMaterial"> | string
    quantity?: FloatWithAggregatesFilter<"MaintenanceMaterial"> | number
    unit?: StringWithAggregatesFilter<"MaintenanceMaterial"> | string
    unitPrice?: FloatWithAggregatesFilter<"MaintenanceMaterial"> | number
    totalPrice?: FloatWithAggregatesFilter<"MaintenanceMaterial"> | number
    supplier?: StringNullableWithAggregatesFilter<"MaintenanceMaterial"> | string | null
    maintenanceSessionId?: StringWithAggregatesFilter<"MaintenanceMaterial"> | string
  }

  export type MaintenancePhotoWhereInput = {
    AND?: MaintenancePhotoWhereInput | MaintenancePhotoWhereInput[]
    OR?: MaintenancePhotoWhereInput[]
    NOT?: MaintenancePhotoWhereInput | MaintenancePhotoWhereInput[]
    id?: StringFilter<"MaintenancePhoto"> | string
    url?: StringFilter<"MaintenancePhoto"> | string
    type?: StringNullableFilter<"MaintenancePhoto"> | string | null
    caption?: StringNullableFilter<"MaintenancePhoto"> | string | null
    maintenanceSessionId?: StringFilter<"MaintenancePhoto"> | string
    createdAt?: DateTimeFilter<"MaintenancePhoto"> | Date | string
    maintenanceSession?: XOR<MaintenanceSessionScalarRelationFilter, MaintenanceSessionWhereInput>
  }

  export type MaintenancePhotoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    maintenanceSessionId?: SortOrder
    createdAt?: SortOrder
    maintenanceSession?: MaintenanceSessionOrderByWithRelationInput
  }

  export type MaintenancePhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenancePhotoWhereInput | MaintenancePhotoWhereInput[]
    OR?: MaintenancePhotoWhereInput[]
    NOT?: MaintenancePhotoWhereInput | MaintenancePhotoWhereInput[]
    url?: StringFilter<"MaintenancePhoto"> | string
    type?: StringNullableFilter<"MaintenancePhoto"> | string | null
    caption?: StringNullableFilter<"MaintenancePhoto"> | string | null
    maintenanceSessionId?: StringFilter<"MaintenancePhoto"> | string
    createdAt?: DateTimeFilter<"MaintenancePhoto"> | Date | string
    maintenanceSession?: XOR<MaintenanceSessionScalarRelationFilter, MaintenanceSessionWhereInput>
  }, "id">

  export type MaintenancePhotoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    maintenanceSessionId?: SortOrder
    createdAt?: SortOrder
    _count?: MaintenancePhotoCountOrderByAggregateInput
    _max?: MaintenancePhotoMaxOrderByAggregateInput
    _min?: MaintenancePhotoMinOrderByAggregateInput
  }

  export type MaintenancePhotoScalarWhereWithAggregatesInput = {
    AND?: MaintenancePhotoScalarWhereWithAggregatesInput | MaintenancePhotoScalarWhereWithAggregatesInput[]
    OR?: MaintenancePhotoScalarWhereWithAggregatesInput[]
    NOT?: MaintenancePhotoScalarWhereWithAggregatesInput | MaintenancePhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenancePhoto"> | string
    url?: StringWithAggregatesFilter<"MaintenancePhoto"> | string
    type?: StringNullableWithAggregatesFilter<"MaintenancePhoto"> | string | null
    caption?: StringNullableWithAggregatesFilter<"MaintenancePhoto"> | string | null
    maintenanceSessionId?: StringWithAggregatesFilter<"MaintenancePhoto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MaintenancePhoto"> | Date | string
  }

  export type LaundryProductWhereInput = {
    AND?: LaundryProductWhereInput | LaundryProductWhereInput[]
    OR?: LaundryProductWhereInput[]
    NOT?: LaundryProductWhereInput | LaundryProductWhereInput[]
    id?: StringFilter<"LaundryProduct"> | string
    name?: StringFilter<"LaundryProduct"> | string
    description?: StringFilter<"LaundryProduct"> | string
    price?: FloatFilter<"LaundryProduct"> | number
    stock?: IntFilter<"LaundryProduct"> | number
    category?: StringNullableFilter<"LaundryProduct"> | string | null
    isActive?: BoolFilter<"LaundryProduct"> | boolean
    createdAt?: DateTimeFilter<"LaundryProduct"> | Date | string
    updatedAt?: DateTimeFilter<"LaundryProduct"> | Date | string
    orderItems?: LaundryOrderItemListRelationFilter
  }

  export type LaundryProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderItems?: LaundryOrderItemOrderByRelationAggregateInput
  }

  export type LaundryProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LaundryProductWhereInput | LaundryProductWhereInput[]
    OR?: LaundryProductWhereInput[]
    NOT?: LaundryProductWhereInput | LaundryProductWhereInput[]
    name?: StringFilter<"LaundryProduct"> | string
    description?: StringFilter<"LaundryProduct"> | string
    price?: FloatFilter<"LaundryProduct"> | number
    stock?: IntFilter<"LaundryProduct"> | number
    category?: StringNullableFilter<"LaundryProduct"> | string | null
    isActive?: BoolFilter<"LaundryProduct"> | boolean
    createdAt?: DateTimeFilter<"LaundryProduct"> | Date | string
    updatedAt?: DateTimeFilter<"LaundryProduct"> | Date | string
    orderItems?: LaundryOrderItemListRelationFilter
  }, "id">

  export type LaundryProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaundryProductCountOrderByAggregateInput
    _avg?: LaundryProductAvgOrderByAggregateInput
    _max?: LaundryProductMaxOrderByAggregateInput
    _min?: LaundryProductMinOrderByAggregateInput
    _sum?: LaundryProductSumOrderByAggregateInput
  }

  export type LaundryProductScalarWhereWithAggregatesInput = {
    AND?: LaundryProductScalarWhereWithAggregatesInput | LaundryProductScalarWhereWithAggregatesInput[]
    OR?: LaundryProductScalarWhereWithAggregatesInput[]
    NOT?: LaundryProductScalarWhereWithAggregatesInput | LaundryProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LaundryProduct"> | string
    name?: StringWithAggregatesFilter<"LaundryProduct"> | string
    description?: StringWithAggregatesFilter<"LaundryProduct"> | string
    price?: FloatWithAggregatesFilter<"LaundryProduct"> | number
    stock?: IntWithAggregatesFilter<"LaundryProduct"> | number
    category?: StringNullableWithAggregatesFilter<"LaundryProduct"> | string | null
    isActive?: BoolWithAggregatesFilter<"LaundryProduct"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LaundryProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LaundryProduct"> | Date | string
  }

  export type LaundryOrderWhereInput = {
    AND?: LaundryOrderWhereInput | LaundryOrderWhereInput[]
    OR?: LaundryOrderWhereInput[]
    NOT?: LaundryOrderWhereInput | LaundryOrderWhereInput[]
    id?: StringFilter<"LaundryOrder"> | string
    orderNumber?: StringFilter<"LaundryOrder"> | string
    status?: EnumOrderStatusFilter<"LaundryOrder"> | $Enums.OrderStatus
    receivedDate?: DateTimeNullableFilter<"LaundryOrder"> | Date | string | null
    processedDate?: DateTimeNullableFilter<"LaundryOrder"> | Date | string | null
    readyDate?: DateTimeNullableFilter<"LaundryOrder"> | Date | string | null
    deliveryDate?: DateTimeNullableFilter<"LaundryOrder"> | Date | string | null
    pickupAddress?: StringNullableFilter<"LaundryOrder"> | string | null
    deliveryAddress?: StringFilter<"LaundryOrder"> | string
    instructions?: StringNullableFilter<"LaundryOrder"> | string | null
    subtotal?: FloatFilter<"LaundryOrder"> | number
    taxes?: FloatNullableFilter<"LaundryOrder"> | number | null
    deliveryFee?: FloatNullableFilter<"LaundryOrder"> | number | null
    totalAmount?: FloatFilter<"LaundryOrder"> | number
    notes?: StringNullableFilter<"LaundryOrder"> | string | null
    receivedByClient?: BoolFilter<"LaundryOrder"> | boolean
    receivedAt?: DateTimeNullableFilter<"LaundryOrder"> | Date | string | null
    createdAt?: DateTimeFilter<"LaundryOrder"> | Date | string
    updatedAt?: DateTimeFilter<"LaundryOrder"> | Date | string
    managerId?: StringFilter<"LaundryOrder"> | string
    clientId?: StringFilter<"LaundryOrder"> | string
    manager?: XOR<PoleManagerProfileScalarRelationFilter, PoleManagerProfileWhereInput>
    client?: XOR<LaundryClientProfileScalarRelationFilter, LaundryClientProfileWhereInput>
    items?: LaundryOrderItemListRelationFilter
    deliveryNotes?: DeliveryNoteListRelationFilter
  }

  export type LaundryOrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    receivedDate?: SortOrderInput | SortOrder
    processedDate?: SortOrderInput | SortOrder
    readyDate?: SortOrderInput | SortOrder
    deliveryDate?: SortOrderInput | SortOrder
    pickupAddress?: SortOrderInput | SortOrder
    deliveryAddress?: SortOrder
    instructions?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxes?: SortOrderInput | SortOrder
    deliveryFee?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    receivedByClient?: SortOrder
    receivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    clientId?: SortOrder
    manager?: PoleManagerProfileOrderByWithRelationInput
    client?: LaundryClientProfileOrderByWithRelationInput
    items?: LaundryOrderItemOrderByRelationAggregateInput
    deliveryNotes?: DeliveryNoteOrderByRelationAggregateInput
  }

  export type LaundryOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    AND?: LaundryOrderWhereInput | LaundryOrderWhereInput[]
    OR?: LaundryOrderWhereInput[]
    NOT?: LaundryOrderWhereInput | LaundryOrderWhereInput[]
    status?: EnumOrderStatusFilter<"LaundryOrder"> | $Enums.OrderStatus
    receivedDate?: DateTimeNullableFilter<"LaundryOrder"> | Date | string | null
    processedDate?: DateTimeNullableFilter<"LaundryOrder"> | Date | string | null
    readyDate?: DateTimeNullableFilter<"LaundryOrder"> | Date | string | null
    deliveryDate?: DateTimeNullableFilter<"LaundryOrder"> | Date | string | null
    pickupAddress?: StringNullableFilter<"LaundryOrder"> | string | null
    deliveryAddress?: StringFilter<"LaundryOrder"> | string
    instructions?: StringNullableFilter<"LaundryOrder"> | string | null
    subtotal?: FloatFilter<"LaundryOrder"> | number
    taxes?: FloatNullableFilter<"LaundryOrder"> | number | null
    deliveryFee?: FloatNullableFilter<"LaundryOrder"> | number | null
    totalAmount?: FloatFilter<"LaundryOrder"> | number
    notes?: StringNullableFilter<"LaundryOrder"> | string | null
    receivedByClient?: BoolFilter<"LaundryOrder"> | boolean
    receivedAt?: DateTimeNullableFilter<"LaundryOrder"> | Date | string | null
    createdAt?: DateTimeFilter<"LaundryOrder"> | Date | string
    updatedAt?: DateTimeFilter<"LaundryOrder"> | Date | string
    managerId?: StringFilter<"LaundryOrder"> | string
    clientId?: StringFilter<"LaundryOrder"> | string
    manager?: XOR<PoleManagerProfileScalarRelationFilter, PoleManagerProfileWhereInput>
    client?: XOR<LaundryClientProfileScalarRelationFilter, LaundryClientProfileWhereInput>
    items?: LaundryOrderItemListRelationFilter
    deliveryNotes?: DeliveryNoteListRelationFilter
  }, "id" | "orderNumber">

  export type LaundryOrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    receivedDate?: SortOrderInput | SortOrder
    processedDate?: SortOrderInput | SortOrder
    readyDate?: SortOrderInput | SortOrder
    deliveryDate?: SortOrderInput | SortOrder
    pickupAddress?: SortOrderInput | SortOrder
    deliveryAddress?: SortOrder
    instructions?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxes?: SortOrderInput | SortOrder
    deliveryFee?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    receivedByClient?: SortOrder
    receivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    clientId?: SortOrder
    _count?: LaundryOrderCountOrderByAggregateInput
    _avg?: LaundryOrderAvgOrderByAggregateInput
    _max?: LaundryOrderMaxOrderByAggregateInput
    _min?: LaundryOrderMinOrderByAggregateInput
    _sum?: LaundryOrderSumOrderByAggregateInput
  }

  export type LaundryOrderScalarWhereWithAggregatesInput = {
    AND?: LaundryOrderScalarWhereWithAggregatesInput | LaundryOrderScalarWhereWithAggregatesInput[]
    OR?: LaundryOrderScalarWhereWithAggregatesInput[]
    NOT?: LaundryOrderScalarWhereWithAggregatesInput | LaundryOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LaundryOrder"> | string
    orderNumber?: StringWithAggregatesFilter<"LaundryOrder"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"LaundryOrder"> | $Enums.OrderStatus
    receivedDate?: DateTimeNullableWithAggregatesFilter<"LaundryOrder"> | Date | string | null
    processedDate?: DateTimeNullableWithAggregatesFilter<"LaundryOrder"> | Date | string | null
    readyDate?: DateTimeNullableWithAggregatesFilter<"LaundryOrder"> | Date | string | null
    deliveryDate?: DateTimeNullableWithAggregatesFilter<"LaundryOrder"> | Date | string | null
    pickupAddress?: StringNullableWithAggregatesFilter<"LaundryOrder"> | string | null
    deliveryAddress?: StringWithAggregatesFilter<"LaundryOrder"> | string
    instructions?: StringNullableWithAggregatesFilter<"LaundryOrder"> | string | null
    subtotal?: FloatWithAggregatesFilter<"LaundryOrder"> | number
    taxes?: FloatNullableWithAggregatesFilter<"LaundryOrder"> | number | null
    deliveryFee?: FloatNullableWithAggregatesFilter<"LaundryOrder"> | number | null
    totalAmount?: FloatWithAggregatesFilter<"LaundryOrder"> | number
    notes?: StringNullableWithAggregatesFilter<"LaundryOrder"> | string | null
    receivedByClient?: BoolWithAggregatesFilter<"LaundryOrder"> | boolean
    receivedAt?: DateTimeNullableWithAggregatesFilter<"LaundryOrder"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LaundryOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LaundryOrder"> | Date | string
    managerId?: StringWithAggregatesFilter<"LaundryOrder"> | string
    clientId?: StringWithAggregatesFilter<"LaundryOrder"> | string
  }

  export type LaundryOrderItemWhereInput = {
    AND?: LaundryOrderItemWhereInput | LaundryOrderItemWhereInput[]
    OR?: LaundryOrderItemWhereInput[]
    NOT?: LaundryOrderItemWhereInput | LaundryOrderItemWhereInput[]
    id?: StringFilter<"LaundryOrderItem"> | string
    quantity?: IntFilter<"LaundryOrderItem"> | number
    unitPrice?: FloatFilter<"LaundryOrderItem"> | number
    subtotal?: FloatFilter<"LaundryOrderItem"> | number
    notes?: StringNullableFilter<"LaundryOrderItem"> | string | null
    orderId?: StringFilter<"LaundryOrderItem"> | string
    productId?: StringFilter<"LaundryOrderItem"> | string
    createdAt?: DateTimeFilter<"LaundryOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"LaundryOrderItem"> | Date | string
    order?: XOR<LaundryOrderScalarRelationFilter, LaundryOrderWhereInput>
    product?: XOR<LaundryProductScalarRelationFilter, LaundryProductWhereInput>
  }

  export type LaundryOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    notes?: SortOrderInput | SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: LaundryOrderOrderByWithRelationInput
    product?: LaundryProductOrderByWithRelationInput
  }

  export type LaundryOrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LaundryOrderItemWhereInput | LaundryOrderItemWhereInput[]
    OR?: LaundryOrderItemWhereInput[]
    NOT?: LaundryOrderItemWhereInput | LaundryOrderItemWhereInput[]
    quantity?: IntFilter<"LaundryOrderItem"> | number
    unitPrice?: FloatFilter<"LaundryOrderItem"> | number
    subtotal?: FloatFilter<"LaundryOrderItem"> | number
    notes?: StringNullableFilter<"LaundryOrderItem"> | string | null
    orderId?: StringFilter<"LaundryOrderItem"> | string
    productId?: StringFilter<"LaundryOrderItem"> | string
    createdAt?: DateTimeFilter<"LaundryOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"LaundryOrderItem"> | Date | string
    order?: XOR<LaundryOrderScalarRelationFilter, LaundryOrderWhereInput>
    product?: XOR<LaundryProductScalarRelationFilter, LaundryProductWhereInput>
  }, "id">

  export type LaundryOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    notes?: SortOrderInput | SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaundryOrderItemCountOrderByAggregateInput
    _avg?: LaundryOrderItemAvgOrderByAggregateInput
    _max?: LaundryOrderItemMaxOrderByAggregateInput
    _min?: LaundryOrderItemMinOrderByAggregateInput
    _sum?: LaundryOrderItemSumOrderByAggregateInput
  }

  export type LaundryOrderItemScalarWhereWithAggregatesInput = {
    AND?: LaundryOrderItemScalarWhereWithAggregatesInput | LaundryOrderItemScalarWhereWithAggregatesInput[]
    OR?: LaundryOrderItemScalarWhereWithAggregatesInput[]
    NOT?: LaundryOrderItemScalarWhereWithAggregatesInput | LaundryOrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LaundryOrderItem"> | string
    quantity?: IntWithAggregatesFilter<"LaundryOrderItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"LaundryOrderItem"> | number
    subtotal?: FloatWithAggregatesFilter<"LaundryOrderItem"> | number
    notes?: StringNullableWithAggregatesFilter<"LaundryOrderItem"> | string | null
    orderId?: StringWithAggregatesFilter<"LaundryOrderItem"> | string
    productId?: StringWithAggregatesFilter<"LaundryOrderItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LaundryOrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LaundryOrderItem"> | Date | string
  }

  export type DeliveryNoteWhereInput = {
    AND?: DeliveryNoteWhereInput | DeliveryNoteWhereInput[]
    OR?: DeliveryNoteWhereInput[]
    NOT?: DeliveryNoteWhereInput | DeliveryNoteWhereInput[]
    id?: StringFilter<"DeliveryNote"> | string
    number?: StringFilter<"DeliveryNote"> | string
    date?: DateTimeFilter<"DeliveryNote"> | Date | string
    notes?: StringNullableFilter<"DeliveryNote"> | string | null
    orderId?: StringFilter<"DeliveryNote"> | string
    createdAt?: DateTimeFilter<"DeliveryNote"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryNote"> | Date | string
    order?: XOR<LaundryOrderScalarRelationFilter, LaundryOrderWhereInput>
  }

  export type DeliveryNoteOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    notes?: SortOrderInput | SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: LaundryOrderOrderByWithRelationInput
  }

  export type DeliveryNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    number?: string
    AND?: DeliveryNoteWhereInput | DeliveryNoteWhereInput[]
    OR?: DeliveryNoteWhereInput[]
    NOT?: DeliveryNoteWhereInput | DeliveryNoteWhereInput[]
    date?: DateTimeFilter<"DeliveryNote"> | Date | string
    notes?: StringNullableFilter<"DeliveryNote"> | string | null
    orderId?: StringFilter<"DeliveryNote"> | string
    createdAt?: DateTimeFilter<"DeliveryNote"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryNote"> | Date | string
    order?: XOR<LaundryOrderScalarRelationFilter, LaundryOrderWhereInput>
  }, "id" | "number">

  export type DeliveryNoteOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    notes?: SortOrderInput | SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeliveryNoteCountOrderByAggregateInput
    _max?: DeliveryNoteMaxOrderByAggregateInput
    _min?: DeliveryNoteMinOrderByAggregateInput
  }

  export type DeliveryNoteScalarWhereWithAggregatesInput = {
    AND?: DeliveryNoteScalarWhereWithAggregatesInput | DeliveryNoteScalarWhereWithAggregatesInput[]
    OR?: DeliveryNoteScalarWhereWithAggregatesInput[]
    NOT?: DeliveryNoteScalarWhereWithAggregatesInput | DeliveryNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryNote"> | string
    number?: StringWithAggregatesFilter<"DeliveryNote"> | string
    date?: DateTimeWithAggregatesFilter<"DeliveryNote"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"DeliveryNote"> | string | null
    orderId?: StringWithAggregatesFilter<"DeliveryNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeliveryNote"> | Date | string
  }

  export type TaskAssignmentWhereInput = {
    AND?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    OR?: TaskAssignmentWhereInput[]
    NOT?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    id?: StringFilter<"TaskAssignment"> | string
    title?: StringFilter<"TaskAssignment"> | string
    description?: StringNullableFilter<"TaskAssignment"> | string | null
    type?: StringFilter<"TaskAssignment"> | string
    priority?: StringFilter<"TaskAssignment"> | string
    status?: StringFilter<"TaskAssignment"> | string
    assignedAt?: DateTimeFilter<"TaskAssignment"> | Date | string
    dueDate?: DateTimeNullableFilter<"TaskAssignment"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"TaskAssignment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TaskAssignment"> | Date | string | null
    agentId?: StringFilter<"TaskAssignment"> | string
    propertyId?: StringNullableFilter<"TaskAssignment"> | string | null
    reservationId?: StringNullableFilter<"TaskAssignment"> | string | null
    cleaningSessionId?: StringNullableFilter<"TaskAssignment"> | string | null
    maintenanceSessionId?: StringNullableFilter<"TaskAssignment"> | string | null
    ticketId?: StringNullableFilter<"TaskAssignment"> | string | null
    estimatedDuration?: IntNullableFilter<"TaskAssignment"> | number | null
    actualDuration?: IntNullableFilter<"TaskAssignment"> | number | null
    notes?: StringNullableFilter<"TaskAssignment"> | string | null
    createdAt?: DateTimeFilter<"TaskAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"TaskAssignment"> | Date | string
    agent?: XOR<AgentProfileScalarRelationFilter, AgentProfileWhereInput>
  }

  export type TaskAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    agentId?: SortOrder
    propertyId?: SortOrderInput | SortOrder
    reservationId?: SortOrderInput | SortOrder
    cleaningSessionId?: SortOrderInput | SortOrder
    maintenanceSessionId?: SortOrderInput | SortOrder
    ticketId?: SortOrderInput | SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    actualDuration?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentProfileOrderByWithRelationInput
  }

  export type TaskAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    OR?: TaskAssignmentWhereInput[]
    NOT?: TaskAssignmentWhereInput | TaskAssignmentWhereInput[]
    title?: StringFilter<"TaskAssignment"> | string
    description?: StringNullableFilter<"TaskAssignment"> | string | null
    type?: StringFilter<"TaskAssignment"> | string
    priority?: StringFilter<"TaskAssignment"> | string
    status?: StringFilter<"TaskAssignment"> | string
    assignedAt?: DateTimeFilter<"TaskAssignment"> | Date | string
    dueDate?: DateTimeNullableFilter<"TaskAssignment"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"TaskAssignment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TaskAssignment"> | Date | string | null
    agentId?: StringFilter<"TaskAssignment"> | string
    propertyId?: StringNullableFilter<"TaskAssignment"> | string | null
    reservationId?: StringNullableFilter<"TaskAssignment"> | string | null
    cleaningSessionId?: StringNullableFilter<"TaskAssignment"> | string | null
    maintenanceSessionId?: StringNullableFilter<"TaskAssignment"> | string | null
    ticketId?: StringNullableFilter<"TaskAssignment"> | string | null
    estimatedDuration?: IntNullableFilter<"TaskAssignment"> | number | null
    actualDuration?: IntNullableFilter<"TaskAssignment"> | number | null
    notes?: StringNullableFilter<"TaskAssignment"> | string | null
    createdAt?: DateTimeFilter<"TaskAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"TaskAssignment"> | Date | string
    agent?: XOR<AgentProfileScalarRelationFilter, AgentProfileWhereInput>
  }, "id">

  export type TaskAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    agentId?: SortOrder
    propertyId?: SortOrderInput | SortOrder
    reservationId?: SortOrderInput | SortOrder
    cleaningSessionId?: SortOrderInput | SortOrder
    maintenanceSessionId?: SortOrderInput | SortOrder
    ticketId?: SortOrderInput | SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    actualDuration?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskAssignmentCountOrderByAggregateInput
    _avg?: TaskAssignmentAvgOrderByAggregateInput
    _max?: TaskAssignmentMaxOrderByAggregateInput
    _min?: TaskAssignmentMinOrderByAggregateInput
    _sum?: TaskAssignmentSumOrderByAggregateInput
  }

  export type TaskAssignmentScalarWhereWithAggregatesInput = {
    AND?: TaskAssignmentScalarWhereWithAggregatesInput | TaskAssignmentScalarWhereWithAggregatesInput[]
    OR?: TaskAssignmentScalarWhereWithAggregatesInput[]
    NOT?: TaskAssignmentScalarWhereWithAggregatesInput | TaskAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskAssignment"> | string
    title?: StringWithAggregatesFilter<"TaskAssignment"> | string
    description?: StringNullableWithAggregatesFilter<"TaskAssignment"> | string | null
    type?: StringWithAggregatesFilter<"TaskAssignment"> | string
    priority?: StringWithAggregatesFilter<"TaskAssignment"> | string
    status?: StringWithAggregatesFilter<"TaskAssignment"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"TaskAssignment"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"TaskAssignment"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"TaskAssignment"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"TaskAssignment"> | Date | string | null
    agentId?: StringWithAggregatesFilter<"TaskAssignment"> | string
    propertyId?: StringNullableWithAggregatesFilter<"TaskAssignment"> | string | null
    reservationId?: StringNullableWithAggregatesFilter<"TaskAssignment"> | string | null
    cleaningSessionId?: StringNullableWithAggregatesFilter<"TaskAssignment"> | string | null
    maintenanceSessionId?: StringNullableWithAggregatesFilter<"TaskAssignment"> | string | null
    ticketId?: StringNullableWithAggregatesFilter<"TaskAssignment"> | string | null
    estimatedDuration?: IntNullableWithAggregatesFilter<"TaskAssignment"> | number | null
    actualDuration?: IntNullableWithAggregatesFilter<"TaskAssignment"> | number | null
    notes?: StringNullableWithAggregatesFilter<"TaskAssignment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TaskAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaskAssignment"> | Date | string
  }

  export type PropertyContractWhereInput = {
    AND?: PropertyContractWhereInput | PropertyContractWhereInput[]
    OR?: PropertyContractWhereInput[]
    NOT?: PropertyContractWhereInput | PropertyContractWhereInput[]
    id?: StringFilter<"PropertyContract"> | string
    contractNumber?: StringFilter<"PropertyContract"> | string
    type?: StringFilter<"PropertyContract"> | string
    status?: StringFilter<"PropertyContract"> | string
    startDate?: DateTimeFilter<"PropertyContract"> | Date | string
    endDate?: DateTimeNullableFilter<"PropertyContract"> | Date | string | null
    propertyId?: StringFilter<"PropertyContract"> | string
    propertyOwnerId?: StringFilter<"PropertyContract"> | string
    monthlyFee?: FloatNullableFilter<"PropertyContract"> | number | null
    commissionRate?: FloatNullableFilter<"PropertyContract"> | number | null
    documentUrl?: StringNullableFilter<"PropertyContract"> | string | null
    signedAt?: DateTimeNullableFilter<"PropertyContract"> | Date | string | null
    createdAt?: DateTimeFilter<"PropertyContract"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyContract"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    propertyOwner?: XOR<PropertyOwnerProfileScalarRelationFilter, PropertyOwnerProfileWhereInput>
  }

  export type PropertyContractOrderByWithRelationInput = {
    id?: SortOrder
    contractNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    propertyOwnerId?: SortOrder
    monthlyFee?: SortOrderInput | SortOrder
    commissionRate?: SortOrderInput | SortOrder
    documentUrl?: SortOrderInput | SortOrder
    signedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    propertyOwner?: PropertyOwnerProfileOrderByWithRelationInput
  }

  export type PropertyContractWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contractNumber?: string
    AND?: PropertyContractWhereInput | PropertyContractWhereInput[]
    OR?: PropertyContractWhereInput[]
    NOT?: PropertyContractWhereInput | PropertyContractWhereInput[]
    type?: StringFilter<"PropertyContract"> | string
    status?: StringFilter<"PropertyContract"> | string
    startDate?: DateTimeFilter<"PropertyContract"> | Date | string
    endDate?: DateTimeNullableFilter<"PropertyContract"> | Date | string | null
    propertyId?: StringFilter<"PropertyContract"> | string
    propertyOwnerId?: StringFilter<"PropertyContract"> | string
    monthlyFee?: FloatNullableFilter<"PropertyContract"> | number | null
    commissionRate?: FloatNullableFilter<"PropertyContract"> | number | null
    documentUrl?: StringNullableFilter<"PropertyContract"> | string | null
    signedAt?: DateTimeNullableFilter<"PropertyContract"> | Date | string | null
    createdAt?: DateTimeFilter<"PropertyContract"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyContract"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    propertyOwner?: XOR<PropertyOwnerProfileScalarRelationFilter, PropertyOwnerProfileWhereInput>
  }, "id" | "contractNumber">

  export type PropertyContractOrderByWithAggregationInput = {
    id?: SortOrder
    contractNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    propertyOwnerId?: SortOrder
    monthlyFee?: SortOrderInput | SortOrder
    commissionRate?: SortOrderInput | SortOrder
    documentUrl?: SortOrderInput | SortOrder
    signedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyContractCountOrderByAggregateInput
    _avg?: PropertyContractAvgOrderByAggregateInput
    _max?: PropertyContractMaxOrderByAggregateInput
    _min?: PropertyContractMinOrderByAggregateInput
    _sum?: PropertyContractSumOrderByAggregateInput
  }

  export type PropertyContractScalarWhereWithAggregatesInput = {
    AND?: PropertyContractScalarWhereWithAggregatesInput | PropertyContractScalarWhereWithAggregatesInput[]
    OR?: PropertyContractScalarWhereWithAggregatesInput[]
    NOT?: PropertyContractScalarWhereWithAggregatesInput | PropertyContractScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyContract"> | string
    contractNumber?: StringWithAggregatesFilter<"PropertyContract"> | string
    type?: StringWithAggregatesFilter<"PropertyContract"> | string
    status?: StringWithAggregatesFilter<"PropertyContract"> | string
    startDate?: DateTimeWithAggregatesFilter<"PropertyContract"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"PropertyContract"> | Date | string | null
    propertyId?: StringWithAggregatesFilter<"PropertyContract"> | string
    propertyOwnerId?: StringWithAggregatesFilter<"PropertyContract"> | string
    monthlyFee?: FloatNullableWithAggregatesFilter<"PropertyContract"> | number | null
    commissionRate?: FloatNullableWithAggregatesFilter<"PropertyContract"> | number | null
    documentUrl?: StringNullableWithAggregatesFilter<"PropertyContract"> | string | null
    signedAt?: DateTimeNullableWithAggregatesFilter<"PropertyContract"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PropertyContract"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyContract"> | Date | string
  }

  export type SuperAdminInvoiceWhereInput = {
    AND?: SuperAdminInvoiceWhereInput | SuperAdminInvoiceWhereInput[]
    OR?: SuperAdminInvoiceWhereInput[]
    NOT?: SuperAdminInvoiceWhereInput | SuperAdminInvoiceWhereInput[]
    id?: StringFilter<"SuperAdminInvoice"> | string
    invoiceNumber?: StringFilter<"SuperAdminInvoice"> | string
    status?: StringFilter<"SuperAdminInvoice"> | string
    issueDate?: DateTimeFilter<"SuperAdminInvoice"> | Date | string
    dueDate?: DateTimeFilter<"SuperAdminInvoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"SuperAdminInvoice"> | Date | string | null
    subtotal?: FloatFilter<"SuperAdminInvoice"> | number
    taxRate?: FloatFilter<"SuperAdminInvoice"> | number
    taxAmount?: FloatFilter<"SuperAdminInvoice"> | number
    totalAmount?: FloatFilter<"SuperAdminInvoice"> | number
    paidAmount?: FloatFilter<"SuperAdminInvoice"> | number
    superAdminId?: StringFilter<"SuperAdminInvoice"> | string
    notes?: StringNullableFilter<"SuperAdminInvoice"> | string | null
    createdAt?: DateTimeFilter<"SuperAdminInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"SuperAdminInvoice"> | Date | string
    superAdmin?: XOR<SuperAdminProfileScalarRelationFilter, SuperAdminProfileWhereInput>
    items?: SuperAdminInvoiceItemListRelationFilter
  }

  export type SuperAdminInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    superAdminId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    superAdmin?: SuperAdminProfileOrderByWithRelationInput
    items?: SuperAdminInvoiceItemOrderByRelationAggregateInput
  }

  export type SuperAdminInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: SuperAdminInvoiceWhereInput | SuperAdminInvoiceWhereInput[]
    OR?: SuperAdminInvoiceWhereInput[]
    NOT?: SuperAdminInvoiceWhereInput | SuperAdminInvoiceWhereInput[]
    status?: StringFilter<"SuperAdminInvoice"> | string
    issueDate?: DateTimeFilter<"SuperAdminInvoice"> | Date | string
    dueDate?: DateTimeFilter<"SuperAdminInvoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"SuperAdminInvoice"> | Date | string | null
    subtotal?: FloatFilter<"SuperAdminInvoice"> | number
    taxRate?: FloatFilter<"SuperAdminInvoice"> | number
    taxAmount?: FloatFilter<"SuperAdminInvoice"> | number
    totalAmount?: FloatFilter<"SuperAdminInvoice"> | number
    paidAmount?: FloatFilter<"SuperAdminInvoice"> | number
    superAdminId?: StringFilter<"SuperAdminInvoice"> | string
    notes?: StringNullableFilter<"SuperAdminInvoice"> | string | null
    createdAt?: DateTimeFilter<"SuperAdminInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"SuperAdminInvoice"> | Date | string
    superAdmin?: XOR<SuperAdminProfileScalarRelationFilter, SuperAdminProfileWhereInput>
    items?: SuperAdminInvoiceItemListRelationFilter
  }, "id" | "invoiceNumber">

  export type SuperAdminInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    superAdminId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SuperAdminInvoiceCountOrderByAggregateInput
    _avg?: SuperAdminInvoiceAvgOrderByAggregateInput
    _max?: SuperAdminInvoiceMaxOrderByAggregateInput
    _min?: SuperAdminInvoiceMinOrderByAggregateInput
    _sum?: SuperAdminInvoiceSumOrderByAggregateInput
  }

  export type SuperAdminInvoiceScalarWhereWithAggregatesInput = {
    AND?: SuperAdminInvoiceScalarWhereWithAggregatesInput | SuperAdminInvoiceScalarWhereWithAggregatesInput[]
    OR?: SuperAdminInvoiceScalarWhereWithAggregatesInput[]
    NOT?: SuperAdminInvoiceScalarWhereWithAggregatesInput | SuperAdminInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SuperAdminInvoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"SuperAdminInvoice"> | string
    status?: StringWithAggregatesFilter<"SuperAdminInvoice"> | string
    issueDate?: DateTimeWithAggregatesFilter<"SuperAdminInvoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"SuperAdminInvoice"> | Date | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"SuperAdminInvoice"> | Date | string | null
    subtotal?: FloatWithAggregatesFilter<"SuperAdminInvoice"> | number
    taxRate?: FloatWithAggregatesFilter<"SuperAdminInvoice"> | number
    taxAmount?: FloatWithAggregatesFilter<"SuperAdminInvoice"> | number
    totalAmount?: FloatWithAggregatesFilter<"SuperAdminInvoice"> | number
    paidAmount?: FloatWithAggregatesFilter<"SuperAdminInvoice"> | number
    superAdminId?: StringWithAggregatesFilter<"SuperAdminInvoice"> | string
    notes?: StringNullableWithAggregatesFilter<"SuperAdminInvoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SuperAdminInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SuperAdminInvoice"> | Date | string
  }

  export type SuperAdminInvoiceItemWhereInput = {
    AND?: SuperAdminInvoiceItemWhereInput | SuperAdminInvoiceItemWhereInput[]
    OR?: SuperAdminInvoiceItemWhereInput[]
    NOT?: SuperAdminInvoiceItemWhereInput | SuperAdminInvoiceItemWhereInput[]
    id?: StringFilter<"SuperAdminInvoiceItem"> | string
    description?: StringFilter<"SuperAdminInvoiceItem"> | string
    quantity?: FloatFilter<"SuperAdminInvoiceItem"> | number
    unitPrice?: FloatFilter<"SuperAdminInvoiceItem"> | number
    totalPrice?: FloatFilter<"SuperAdminInvoiceItem"> | number
    poleType?: EnumPoleTypeNullableFilter<"SuperAdminInvoiceItem"> | $Enums.PoleType | null
    invoiceId?: StringFilter<"SuperAdminInvoiceItem"> | string
    invoice?: XOR<SuperAdminInvoiceScalarRelationFilter, SuperAdminInvoiceWhereInput>
  }

  export type SuperAdminInvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    poleType?: SortOrderInput | SortOrder
    invoiceId?: SortOrder
    invoice?: SuperAdminInvoiceOrderByWithRelationInput
  }

  export type SuperAdminInvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SuperAdminInvoiceItemWhereInput | SuperAdminInvoiceItemWhereInput[]
    OR?: SuperAdminInvoiceItemWhereInput[]
    NOT?: SuperAdminInvoiceItemWhereInput | SuperAdminInvoiceItemWhereInput[]
    description?: StringFilter<"SuperAdminInvoiceItem"> | string
    quantity?: FloatFilter<"SuperAdminInvoiceItem"> | number
    unitPrice?: FloatFilter<"SuperAdminInvoiceItem"> | number
    totalPrice?: FloatFilter<"SuperAdminInvoiceItem"> | number
    poleType?: EnumPoleTypeNullableFilter<"SuperAdminInvoiceItem"> | $Enums.PoleType | null
    invoiceId?: StringFilter<"SuperAdminInvoiceItem"> | string
    invoice?: XOR<SuperAdminInvoiceScalarRelationFilter, SuperAdminInvoiceWhereInput>
  }, "id">

  export type SuperAdminInvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    poleType?: SortOrderInput | SortOrder
    invoiceId?: SortOrder
    _count?: SuperAdminInvoiceItemCountOrderByAggregateInput
    _avg?: SuperAdminInvoiceItemAvgOrderByAggregateInput
    _max?: SuperAdminInvoiceItemMaxOrderByAggregateInput
    _min?: SuperAdminInvoiceItemMinOrderByAggregateInput
    _sum?: SuperAdminInvoiceItemSumOrderByAggregateInput
  }

  export type SuperAdminInvoiceItemScalarWhereWithAggregatesInput = {
    AND?: SuperAdminInvoiceItemScalarWhereWithAggregatesInput | SuperAdminInvoiceItemScalarWhereWithAggregatesInput[]
    OR?: SuperAdminInvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: SuperAdminInvoiceItemScalarWhereWithAggregatesInput | SuperAdminInvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SuperAdminInvoiceItem"> | string
    description?: StringWithAggregatesFilter<"SuperAdminInvoiceItem"> | string
    quantity?: FloatWithAggregatesFilter<"SuperAdminInvoiceItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"SuperAdminInvoiceItem"> | number
    totalPrice?: FloatWithAggregatesFilter<"SuperAdminInvoiceItem"> | number
    poleType?: EnumPoleTypeNullableWithAggregatesFilter<"SuperAdminInvoiceItem"> | $Enums.PoleType | null
    invoiceId?: StringWithAggregatesFilter<"SuperAdminInvoiceItem"> | string
  }

  export type LaundryInvoiceWhereInput = {
    AND?: LaundryInvoiceWhereInput | LaundryInvoiceWhereInput[]
    OR?: LaundryInvoiceWhereInput[]
    NOT?: LaundryInvoiceWhereInput | LaundryInvoiceWhereInput[]
    id?: StringFilter<"LaundryInvoice"> | string
    invoiceNumber?: StringFilter<"LaundryInvoice"> | string
    status?: StringFilter<"LaundryInvoice"> | string
    issueDate?: DateTimeFilter<"LaundryInvoice"> | Date | string
    dueDate?: DateTimeFilter<"LaundryInvoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"LaundryInvoice"> | Date | string | null
    subtotal?: FloatFilter<"LaundryInvoice"> | number
    taxRate?: FloatFilter<"LaundryInvoice"> | number
    taxAmount?: FloatFilter<"LaundryInvoice"> | number
    totalAmount?: FloatFilter<"LaundryInvoice"> | number
    paidAmount?: FloatFilter<"LaundryInvoice"> | number
    clientId?: StringFilter<"LaundryInvoice"> | string
    notes?: StringNullableFilter<"LaundryInvoice"> | string | null
    createdAt?: DateTimeFilter<"LaundryInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"LaundryInvoice"> | Date | string
    client?: XOR<LaundryClientProfileScalarRelationFilter, LaundryClientProfileWhereInput>
  }

  export type LaundryInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    clientId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: LaundryClientProfileOrderByWithRelationInput
  }

  export type LaundryInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: LaundryInvoiceWhereInput | LaundryInvoiceWhereInput[]
    OR?: LaundryInvoiceWhereInput[]
    NOT?: LaundryInvoiceWhereInput | LaundryInvoiceWhereInput[]
    status?: StringFilter<"LaundryInvoice"> | string
    issueDate?: DateTimeFilter<"LaundryInvoice"> | Date | string
    dueDate?: DateTimeFilter<"LaundryInvoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"LaundryInvoice"> | Date | string | null
    subtotal?: FloatFilter<"LaundryInvoice"> | number
    taxRate?: FloatFilter<"LaundryInvoice"> | number
    taxAmount?: FloatFilter<"LaundryInvoice"> | number
    totalAmount?: FloatFilter<"LaundryInvoice"> | number
    paidAmount?: FloatFilter<"LaundryInvoice"> | number
    clientId?: StringFilter<"LaundryInvoice"> | string
    notes?: StringNullableFilter<"LaundryInvoice"> | string | null
    createdAt?: DateTimeFilter<"LaundryInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"LaundryInvoice"> | Date | string
    client?: XOR<LaundryClientProfileScalarRelationFilter, LaundryClientProfileWhereInput>
  }, "id" | "invoiceNumber">

  export type LaundryInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    clientId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaundryInvoiceCountOrderByAggregateInput
    _avg?: LaundryInvoiceAvgOrderByAggregateInput
    _max?: LaundryInvoiceMaxOrderByAggregateInput
    _min?: LaundryInvoiceMinOrderByAggregateInput
    _sum?: LaundryInvoiceSumOrderByAggregateInput
  }

  export type LaundryInvoiceScalarWhereWithAggregatesInput = {
    AND?: LaundryInvoiceScalarWhereWithAggregatesInput | LaundryInvoiceScalarWhereWithAggregatesInput[]
    OR?: LaundryInvoiceScalarWhereWithAggregatesInput[]
    NOT?: LaundryInvoiceScalarWhereWithAggregatesInput | LaundryInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LaundryInvoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"LaundryInvoice"> | string
    status?: StringWithAggregatesFilter<"LaundryInvoice"> | string
    issueDate?: DateTimeWithAggregatesFilter<"LaundryInvoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"LaundryInvoice"> | Date | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"LaundryInvoice"> | Date | string | null
    subtotal?: FloatWithAggregatesFilter<"LaundryInvoice"> | number
    taxRate?: FloatWithAggregatesFilter<"LaundryInvoice"> | number
    taxAmount?: FloatWithAggregatesFilter<"LaundryInvoice"> | number
    totalAmount?: FloatWithAggregatesFilter<"LaundryInvoice"> | number
    paidAmount?: FloatWithAggregatesFilter<"LaundryInvoice"> | number
    clientId?: StringWithAggregatesFilter<"LaundryInvoice"> | string
    notes?: StringNullableWithAggregatesFilter<"LaundryInvoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LaundryInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LaundryInvoice"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    priority?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    userId?: StringFilter<"Notification"> | string
    relatedType?: StringNullableFilter<"Notification"> | string | null
    relatedId?: StringNullableFilter<"Notification"> | string | null
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrderInput | SortOrder
    read?: SortOrder
    userId?: SortOrder
    relatedType?: SortOrderInput | SortOrder
    relatedId?: SortOrderInput | SortOrder
    actionUrl?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    priority?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    userId?: StringFilter<"Notification"> | string
    relatedType?: StringNullableFilter<"Notification"> | string | null
    relatedId?: StringNullableFilter<"Notification"> | string | null
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrderInput | SortOrder
    read?: SortOrder
    userId?: SortOrder
    relatedType?: SortOrderInput | SortOrder
    relatedId?: SortOrderInput | SortOrder
    actionUrl?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    priority?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    userId?: StringWithAggregatesFilter<"Notification"> | string
    relatedType?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    relatedId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    superAdminProfile?: SuperAdminProfileCreateNestedOneWithoutUserInput
    poleManagerProfile?: PoleManagerProfileCreateNestedOneWithoutUserInput
    propertyOwnerProfile?: PropertyOwnerProfileCreateNestedOneWithoutUserInput
    laundryClientProfile?: LaundryClientProfileCreateNestedOneWithoutUserInput
    agentProfile?: AgentProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    superAdminProfile?: SuperAdminProfileUncheckedCreateNestedOneWithoutUserInput
    poleManagerProfile?: PoleManagerProfileUncheckedCreateNestedOneWithoutUserInput
    propertyOwnerProfile?: PropertyOwnerProfileUncheckedCreateNestedOneWithoutUserInput
    laundryClientProfile?: LaundryClientProfileUncheckedCreateNestedOneWithoutUserInput
    agentProfile?: AgentProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    superAdminProfile?: SuperAdminProfileUpdateOneWithoutUserNestedInput
    poleManagerProfile?: PoleManagerProfileUpdateOneWithoutUserNestedInput
    propertyOwnerProfile?: PropertyOwnerProfileUpdateOneWithoutUserNestedInput
    laundryClientProfile?: LaundryClientProfileUpdateOneWithoutUserNestedInput
    agentProfile?: AgentProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    superAdminProfile?: SuperAdminProfileUncheckedUpdateOneWithoutUserNestedInput
    poleManagerProfile?: PoleManagerProfileUncheckedUpdateOneWithoutUserNestedInput
    propertyOwnerProfile?: PropertyOwnerProfileUncheckedUpdateOneWithoutUserNestedInput
    laundryClientProfile?: LaundryClientProfileUncheckedUpdateOneWithoutUserNestedInput
    agentProfile?: AgentProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SuperAdminProfileCreateInput = {
    id?: string
    companyName: string
    businessNumber?: string | null
    vatNumber?: string | null
    billingAddress: string
    billingCity: string
    billingCountry?: string
    billingPostal: string
    subscriptionTier?: string
    subscriptionStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSuperAdminProfileInput
    poleSubscriptions?: PoleSubscriptionCreateNestedManyWithoutSuperAdminInput
    poleManagers?: PoleManagerProfileCreateNestedManyWithoutSuperAdminInput
    invoices?: SuperAdminInvoiceCreateNestedManyWithoutSuperAdminInput
  }

  export type SuperAdminProfileUncheckedCreateInput = {
    id?: string
    userId: string
    companyName: string
    businessNumber?: string | null
    vatNumber?: string | null
    billingAddress: string
    billingCity: string
    billingCountry?: string
    billingPostal: string
    subscriptionTier?: string
    subscriptionStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    poleSubscriptions?: PoleSubscriptionUncheckedCreateNestedManyWithoutSuperAdminInput
    poleManagers?: PoleManagerProfileUncheckedCreateNestedManyWithoutSuperAdminInput
    invoices?: SuperAdminInvoiceUncheckedCreateNestedManyWithoutSuperAdminInput
  }

  export type SuperAdminProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    businessNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingCountry?: StringFieldUpdateOperationsInput | string
    billingPostal?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSuperAdminProfileNestedInput
    poleSubscriptions?: PoleSubscriptionUpdateManyWithoutSuperAdminNestedInput
    poleManagers?: PoleManagerProfileUpdateManyWithoutSuperAdminNestedInput
    invoices?: SuperAdminInvoiceUpdateManyWithoutSuperAdminNestedInput
  }

  export type SuperAdminProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    businessNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingCountry?: StringFieldUpdateOperationsInput | string
    billingPostal?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poleSubscriptions?: PoleSubscriptionUncheckedUpdateManyWithoutSuperAdminNestedInput
    poleManagers?: PoleManagerProfileUncheckedUpdateManyWithoutSuperAdminNestedInput
    invoices?: SuperAdminInvoiceUncheckedUpdateManyWithoutSuperAdminNestedInput
  }

  export type SuperAdminProfileCreateManyInput = {
    id?: string
    userId: string
    companyName: string
    businessNumber?: string | null
    vatNumber?: string | null
    billingAddress: string
    billingCity: string
    billingCountry?: string
    billingPostal: string
    subscriptionTier?: string
    subscriptionStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuperAdminProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    businessNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingCountry?: StringFieldUpdateOperationsInput | string
    billingPostal?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuperAdminProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    businessNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingCountry?: StringFieldUpdateOperationsInput | string
    billingPostal?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PoleSubscriptionCreateInput = {
    id?: string
    poleType: $Enums.PoleType
    status?: $Enums.PoleStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    monthlyPrice: number
    lastBillingDate?: Date | string | null
    nextBillingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdmin: SuperAdminProfileCreateNestedOneWithoutPoleSubscriptionsInput
  }

  export type PoleSubscriptionUncheckedCreateInput = {
    id?: string
    poleType: $Enums.PoleType
    status?: $Enums.PoleStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    monthlyPrice: number
    lastBillingDate?: Date | string | null
    nextBillingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdminId: string
  }

  export type PoleSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleType?: EnumPoleTypeFieldUpdateOperationsInput | $Enums.PoleType
    status?: EnumPoleStatusFieldUpdateOperationsInput | $Enums.PoleStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyPrice?: FloatFieldUpdateOperationsInput | number
    lastBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdmin?: SuperAdminProfileUpdateOneRequiredWithoutPoleSubscriptionsNestedInput
  }

  export type PoleSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleType?: EnumPoleTypeFieldUpdateOperationsInput | $Enums.PoleType
    status?: EnumPoleStatusFieldUpdateOperationsInput | $Enums.PoleStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyPrice?: FloatFieldUpdateOperationsInput | number
    lastBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type PoleSubscriptionCreateManyInput = {
    id?: string
    poleType: $Enums.PoleType
    status?: $Enums.PoleStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    monthlyPrice: number
    lastBillingDate?: Date | string | null
    nextBillingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdminId: string
  }

  export type PoleSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleType?: EnumPoleTypeFieldUpdateOperationsInput | $Enums.PoleType
    status?: EnumPoleStatusFieldUpdateOperationsInput | $Enums.PoleStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyPrice?: FloatFieldUpdateOperationsInput | number
    lastBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PoleSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleType?: EnumPoleTypeFieldUpdateOperationsInput | $Enums.PoleType
    status?: EnumPoleStatusFieldUpdateOperationsInput | $Enums.PoleStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyPrice?: FloatFieldUpdateOperationsInput | number
    lastBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type PoleManagerProfileCreateInput = {
    id?: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPoleManagerProfileInput
    superAdmin: SuperAdminProfileCreateNestedOneWithoutPoleManagersInput
    properties?: PropertyCreateNestedManyWithoutManagerInput
    reservations?: ReservationCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutManagerInput
    tickets?: TicketCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileUncheckedCreateInput = {
    id?: string
    userId: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdminId: string
    properties?: PropertyUncheckedCreateNestedManyWithoutManagerInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutManagerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderUncheckedCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileUncheckedCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPoleManagerProfileNestedInput
    superAdmin?: SuperAdminProfileUpdateOneRequiredWithoutPoleManagersNestedInput
    properties?: PropertyUpdateManyWithoutManagerNestedInput
    reservations?: ReservationUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutManagerNestedInput
    tickets?: TicketUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUpdateManyWithoutManagerNestedInput
  }

  export type PoleManagerProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdminId?: StringFieldUpdateOperationsInput | string
    properties?: PropertyUncheckedUpdateManyWithoutManagerNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutManagerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUncheckedUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type PoleManagerProfileCreateManyInput = {
    id?: string
    userId: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdminId: string
  }

  export type PoleManagerProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PoleManagerProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyOwnerProfileCreateInput = {
    id?: string
    company?: string | null
    taxNumber?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    postal?: string | null
    preferredContactMethod?: string | null
    receiveNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertyOwnerProfileInput
    properties?: PropertyCreateNestedManyWithoutOwnerInput
    contracts?: PropertyContractCreateNestedManyWithoutPropertyOwnerInput
  }

  export type PropertyOwnerProfileUncheckedCreateInput = {
    id?: string
    userId: string
    company?: string | null
    taxNumber?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    postal?: string | null
    preferredContactMethod?: string | null
    receiveNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    contracts?: PropertyContractUncheckedCreateNestedManyWithoutPropertyOwnerInput
  }

  export type PropertyOwnerProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiveNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertyOwnerProfileNestedInput
    properties?: PropertyUpdateManyWithoutOwnerNestedInput
    contracts?: PropertyContractUpdateManyWithoutPropertyOwnerNestedInput
  }

  export type PropertyOwnerProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiveNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    contracts?: PropertyContractUncheckedUpdateManyWithoutPropertyOwnerNestedInput
  }

  export type PropertyOwnerProfileCreateManyInput = {
    id?: string
    userId: string
    company?: string | null
    taxNumber?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    postal?: string | null
    preferredContactMethod?: string | null
    receiveNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyOwnerProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiveNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyOwnerProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiveNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryClientProfileCreateInput = {
    id?: string
    companyName?: string | null
    contactPerson?: string | null
    defaultPickupAddress?: string | null
    defaultDeliveryAddress: string
    preferredPickupTime?: string | null
    specialInstructions?: string | null
    creditLimit?: number | null
    paymentTerms?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLaundryClientProfileInput
    laundryOrders?: LaundryOrderCreateNestedManyWithoutClientInput
    laundryInvoices?: LaundryInvoiceCreateNestedManyWithoutClientInput
  }

  export type LaundryClientProfileUncheckedCreateInput = {
    id?: string
    userId: string
    companyName?: string | null
    contactPerson?: string | null
    defaultPickupAddress?: string | null
    defaultDeliveryAddress: string
    preferredPickupTime?: string | null
    specialInstructions?: string | null
    creditLimit?: number | null
    paymentTerms?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryOrders?: LaundryOrderUncheckedCreateNestedManyWithoutClientInput
    laundryInvoices?: LaundryInvoiceUncheckedCreateNestedManyWithoutClientInput
  }

  export type LaundryClientProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDeliveryAddress?: StringFieldUpdateOperationsInput | string
    preferredPickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLaundryClientProfileNestedInput
    laundryOrders?: LaundryOrderUpdateManyWithoutClientNestedInput
    laundryInvoices?: LaundryInvoiceUpdateManyWithoutClientNestedInput
  }

  export type LaundryClientProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDeliveryAddress?: StringFieldUpdateOperationsInput | string
    preferredPickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryOrders?: LaundryOrderUncheckedUpdateManyWithoutClientNestedInput
    laundryInvoices?: LaundryInvoiceUncheckedUpdateManyWithoutClientNestedInput
  }

  export type LaundryClientProfileCreateManyInput = {
    id?: string
    userId: string
    companyName?: string | null
    contactPerson?: string | null
    defaultPickupAddress?: string | null
    defaultDeliveryAddress: string
    preferredPickupTime?: string | null
    specialInstructions?: string | null
    creditLimit?: number | null
    paymentTerms?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryClientProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDeliveryAddress?: StringFieldUpdateOperationsInput | string
    preferredPickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryClientProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDeliveryAddress?: StringFieldUpdateOperationsInput | string
    preferredPickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentProfileCreateInput = {
    id?: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentProfileInput
    specialties?: AgentSpecialtyCreateNestedManyWithoutAgentInput
    manager: PoleManagerProfileCreateNestedOneWithoutManagedAgentsInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutAgentInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutAgentInput
    tickets?: TicketCreateNestedManyWithoutAgentInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutAgentInput
  }

  export type AgentProfileUncheckedCreateInput = {
    id?: string
    userId: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    specialties?: AgentSpecialtyUncheckedCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutAgentInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAgentInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentProfileNestedInput
    specialties?: AgentSpecialtyUpdateManyWithoutAgentNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutManagedAgentsNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutAgentNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutAgentNestedInput
    tickets?: TicketUpdateManyWithoutAgentNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutAgentNestedInput
  }

  export type AgentProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    specialties?: AgentSpecialtyUncheckedUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAgentNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentProfileCreateManyInput = {
    id?: string
    userId: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
  }

  export type AgentProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
  }

  export type AgentSpecialtyCreateInput = {
    id?: string
    name: string
    category?: string | null
    level?: string | null
    certified?: boolean
    agent: AgentProfileCreateNestedOneWithoutSpecialtiesInput
  }

  export type AgentSpecialtyUncheckedCreateInput = {
    id?: string
    name: string
    category?: string | null
    level?: string | null
    certified?: boolean
    agentId: string
  }

  export type AgentSpecialtyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    agent?: AgentProfileUpdateOneRequiredWithoutSpecialtiesNestedInput
  }

  export type AgentSpecialtyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    agentId?: StringFieldUpdateOperationsInput | string
  }

  export type AgentSpecialtyCreateManyInput = {
    id?: string
    name: string
    category?: string | null
    level?: string | null
    certified?: boolean
    agentId: string
  }

  export type AgentSpecialtyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    certified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AgentSpecialtyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    agentId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyCreateInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoCreateNestedManyWithoutPropertyInput
    owner: PropertyOwnerProfileCreateNestedOneWithoutPropertiesInput
    manager?: PoleManagerProfileCreateNestedOneWithoutPropertiesInput
    reservations?: ReservationCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutPropertyInput
    tickets?: TicketCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    managerId?: string | null
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewUncheckedCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUpdateManyWithoutPropertyNestedInput
    owner?: PropertyOwnerProfileUpdateOneRequiredWithoutPropertiesNestedInput
    manager?: PoleManagerProfileUpdateOneWithoutPropertiesNestedInput
    reservations?: ReservationUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUncheckedUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateManyInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    managerId?: string | null
  }

  export type PropertyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyFeatureCreateInput = {
    id?: string
    name: string
    icon?: string | null
    category?: string | null
    property: PropertyCreateNestedOneWithoutFeaturesInput
  }

  export type PropertyFeatureUncheckedCreateInput = {
    id?: string
    name: string
    icon?: string | null
    category?: string | null
    propertyId: string
  }

  export type PropertyFeatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    property?: PropertyUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type PropertyFeatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyFeatureCreateManyInput = {
    id?: string
    name: string
    icon?: string | null
    category?: string | null
    propertyId: string
  }

  export type PropertyFeatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyFeatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyPhotoCreateInput = {
    id?: string
    url: string
    caption?: string | null
    isMain?: boolean
    order?: number
    type?: string | null
    createdAt?: Date | string
    property: PropertyCreateNestedOneWithoutPhotosInput
  }

  export type PropertyPhotoUncheckedCreateInput = {
    id?: string
    url: string
    caption?: string | null
    isMain?: boolean
    order?: number
    type?: string | null
    propertyId: string
    createdAt?: Date | string
  }

  export type PropertyPhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type PropertyPhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPhotoCreateManyInput = {
    id?: string
    url: string
    caption?: string | null
    isMain?: boolean
    order?: number
    type?: string | null
    propertyId: string
    createdAt?: Date | string
  }

  export type PropertyPhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    guestName: string
    guestEmail?: string | null
    createdAt?: Date | string
    property: PropertyCreateNestedOneWithoutReviewsInput
  }

  export type PropertyReviewUncheckedCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    guestName: string
    guestEmail?: string | null
    propertyId: string
    createdAt?: Date | string
  }

  export type PropertyReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type PropertyReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyReviewCreateManyInput = {
    id?: string
    rating: number
    comment?: string | null
    guestName: string
    guestEmail?: string | null
    propertyId: string
    createdAt?: Date | string
  }

  export type PropertyReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateInput = {
    id?: string
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    guestCount?: number
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    totalPrice: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    confirmationCode?: string | null
    bookingSource?: string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutReservationsInput
    manager: PoleManagerProfileCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateInput = {
    id?: string
    propertyId: string
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    guestCount?: number
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    totalPrice: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    confirmationCode?: string | null
    bookingSource?: string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
  }

  export type ReservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingSource?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutReservationsNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingSource?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
  }

  export type ReservationCreateManyInput = {
    id?: string
    propertyId: string
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    guestCount?: number
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    totalPrice: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    confirmationCode?: string | null
    bookingSource?: string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
  }

  export type ReservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingSource?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingSource?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
  }

  export type CleaningSessionCreateInput = {
    id?: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    cleaningType: string
    status?: $Enums.SessionStatus
    notes?: string | null
    agentNotes?: string | null
    ownerRating?: number | null
    managerRating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutCleaningSessionsInput
    agent: AgentProfileCreateNestedOneWithoutCleaningSessionsInput
    checklist?: CleaningChecklistCreateNestedManyWithoutCleaningSessionInput
    photos?: CleaningPhotoCreateNestedManyWithoutCleaningSessionInput
    manager: PoleManagerProfileCreateNestedOneWithoutCleaningSessionsInput
  }

  export type CleaningSessionUncheckedCreateInput = {
    id?: string
    propertyId: string
    agentId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    cleaningType: string
    status?: $Enums.SessionStatus
    notes?: string | null
    agentNotes?: string | null
    ownerRating?: number | null
    managerRating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    checklist?: CleaningChecklistUncheckedCreateNestedManyWithoutCleaningSessionInput
    photos?: CleaningPhotoUncheckedCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cleaningType?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    managerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutCleaningSessionsNestedInput
    agent?: AgentProfileUpdateOneRequiredWithoutCleaningSessionsNestedInput
    checklist?: CleaningChecklistUpdateManyWithoutCleaningSessionNestedInput
    photos?: CleaningPhotoUpdateManyWithoutCleaningSessionNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutCleaningSessionsNestedInput
  }

  export type CleaningSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cleaningType?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    managerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    checklist?: CleaningChecklistUncheckedUpdateManyWithoutCleaningSessionNestedInput
    photos?: CleaningPhotoUncheckedUpdateManyWithoutCleaningSessionNestedInput
  }

  export type CleaningSessionCreateManyInput = {
    id?: string
    propertyId: string
    agentId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    cleaningType: string
    status?: $Enums.SessionStatus
    notes?: string | null
    agentNotes?: string | null
    ownerRating?: number | null
    managerRating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
  }

  export type CleaningSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cleaningType?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    managerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cleaningType?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    managerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
  }

  export type CleaningChecklistCreateInput = {
    id?: string
    item: string
    completed?: boolean
    notes?: string | null
    order?: number
    cleaningSession: CleaningSessionCreateNestedOneWithoutChecklistInput
  }

  export type CleaningChecklistUncheckedCreateInput = {
    id?: string
    item: string
    completed?: boolean
    notes?: string | null
    order?: number
    cleaningSessionId: string
  }

  export type CleaningChecklistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    cleaningSession?: CleaningSessionUpdateOneRequiredWithoutChecklistNestedInput
  }

  export type CleaningChecklistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    cleaningSessionId?: StringFieldUpdateOperationsInput | string
  }

  export type CleaningChecklistCreateManyInput = {
    id?: string
    item: string
    completed?: boolean
    notes?: string | null
    order?: number
    cleaningSessionId: string
  }

  export type CleaningChecklistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type CleaningChecklistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    cleaningSessionId?: StringFieldUpdateOperationsInput | string
  }

  export type CleaningPhotoCreateInput = {
    id?: string
    url: string
    type?: string | null
    caption?: string | null
    createdAt?: Date | string
    cleaningSession: CleaningSessionCreateNestedOneWithoutPhotosInput
  }

  export type CleaningPhotoUncheckedCreateInput = {
    id?: string
    url: string
    type?: string | null
    caption?: string | null
    cleaningSessionId: string
    createdAt?: Date | string
  }

  export type CleaningPhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cleaningSession?: CleaningSessionUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type CleaningPhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningSessionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningPhotoCreateManyInput = {
    id?: string
    url: string
    type?: string | null
    caption?: string | null
    cleaningSessionId: string
    createdAt?: Date | string
  }

  export type CleaningPhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningPhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningSessionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    reportedBy: string
    reportedAt?: Date | string
    assignedAt?: Date | string | null
    category?: string | null
    issueType?: string | null
    roomLocation?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    estimatedCost?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutTicketsInput
    agent?: AgentProfileCreateNestedOneWithoutTicketsInput
    photos?: TicketPhotoCreateNestedManyWithoutTicketInput
    manager: PoleManagerProfileCreateNestedOneWithoutTicketsInput
    maintenanceSession?: MaintenanceSessionCreateNestedOneWithoutTicketInput
  }

  export type TicketUncheckedCreateInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    propertyId: string
    reportedBy: string
    reportedAt?: Date | string
    agentId?: string | null
    assignedAt?: Date | string | null
    category?: string | null
    issueType?: string | null
    roomLocation?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    estimatedCost?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    photos?: TicketPhotoUncheckedCreateNestedManyWithoutTicketInput
    maintenanceSession?: MaintenanceSessionUncheckedCreateNestedOneWithoutTicketInput
  }

  export type TicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    roomLocation?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutTicketsNestedInput
    agent?: AgentProfileUpdateOneWithoutTicketsNestedInput
    photos?: TicketPhotoUpdateManyWithoutTicketNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutTicketsNestedInput
    maintenanceSession?: MaintenanceSessionUpdateOneWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    propertyId?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    roomLocation?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    photos?: TicketPhotoUncheckedUpdateManyWithoutTicketNestedInput
    maintenanceSession?: MaintenanceSessionUncheckedUpdateOneWithoutTicketNestedInput
  }

  export type TicketCreateManyInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    propertyId: string
    reportedBy: string
    reportedAt?: Date | string
    agentId?: string | null
    assignedAt?: Date | string | null
    category?: string | null
    issueType?: string | null
    roomLocation?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    estimatedCost?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
  }

  export type TicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    roomLocation?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    propertyId?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    roomLocation?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketPhotoCreateInput = {
    id?: string
    url: string
    caption?: string | null
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutPhotosInput
  }

  export type TicketPhotoUncheckedCreateInput = {
    id?: string
    url: string
    caption?: string | null
    ticketId: string
    createdAt?: Date | string
  }

  export type TicketPhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type TicketPhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketPhotoCreateManyInput = {
    id?: string
    url: string
    caption?: string | null
    ticketId: string
    createdAt?: Date | string
  }

  export type TicketPhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketPhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceSessionCreateInput = {
    id?: string
    sessionNumber: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutMaintenanceSessionInput
    property: PropertyCreateNestedOneWithoutMaintenanceSessionsInput
    agent: AgentProfileCreateNestedOneWithoutMaintenanceSessionsInput
    materials?: MaintenanceMaterialCreateNestedManyWithoutMaintenanceSessionInput
    photos?: MaintenancePhotoCreateNestedManyWithoutMaintenanceSessionInput
    manager: PoleManagerProfileCreateNestedOneWithoutMaintenanceSessionsInput
  }

  export type MaintenanceSessionUncheckedCreateInput = {
    id?: string
    sessionNumber: string
    ticketId: string
    propertyId: string
    agentId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    materials?: MaintenanceMaterialUncheckedCreateNestedManyWithoutMaintenanceSessionInput
    photos?: MaintenancePhotoUncheckedCreateNestedManyWithoutMaintenanceSessionInput
  }

  export type MaintenanceSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutMaintenanceSessionNestedInput
    property?: PropertyUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    agent?: AgentProfileUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    materials?: MaintenanceMaterialUpdateManyWithoutMaintenanceSessionNestedInput
    photos?: MaintenancePhotoUpdateManyWithoutMaintenanceSessionNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    materials?: MaintenanceMaterialUncheckedUpdateManyWithoutMaintenanceSessionNestedInput
    photos?: MaintenancePhotoUncheckedUpdateManyWithoutMaintenanceSessionNestedInput
  }

  export type MaintenanceSessionCreateManyInput = {
    id?: string
    sessionNumber: string
    ticketId: string
    propertyId: string
    agentId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
  }

  export type MaintenanceSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceMaterialCreateInput = {
    id?: string
    name: string
    quantity: number
    unit: string
    unitPrice: number
    totalPrice: number
    supplier?: string | null
    maintenanceSession: MaintenanceSessionCreateNestedOneWithoutMaterialsInput
  }

  export type MaintenanceMaterialUncheckedCreateInput = {
    id?: string
    name: string
    quantity: number
    unit: string
    unitPrice: number
    totalPrice: number
    supplier?: string | null
    maintenanceSessionId: string
  }

  export type MaintenanceMaterialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSession?: MaintenanceSessionUpdateOneRequiredWithoutMaterialsNestedInput
  }

  export type MaintenanceMaterialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessionId?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceMaterialCreateManyInput = {
    id?: string
    name: string
    quantity: number
    unit: string
    unitPrice: number
    totalPrice: number
    supplier?: string | null
    maintenanceSessionId: string
  }

  export type MaintenanceMaterialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceMaterialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessionId?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenancePhotoCreateInput = {
    id?: string
    url: string
    type?: string | null
    caption?: string | null
    createdAt?: Date | string
    maintenanceSession: MaintenanceSessionCreateNestedOneWithoutPhotosInput
  }

  export type MaintenancePhotoUncheckedCreateInput = {
    id?: string
    url: string
    type?: string | null
    caption?: string | null
    maintenanceSessionId: string
    createdAt?: Date | string
  }

  export type MaintenancePhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceSession?: MaintenanceSessionUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type MaintenancePhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenancePhotoCreateManyInput = {
    id?: string
    url: string
    type?: string | null
    caption?: string | null
    maintenanceSessionId: string
    createdAt?: Date | string
  }

  export type MaintenancePhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenancePhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryProductCreateInput = {
    id?: string
    name: string
    description: string
    price: number
    stock?: number
    category?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: LaundryOrderItemCreateNestedManyWithoutProductInput
  }

  export type LaundryProductUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    price: number
    stock?: number
    category?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: LaundryOrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type LaundryProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: LaundryOrderItemUpdateManyWithoutProductNestedInput
  }

  export type LaundryProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: LaundryOrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type LaundryProductCreateManyInput = {
    id?: string
    name: string
    description: string
    price: number
    stock?: number
    category?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryOrderCreateInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    processedDate?: Date | string | null
    readyDate?: Date | string | null
    deliveryDate?: Date | string | null
    pickupAddress?: string | null
    deliveryAddress: string
    instructions?: string | null
    subtotal: number
    taxes?: number | null
    deliveryFee?: number | null
    totalAmount: number
    notes?: string | null
    receivedByClient?: boolean
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager: PoleManagerProfileCreateNestedOneWithoutLaundryOrdersInput
    client: LaundryClientProfileCreateNestedOneWithoutLaundryOrdersInput
    items?: LaundryOrderItemCreateNestedManyWithoutOrderInput
    deliveryNotes?: DeliveryNoteCreateNestedManyWithoutOrderInput
  }

  export type LaundryOrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    processedDate?: Date | string | null
    readyDate?: Date | string | null
    deliveryDate?: Date | string | null
    pickupAddress?: string | null
    deliveryAddress: string
    instructions?: string | null
    subtotal: number
    taxes?: number | null
    deliveryFee?: number | null
    totalAmount: number
    notes?: string | null
    receivedByClient?: boolean
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    clientId: string
    items?: LaundryOrderItemUncheckedCreateNestedManyWithoutOrderInput
    deliveryNotes?: DeliveryNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LaundryOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByClient?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: PoleManagerProfileUpdateOneRequiredWithoutLaundryOrdersNestedInput
    client?: LaundryClientProfileUpdateOneRequiredWithoutLaundryOrdersNestedInput
    items?: LaundryOrderItemUpdateManyWithoutOrderNestedInput
    deliveryNotes?: DeliveryNoteUpdateManyWithoutOrderNestedInput
  }

  export type LaundryOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByClient?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    items?: LaundryOrderItemUncheckedUpdateManyWithoutOrderNestedInput
    deliveryNotes?: DeliveryNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LaundryOrderCreateManyInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    processedDate?: Date | string | null
    readyDate?: Date | string | null
    deliveryDate?: Date | string | null
    pickupAddress?: string | null
    deliveryAddress: string
    instructions?: string | null
    subtotal: number
    taxes?: number | null
    deliveryFee?: number | null
    totalAmount: number
    notes?: string | null
    receivedByClient?: boolean
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    clientId: string
  }

  export type LaundryOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByClient?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByClient?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type LaundryOrderItemCreateInput = {
    id?: string
    quantity: number
    unitPrice: number
    subtotal: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: LaundryOrderCreateNestedOneWithoutItemsInput
    product: LaundryProductCreateNestedOneWithoutOrderItemsInput
  }

  export type LaundryOrderItemUncheckedCreateInput = {
    id?: string
    quantity: number
    unitPrice: number
    subtotal: number
    notes?: string | null
    orderId: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryOrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: LaundryOrderUpdateOneRequiredWithoutItemsNestedInput
    product?: LaundryProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type LaundryOrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryOrderItemCreateManyInput = {
    id?: string
    quantity: number
    unitPrice: number
    subtotal: number
    notes?: string | null
    orderId: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryOrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryOrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryNoteCreateInput = {
    id?: string
    number: string
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: LaundryOrderCreateNestedOneWithoutDeliveryNotesInput
  }

  export type DeliveryNoteUncheckedCreateInput = {
    id?: string
    number: string
    date: Date | string
    notes?: string | null
    orderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: LaundryOrderUpdateOneRequiredWithoutDeliveryNotesNestedInput
  }

  export type DeliveryNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryNoteCreateManyInput = {
    id?: string
    number: string
    date: Date | string
    notes?: string | null
    orderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    priority?: string
    status?: string
    assignedAt?: Date | string
    dueDate?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    propertyId?: string | null
    reservationId?: string | null
    cleaningSessionId?: string | null
    maintenanceSessionId?: string | null
    ticketId?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentProfileCreateNestedOneWithoutTaskAssignmentsInput
  }

  export type TaskAssignmentUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    priority?: string
    status?: string
    assignedAt?: Date | string
    dueDate?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    agentId: string
    propertyId?: string | null
    reservationId?: string | null
    cleaningSessionId?: string | null
    maintenanceSessionId?: string | null
    ticketId?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentProfileUpdateOneRequiredWithoutTaskAssignmentsNestedInput
  }

  export type TaskAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agentId?: StringFieldUpdateOperationsInput | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    priority?: string
    status?: string
    assignedAt?: Date | string
    dueDate?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    agentId: string
    propertyId?: string | null
    reservationId?: string | null
    cleaningSessionId?: string | null
    maintenanceSessionId?: string | null
    ticketId?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agentId?: StringFieldUpdateOperationsInput | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyContractCreateInput = {
    id?: string
    contractNumber: string
    type: string
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    monthlyFee?: number | null
    commissionRate?: number | null
    documentUrl?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutContractsInput
    propertyOwner: PropertyOwnerProfileCreateNestedOneWithoutContractsInput
  }

  export type PropertyContractUncheckedCreateInput = {
    id?: string
    contractNumber: string
    type: string
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    propertyId: string
    propertyOwnerId: string
    monthlyFee?: number | null
    commissionRate?: number | null
    documentUrl?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyContractUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutContractsNestedInput
    propertyOwner?: PropertyOwnerProfileUpdateOneRequiredWithoutContractsNestedInput
  }

  export type PropertyContractUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    propertyOwnerId?: StringFieldUpdateOperationsInput | string
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyContractCreateManyInput = {
    id?: string
    contractNumber: string
    type: string
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    propertyId: string
    propertyOwnerId: string
    monthlyFee?: number | null
    commissionRate?: number | null
    documentUrl?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyContractUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyContractUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    propertyOwnerId?: StringFieldUpdateOperationsInput | string
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuperAdminInvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    subtotal: number
    taxRate?: number
    taxAmount: number
    totalAmount: number
    paidAmount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdmin: SuperAdminProfileCreateNestedOneWithoutInvoicesInput
    items?: SuperAdminInvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type SuperAdminInvoiceUncheckedCreateInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    subtotal: number
    taxRate?: number
    taxAmount: number
    totalAmount: number
    paidAmount?: number
    superAdminId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SuperAdminInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type SuperAdminInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdmin?: SuperAdminProfileUpdateOneRequiredWithoutInvoicesNestedInput
    items?: SuperAdminInvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type SuperAdminInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    superAdminId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SuperAdminInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type SuperAdminInvoiceCreateManyInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    subtotal: number
    taxRate?: number
    taxAmount: number
    totalAmount: number
    paidAmount?: number
    superAdminId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuperAdminInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuperAdminInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    superAdminId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuperAdminInvoiceItemCreateInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: number
    totalPrice: number
    poleType?: $Enums.PoleType | null
    invoice: SuperAdminInvoiceCreateNestedOneWithoutItemsInput
  }

  export type SuperAdminInvoiceItemUncheckedCreateInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: number
    totalPrice: number
    poleType?: $Enums.PoleType | null
    invoiceId: string
  }

  export type SuperAdminInvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    poleType?: NullableEnumPoleTypeFieldUpdateOperationsInput | $Enums.PoleType | null
    invoice?: SuperAdminInvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type SuperAdminInvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    poleType?: NullableEnumPoleTypeFieldUpdateOperationsInput | $Enums.PoleType | null
    invoiceId?: StringFieldUpdateOperationsInput | string
  }

  export type SuperAdminInvoiceItemCreateManyInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: number
    totalPrice: number
    poleType?: $Enums.PoleType | null
    invoiceId: string
  }

  export type SuperAdminInvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    poleType?: NullableEnumPoleTypeFieldUpdateOperationsInput | $Enums.PoleType | null
  }

  export type SuperAdminInvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    poleType?: NullableEnumPoleTypeFieldUpdateOperationsInput | $Enums.PoleType | null
    invoiceId?: StringFieldUpdateOperationsInput | string
  }

  export type LaundryInvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    subtotal: number
    taxRate?: number
    taxAmount: number
    totalAmount: number
    paidAmount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: LaundryClientProfileCreateNestedOneWithoutLaundryInvoicesInput
  }

  export type LaundryInvoiceUncheckedCreateInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    subtotal: number
    taxRate?: number
    taxAmount: number
    totalAmount: number
    paidAmount?: number
    clientId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: LaundryClientProfileUpdateOneRequiredWithoutLaundryInvoicesNestedInput
  }

  export type LaundryInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    clientId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryInvoiceCreateManyInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    subtotal: number
    taxRate?: number
    taxAmount: number
    totalAmount: number
    paidAmount?: number
    clientId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    clientId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    priority?: string | null
    read?: boolean
    relatedType?: string | null
    relatedId?: string | null
    actionUrl?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    priority?: string | null
    read?: boolean
    userId: string
    relatedType?: string | null
    relatedId?: string | null
    actionUrl?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    priority?: string | null
    read?: boolean
    userId: string
    relatedType?: string | null
    relatedId?: string | null
    actionUrl?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SuperAdminProfileNullableScalarRelationFilter = {
    is?: SuperAdminProfileWhereInput | null
    isNot?: SuperAdminProfileWhereInput | null
  }

  export type PoleManagerProfileNullableScalarRelationFilter = {
    is?: PoleManagerProfileWhereInput | null
    isNot?: PoleManagerProfileWhereInput | null
  }

  export type PropertyOwnerProfileNullableScalarRelationFilter = {
    is?: PropertyOwnerProfileWhereInput | null
    isNot?: PropertyOwnerProfileWhereInput | null
  }

  export type LaundryClientProfileNullableScalarRelationFilter = {
    is?: LaundryClientProfileWhereInput | null
    isNot?: LaundryClientProfileWhereInput | null
  }

  export type AgentProfileNullableScalarRelationFilter = {
    is?: AgentProfileWhereInput | null
    isNot?: AgentProfileWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PoleSubscriptionListRelationFilter = {
    every?: PoleSubscriptionWhereInput
    some?: PoleSubscriptionWhereInput
    none?: PoleSubscriptionWhereInput
  }

  export type PoleManagerProfileListRelationFilter = {
    every?: PoleManagerProfileWhereInput
    some?: PoleManagerProfileWhereInput
    none?: PoleManagerProfileWhereInput
  }

  export type SuperAdminInvoiceListRelationFilter = {
    every?: SuperAdminInvoiceWhereInput
    some?: SuperAdminInvoiceWhereInput
    none?: SuperAdminInvoiceWhereInput
  }

  export type PoleSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PoleManagerProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuperAdminInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuperAdminProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    businessNumber?: SortOrder
    vatNumber?: SortOrder
    billingAddress?: SortOrder
    billingCity?: SortOrder
    billingCountry?: SortOrder
    billingPostal?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuperAdminProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    businessNumber?: SortOrder
    vatNumber?: SortOrder
    billingAddress?: SortOrder
    billingCity?: SortOrder
    billingCountry?: SortOrder
    billingPostal?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuperAdminProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    businessNumber?: SortOrder
    vatNumber?: SortOrder
    billingAddress?: SortOrder
    billingCity?: SortOrder
    billingCountry?: SortOrder
    billingPostal?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPoleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PoleType | EnumPoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPoleTypeFilter<$PrismaModel> | $Enums.PoleType
  }

  export type EnumPoleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PoleStatus | EnumPoleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PoleStatus[] | ListEnumPoleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoleStatus[] | ListEnumPoleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPoleStatusFilter<$PrismaModel> | $Enums.PoleStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SuperAdminProfileScalarRelationFilter = {
    is?: SuperAdminProfileWhereInput
    isNot?: SuperAdminProfileWhereInput
  }

  export type PoleSubscriptionSuperAdminIdPoleTypeCompoundUniqueInput = {
    superAdminId: string
    poleType: $Enums.PoleType
  }

  export type PoleSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    poleType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trialEndDate?: SortOrder
    monthlyPrice?: SortOrder
    lastBillingDate?: SortOrder
    nextBillingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    superAdminId?: SortOrder
  }

  export type PoleSubscriptionAvgOrderByAggregateInput = {
    monthlyPrice?: SortOrder
  }

  export type PoleSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    poleType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trialEndDate?: SortOrder
    monthlyPrice?: SortOrder
    lastBillingDate?: SortOrder
    nextBillingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    superAdminId?: SortOrder
  }

  export type PoleSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    poleType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trialEndDate?: SortOrder
    monthlyPrice?: SortOrder
    lastBillingDate?: SortOrder
    nextBillingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    superAdminId?: SortOrder
  }

  export type PoleSubscriptionSumOrderByAggregateInput = {
    monthlyPrice?: SortOrder
  }

  export type EnumPoleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoleType | EnumPoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPoleTypeWithAggregatesFilter<$PrismaModel> | $Enums.PoleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoleTypeFilter<$PrismaModel>
    _max?: NestedEnumPoleTypeFilter<$PrismaModel>
  }

  export type EnumPoleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoleStatus | EnumPoleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PoleStatus[] | ListEnumPoleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoleStatus[] | ListEnumPoleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPoleStatusWithAggregatesFilter<$PrismaModel> | $Enums.PoleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoleStatusFilter<$PrismaModel>
    _max?: NestedEnumPoleStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPoleTypeNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel> | null
    has?: $Enums.PoleType | EnumPoleTypeFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel>
    hasSome?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type ReservationListRelationFilter = {
    every?: ReservationWhereInput
    some?: ReservationWhereInput
    none?: ReservationWhereInput
  }

  export type CleaningSessionListRelationFilter = {
    every?: CleaningSessionWhereInput
    some?: CleaningSessionWhereInput
    none?: CleaningSessionWhereInput
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type MaintenanceSessionListRelationFilter = {
    every?: MaintenanceSessionWhereInput
    some?: MaintenanceSessionWhereInput
    none?: MaintenanceSessionWhereInput
  }

  export type LaundryOrderListRelationFilter = {
    every?: LaundryOrderWhereInput
    some?: LaundryOrderWhereInput
    none?: LaundryOrderWhereInput
  }

  export type AgentProfileListRelationFilter = {
    every?: AgentProfileWhereInput
    some?: AgentProfileWhereInput
    none?: AgentProfileWhereInput
  }

  export type PropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CleaningSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenanceSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaundryOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PoleManagerProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    poleTypes?: SortOrder
    canViewAnalytics?: SortOrder
    canManageAgents?: SortOrder
    canManageClients?: SortOrder
    canManageBilling?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    superAdminId?: SortOrder
  }

  export type PoleManagerProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    canViewAnalytics?: SortOrder
    canManageAgents?: SortOrder
    canManageClients?: SortOrder
    canManageBilling?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    superAdminId?: SortOrder
  }

  export type PoleManagerProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    canViewAnalytics?: SortOrder
    canManageAgents?: SortOrder
    canManageClients?: SortOrder
    canManageBilling?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    superAdminId?: SortOrder
  }

  export type PropertyContractListRelationFilter = {
    every?: PropertyContractWhereInput
    some?: PropertyContractWhereInput
    none?: PropertyContractWhereInput
  }

  export type PropertyContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyOwnerProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrder
    taxNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postal?: SortOrder
    preferredContactMethod?: SortOrder
    receiveNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyOwnerProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrder
    taxNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postal?: SortOrder
    preferredContactMethod?: SortOrder
    receiveNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyOwnerProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrder
    taxNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postal?: SortOrder
    preferredContactMethod?: SortOrder
    receiveNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type LaundryInvoiceListRelationFilter = {
    every?: LaundryInvoiceWhereInput
    some?: LaundryInvoiceWhereInput
    none?: LaundryInvoiceWhereInput
  }

  export type LaundryInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaundryClientProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrder
    defaultPickupAddress?: SortOrder
    defaultDeliveryAddress?: SortOrder
    preferredPickupTime?: SortOrder
    specialInstructions?: SortOrder
    creditLimit?: SortOrder
    paymentTerms?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryClientProfileAvgOrderByAggregateInput = {
    creditLimit?: SortOrder
    paymentTerms?: SortOrder
  }

  export type LaundryClientProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrder
    defaultPickupAddress?: SortOrder
    defaultDeliveryAddress?: SortOrder
    preferredPickupTime?: SortOrder
    specialInstructions?: SortOrder
    creditLimit?: SortOrder
    paymentTerms?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryClientProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrder
    defaultPickupAddress?: SortOrder
    defaultDeliveryAddress?: SortOrder
    preferredPickupTime?: SortOrder
    specialInstructions?: SortOrder
    creditLimit?: SortOrder
    paymentTerms?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryClientProfileSumOrderByAggregateInput = {
    creditLimit?: SortOrder
    paymentTerms?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumAgentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentTypeFilter<$PrismaModel> | $Enums.AgentType
  }

  export type EnumAgentAvailabilityFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentAvailability | EnumAgentAvailabilityFieldRefInput<$PrismaModel>
    in?: $Enums.AgentAvailability[] | ListEnumAgentAvailabilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentAvailability[] | ListEnumAgentAvailabilityFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentAvailabilityFilter<$PrismaModel> | $Enums.AgentAvailability
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AgentSpecialtyListRelationFilter = {
    every?: AgentSpecialtyWhereInput
    some?: AgentSpecialtyWhereInput
    none?: AgentSpecialtyWhereInput
  }

  export type PoleManagerProfileScalarRelationFilter = {
    is?: PoleManagerProfileWhereInput
    isNot?: PoleManagerProfileWhereInput
  }

  export type TaskAssignmentListRelationFilter = {
    every?: TaskAssignmentWhereInput
    some?: TaskAssignmentWhereInput
    none?: TaskAssignmentWhereInput
  }

  export type AgentSpecialtyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agentType?: SortOrder
    availability?: SortOrder
    employeeId?: SortOrder
    certifications?: SortOrder
    currentLocation?: SortOrder
    serviceZones?: SortOrder
    rating?: SortOrder
    completedTasks?: SortOrder
    averageRating?: SortOrder
    responseTime?: SortOrder
    workingHours?: SortOrder
    availabilityCalendar?: SortOrder
    hourlyRate?: SortOrder
    isActive?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
  }

  export type AgentProfileAvgOrderByAggregateInput = {
    rating?: SortOrder
    completedTasks?: SortOrder
    averageRating?: SortOrder
    responseTime?: SortOrder
    hourlyRate?: SortOrder
  }

  export type AgentProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agentType?: SortOrder
    availability?: SortOrder
    employeeId?: SortOrder
    rating?: SortOrder
    completedTasks?: SortOrder
    averageRating?: SortOrder
    responseTime?: SortOrder
    hourlyRate?: SortOrder
    isActive?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
  }

  export type AgentProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agentType?: SortOrder
    availability?: SortOrder
    employeeId?: SortOrder
    rating?: SortOrder
    completedTasks?: SortOrder
    averageRating?: SortOrder
    responseTime?: SortOrder
    hourlyRate?: SortOrder
    isActive?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
  }

  export type AgentProfileSumOrderByAggregateInput = {
    rating?: SortOrder
    completedTasks?: SortOrder
    averageRating?: SortOrder
    responseTime?: SortOrder
    hourlyRate?: SortOrder
  }

  export type EnumAgentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AgentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentTypeFilter<$PrismaModel>
    _max?: NestedEnumAgentTypeFilter<$PrismaModel>
  }

  export type EnumAgentAvailabilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentAvailability | EnumAgentAvailabilityFieldRefInput<$PrismaModel>
    in?: $Enums.AgentAvailability[] | ListEnumAgentAvailabilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentAvailability[] | ListEnumAgentAvailabilityFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentAvailabilityWithAggregatesFilter<$PrismaModel> | $Enums.AgentAvailability
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentAvailabilityFilter<$PrismaModel>
    _max?: NestedEnumAgentAvailabilityFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type AgentProfileScalarRelationFilter = {
    is?: AgentProfileWhereInput
    isNot?: AgentProfileWhereInput
  }

  export type AgentSpecialtyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    level?: SortOrder
    certified?: SortOrder
    agentId?: SortOrder
  }

  export type AgentSpecialtyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    level?: SortOrder
    certified?: SortOrder
    agentId?: SortOrder
  }

  export type AgentSpecialtyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    level?: SortOrder
    certified?: SortOrder
    agentId?: SortOrder
  }

  export type EnumPropertyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusFilter<$PrismaModel> | $Enums.PropertyStatus
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type PropertyFeatureListRelationFilter = {
    every?: PropertyFeatureWhereInput
    some?: PropertyFeatureWhereInput
    none?: PropertyFeatureWhereInput
  }

  export type PropertyPhotoListRelationFilter = {
    every?: PropertyPhotoWhereInput
    some?: PropertyPhotoWhereInput
    none?: PropertyPhotoWhereInput
  }

  export type PropertyOwnerProfileScalarRelationFilter = {
    is?: PropertyOwnerProfileWhereInput
    isNot?: PropertyOwnerProfileWhereInput
  }

  export type PropertyReviewListRelationFilter = {
    every?: PropertyReviewWhereInput
    some?: PropertyReviewWhereInput
    none?: PropertyReviewWhereInput
  }

  export type PropertyFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    surface?: SortOrder
    numberOfRooms?: SortOrder
    numberOfBedrooms?: SortOrder
    numberOfBathrooms?: SortOrder
    maxGuests?: SortOrder
    floor?: SortOrder
    hasElevator?: SortOrder
    hasParking?: SortOrder
    hasBalcony?: SortOrder
    pricePerNight?: SortOrder
    cleaningFee?: SortOrder
    serviceFee?: SortOrder
    securityDeposit?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    cancellationPolicy?: SortOrder
    houseRules?: SortOrder
    accessInstructions?: SortOrder
    cleaningInstructions?: SortOrder
    maintenanceNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    managerId?: SortOrder
  }

  export type PropertyAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    surface?: SortOrder
    numberOfRooms?: SortOrder
    numberOfBedrooms?: SortOrder
    numberOfBathrooms?: SortOrder
    maxGuests?: SortOrder
    floor?: SortOrder
    pricePerNight?: SortOrder
    cleaningFee?: SortOrder
    serviceFee?: SortOrder
    securityDeposit?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    surface?: SortOrder
    numberOfRooms?: SortOrder
    numberOfBedrooms?: SortOrder
    numberOfBathrooms?: SortOrder
    maxGuests?: SortOrder
    floor?: SortOrder
    hasElevator?: SortOrder
    hasParking?: SortOrder
    hasBalcony?: SortOrder
    pricePerNight?: SortOrder
    cleaningFee?: SortOrder
    serviceFee?: SortOrder
    securityDeposit?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    cancellationPolicy?: SortOrder
    houseRules?: SortOrder
    accessInstructions?: SortOrder
    cleaningInstructions?: SortOrder
    maintenanceNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    managerId?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    surface?: SortOrder
    numberOfRooms?: SortOrder
    numberOfBedrooms?: SortOrder
    numberOfBathrooms?: SortOrder
    maxGuests?: SortOrder
    floor?: SortOrder
    hasElevator?: SortOrder
    hasParking?: SortOrder
    hasBalcony?: SortOrder
    pricePerNight?: SortOrder
    cleaningFee?: SortOrder
    serviceFee?: SortOrder
    securityDeposit?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    cancellationPolicy?: SortOrder
    houseRules?: SortOrder
    accessInstructions?: SortOrder
    cleaningInstructions?: SortOrder
    maintenanceNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    managerId?: SortOrder
  }

  export type PropertySumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    surface?: SortOrder
    numberOfRooms?: SortOrder
    numberOfBedrooms?: SortOrder
    numberOfBathrooms?: SortOrder
    maxGuests?: SortOrder
    floor?: SortOrder
    pricePerNight?: SortOrder
    cleaningFee?: SortOrder
    serviceFee?: SortOrder
    securityDeposit?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
  }

  export type EnumPropertyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel> | $Enums.PropertyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyStatusFilter<$PrismaModel>
    _max?: NestedEnumPropertyStatusFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type PropertyScalarRelationFilter = {
    is?: PropertyWhereInput
    isNot?: PropertyWhereInput
  }

  export type PropertyFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    propertyId?: SortOrder
  }

  export type PropertyFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    propertyId?: SortOrder
  }

  export type PropertyFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    propertyId?: SortOrder
  }

  export type PropertyPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    caption?: SortOrder
    isMain?: SortOrder
    order?: SortOrder
    type?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyPhotoAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type PropertyPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    caption?: SortOrder
    isMain?: SortOrder
    order?: SortOrder
    type?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    caption?: SortOrder
    isMain?: SortOrder
    order?: SortOrder
    type?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyPhotoSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type PropertyReviewCountOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type PropertyReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyReviewMinOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumReservationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationStatus | EnumReservationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReservationStatus[] | ListEnumReservationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReservationStatus[] | ListEnumReservationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReservationStatusFilter<$PrismaModel> | $Enums.ReservationStatus
  }

  export type ReservationCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    guestCount?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    nights?: SortOrder
    basePrice?: SortOrder
    cleaningFee?: SortOrder
    serviceFee?: SortOrder
    taxes?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    confirmationCode?: SortOrder
    bookingSource?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
  }

  export type ReservationAvgOrderByAggregateInput = {
    guestCount?: SortOrder
    nights?: SortOrder
    basePrice?: SortOrder
    cleaningFee?: SortOrder
    serviceFee?: SortOrder
    taxes?: SortOrder
    totalPrice?: SortOrder
  }

  export type ReservationMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    guestCount?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    nights?: SortOrder
    basePrice?: SortOrder
    cleaningFee?: SortOrder
    serviceFee?: SortOrder
    taxes?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    confirmationCode?: SortOrder
    bookingSource?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
  }

  export type ReservationMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    guestCount?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    nights?: SortOrder
    basePrice?: SortOrder
    cleaningFee?: SortOrder
    serviceFee?: SortOrder
    taxes?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    confirmationCode?: SortOrder
    bookingSource?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
  }

  export type ReservationSumOrderByAggregateInput = {
    guestCount?: SortOrder
    nights?: SortOrder
    basePrice?: SortOrder
    cleaningFee?: SortOrder
    serviceFee?: SortOrder
    taxes?: SortOrder
    totalPrice?: SortOrder
  }

  export type EnumReservationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationStatus | EnumReservationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReservationStatus[] | ListEnumReservationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReservationStatus[] | ListEnumReservationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReservationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReservationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReservationStatusFilter<$PrismaModel>
    _max?: NestedEnumReservationStatusFilter<$PrismaModel>
  }

  export type EnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type CleaningChecklistListRelationFilter = {
    every?: CleaningChecklistWhereInput
    some?: CleaningChecklistWhereInput
    none?: CleaningChecklistWhereInput
  }

  export type CleaningPhotoListRelationFilter = {
    every?: CleaningPhotoWhereInput
    some?: CleaningPhotoWhereInput
    none?: CleaningPhotoWhereInput
  }

  export type CleaningChecklistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CleaningPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CleaningSessionCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    agentId?: SortOrder
    scheduledDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    cleaningType?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    agentNotes?: SortOrder
    ownerRating?: SortOrder
    managerRating?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
  }

  export type CleaningSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
    ownerRating?: SortOrder
    managerRating?: SortOrder
  }

  export type CleaningSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    agentId?: SortOrder
    scheduledDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    cleaningType?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    agentNotes?: SortOrder
    ownerRating?: SortOrder
    managerRating?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
  }

  export type CleaningSessionMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    agentId?: SortOrder
    scheduledDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    cleaningType?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    agentNotes?: SortOrder
    ownerRating?: SortOrder
    managerRating?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
  }

  export type CleaningSessionSumOrderByAggregateInput = {
    duration?: SortOrder
    ownerRating?: SortOrder
    managerRating?: SortOrder
  }

  export type EnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type CleaningSessionScalarRelationFilter = {
    is?: CleaningSessionWhereInput
    isNot?: CleaningSessionWhereInput
  }

  export type CleaningChecklistCountOrderByAggregateInput = {
    id?: SortOrder
    item?: SortOrder
    completed?: SortOrder
    notes?: SortOrder
    order?: SortOrder
    cleaningSessionId?: SortOrder
  }

  export type CleaningChecklistAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CleaningChecklistMaxOrderByAggregateInput = {
    id?: SortOrder
    item?: SortOrder
    completed?: SortOrder
    notes?: SortOrder
    order?: SortOrder
    cleaningSessionId?: SortOrder
  }

  export type CleaningChecklistMinOrderByAggregateInput = {
    id?: SortOrder
    item?: SortOrder
    completed?: SortOrder
    notes?: SortOrder
    order?: SortOrder
    cleaningSessionId?: SortOrder
  }

  export type CleaningChecklistSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CleaningPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    caption?: SortOrder
    cleaningSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type CleaningPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    caption?: SortOrder
    cleaningSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type CleaningPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    caption?: SortOrder
    cleaningSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type EnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type TicketPhotoListRelationFilter = {
    every?: TicketPhotoWhereInput
    some?: TicketPhotoWhereInput
    none?: TicketPhotoWhereInput
  }

  export type MaintenanceSessionNullableScalarRelationFilter = {
    is?: MaintenanceSessionWhereInput | null
    isNot?: MaintenanceSessionWhereInput | null
  }

  export type TicketPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    propertyId?: SortOrder
    reportedBy?: SortOrder
    reportedAt?: SortOrder
    agentId?: SortOrder
    assignedAt?: SortOrder
    category?: SortOrder
    issueType?: SortOrder
    roomLocation?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    estimatedCost?: SortOrder
    estimatedDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
  }

  export type TicketAvgOrderByAggregateInput = {
    estimatedCost?: SortOrder
    estimatedDuration?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    propertyId?: SortOrder
    reportedBy?: SortOrder
    reportedAt?: SortOrder
    agentId?: SortOrder
    assignedAt?: SortOrder
    category?: SortOrder
    issueType?: SortOrder
    roomLocation?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    estimatedCost?: SortOrder
    estimatedDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    propertyId?: SortOrder
    reportedBy?: SortOrder
    reportedAt?: SortOrder
    agentId?: SortOrder
    assignedAt?: SortOrder
    category?: SortOrder
    issueType?: SortOrder
    roomLocation?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    estimatedCost?: SortOrder
    estimatedDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
  }

  export type TicketSumOrderByAggregateInput = {
    estimatedCost?: SortOrder
    estimatedDuration?: SortOrder
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type EnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type TicketScalarRelationFilter = {
    is?: TicketWhereInput
    isNot?: TicketWhereInput
  }

  export type TicketPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    caption?: SortOrder
    ticketId?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    caption?: SortOrder
    ticketId?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    caption?: SortOrder
    ticketId?: SortOrder
    createdAt?: SortOrder
  }

  export type MaintenanceMaterialListRelationFilter = {
    every?: MaintenanceMaterialWhereInput
    some?: MaintenanceMaterialWhereInput
    none?: MaintenanceMaterialWhereInput
  }

  export type MaintenancePhotoListRelationFilter = {
    every?: MaintenancePhotoWhereInput
    some?: MaintenancePhotoWhereInput
    none?: MaintenancePhotoWhereInput
  }

  export type MaintenanceMaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenancePhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenanceSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
    ticketId?: SortOrder
    propertyId?: SortOrder
    agentId?: SortOrder
    scheduledDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    workDescription?: SortOrder
    agentNotes?: SortOrder
    laborCost?: SortOrder
    materialsCost?: SortOrder
    totalCost?: SortOrder
    ownerApproval?: SortOrder
    managerApproval?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
  }

  export type MaintenanceSessionAvgOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    laborCost?: SortOrder
    materialsCost?: SortOrder
    totalCost?: SortOrder
  }

  export type MaintenanceSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
    ticketId?: SortOrder
    propertyId?: SortOrder
    agentId?: SortOrder
    scheduledDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    workDescription?: SortOrder
    agentNotes?: SortOrder
    laborCost?: SortOrder
    materialsCost?: SortOrder
    totalCost?: SortOrder
    ownerApproval?: SortOrder
    managerApproval?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
  }

  export type MaintenanceSessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
    ticketId?: SortOrder
    propertyId?: SortOrder
    agentId?: SortOrder
    scheduledDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    workDescription?: SortOrder
    agentNotes?: SortOrder
    laborCost?: SortOrder
    materialsCost?: SortOrder
    totalCost?: SortOrder
    ownerApproval?: SortOrder
    managerApproval?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
  }

  export type MaintenanceSessionSumOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    laborCost?: SortOrder
    materialsCost?: SortOrder
    totalCost?: SortOrder
  }

  export type MaintenanceSessionScalarRelationFilter = {
    is?: MaintenanceSessionWhereInput
    isNot?: MaintenanceSessionWhereInput
  }

  export type MaintenanceMaterialCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    supplier?: SortOrder
    maintenanceSessionId?: SortOrder
  }

  export type MaintenanceMaterialAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type MaintenanceMaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    supplier?: SortOrder
    maintenanceSessionId?: SortOrder
  }

  export type MaintenanceMaterialMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    supplier?: SortOrder
    maintenanceSessionId?: SortOrder
  }

  export type MaintenanceMaterialSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type MaintenancePhotoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    caption?: SortOrder
    maintenanceSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type MaintenancePhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    caption?: SortOrder
    maintenanceSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type MaintenancePhotoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    caption?: SortOrder
    maintenanceSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type LaundryOrderItemListRelationFilter = {
    every?: LaundryOrderItemWhereInput
    some?: LaundryOrderItemWhereInput
    none?: LaundryOrderItemWhereInput
  }

  export type LaundryOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaundryProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryProductAvgOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type LaundryProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryProductSumOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type LaundryClientProfileScalarRelationFilter = {
    is?: LaundryClientProfileWhereInput
    isNot?: LaundryClientProfileWhereInput
  }

  export type DeliveryNoteListRelationFilter = {
    every?: DeliveryNoteWhereInput
    some?: DeliveryNoteWhereInput
    none?: DeliveryNoteWhereInput
  }

  export type DeliveryNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaundryOrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    receivedDate?: SortOrder
    processedDate?: SortOrder
    readyDate?: SortOrder
    deliveryDate?: SortOrder
    pickupAddress?: SortOrder
    deliveryAddress?: SortOrder
    instructions?: SortOrder
    subtotal?: SortOrder
    taxes?: SortOrder
    deliveryFee?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    receivedByClient?: SortOrder
    receivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    clientId?: SortOrder
  }

  export type LaundryOrderAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxes?: SortOrder
    deliveryFee?: SortOrder
    totalAmount?: SortOrder
  }

  export type LaundryOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    receivedDate?: SortOrder
    processedDate?: SortOrder
    readyDate?: SortOrder
    deliveryDate?: SortOrder
    pickupAddress?: SortOrder
    deliveryAddress?: SortOrder
    instructions?: SortOrder
    subtotal?: SortOrder
    taxes?: SortOrder
    deliveryFee?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    receivedByClient?: SortOrder
    receivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    clientId?: SortOrder
  }

  export type LaundryOrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    receivedDate?: SortOrder
    processedDate?: SortOrder
    readyDate?: SortOrder
    deliveryDate?: SortOrder
    pickupAddress?: SortOrder
    deliveryAddress?: SortOrder
    instructions?: SortOrder
    subtotal?: SortOrder
    taxes?: SortOrder
    deliveryFee?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    receivedByClient?: SortOrder
    receivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    clientId?: SortOrder
  }

  export type LaundryOrderSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxes?: SortOrder
    deliveryFee?: SortOrder
    totalAmount?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type LaundryOrderScalarRelationFilter = {
    is?: LaundryOrderWhereInput
    isNot?: LaundryOrderWhereInput
  }

  export type LaundryProductScalarRelationFilter = {
    is?: LaundryProductWhereInput
    isNot?: LaundryProductWhereInput
  }

  export type LaundryOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    notes?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryOrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type LaundryOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    notes?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    notes?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryOrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type DeliveryNoteCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryNoteMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    dueDate?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    agentId?: SortOrder
    propertyId?: SortOrder
    reservationId?: SortOrder
    cleaningSessionId?: SortOrder
    maintenanceSessionId?: SortOrder
    ticketId?: SortOrder
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskAssignmentAvgOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
  }

  export type TaskAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    dueDate?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    agentId?: SortOrder
    propertyId?: SortOrder
    reservationId?: SortOrder
    cleaningSessionId?: SortOrder
    maintenanceSessionId?: SortOrder
    ticketId?: SortOrder
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    dueDate?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    agentId?: SortOrder
    propertyId?: SortOrder
    reservationId?: SortOrder
    cleaningSessionId?: SortOrder
    maintenanceSessionId?: SortOrder
    ticketId?: SortOrder
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskAssignmentSumOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
  }

  export type PropertyContractCountOrderByAggregateInput = {
    id?: SortOrder
    contractNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    propertyId?: SortOrder
    propertyOwnerId?: SortOrder
    monthlyFee?: SortOrder
    commissionRate?: SortOrder
    documentUrl?: SortOrder
    signedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyContractAvgOrderByAggregateInput = {
    monthlyFee?: SortOrder
    commissionRate?: SortOrder
  }

  export type PropertyContractMaxOrderByAggregateInput = {
    id?: SortOrder
    contractNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    propertyId?: SortOrder
    propertyOwnerId?: SortOrder
    monthlyFee?: SortOrder
    commissionRate?: SortOrder
    documentUrl?: SortOrder
    signedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyContractMinOrderByAggregateInput = {
    id?: SortOrder
    contractNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    propertyId?: SortOrder
    propertyOwnerId?: SortOrder
    monthlyFee?: SortOrder
    commissionRate?: SortOrder
    documentUrl?: SortOrder
    signedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyContractSumOrderByAggregateInput = {
    monthlyFee?: SortOrder
    commissionRate?: SortOrder
  }

  export type SuperAdminInvoiceItemListRelationFilter = {
    every?: SuperAdminInvoiceItemWhereInput
    some?: SuperAdminInvoiceItemWhereInput
    none?: SuperAdminInvoiceItemWhereInput
  }

  export type SuperAdminInvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuperAdminInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    superAdminId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuperAdminInvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type SuperAdminInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    superAdminId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuperAdminInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    superAdminId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuperAdminInvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type EnumPoleTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PoleType | EnumPoleTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPoleTypeNullableFilter<$PrismaModel> | $Enums.PoleType | null
  }

  export type SuperAdminInvoiceScalarRelationFilter = {
    is?: SuperAdminInvoiceWhereInput
    isNot?: SuperAdminInvoiceWhereInput
  }

  export type SuperAdminInvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    poleType?: SortOrder
    invoiceId?: SortOrder
  }

  export type SuperAdminInvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type SuperAdminInvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    poleType?: SortOrder
    invoiceId?: SortOrder
  }

  export type SuperAdminInvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    poleType?: SortOrder
    invoiceId?: SortOrder
  }

  export type SuperAdminInvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type EnumPoleTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoleType | EnumPoleTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPoleTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PoleType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPoleTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPoleTypeNullableFilter<$PrismaModel>
  }

  export type LaundryInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    clientId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryInvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type LaundryInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    clientId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    clientId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryInvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    read?: SortOrder
    userId?: SortOrder
    relatedType?: SortOrder
    relatedId?: SortOrder
    actionUrl?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    read?: SortOrder
    userId?: SortOrder
    relatedType?: SortOrder
    relatedId?: SortOrder
    actionUrl?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    read?: SortOrder
    userId?: SortOrder
    relatedType?: SortOrder
    relatedId?: SortOrder
    actionUrl?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SuperAdminProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<SuperAdminProfileCreateWithoutUserInput, SuperAdminProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuperAdminProfileCreateOrConnectWithoutUserInput
    connect?: SuperAdminProfileWhereUniqueInput
  }

  export type PoleManagerProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<PoleManagerProfileCreateWithoutUserInput, PoleManagerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutUserInput
    connect?: PoleManagerProfileWhereUniqueInput
  }

  export type PropertyOwnerProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<PropertyOwnerProfileCreateWithoutUserInput, PropertyOwnerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PropertyOwnerProfileCreateOrConnectWithoutUserInput
    connect?: PropertyOwnerProfileWhereUniqueInput
  }

  export type LaundryClientProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<LaundryClientProfileCreateWithoutUserInput, LaundryClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: LaundryClientProfileCreateOrConnectWithoutUserInput
    connect?: LaundryClientProfileWhereUniqueInput
  }

  export type AgentProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<AgentProfileCreateWithoutUserInput, AgentProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentProfileCreateOrConnectWithoutUserInput
    connect?: AgentProfileWhereUniqueInput
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SuperAdminProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SuperAdminProfileCreateWithoutUserInput, SuperAdminProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuperAdminProfileCreateOrConnectWithoutUserInput
    connect?: SuperAdminProfileWhereUniqueInput
  }

  export type PoleManagerProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PoleManagerProfileCreateWithoutUserInput, PoleManagerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutUserInput
    connect?: PoleManagerProfileWhereUniqueInput
  }

  export type PropertyOwnerProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PropertyOwnerProfileCreateWithoutUserInput, PropertyOwnerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PropertyOwnerProfileCreateOrConnectWithoutUserInput
    connect?: PropertyOwnerProfileWhereUniqueInput
  }

  export type LaundryClientProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<LaundryClientProfileCreateWithoutUserInput, LaundryClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: LaundryClientProfileCreateOrConnectWithoutUserInput
    connect?: LaundryClientProfileWhereUniqueInput
  }

  export type AgentProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AgentProfileCreateWithoutUserInput, AgentProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentProfileCreateOrConnectWithoutUserInput
    connect?: AgentProfileWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SuperAdminProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<SuperAdminProfileCreateWithoutUserInput, SuperAdminProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuperAdminProfileCreateOrConnectWithoutUserInput
    upsert?: SuperAdminProfileUpsertWithoutUserInput
    disconnect?: SuperAdminProfileWhereInput | boolean
    delete?: SuperAdminProfileWhereInput | boolean
    connect?: SuperAdminProfileWhereUniqueInput
    update?: XOR<XOR<SuperAdminProfileUpdateToOneWithWhereWithoutUserInput, SuperAdminProfileUpdateWithoutUserInput>, SuperAdminProfileUncheckedUpdateWithoutUserInput>
  }

  export type PoleManagerProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<PoleManagerProfileCreateWithoutUserInput, PoleManagerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutUserInput
    upsert?: PoleManagerProfileUpsertWithoutUserInput
    disconnect?: PoleManagerProfileWhereInput | boolean
    delete?: PoleManagerProfileWhereInput | boolean
    connect?: PoleManagerProfileWhereUniqueInput
    update?: XOR<XOR<PoleManagerProfileUpdateToOneWithWhereWithoutUserInput, PoleManagerProfileUpdateWithoutUserInput>, PoleManagerProfileUncheckedUpdateWithoutUserInput>
  }

  export type PropertyOwnerProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<PropertyOwnerProfileCreateWithoutUserInput, PropertyOwnerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PropertyOwnerProfileCreateOrConnectWithoutUserInput
    upsert?: PropertyOwnerProfileUpsertWithoutUserInput
    disconnect?: PropertyOwnerProfileWhereInput | boolean
    delete?: PropertyOwnerProfileWhereInput | boolean
    connect?: PropertyOwnerProfileWhereUniqueInput
    update?: XOR<XOR<PropertyOwnerProfileUpdateToOneWithWhereWithoutUserInput, PropertyOwnerProfileUpdateWithoutUserInput>, PropertyOwnerProfileUncheckedUpdateWithoutUserInput>
  }

  export type LaundryClientProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<LaundryClientProfileCreateWithoutUserInput, LaundryClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: LaundryClientProfileCreateOrConnectWithoutUserInput
    upsert?: LaundryClientProfileUpsertWithoutUserInput
    disconnect?: LaundryClientProfileWhereInput | boolean
    delete?: LaundryClientProfileWhereInput | boolean
    connect?: LaundryClientProfileWhereUniqueInput
    update?: XOR<XOR<LaundryClientProfileUpdateToOneWithWhereWithoutUserInput, LaundryClientProfileUpdateWithoutUserInput>, LaundryClientProfileUncheckedUpdateWithoutUserInput>
  }

  export type AgentProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgentProfileCreateWithoutUserInput, AgentProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentProfileCreateOrConnectWithoutUserInput
    upsert?: AgentProfileUpsertWithoutUserInput
    disconnect?: AgentProfileWhereInput | boolean
    delete?: AgentProfileWhereInput | boolean
    connect?: AgentProfileWhereUniqueInput
    update?: XOR<XOR<AgentProfileUpdateToOneWithWhereWithoutUserInput, AgentProfileUpdateWithoutUserInput>, AgentProfileUncheckedUpdateWithoutUserInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SuperAdminProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SuperAdminProfileCreateWithoutUserInput, SuperAdminProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuperAdminProfileCreateOrConnectWithoutUserInput
    upsert?: SuperAdminProfileUpsertWithoutUserInput
    disconnect?: SuperAdminProfileWhereInput | boolean
    delete?: SuperAdminProfileWhereInput | boolean
    connect?: SuperAdminProfileWhereUniqueInput
    update?: XOR<XOR<SuperAdminProfileUpdateToOneWithWhereWithoutUserInput, SuperAdminProfileUpdateWithoutUserInput>, SuperAdminProfileUncheckedUpdateWithoutUserInput>
  }

  export type PoleManagerProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PoleManagerProfileCreateWithoutUserInput, PoleManagerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutUserInput
    upsert?: PoleManagerProfileUpsertWithoutUserInput
    disconnect?: PoleManagerProfileWhereInput | boolean
    delete?: PoleManagerProfileWhereInput | boolean
    connect?: PoleManagerProfileWhereUniqueInput
    update?: XOR<XOR<PoleManagerProfileUpdateToOneWithWhereWithoutUserInput, PoleManagerProfileUpdateWithoutUserInput>, PoleManagerProfileUncheckedUpdateWithoutUserInput>
  }

  export type PropertyOwnerProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PropertyOwnerProfileCreateWithoutUserInput, PropertyOwnerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PropertyOwnerProfileCreateOrConnectWithoutUserInput
    upsert?: PropertyOwnerProfileUpsertWithoutUserInput
    disconnect?: PropertyOwnerProfileWhereInput | boolean
    delete?: PropertyOwnerProfileWhereInput | boolean
    connect?: PropertyOwnerProfileWhereUniqueInput
    update?: XOR<XOR<PropertyOwnerProfileUpdateToOneWithWhereWithoutUserInput, PropertyOwnerProfileUpdateWithoutUserInput>, PropertyOwnerProfileUncheckedUpdateWithoutUserInput>
  }

  export type LaundryClientProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<LaundryClientProfileCreateWithoutUserInput, LaundryClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: LaundryClientProfileCreateOrConnectWithoutUserInput
    upsert?: LaundryClientProfileUpsertWithoutUserInput
    disconnect?: LaundryClientProfileWhereInput | boolean
    delete?: LaundryClientProfileWhereInput | boolean
    connect?: LaundryClientProfileWhereUniqueInput
    update?: XOR<XOR<LaundryClientProfileUpdateToOneWithWhereWithoutUserInput, LaundryClientProfileUpdateWithoutUserInput>, LaundryClientProfileUncheckedUpdateWithoutUserInput>
  }

  export type AgentProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgentProfileCreateWithoutUserInput, AgentProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentProfileCreateOrConnectWithoutUserInput
    upsert?: AgentProfileUpsertWithoutUserInput
    disconnect?: AgentProfileWhereInput | boolean
    delete?: AgentProfileWhereInput | boolean
    connect?: AgentProfileWhereUniqueInput
    update?: XOR<XOR<AgentProfileUpdateToOneWithWhereWithoutUserInput, AgentProfileUpdateWithoutUserInput>, AgentProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutSuperAdminProfileInput = {
    create?: XOR<UserCreateWithoutSuperAdminProfileInput, UserUncheckedCreateWithoutSuperAdminProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuperAdminProfileInput
    connect?: UserWhereUniqueInput
  }

  export type PoleSubscriptionCreateNestedManyWithoutSuperAdminInput = {
    create?: XOR<PoleSubscriptionCreateWithoutSuperAdminInput, PoleSubscriptionUncheckedCreateWithoutSuperAdminInput> | PoleSubscriptionCreateWithoutSuperAdminInput[] | PoleSubscriptionUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: PoleSubscriptionCreateOrConnectWithoutSuperAdminInput | PoleSubscriptionCreateOrConnectWithoutSuperAdminInput[]
    createMany?: PoleSubscriptionCreateManySuperAdminInputEnvelope
    connect?: PoleSubscriptionWhereUniqueInput | PoleSubscriptionWhereUniqueInput[]
  }

  export type PoleManagerProfileCreateNestedManyWithoutSuperAdminInput = {
    create?: XOR<PoleManagerProfileCreateWithoutSuperAdminInput, PoleManagerProfileUncheckedCreateWithoutSuperAdminInput> | PoleManagerProfileCreateWithoutSuperAdminInput[] | PoleManagerProfileUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutSuperAdminInput | PoleManagerProfileCreateOrConnectWithoutSuperAdminInput[]
    createMany?: PoleManagerProfileCreateManySuperAdminInputEnvelope
    connect?: PoleManagerProfileWhereUniqueInput | PoleManagerProfileWhereUniqueInput[]
  }

  export type SuperAdminInvoiceCreateNestedManyWithoutSuperAdminInput = {
    create?: XOR<SuperAdminInvoiceCreateWithoutSuperAdminInput, SuperAdminInvoiceUncheckedCreateWithoutSuperAdminInput> | SuperAdminInvoiceCreateWithoutSuperAdminInput[] | SuperAdminInvoiceUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: SuperAdminInvoiceCreateOrConnectWithoutSuperAdminInput | SuperAdminInvoiceCreateOrConnectWithoutSuperAdminInput[]
    createMany?: SuperAdminInvoiceCreateManySuperAdminInputEnvelope
    connect?: SuperAdminInvoiceWhereUniqueInput | SuperAdminInvoiceWhereUniqueInput[]
  }

  export type PoleSubscriptionUncheckedCreateNestedManyWithoutSuperAdminInput = {
    create?: XOR<PoleSubscriptionCreateWithoutSuperAdminInput, PoleSubscriptionUncheckedCreateWithoutSuperAdminInput> | PoleSubscriptionCreateWithoutSuperAdminInput[] | PoleSubscriptionUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: PoleSubscriptionCreateOrConnectWithoutSuperAdminInput | PoleSubscriptionCreateOrConnectWithoutSuperAdminInput[]
    createMany?: PoleSubscriptionCreateManySuperAdminInputEnvelope
    connect?: PoleSubscriptionWhereUniqueInput | PoleSubscriptionWhereUniqueInput[]
  }

  export type PoleManagerProfileUncheckedCreateNestedManyWithoutSuperAdminInput = {
    create?: XOR<PoleManagerProfileCreateWithoutSuperAdminInput, PoleManagerProfileUncheckedCreateWithoutSuperAdminInput> | PoleManagerProfileCreateWithoutSuperAdminInput[] | PoleManagerProfileUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutSuperAdminInput | PoleManagerProfileCreateOrConnectWithoutSuperAdminInput[]
    createMany?: PoleManagerProfileCreateManySuperAdminInputEnvelope
    connect?: PoleManagerProfileWhereUniqueInput | PoleManagerProfileWhereUniqueInput[]
  }

  export type SuperAdminInvoiceUncheckedCreateNestedManyWithoutSuperAdminInput = {
    create?: XOR<SuperAdminInvoiceCreateWithoutSuperAdminInput, SuperAdminInvoiceUncheckedCreateWithoutSuperAdminInput> | SuperAdminInvoiceCreateWithoutSuperAdminInput[] | SuperAdminInvoiceUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: SuperAdminInvoiceCreateOrConnectWithoutSuperAdminInput | SuperAdminInvoiceCreateOrConnectWithoutSuperAdminInput[]
    createMany?: SuperAdminInvoiceCreateManySuperAdminInputEnvelope
    connect?: SuperAdminInvoiceWhereUniqueInput | SuperAdminInvoiceWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSuperAdminProfileNestedInput = {
    create?: XOR<UserCreateWithoutSuperAdminProfileInput, UserUncheckedCreateWithoutSuperAdminProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuperAdminProfileInput
    upsert?: UserUpsertWithoutSuperAdminProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSuperAdminProfileInput, UserUpdateWithoutSuperAdminProfileInput>, UserUncheckedUpdateWithoutSuperAdminProfileInput>
  }

  export type PoleSubscriptionUpdateManyWithoutSuperAdminNestedInput = {
    create?: XOR<PoleSubscriptionCreateWithoutSuperAdminInput, PoleSubscriptionUncheckedCreateWithoutSuperAdminInput> | PoleSubscriptionCreateWithoutSuperAdminInput[] | PoleSubscriptionUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: PoleSubscriptionCreateOrConnectWithoutSuperAdminInput | PoleSubscriptionCreateOrConnectWithoutSuperAdminInput[]
    upsert?: PoleSubscriptionUpsertWithWhereUniqueWithoutSuperAdminInput | PoleSubscriptionUpsertWithWhereUniqueWithoutSuperAdminInput[]
    createMany?: PoleSubscriptionCreateManySuperAdminInputEnvelope
    set?: PoleSubscriptionWhereUniqueInput | PoleSubscriptionWhereUniqueInput[]
    disconnect?: PoleSubscriptionWhereUniqueInput | PoleSubscriptionWhereUniqueInput[]
    delete?: PoleSubscriptionWhereUniqueInput | PoleSubscriptionWhereUniqueInput[]
    connect?: PoleSubscriptionWhereUniqueInput | PoleSubscriptionWhereUniqueInput[]
    update?: PoleSubscriptionUpdateWithWhereUniqueWithoutSuperAdminInput | PoleSubscriptionUpdateWithWhereUniqueWithoutSuperAdminInput[]
    updateMany?: PoleSubscriptionUpdateManyWithWhereWithoutSuperAdminInput | PoleSubscriptionUpdateManyWithWhereWithoutSuperAdminInput[]
    deleteMany?: PoleSubscriptionScalarWhereInput | PoleSubscriptionScalarWhereInput[]
  }

  export type PoleManagerProfileUpdateManyWithoutSuperAdminNestedInput = {
    create?: XOR<PoleManagerProfileCreateWithoutSuperAdminInput, PoleManagerProfileUncheckedCreateWithoutSuperAdminInput> | PoleManagerProfileCreateWithoutSuperAdminInput[] | PoleManagerProfileUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutSuperAdminInput | PoleManagerProfileCreateOrConnectWithoutSuperAdminInput[]
    upsert?: PoleManagerProfileUpsertWithWhereUniqueWithoutSuperAdminInput | PoleManagerProfileUpsertWithWhereUniqueWithoutSuperAdminInput[]
    createMany?: PoleManagerProfileCreateManySuperAdminInputEnvelope
    set?: PoleManagerProfileWhereUniqueInput | PoleManagerProfileWhereUniqueInput[]
    disconnect?: PoleManagerProfileWhereUniqueInput | PoleManagerProfileWhereUniqueInput[]
    delete?: PoleManagerProfileWhereUniqueInput | PoleManagerProfileWhereUniqueInput[]
    connect?: PoleManagerProfileWhereUniqueInput | PoleManagerProfileWhereUniqueInput[]
    update?: PoleManagerProfileUpdateWithWhereUniqueWithoutSuperAdminInput | PoleManagerProfileUpdateWithWhereUniqueWithoutSuperAdminInput[]
    updateMany?: PoleManagerProfileUpdateManyWithWhereWithoutSuperAdminInput | PoleManagerProfileUpdateManyWithWhereWithoutSuperAdminInput[]
    deleteMany?: PoleManagerProfileScalarWhereInput | PoleManagerProfileScalarWhereInput[]
  }

  export type SuperAdminInvoiceUpdateManyWithoutSuperAdminNestedInput = {
    create?: XOR<SuperAdminInvoiceCreateWithoutSuperAdminInput, SuperAdminInvoiceUncheckedCreateWithoutSuperAdminInput> | SuperAdminInvoiceCreateWithoutSuperAdminInput[] | SuperAdminInvoiceUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: SuperAdminInvoiceCreateOrConnectWithoutSuperAdminInput | SuperAdminInvoiceCreateOrConnectWithoutSuperAdminInput[]
    upsert?: SuperAdminInvoiceUpsertWithWhereUniqueWithoutSuperAdminInput | SuperAdminInvoiceUpsertWithWhereUniqueWithoutSuperAdminInput[]
    createMany?: SuperAdminInvoiceCreateManySuperAdminInputEnvelope
    set?: SuperAdminInvoiceWhereUniqueInput | SuperAdminInvoiceWhereUniqueInput[]
    disconnect?: SuperAdminInvoiceWhereUniqueInput | SuperAdminInvoiceWhereUniqueInput[]
    delete?: SuperAdminInvoiceWhereUniqueInput | SuperAdminInvoiceWhereUniqueInput[]
    connect?: SuperAdminInvoiceWhereUniqueInput | SuperAdminInvoiceWhereUniqueInput[]
    update?: SuperAdminInvoiceUpdateWithWhereUniqueWithoutSuperAdminInput | SuperAdminInvoiceUpdateWithWhereUniqueWithoutSuperAdminInput[]
    updateMany?: SuperAdminInvoiceUpdateManyWithWhereWithoutSuperAdminInput | SuperAdminInvoiceUpdateManyWithWhereWithoutSuperAdminInput[]
    deleteMany?: SuperAdminInvoiceScalarWhereInput | SuperAdminInvoiceScalarWhereInput[]
  }

  export type PoleSubscriptionUncheckedUpdateManyWithoutSuperAdminNestedInput = {
    create?: XOR<PoleSubscriptionCreateWithoutSuperAdminInput, PoleSubscriptionUncheckedCreateWithoutSuperAdminInput> | PoleSubscriptionCreateWithoutSuperAdminInput[] | PoleSubscriptionUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: PoleSubscriptionCreateOrConnectWithoutSuperAdminInput | PoleSubscriptionCreateOrConnectWithoutSuperAdminInput[]
    upsert?: PoleSubscriptionUpsertWithWhereUniqueWithoutSuperAdminInput | PoleSubscriptionUpsertWithWhereUniqueWithoutSuperAdminInput[]
    createMany?: PoleSubscriptionCreateManySuperAdminInputEnvelope
    set?: PoleSubscriptionWhereUniqueInput | PoleSubscriptionWhereUniqueInput[]
    disconnect?: PoleSubscriptionWhereUniqueInput | PoleSubscriptionWhereUniqueInput[]
    delete?: PoleSubscriptionWhereUniqueInput | PoleSubscriptionWhereUniqueInput[]
    connect?: PoleSubscriptionWhereUniqueInput | PoleSubscriptionWhereUniqueInput[]
    update?: PoleSubscriptionUpdateWithWhereUniqueWithoutSuperAdminInput | PoleSubscriptionUpdateWithWhereUniqueWithoutSuperAdminInput[]
    updateMany?: PoleSubscriptionUpdateManyWithWhereWithoutSuperAdminInput | PoleSubscriptionUpdateManyWithWhereWithoutSuperAdminInput[]
    deleteMany?: PoleSubscriptionScalarWhereInput | PoleSubscriptionScalarWhereInput[]
  }

  export type PoleManagerProfileUncheckedUpdateManyWithoutSuperAdminNestedInput = {
    create?: XOR<PoleManagerProfileCreateWithoutSuperAdminInput, PoleManagerProfileUncheckedCreateWithoutSuperAdminInput> | PoleManagerProfileCreateWithoutSuperAdminInput[] | PoleManagerProfileUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutSuperAdminInput | PoleManagerProfileCreateOrConnectWithoutSuperAdminInput[]
    upsert?: PoleManagerProfileUpsertWithWhereUniqueWithoutSuperAdminInput | PoleManagerProfileUpsertWithWhereUniqueWithoutSuperAdminInput[]
    createMany?: PoleManagerProfileCreateManySuperAdminInputEnvelope
    set?: PoleManagerProfileWhereUniqueInput | PoleManagerProfileWhereUniqueInput[]
    disconnect?: PoleManagerProfileWhereUniqueInput | PoleManagerProfileWhereUniqueInput[]
    delete?: PoleManagerProfileWhereUniqueInput | PoleManagerProfileWhereUniqueInput[]
    connect?: PoleManagerProfileWhereUniqueInput | PoleManagerProfileWhereUniqueInput[]
    update?: PoleManagerProfileUpdateWithWhereUniqueWithoutSuperAdminInput | PoleManagerProfileUpdateWithWhereUniqueWithoutSuperAdminInput[]
    updateMany?: PoleManagerProfileUpdateManyWithWhereWithoutSuperAdminInput | PoleManagerProfileUpdateManyWithWhereWithoutSuperAdminInput[]
    deleteMany?: PoleManagerProfileScalarWhereInput | PoleManagerProfileScalarWhereInput[]
  }

  export type SuperAdminInvoiceUncheckedUpdateManyWithoutSuperAdminNestedInput = {
    create?: XOR<SuperAdminInvoiceCreateWithoutSuperAdminInput, SuperAdminInvoiceUncheckedCreateWithoutSuperAdminInput> | SuperAdminInvoiceCreateWithoutSuperAdminInput[] | SuperAdminInvoiceUncheckedCreateWithoutSuperAdminInput[]
    connectOrCreate?: SuperAdminInvoiceCreateOrConnectWithoutSuperAdminInput | SuperAdminInvoiceCreateOrConnectWithoutSuperAdminInput[]
    upsert?: SuperAdminInvoiceUpsertWithWhereUniqueWithoutSuperAdminInput | SuperAdminInvoiceUpsertWithWhereUniqueWithoutSuperAdminInput[]
    createMany?: SuperAdminInvoiceCreateManySuperAdminInputEnvelope
    set?: SuperAdminInvoiceWhereUniqueInput | SuperAdminInvoiceWhereUniqueInput[]
    disconnect?: SuperAdminInvoiceWhereUniqueInput | SuperAdminInvoiceWhereUniqueInput[]
    delete?: SuperAdminInvoiceWhereUniqueInput | SuperAdminInvoiceWhereUniqueInput[]
    connect?: SuperAdminInvoiceWhereUniqueInput | SuperAdminInvoiceWhereUniqueInput[]
    update?: SuperAdminInvoiceUpdateWithWhereUniqueWithoutSuperAdminInput | SuperAdminInvoiceUpdateWithWhereUniqueWithoutSuperAdminInput[]
    updateMany?: SuperAdminInvoiceUpdateManyWithWhereWithoutSuperAdminInput | SuperAdminInvoiceUpdateManyWithWhereWithoutSuperAdminInput[]
    deleteMany?: SuperAdminInvoiceScalarWhereInput | SuperAdminInvoiceScalarWhereInput[]
  }

  export type SuperAdminProfileCreateNestedOneWithoutPoleSubscriptionsInput = {
    create?: XOR<SuperAdminProfileCreateWithoutPoleSubscriptionsInput, SuperAdminProfileUncheckedCreateWithoutPoleSubscriptionsInput>
    connectOrCreate?: SuperAdminProfileCreateOrConnectWithoutPoleSubscriptionsInput
    connect?: SuperAdminProfileWhereUniqueInput
  }

  export type EnumPoleTypeFieldUpdateOperationsInput = {
    set?: $Enums.PoleType
  }

  export type EnumPoleStatusFieldUpdateOperationsInput = {
    set?: $Enums.PoleStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SuperAdminProfileUpdateOneRequiredWithoutPoleSubscriptionsNestedInput = {
    create?: XOR<SuperAdminProfileCreateWithoutPoleSubscriptionsInput, SuperAdminProfileUncheckedCreateWithoutPoleSubscriptionsInput>
    connectOrCreate?: SuperAdminProfileCreateOrConnectWithoutPoleSubscriptionsInput
    upsert?: SuperAdminProfileUpsertWithoutPoleSubscriptionsInput
    connect?: SuperAdminProfileWhereUniqueInput
    update?: XOR<XOR<SuperAdminProfileUpdateToOneWithWhereWithoutPoleSubscriptionsInput, SuperAdminProfileUpdateWithoutPoleSubscriptionsInput>, SuperAdminProfileUncheckedUpdateWithoutPoleSubscriptionsInput>
  }

  export type PoleManagerProfileCreatepoleTypesInput = {
    set: $Enums.PoleType[]
  }

  export type UserCreateNestedOneWithoutPoleManagerProfileInput = {
    create?: XOR<UserCreateWithoutPoleManagerProfileInput, UserUncheckedCreateWithoutPoleManagerProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutPoleManagerProfileInput
    connect?: UserWhereUniqueInput
  }

  export type SuperAdminProfileCreateNestedOneWithoutPoleManagersInput = {
    create?: XOR<SuperAdminProfileCreateWithoutPoleManagersInput, SuperAdminProfileUncheckedCreateWithoutPoleManagersInput>
    connectOrCreate?: SuperAdminProfileCreateOrConnectWithoutPoleManagersInput
    connect?: SuperAdminProfileWhereUniqueInput
  }

  export type PropertyCreateNestedManyWithoutManagerInput = {
    create?: XOR<PropertyCreateWithoutManagerInput, PropertyUncheckedCreateWithoutManagerInput> | PropertyCreateWithoutManagerInput[] | PropertyUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutManagerInput | PropertyCreateOrConnectWithoutManagerInput[]
    createMany?: PropertyCreateManyManagerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutManagerInput = {
    create?: XOR<ReservationCreateWithoutManagerInput, ReservationUncheckedCreateWithoutManagerInput> | ReservationCreateWithoutManagerInput[] | ReservationUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutManagerInput | ReservationCreateOrConnectWithoutManagerInput[]
    createMany?: ReservationCreateManyManagerInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CleaningSessionCreateNestedManyWithoutManagerInput = {
    create?: XOR<CleaningSessionCreateWithoutManagerInput, CleaningSessionUncheckedCreateWithoutManagerInput> | CleaningSessionCreateWithoutManagerInput[] | CleaningSessionUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutManagerInput | CleaningSessionCreateOrConnectWithoutManagerInput[]
    createMany?: CleaningSessionCreateManyManagerInputEnvelope
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutManagerInput = {
    create?: XOR<TicketCreateWithoutManagerInput, TicketUncheckedCreateWithoutManagerInput> | TicketCreateWithoutManagerInput[] | TicketUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutManagerInput | TicketCreateOrConnectWithoutManagerInput[]
    createMany?: TicketCreateManyManagerInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type MaintenanceSessionCreateNestedManyWithoutManagerInput = {
    create?: XOR<MaintenanceSessionCreateWithoutManagerInput, MaintenanceSessionUncheckedCreateWithoutManagerInput> | MaintenanceSessionCreateWithoutManagerInput[] | MaintenanceSessionUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutManagerInput | MaintenanceSessionCreateOrConnectWithoutManagerInput[]
    createMany?: MaintenanceSessionCreateManyManagerInputEnvelope
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
  }

  export type LaundryOrderCreateNestedManyWithoutManagerInput = {
    create?: XOR<LaundryOrderCreateWithoutManagerInput, LaundryOrderUncheckedCreateWithoutManagerInput> | LaundryOrderCreateWithoutManagerInput[] | LaundryOrderUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: LaundryOrderCreateOrConnectWithoutManagerInput | LaundryOrderCreateOrConnectWithoutManagerInput[]
    createMany?: LaundryOrderCreateManyManagerInputEnvelope
    connect?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
  }

  export type AgentProfileCreateNestedManyWithoutManagerInput = {
    create?: XOR<AgentProfileCreateWithoutManagerInput, AgentProfileUncheckedCreateWithoutManagerInput> | AgentProfileCreateWithoutManagerInput[] | AgentProfileUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: AgentProfileCreateOrConnectWithoutManagerInput | AgentProfileCreateOrConnectWithoutManagerInput[]
    createMany?: AgentProfileCreateManyManagerInputEnvelope
    connect?: AgentProfileWhereUniqueInput | AgentProfileWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<PropertyCreateWithoutManagerInput, PropertyUncheckedCreateWithoutManagerInput> | PropertyCreateWithoutManagerInput[] | PropertyUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutManagerInput | PropertyCreateOrConnectWithoutManagerInput[]
    createMany?: PropertyCreateManyManagerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<ReservationCreateWithoutManagerInput, ReservationUncheckedCreateWithoutManagerInput> | ReservationCreateWithoutManagerInput[] | ReservationUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutManagerInput | ReservationCreateOrConnectWithoutManagerInput[]
    createMany?: ReservationCreateManyManagerInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CleaningSessionUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<CleaningSessionCreateWithoutManagerInput, CleaningSessionUncheckedCreateWithoutManagerInput> | CleaningSessionCreateWithoutManagerInput[] | CleaningSessionUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutManagerInput | CleaningSessionCreateOrConnectWithoutManagerInput[]
    createMany?: CleaningSessionCreateManyManagerInputEnvelope
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<TicketCreateWithoutManagerInput, TicketUncheckedCreateWithoutManagerInput> | TicketCreateWithoutManagerInput[] | TicketUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutManagerInput | TicketCreateOrConnectWithoutManagerInput[]
    createMany?: TicketCreateManyManagerInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type MaintenanceSessionUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<MaintenanceSessionCreateWithoutManagerInput, MaintenanceSessionUncheckedCreateWithoutManagerInput> | MaintenanceSessionCreateWithoutManagerInput[] | MaintenanceSessionUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutManagerInput | MaintenanceSessionCreateOrConnectWithoutManagerInput[]
    createMany?: MaintenanceSessionCreateManyManagerInputEnvelope
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
  }

  export type LaundryOrderUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<LaundryOrderCreateWithoutManagerInput, LaundryOrderUncheckedCreateWithoutManagerInput> | LaundryOrderCreateWithoutManagerInput[] | LaundryOrderUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: LaundryOrderCreateOrConnectWithoutManagerInput | LaundryOrderCreateOrConnectWithoutManagerInput[]
    createMany?: LaundryOrderCreateManyManagerInputEnvelope
    connect?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
  }

  export type AgentProfileUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<AgentProfileCreateWithoutManagerInput, AgentProfileUncheckedCreateWithoutManagerInput> | AgentProfileCreateWithoutManagerInput[] | AgentProfileUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: AgentProfileCreateOrConnectWithoutManagerInput | AgentProfileCreateOrConnectWithoutManagerInput[]
    createMany?: AgentProfileCreateManyManagerInputEnvelope
    connect?: AgentProfileWhereUniqueInput | AgentProfileWhereUniqueInput[]
  }

  export type PoleManagerProfileUpdatepoleTypesInput = {
    set?: $Enums.PoleType[]
    push?: $Enums.PoleType | $Enums.PoleType[]
  }

  export type UserUpdateOneRequiredWithoutPoleManagerProfileNestedInput = {
    create?: XOR<UserCreateWithoutPoleManagerProfileInput, UserUncheckedCreateWithoutPoleManagerProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutPoleManagerProfileInput
    upsert?: UserUpsertWithoutPoleManagerProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPoleManagerProfileInput, UserUpdateWithoutPoleManagerProfileInput>, UserUncheckedUpdateWithoutPoleManagerProfileInput>
  }

  export type SuperAdminProfileUpdateOneRequiredWithoutPoleManagersNestedInput = {
    create?: XOR<SuperAdminProfileCreateWithoutPoleManagersInput, SuperAdminProfileUncheckedCreateWithoutPoleManagersInput>
    connectOrCreate?: SuperAdminProfileCreateOrConnectWithoutPoleManagersInput
    upsert?: SuperAdminProfileUpsertWithoutPoleManagersInput
    connect?: SuperAdminProfileWhereUniqueInput
    update?: XOR<XOR<SuperAdminProfileUpdateToOneWithWhereWithoutPoleManagersInput, SuperAdminProfileUpdateWithoutPoleManagersInput>, SuperAdminProfileUncheckedUpdateWithoutPoleManagersInput>
  }

  export type PropertyUpdateManyWithoutManagerNestedInput = {
    create?: XOR<PropertyCreateWithoutManagerInput, PropertyUncheckedCreateWithoutManagerInput> | PropertyCreateWithoutManagerInput[] | PropertyUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutManagerInput | PropertyCreateOrConnectWithoutManagerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutManagerInput | PropertyUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: PropertyCreateManyManagerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutManagerInput | PropertyUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutManagerInput | PropertyUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ReservationCreateWithoutManagerInput, ReservationUncheckedCreateWithoutManagerInput> | ReservationCreateWithoutManagerInput[] | ReservationUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutManagerInput | ReservationCreateOrConnectWithoutManagerInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutManagerInput | ReservationUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ReservationCreateManyManagerInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutManagerInput | ReservationUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutManagerInput | ReservationUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CleaningSessionUpdateManyWithoutManagerNestedInput = {
    create?: XOR<CleaningSessionCreateWithoutManagerInput, CleaningSessionUncheckedCreateWithoutManagerInput> | CleaningSessionCreateWithoutManagerInput[] | CleaningSessionUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutManagerInput | CleaningSessionCreateOrConnectWithoutManagerInput[]
    upsert?: CleaningSessionUpsertWithWhereUniqueWithoutManagerInput | CleaningSessionUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: CleaningSessionCreateManyManagerInputEnvelope
    set?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    disconnect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    delete?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    update?: CleaningSessionUpdateWithWhereUniqueWithoutManagerInput | CleaningSessionUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: CleaningSessionUpdateManyWithWhereWithoutManagerInput | CleaningSessionUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: CleaningSessionScalarWhereInput | CleaningSessionScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutManagerNestedInput = {
    create?: XOR<TicketCreateWithoutManagerInput, TicketUncheckedCreateWithoutManagerInput> | TicketCreateWithoutManagerInput[] | TicketUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutManagerInput | TicketCreateOrConnectWithoutManagerInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutManagerInput | TicketUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: TicketCreateManyManagerInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutManagerInput | TicketUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutManagerInput | TicketUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type MaintenanceSessionUpdateManyWithoutManagerNestedInput = {
    create?: XOR<MaintenanceSessionCreateWithoutManagerInput, MaintenanceSessionUncheckedCreateWithoutManagerInput> | MaintenanceSessionCreateWithoutManagerInput[] | MaintenanceSessionUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutManagerInput | MaintenanceSessionCreateOrConnectWithoutManagerInput[]
    upsert?: MaintenanceSessionUpsertWithWhereUniqueWithoutManagerInput | MaintenanceSessionUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: MaintenanceSessionCreateManyManagerInputEnvelope
    set?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    disconnect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    delete?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    update?: MaintenanceSessionUpdateWithWhereUniqueWithoutManagerInput | MaintenanceSessionUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: MaintenanceSessionUpdateManyWithWhereWithoutManagerInput | MaintenanceSessionUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: MaintenanceSessionScalarWhereInput | MaintenanceSessionScalarWhereInput[]
  }

  export type LaundryOrderUpdateManyWithoutManagerNestedInput = {
    create?: XOR<LaundryOrderCreateWithoutManagerInput, LaundryOrderUncheckedCreateWithoutManagerInput> | LaundryOrderCreateWithoutManagerInput[] | LaundryOrderUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: LaundryOrderCreateOrConnectWithoutManagerInput | LaundryOrderCreateOrConnectWithoutManagerInput[]
    upsert?: LaundryOrderUpsertWithWhereUniqueWithoutManagerInput | LaundryOrderUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: LaundryOrderCreateManyManagerInputEnvelope
    set?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
    disconnect?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
    delete?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
    connect?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
    update?: LaundryOrderUpdateWithWhereUniqueWithoutManagerInput | LaundryOrderUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: LaundryOrderUpdateManyWithWhereWithoutManagerInput | LaundryOrderUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: LaundryOrderScalarWhereInput | LaundryOrderScalarWhereInput[]
  }

  export type AgentProfileUpdateManyWithoutManagerNestedInput = {
    create?: XOR<AgentProfileCreateWithoutManagerInput, AgentProfileUncheckedCreateWithoutManagerInput> | AgentProfileCreateWithoutManagerInput[] | AgentProfileUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: AgentProfileCreateOrConnectWithoutManagerInput | AgentProfileCreateOrConnectWithoutManagerInput[]
    upsert?: AgentProfileUpsertWithWhereUniqueWithoutManagerInput | AgentProfileUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: AgentProfileCreateManyManagerInputEnvelope
    set?: AgentProfileWhereUniqueInput | AgentProfileWhereUniqueInput[]
    disconnect?: AgentProfileWhereUniqueInput | AgentProfileWhereUniqueInput[]
    delete?: AgentProfileWhereUniqueInput | AgentProfileWhereUniqueInput[]
    connect?: AgentProfileWhereUniqueInput | AgentProfileWhereUniqueInput[]
    update?: AgentProfileUpdateWithWhereUniqueWithoutManagerInput | AgentProfileUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: AgentProfileUpdateManyWithWhereWithoutManagerInput | AgentProfileUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: AgentProfileScalarWhereInput | AgentProfileScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<PropertyCreateWithoutManagerInput, PropertyUncheckedCreateWithoutManagerInput> | PropertyCreateWithoutManagerInput[] | PropertyUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutManagerInput | PropertyCreateOrConnectWithoutManagerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutManagerInput | PropertyUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: PropertyCreateManyManagerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutManagerInput | PropertyUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutManagerInput | PropertyUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ReservationCreateWithoutManagerInput, ReservationUncheckedCreateWithoutManagerInput> | ReservationCreateWithoutManagerInput[] | ReservationUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutManagerInput | ReservationCreateOrConnectWithoutManagerInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutManagerInput | ReservationUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ReservationCreateManyManagerInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutManagerInput | ReservationUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutManagerInput | ReservationUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CleaningSessionUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<CleaningSessionCreateWithoutManagerInput, CleaningSessionUncheckedCreateWithoutManagerInput> | CleaningSessionCreateWithoutManagerInput[] | CleaningSessionUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutManagerInput | CleaningSessionCreateOrConnectWithoutManagerInput[]
    upsert?: CleaningSessionUpsertWithWhereUniqueWithoutManagerInput | CleaningSessionUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: CleaningSessionCreateManyManagerInputEnvelope
    set?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    disconnect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    delete?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    update?: CleaningSessionUpdateWithWhereUniqueWithoutManagerInput | CleaningSessionUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: CleaningSessionUpdateManyWithWhereWithoutManagerInput | CleaningSessionUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: CleaningSessionScalarWhereInput | CleaningSessionScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<TicketCreateWithoutManagerInput, TicketUncheckedCreateWithoutManagerInput> | TicketCreateWithoutManagerInput[] | TicketUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutManagerInput | TicketCreateOrConnectWithoutManagerInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutManagerInput | TicketUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: TicketCreateManyManagerInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutManagerInput | TicketUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutManagerInput | TicketUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type MaintenanceSessionUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<MaintenanceSessionCreateWithoutManagerInput, MaintenanceSessionUncheckedCreateWithoutManagerInput> | MaintenanceSessionCreateWithoutManagerInput[] | MaintenanceSessionUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutManagerInput | MaintenanceSessionCreateOrConnectWithoutManagerInput[]
    upsert?: MaintenanceSessionUpsertWithWhereUniqueWithoutManagerInput | MaintenanceSessionUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: MaintenanceSessionCreateManyManagerInputEnvelope
    set?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    disconnect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    delete?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    update?: MaintenanceSessionUpdateWithWhereUniqueWithoutManagerInput | MaintenanceSessionUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: MaintenanceSessionUpdateManyWithWhereWithoutManagerInput | MaintenanceSessionUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: MaintenanceSessionScalarWhereInput | MaintenanceSessionScalarWhereInput[]
  }

  export type LaundryOrderUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<LaundryOrderCreateWithoutManagerInput, LaundryOrderUncheckedCreateWithoutManagerInput> | LaundryOrderCreateWithoutManagerInput[] | LaundryOrderUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: LaundryOrderCreateOrConnectWithoutManagerInput | LaundryOrderCreateOrConnectWithoutManagerInput[]
    upsert?: LaundryOrderUpsertWithWhereUniqueWithoutManagerInput | LaundryOrderUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: LaundryOrderCreateManyManagerInputEnvelope
    set?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
    disconnect?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
    delete?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
    connect?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
    update?: LaundryOrderUpdateWithWhereUniqueWithoutManagerInput | LaundryOrderUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: LaundryOrderUpdateManyWithWhereWithoutManagerInput | LaundryOrderUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: LaundryOrderScalarWhereInput | LaundryOrderScalarWhereInput[]
  }

  export type AgentProfileUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<AgentProfileCreateWithoutManagerInput, AgentProfileUncheckedCreateWithoutManagerInput> | AgentProfileCreateWithoutManagerInput[] | AgentProfileUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: AgentProfileCreateOrConnectWithoutManagerInput | AgentProfileCreateOrConnectWithoutManagerInput[]
    upsert?: AgentProfileUpsertWithWhereUniqueWithoutManagerInput | AgentProfileUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: AgentProfileCreateManyManagerInputEnvelope
    set?: AgentProfileWhereUniqueInput | AgentProfileWhereUniqueInput[]
    disconnect?: AgentProfileWhereUniqueInput | AgentProfileWhereUniqueInput[]
    delete?: AgentProfileWhereUniqueInput | AgentProfileWhereUniqueInput[]
    connect?: AgentProfileWhereUniqueInput | AgentProfileWhereUniqueInput[]
    update?: AgentProfileUpdateWithWhereUniqueWithoutManagerInput | AgentProfileUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: AgentProfileUpdateManyWithWhereWithoutManagerInput | AgentProfileUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: AgentProfileScalarWhereInput | AgentProfileScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPropertyOwnerProfileInput = {
    create?: XOR<UserCreateWithoutPropertyOwnerProfileInput, UserUncheckedCreateWithoutPropertyOwnerProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyOwnerProfileInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyContractCreateNestedManyWithoutPropertyOwnerInput = {
    create?: XOR<PropertyContractCreateWithoutPropertyOwnerInput, PropertyContractUncheckedCreateWithoutPropertyOwnerInput> | PropertyContractCreateWithoutPropertyOwnerInput[] | PropertyContractUncheckedCreateWithoutPropertyOwnerInput[]
    connectOrCreate?: PropertyContractCreateOrConnectWithoutPropertyOwnerInput | PropertyContractCreateOrConnectWithoutPropertyOwnerInput[]
    createMany?: PropertyContractCreateManyPropertyOwnerInputEnvelope
    connect?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyContractUncheckedCreateNestedManyWithoutPropertyOwnerInput = {
    create?: XOR<PropertyContractCreateWithoutPropertyOwnerInput, PropertyContractUncheckedCreateWithoutPropertyOwnerInput> | PropertyContractCreateWithoutPropertyOwnerInput[] | PropertyContractUncheckedCreateWithoutPropertyOwnerInput[]
    connectOrCreate?: PropertyContractCreateOrConnectWithoutPropertyOwnerInput | PropertyContractCreateOrConnectWithoutPropertyOwnerInput[]
    createMany?: PropertyContractCreateManyPropertyOwnerInputEnvelope
    connect?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPropertyOwnerProfileNestedInput = {
    create?: XOR<UserCreateWithoutPropertyOwnerProfileInput, UserUncheckedCreateWithoutPropertyOwnerProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyOwnerProfileInput
    upsert?: UserUpsertWithoutPropertyOwnerProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPropertyOwnerProfileInput, UserUpdateWithoutPropertyOwnerProfileInput>, UserUncheckedUpdateWithoutPropertyOwnerProfileInput>
  }

  export type PropertyUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutOwnerInput | PropertyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutOwnerInput | PropertyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutOwnerInput | PropertyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyContractUpdateManyWithoutPropertyOwnerNestedInput = {
    create?: XOR<PropertyContractCreateWithoutPropertyOwnerInput, PropertyContractUncheckedCreateWithoutPropertyOwnerInput> | PropertyContractCreateWithoutPropertyOwnerInput[] | PropertyContractUncheckedCreateWithoutPropertyOwnerInput[]
    connectOrCreate?: PropertyContractCreateOrConnectWithoutPropertyOwnerInput | PropertyContractCreateOrConnectWithoutPropertyOwnerInput[]
    upsert?: PropertyContractUpsertWithWhereUniqueWithoutPropertyOwnerInput | PropertyContractUpsertWithWhereUniqueWithoutPropertyOwnerInput[]
    createMany?: PropertyContractCreateManyPropertyOwnerInputEnvelope
    set?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
    disconnect?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
    delete?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
    connect?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
    update?: PropertyContractUpdateWithWhereUniqueWithoutPropertyOwnerInput | PropertyContractUpdateWithWhereUniqueWithoutPropertyOwnerInput[]
    updateMany?: PropertyContractUpdateManyWithWhereWithoutPropertyOwnerInput | PropertyContractUpdateManyWithWhereWithoutPropertyOwnerInput[]
    deleteMany?: PropertyContractScalarWhereInput | PropertyContractScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutOwnerInput | PropertyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutOwnerInput | PropertyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutOwnerInput | PropertyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyContractUncheckedUpdateManyWithoutPropertyOwnerNestedInput = {
    create?: XOR<PropertyContractCreateWithoutPropertyOwnerInput, PropertyContractUncheckedCreateWithoutPropertyOwnerInput> | PropertyContractCreateWithoutPropertyOwnerInput[] | PropertyContractUncheckedCreateWithoutPropertyOwnerInput[]
    connectOrCreate?: PropertyContractCreateOrConnectWithoutPropertyOwnerInput | PropertyContractCreateOrConnectWithoutPropertyOwnerInput[]
    upsert?: PropertyContractUpsertWithWhereUniqueWithoutPropertyOwnerInput | PropertyContractUpsertWithWhereUniqueWithoutPropertyOwnerInput[]
    createMany?: PropertyContractCreateManyPropertyOwnerInputEnvelope
    set?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
    disconnect?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
    delete?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
    connect?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
    update?: PropertyContractUpdateWithWhereUniqueWithoutPropertyOwnerInput | PropertyContractUpdateWithWhereUniqueWithoutPropertyOwnerInput[]
    updateMany?: PropertyContractUpdateManyWithWhereWithoutPropertyOwnerInput | PropertyContractUpdateManyWithWhereWithoutPropertyOwnerInput[]
    deleteMany?: PropertyContractScalarWhereInput | PropertyContractScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLaundryClientProfileInput = {
    create?: XOR<UserCreateWithoutLaundryClientProfileInput, UserUncheckedCreateWithoutLaundryClientProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutLaundryClientProfileInput
    connect?: UserWhereUniqueInput
  }

  export type LaundryOrderCreateNestedManyWithoutClientInput = {
    create?: XOR<LaundryOrderCreateWithoutClientInput, LaundryOrderUncheckedCreateWithoutClientInput> | LaundryOrderCreateWithoutClientInput[] | LaundryOrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LaundryOrderCreateOrConnectWithoutClientInput | LaundryOrderCreateOrConnectWithoutClientInput[]
    createMany?: LaundryOrderCreateManyClientInputEnvelope
    connect?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
  }

  export type LaundryInvoiceCreateNestedManyWithoutClientInput = {
    create?: XOR<LaundryInvoiceCreateWithoutClientInput, LaundryInvoiceUncheckedCreateWithoutClientInput> | LaundryInvoiceCreateWithoutClientInput[] | LaundryInvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LaundryInvoiceCreateOrConnectWithoutClientInput | LaundryInvoiceCreateOrConnectWithoutClientInput[]
    createMany?: LaundryInvoiceCreateManyClientInputEnvelope
    connect?: LaundryInvoiceWhereUniqueInput | LaundryInvoiceWhereUniqueInput[]
  }

  export type LaundryOrderUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<LaundryOrderCreateWithoutClientInput, LaundryOrderUncheckedCreateWithoutClientInput> | LaundryOrderCreateWithoutClientInput[] | LaundryOrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LaundryOrderCreateOrConnectWithoutClientInput | LaundryOrderCreateOrConnectWithoutClientInput[]
    createMany?: LaundryOrderCreateManyClientInputEnvelope
    connect?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
  }

  export type LaundryInvoiceUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<LaundryInvoiceCreateWithoutClientInput, LaundryInvoiceUncheckedCreateWithoutClientInput> | LaundryInvoiceCreateWithoutClientInput[] | LaundryInvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LaundryInvoiceCreateOrConnectWithoutClientInput | LaundryInvoiceCreateOrConnectWithoutClientInput[]
    createMany?: LaundryInvoiceCreateManyClientInputEnvelope
    connect?: LaundryInvoiceWhereUniqueInput | LaundryInvoiceWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutLaundryClientProfileNestedInput = {
    create?: XOR<UserCreateWithoutLaundryClientProfileInput, UserUncheckedCreateWithoutLaundryClientProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutLaundryClientProfileInput
    upsert?: UserUpsertWithoutLaundryClientProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLaundryClientProfileInput, UserUpdateWithoutLaundryClientProfileInput>, UserUncheckedUpdateWithoutLaundryClientProfileInput>
  }

  export type LaundryOrderUpdateManyWithoutClientNestedInput = {
    create?: XOR<LaundryOrderCreateWithoutClientInput, LaundryOrderUncheckedCreateWithoutClientInput> | LaundryOrderCreateWithoutClientInput[] | LaundryOrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LaundryOrderCreateOrConnectWithoutClientInput | LaundryOrderCreateOrConnectWithoutClientInput[]
    upsert?: LaundryOrderUpsertWithWhereUniqueWithoutClientInput | LaundryOrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: LaundryOrderCreateManyClientInputEnvelope
    set?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
    disconnect?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
    delete?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
    connect?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
    update?: LaundryOrderUpdateWithWhereUniqueWithoutClientInput | LaundryOrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: LaundryOrderUpdateManyWithWhereWithoutClientInput | LaundryOrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: LaundryOrderScalarWhereInput | LaundryOrderScalarWhereInput[]
  }

  export type LaundryInvoiceUpdateManyWithoutClientNestedInput = {
    create?: XOR<LaundryInvoiceCreateWithoutClientInput, LaundryInvoiceUncheckedCreateWithoutClientInput> | LaundryInvoiceCreateWithoutClientInput[] | LaundryInvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LaundryInvoiceCreateOrConnectWithoutClientInput | LaundryInvoiceCreateOrConnectWithoutClientInput[]
    upsert?: LaundryInvoiceUpsertWithWhereUniqueWithoutClientInput | LaundryInvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: LaundryInvoiceCreateManyClientInputEnvelope
    set?: LaundryInvoiceWhereUniqueInput | LaundryInvoiceWhereUniqueInput[]
    disconnect?: LaundryInvoiceWhereUniqueInput | LaundryInvoiceWhereUniqueInput[]
    delete?: LaundryInvoiceWhereUniqueInput | LaundryInvoiceWhereUniqueInput[]
    connect?: LaundryInvoiceWhereUniqueInput | LaundryInvoiceWhereUniqueInput[]
    update?: LaundryInvoiceUpdateWithWhereUniqueWithoutClientInput | LaundryInvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: LaundryInvoiceUpdateManyWithWhereWithoutClientInput | LaundryInvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: LaundryInvoiceScalarWhereInput | LaundryInvoiceScalarWhereInput[]
  }

  export type LaundryOrderUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<LaundryOrderCreateWithoutClientInput, LaundryOrderUncheckedCreateWithoutClientInput> | LaundryOrderCreateWithoutClientInput[] | LaundryOrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LaundryOrderCreateOrConnectWithoutClientInput | LaundryOrderCreateOrConnectWithoutClientInput[]
    upsert?: LaundryOrderUpsertWithWhereUniqueWithoutClientInput | LaundryOrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: LaundryOrderCreateManyClientInputEnvelope
    set?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
    disconnect?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
    delete?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
    connect?: LaundryOrderWhereUniqueInput | LaundryOrderWhereUniqueInput[]
    update?: LaundryOrderUpdateWithWhereUniqueWithoutClientInput | LaundryOrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: LaundryOrderUpdateManyWithWhereWithoutClientInput | LaundryOrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: LaundryOrderScalarWhereInput | LaundryOrderScalarWhereInput[]
  }

  export type LaundryInvoiceUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<LaundryInvoiceCreateWithoutClientInput, LaundryInvoiceUncheckedCreateWithoutClientInput> | LaundryInvoiceCreateWithoutClientInput[] | LaundryInvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LaundryInvoiceCreateOrConnectWithoutClientInput | LaundryInvoiceCreateOrConnectWithoutClientInput[]
    upsert?: LaundryInvoiceUpsertWithWhereUniqueWithoutClientInput | LaundryInvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: LaundryInvoiceCreateManyClientInputEnvelope
    set?: LaundryInvoiceWhereUniqueInput | LaundryInvoiceWhereUniqueInput[]
    disconnect?: LaundryInvoiceWhereUniqueInput | LaundryInvoiceWhereUniqueInput[]
    delete?: LaundryInvoiceWhereUniqueInput | LaundryInvoiceWhereUniqueInput[]
    connect?: LaundryInvoiceWhereUniqueInput | LaundryInvoiceWhereUniqueInput[]
    update?: LaundryInvoiceUpdateWithWhereUniqueWithoutClientInput | LaundryInvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: LaundryInvoiceUpdateManyWithWhereWithoutClientInput | LaundryInvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: LaundryInvoiceScalarWhereInput | LaundryInvoiceScalarWhereInput[]
  }

  export type AgentProfileCreatecertificationsInput = {
    set: string[]
  }

  export type AgentProfileCreateserviceZonesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAgentProfileInput = {
    create?: XOR<UserCreateWithoutAgentProfileInput, UserUncheckedCreateWithoutAgentProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentProfileInput
    connect?: UserWhereUniqueInput
  }

  export type AgentSpecialtyCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentSpecialtyCreateWithoutAgentInput, AgentSpecialtyUncheckedCreateWithoutAgentInput> | AgentSpecialtyCreateWithoutAgentInput[] | AgentSpecialtyUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentSpecialtyCreateOrConnectWithoutAgentInput | AgentSpecialtyCreateOrConnectWithoutAgentInput[]
    createMany?: AgentSpecialtyCreateManyAgentInputEnvelope
    connect?: AgentSpecialtyWhereUniqueInput | AgentSpecialtyWhereUniqueInput[]
  }

  export type PoleManagerProfileCreateNestedOneWithoutManagedAgentsInput = {
    create?: XOR<PoleManagerProfileCreateWithoutManagedAgentsInput, PoleManagerProfileUncheckedCreateWithoutManagedAgentsInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutManagedAgentsInput
    connect?: PoleManagerProfileWhereUniqueInput
  }

  export type CleaningSessionCreateNestedManyWithoutAgentInput = {
    create?: XOR<CleaningSessionCreateWithoutAgentInput, CleaningSessionUncheckedCreateWithoutAgentInput> | CleaningSessionCreateWithoutAgentInput[] | CleaningSessionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutAgentInput | CleaningSessionCreateOrConnectWithoutAgentInput[]
    createMany?: CleaningSessionCreateManyAgentInputEnvelope
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
  }

  export type MaintenanceSessionCreateNestedManyWithoutAgentInput = {
    create?: XOR<MaintenanceSessionCreateWithoutAgentInput, MaintenanceSessionUncheckedCreateWithoutAgentInput> | MaintenanceSessionCreateWithoutAgentInput[] | MaintenanceSessionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutAgentInput | MaintenanceSessionCreateOrConnectWithoutAgentInput[]
    createMany?: MaintenanceSessionCreateManyAgentInputEnvelope
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutAgentInput = {
    create?: XOR<TicketCreateWithoutAgentInput, TicketUncheckedCreateWithoutAgentInput> | TicketCreateWithoutAgentInput[] | TicketUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAgentInput | TicketCreateOrConnectWithoutAgentInput[]
    createMany?: TicketCreateManyAgentInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TaskAssignmentCreateNestedManyWithoutAgentInput = {
    create?: XOR<TaskAssignmentCreateWithoutAgentInput, TaskAssignmentUncheckedCreateWithoutAgentInput> | TaskAssignmentCreateWithoutAgentInput[] | TaskAssignmentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutAgentInput | TaskAssignmentCreateOrConnectWithoutAgentInput[]
    createMany?: TaskAssignmentCreateManyAgentInputEnvelope
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
  }

  export type AgentSpecialtyUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentSpecialtyCreateWithoutAgentInput, AgentSpecialtyUncheckedCreateWithoutAgentInput> | AgentSpecialtyCreateWithoutAgentInput[] | AgentSpecialtyUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentSpecialtyCreateOrConnectWithoutAgentInput | AgentSpecialtyCreateOrConnectWithoutAgentInput[]
    createMany?: AgentSpecialtyCreateManyAgentInputEnvelope
    connect?: AgentSpecialtyWhereUniqueInput | AgentSpecialtyWhereUniqueInput[]
  }

  export type CleaningSessionUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<CleaningSessionCreateWithoutAgentInput, CleaningSessionUncheckedCreateWithoutAgentInput> | CleaningSessionCreateWithoutAgentInput[] | CleaningSessionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutAgentInput | CleaningSessionCreateOrConnectWithoutAgentInput[]
    createMany?: CleaningSessionCreateManyAgentInputEnvelope
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
  }

  export type MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<MaintenanceSessionCreateWithoutAgentInput, MaintenanceSessionUncheckedCreateWithoutAgentInput> | MaintenanceSessionCreateWithoutAgentInput[] | MaintenanceSessionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutAgentInput | MaintenanceSessionCreateOrConnectWithoutAgentInput[]
    createMany?: MaintenanceSessionCreateManyAgentInputEnvelope
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<TicketCreateWithoutAgentInput, TicketUncheckedCreateWithoutAgentInput> | TicketCreateWithoutAgentInput[] | TicketUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAgentInput | TicketCreateOrConnectWithoutAgentInput[]
    createMany?: TicketCreateManyAgentInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TaskAssignmentUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<TaskAssignmentCreateWithoutAgentInput, TaskAssignmentUncheckedCreateWithoutAgentInput> | TaskAssignmentCreateWithoutAgentInput[] | TaskAssignmentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutAgentInput | TaskAssignmentCreateOrConnectWithoutAgentInput[]
    createMany?: TaskAssignmentCreateManyAgentInputEnvelope
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
  }

  export type EnumAgentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AgentType
  }

  export type EnumAgentAvailabilityFieldUpdateOperationsInput = {
    set?: $Enums.AgentAvailability
  }

  export type AgentProfileUpdatecertificationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AgentProfileUpdateserviceZonesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAgentProfileNestedInput = {
    create?: XOR<UserCreateWithoutAgentProfileInput, UserUncheckedCreateWithoutAgentProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentProfileInput
    upsert?: UserUpsertWithoutAgentProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgentProfileInput, UserUpdateWithoutAgentProfileInput>, UserUncheckedUpdateWithoutAgentProfileInput>
  }

  export type AgentSpecialtyUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentSpecialtyCreateWithoutAgentInput, AgentSpecialtyUncheckedCreateWithoutAgentInput> | AgentSpecialtyCreateWithoutAgentInput[] | AgentSpecialtyUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentSpecialtyCreateOrConnectWithoutAgentInput | AgentSpecialtyCreateOrConnectWithoutAgentInput[]
    upsert?: AgentSpecialtyUpsertWithWhereUniqueWithoutAgentInput | AgentSpecialtyUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentSpecialtyCreateManyAgentInputEnvelope
    set?: AgentSpecialtyWhereUniqueInput | AgentSpecialtyWhereUniqueInput[]
    disconnect?: AgentSpecialtyWhereUniqueInput | AgentSpecialtyWhereUniqueInput[]
    delete?: AgentSpecialtyWhereUniqueInput | AgentSpecialtyWhereUniqueInput[]
    connect?: AgentSpecialtyWhereUniqueInput | AgentSpecialtyWhereUniqueInput[]
    update?: AgentSpecialtyUpdateWithWhereUniqueWithoutAgentInput | AgentSpecialtyUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentSpecialtyUpdateManyWithWhereWithoutAgentInput | AgentSpecialtyUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentSpecialtyScalarWhereInput | AgentSpecialtyScalarWhereInput[]
  }

  export type PoleManagerProfileUpdateOneRequiredWithoutManagedAgentsNestedInput = {
    create?: XOR<PoleManagerProfileCreateWithoutManagedAgentsInput, PoleManagerProfileUncheckedCreateWithoutManagedAgentsInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutManagedAgentsInput
    upsert?: PoleManagerProfileUpsertWithoutManagedAgentsInput
    connect?: PoleManagerProfileWhereUniqueInput
    update?: XOR<XOR<PoleManagerProfileUpdateToOneWithWhereWithoutManagedAgentsInput, PoleManagerProfileUpdateWithoutManagedAgentsInput>, PoleManagerProfileUncheckedUpdateWithoutManagedAgentsInput>
  }

  export type CleaningSessionUpdateManyWithoutAgentNestedInput = {
    create?: XOR<CleaningSessionCreateWithoutAgentInput, CleaningSessionUncheckedCreateWithoutAgentInput> | CleaningSessionCreateWithoutAgentInput[] | CleaningSessionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutAgentInput | CleaningSessionCreateOrConnectWithoutAgentInput[]
    upsert?: CleaningSessionUpsertWithWhereUniqueWithoutAgentInput | CleaningSessionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: CleaningSessionCreateManyAgentInputEnvelope
    set?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    disconnect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    delete?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    update?: CleaningSessionUpdateWithWhereUniqueWithoutAgentInput | CleaningSessionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: CleaningSessionUpdateManyWithWhereWithoutAgentInput | CleaningSessionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: CleaningSessionScalarWhereInput | CleaningSessionScalarWhereInput[]
  }

  export type MaintenanceSessionUpdateManyWithoutAgentNestedInput = {
    create?: XOR<MaintenanceSessionCreateWithoutAgentInput, MaintenanceSessionUncheckedCreateWithoutAgentInput> | MaintenanceSessionCreateWithoutAgentInput[] | MaintenanceSessionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutAgentInput | MaintenanceSessionCreateOrConnectWithoutAgentInput[]
    upsert?: MaintenanceSessionUpsertWithWhereUniqueWithoutAgentInput | MaintenanceSessionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: MaintenanceSessionCreateManyAgentInputEnvelope
    set?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    disconnect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    delete?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    update?: MaintenanceSessionUpdateWithWhereUniqueWithoutAgentInput | MaintenanceSessionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: MaintenanceSessionUpdateManyWithWhereWithoutAgentInput | MaintenanceSessionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: MaintenanceSessionScalarWhereInput | MaintenanceSessionScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutAgentNestedInput = {
    create?: XOR<TicketCreateWithoutAgentInput, TicketUncheckedCreateWithoutAgentInput> | TicketCreateWithoutAgentInput[] | TicketUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAgentInput | TicketCreateOrConnectWithoutAgentInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAgentInput | TicketUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: TicketCreateManyAgentInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAgentInput | TicketUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAgentInput | TicketUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TaskAssignmentUpdateManyWithoutAgentNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutAgentInput, TaskAssignmentUncheckedCreateWithoutAgentInput> | TaskAssignmentCreateWithoutAgentInput[] | TaskAssignmentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutAgentInput | TaskAssignmentCreateOrConnectWithoutAgentInput[]
    upsert?: TaskAssignmentUpsertWithWhereUniqueWithoutAgentInput | TaskAssignmentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: TaskAssignmentCreateManyAgentInputEnvelope
    set?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    disconnect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    delete?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    update?: TaskAssignmentUpdateWithWhereUniqueWithoutAgentInput | TaskAssignmentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: TaskAssignmentUpdateManyWithWhereWithoutAgentInput | TaskAssignmentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
  }

  export type AgentSpecialtyUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentSpecialtyCreateWithoutAgentInput, AgentSpecialtyUncheckedCreateWithoutAgentInput> | AgentSpecialtyCreateWithoutAgentInput[] | AgentSpecialtyUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentSpecialtyCreateOrConnectWithoutAgentInput | AgentSpecialtyCreateOrConnectWithoutAgentInput[]
    upsert?: AgentSpecialtyUpsertWithWhereUniqueWithoutAgentInput | AgentSpecialtyUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentSpecialtyCreateManyAgentInputEnvelope
    set?: AgentSpecialtyWhereUniqueInput | AgentSpecialtyWhereUniqueInput[]
    disconnect?: AgentSpecialtyWhereUniqueInput | AgentSpecialtyWhereUniqueInput[]
    delete?: AgentSpecialtyWhereUniqueInput | AgentSpecialtyWhereUniqueInput[]
    connect?: AgentSpecialtyWhereUniqueInput | AgentSpecialtyWhereUniqueInput[]
    update?: AgentSpecialtyUpdateWithWhereUniqueWithoutAgentInput | AgentSpecialtyUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentSpecialtyUpdateManyWithWhereWithoutAgentInput | AgentSpecialtyUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentSpecialtyScalarWhereInput | AgentSpecialtyScalarWhereInput[]
  }

  export type CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<CleaningSessionCreateWithoutAgentInput, CleaningSessionUncheckedCreateWithoutAgentInput> | CleaningSessionCreateWithoutAgentInput[] | CleaningSessionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutAgentInput | CleaningSessionCreateOrConnectWithoutAgentInput[]
    upsert?: CleaningSessionUpsertWithWhereUniqueWithoutAgentInput | CleaningSessionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: CleaningSessionCreateManyAgentInputEnvelope
    set?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    disconnect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    delete?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    update?: CleaningSessionUpdateWithWhereUniqueWithoutAgentInput | CleaningSessionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: CleaningSessionUpdateManyWithWhereWithoutAgentInput | CleaningSessionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: CleaningSessionScalarWhereInput | CleaningSessionScalarWhereInput[]
  }

  export type MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<MaintenanceSessionCreateWithoutAgentInput, MaintenanceSessionUncheckedCreateWithoutAgentInput> | MaintenanceSessionCreateWithoutAgentInput[] | MaintenanceSessionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutAgentInput | MaintenanceSessionCreateOrConnectWithoutAgentInput[]
    upsert?: MaintenanceSessionUpsertWithWhereUniqueWithoutAgentInput | MaintenanceSessionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: MaintenanceSessionCreateManyAgentInputEnvelope
    set?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    disconnect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    delete?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    update?: MaintenanceSessionUpdateWithWhereUniqueWithoutAgentInput | MaintenanceSessionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: MaintenanceSessionUpdateManyWithWhereWithoutAgentInput | MaintenanceSessionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: MaintenanceSessionScalarWhereInput | MaintenanceSessionScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<TicketCreateWithoutAgentInput, TicketUncheckedCreateWithoutAgentInput> | TicketCreateWithoutAgentInput[] | TicketUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAgentInput | TicketCreateOrConnectWithoutAgentInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAgentInput | TicketUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: TicketCreateManyAgentInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAgentInput | TicketUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAgentInput | TicketUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TaskAssignmentUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<TaskAssignmentCreateWithoutAgentInput, TaskAssignmentUncheckedCreateWithoutAgentInput> | TaskAssignmentCreateWithoutAgentInput[] | TaskAssignmentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TaskAssignmentCreateOrConnectWithoutAgentInput | TaskAssignmentCreateOrConnectWithoutAgentInput[]
    upsert?: TaskAssignmentUpsertWithWhereUniqueWithoutAgentInput | TaskAssignmentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: TaskAssignmentCreateManyAgentInputEnvelope
    set?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    disconnect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    delete?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    connect?: TaskAssignmentWhereUniqueInput | TaskAssignmentWhereUniqueInput[]
    update?: TaskAssignmentUpdateWithWhereUniqueWithoutAgentInput | TaskAssignmentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: TaskAssignmentUpdateManyWithWhereWithoutAgentInput | TaskAssignmentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
  }

  export type AgentProfileCreateNestedOneWithoutSpecialtiesInput = {
    create?: XOR<AgentProfileCreateWithoutSpecialtiesInput, AgentProfileUncheckedCreateWithoutSpecialtiesInput>
    connectOrCreate?: AgentProfileCreateOrConnectWithoutSpecialtiesInput
    connect?: AgentProfileWhereUniqueInput
  }

  export type AgentProfileUpdateOneRequiredWithoutSpecialtiesNestedInput = {
    create?: XOR<AgentProfileCreateWithoutSpecialtiesInput, AgentProfileUncheckedCreateWithoutSpecialtiesInput>
    connectOrCreate?: AgentProfileCreateOrConnectWithoutSpecialtiesInput
    upsert?: AgentProfileUpsertWithoutSpecialtiesInput
    connect?: AgentProfileWhereUniqueInput
    update?: XOR<XOR<AgentProfileUpdateToOneWithWhereWithoutSpecialtiesInput, AgentProfileUpdateWithoutSpecialtiesInput>, AgentProfileUncheckedUpdateWithoutSpecialtiesInput>
  }

  export type PropertyFeatureCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyFeatureCreateWithoutPropertyInput, PropertyFeatureUncheckedCreateWithoutPropertyInput> | PropertyFeatureCreateWithoutPropertyInput[] | PropertyFeatureUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyFeatureCreateOrConnectWithoutPropertyInput | PropertyFeatureCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyFeatureCreateManyPropertyInputEnvelope
    connect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
  }

  export type PropertyPhotoCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyPhotoCreateWithoutPropertyInput, PropertyPhotoUncheckedCreateWithoutPropertyInput> | PropertyPhotoCreateWithoutPropertyInput[] | PropertyPhotoUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyPhotoCreateOrConnectWithoutPropertyInput | PropertyPhotoCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyPhotoCreateManyPropertyInputEnvelope
    connect?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
  }

  export type PropertyOwnerProfileCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<PropertyOwnerProfileCreateWithoutPropertiesInput, PropertyOwnerProfileUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyOwnerProfileCreateOrConnectWithoutPropertiesInput
    connect?: PropertyOwnerProfileWhereUniqueInput
  }

  export type PoleManagerProfileCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<PoleManagerProfileCreateWithoutPropertiesInput, PoleManagerProfileUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutPropertiesInput
    connect?: PoleManagerProfileWhereUniqueInput
  }

  export type ReservationCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ReservationCreateWithoutPropertyInput, ReservationUncheckedCreateWithoutPropertyInput> | ReservationCreateWithoutPropertyInput[] | ReservationUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPropertyInput | ReservationCreateOrConnectWithoutPropertyInput[]
    createMany?: ReservationCreateManyPropertyInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CleaningSessionCreateNestedManyWithoutPropertyInput = {
    create?: XOR<CleaningSessionCreateWithoutPropertyInput, CleaningSessionUncheckedCreateWithoutPropertyInput> | CleaningSessionCreateWithoutPropertyInput[] | CleaningSessionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutPropertyInput | CleaningSessionCreateOrConnectWithoutPropertyInput[]
    createMany?: CleaningSessionCreateManyPropertyInputEnvelope
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
  }

  export type MaintenanceSessionCreateNestedManyWithoutPropertyInput = {
    create?: XOR<MaintenanceSessionCreateWithoutPropertyInput, MaintenanceSessionUncheckedCreateWithoutPropertyInput> | MaintenanceSessionCreateWithoutPropertyInput[] | MaintenanceSessionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutPropertyInput | MaintenanceSessionCreateOrConnectWithoutPropertyInput[]
    createMany?: MaintenanceSessionCreateManyPropertyInputEnvelope
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutPropertyInput = {
    create?: XOR<TicketCreateWithoutPropertyInput, TicketUncheckedCreateWithoutPropertyInput> | TicketCreateWithoutPropertyInput[] | TicketUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutPropertyInput | TicketCreateOrConnectWithoutPropertyInput[]
    createMany?: TicketCreateManyPropertyInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type PropertyReviewCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyReviewCreateWithoutPropertyInput, PropertyReviewUncheckedCreateWithoutPropertyInput> | PropertyReviewCreateWithoutPropertyInput[] | PropertyReviewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyReviewCreateOrConnectWithoutPropertyInput | PropertyReviewCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyReviewCreateManyPropertyInputEnvelope
    connect?: PropertyReviewWhereUniqueInput | PropertyReviewWhereUniqueInput[]
  }

  export type PropertyContractCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyContractCreateWithoutPropertyInput, PropertyContractUncheckedCreateWithoutPropertyInput> | PropertyContractCreateWithoutPropertyInput[] | PropertyContractUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyContractCreateOrConnectWithoutPropertyInput | PropertyContractCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyContractCreateManyPropertyInputEnvelope
    connect?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
  }

  export type PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyFeatureCreateWithoutPropertyInput, PropertyFeatureUncheckedCreateWithoutPropertyInput> | PropertyFeatureCreateWithoutPropertyInput[] | PropertyFeatureUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyFeatureCreateOrConnectWithoutPropertyInput | PropertyFeatureCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyFeatureCreateManyPropertyInputEnvelope
    connect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
  }

  export type PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyPhotoCreateWithoutPropertyInput, PropertyPhotoUncheckedCreateWithoutPropertyInput> | PropertyPhotoCreateWithoutPropertyInput[] | PropertyPhotoUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyPhotoCreateOrConnectWithoutPropertyInput | PropertyPhotoCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyPhotoCreateManyPropertyInputEnvelope
    connect?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ReservationCreateWithoutPropertyInput, ReservationUncheckedCreateWithoutPropertyInput> | ReservationCreateWithoutPropertyInput[] | ReservationUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPropertyInput | ReservationCreateOrConnectWithoutPropertyInput[]
    createMany?: ReservationCreateManyPropertyInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<CleaningSessionCreateWithoutPropertyInput, CleaningSessionUncheckedCreateWithoutPropertyInput> | CleaningSessionCreateWithoutPropertyInput[] | CleaningSessionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutPropertyInput | CleaningSessionCreateOrConnectWithoutPropertyInput[]
    createMany?: CleaningSessionCreateManyPropertyInputEnvelope
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
  }

  export type MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<MaintenanceSessionCreateWithoutPropertyInput, MaintenanceSessionUncheckedCreateWithoutPropertyInput> | MaintenanceSessionCreateWithoutPropertyInput[] | MaintenanceSessionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutPropertyInput | MaintenanceSessionCreateOrConnectWithoutPropertyInput[]
    createMany?: MaintenanceSessionCreateManyPropertyInputEnvelope
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<TicketCreateWithoutPropertyInput, TicketUncheckedCreateWithoutPropertyInput> | TicketCreateWithoutPropertyInput[] | TicketUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutPropertyInput | TicketCreateOrConnectWithoutPropertyInput[]
    createMany?: TicketCreateManyPropertyInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type PropertyReviewUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyReviewCreateWithoutPropertyInput, PropertyReviewUncheckedCreateWithoutPropertyInput> | PropertyReviewCreateWithoutPropertyInput[] | PropertyReviewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyReviewCreateOrConnectWithoutPropertyInput | PropertyReviewCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyReviewCreateManyPropertyInputEnvelope
    connect?: PropertyReviewWhereUniqueInput | PropertyReviewWhereUniqueInput[]
  }

  export type PropertyContractUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyContractCreateWithoutPropertyInput, PropertyContractUncheckedCreateWithoutPropertyInput> | PropertyContractCreateWithoutPropertyInput[] | PropertyContractUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyContractCreateOrConnectWithoutPropertyInput | PropertyContractCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyContractCreateManyPropertyInputEnvelope
    connect?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
  }

  export type EnumPropertyStatusFieldUpdateOperationsInput = {
    set?: $Enums.PropertyStatus
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type PropertyFeatureUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyFeatureCreateWithoutPropertyInput, PropertyFeatureUncheckedCreateWithoutPropertyInput> | PropertyFeatureCreateWithoutPropertyInput[] | PropertyFeatureUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyFeatureCreateOrConnectWithoutPropertyInput | PropertyFeatureCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyFeatureUpsertWithWhereUniqueWithoutPropertyInput | PropertyFeatureUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyFeatureCreateManyPropertyInputEnvelope
    set?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    disconnect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    delete?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    connect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    update?: PropertyFeatureUpdateWithWhereUniqueWithoutPropertyInput | PropertyFeatureUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyFeatureUpdateManyWithWhereWithoutPropertyInput | PropertyFeatureUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyFeatureScalarWhereInput | PropertyFeatureScalarWhereInput[]
  }

  export type PropertyPhotoUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyPhotoCreateWithoutPropertyInput, PropertyPhotoUncheckedCreateWithoutPropertyInput> | PropertyPhotoCreateWithoutPropertyInput[] | PropertyPhotoUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyPhotoCreateOrConnectWithoutPropertyInput | PropertyPhotoCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyPhotoUpsertWithWhereUniqueWithoutPropertyInput | PropertyPhotoUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyPhotoCreateManyPropertyInputEnvelope
    set?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
    disconnect?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
    delete?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
    connect?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
    update?: PropertyPhotoUpdateWithWhereUniqueWithoutPropertyInput | PropertyPhotoUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyPhotoUpdateManyWithWhereWithoutPropertyInput | PropertyPhotoUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyPhotoScalarWhereInput | PropertyPhotoScalarWhereInput[]
  }

  export type PropertyOwnerProfileUpdateOneRequiredWithoutPropertiesNestedInput = {
    create?: XOR<PropertyOwnerProfileCreateWithoutPropertiesInput, PropertyOwnerProfileUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyOwnerProfileCreateOrConnectWithoutPropertiesInput
    upsert?: PropertyOwnerProfileUpsertWithoutPropertiesInput
    connect?: PropertyOwnerProfileWhereUniqueInput
    update?: XOR<XOR<PropertyOwnerProfileUpdateToOneWithWhereWithoutPropertiesInput, PropertyOwnerProfileUpdateWithoutPropertiesInput>, PropertyOwnerProfileUncheckedUpdateWithoutPropertiesInput>
  }

  export type PoleManagerProfileUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<PoleManagerProfileCreateWithoutPropertiesInput, PoleManagerProfileUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutPropertiesInput
    upsert?: PoleManagerProfileUpsertWithoutPropertiesInput
    disconnect?: PoleManagerProfileWhereInput | boolean
    delete?: PoleManagerProfileWhereInput | boolean
    connect?: PoleManagerProfileWhereUniqueInput
    update?: XOR<XOR<PoleManagerProfileUpdateToOneWithWhereWithoutPropertiesInput, PoleManagerProfileUpdateWithoutPropertiesInput>, PoleManagerProfileUncheckedUpdateWithoutPropertiesInput>
  }

  export type ReservationUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ReservationCreateWithoutPropertyInput, ReservationUncheckedCreateWithoutPropertyInput> | ReservationCreateWithoutPropertyInput[] | ReservationUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPropertyInput | ReservationCreateOrConnectWithoutPropertyInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutPropertyInput | ReservationUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ReservationCreateManyPropertyInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutPropertyInput | ReservationUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutPropertyInput | ReservationUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CleaningSessionUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<CleaningSessionCreateWithoutPropertyInput, CleaningSessionUncheckedCreateWithoutPropertyInput> | CleaningSessionCreateWithoutPropertyInput[] | CleaningSessionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutPropertyInput | CleaningSessionCreateOrConnectWithoutPropertyInput[]
    upsert?: CleaningSessionUpsertWithWhereUniqueWithoutPropertyInput | CleaningSessionUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: CleaningSessionCreateManyPropertyInputEnvelope
    set?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    disconnect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    delete?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    update?: CleaningSessionUpdateWithWhereUniqueWithoutPropertyInput | CleaningSessionUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: CleaningSessionUpdateManyWithWhereWithoutPropertyInput | CleaningSessionUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: CleaningSessionScalarWhereInput | CleaningSessionScalarWhereInput[]
  }

  export type MaintenanceSessionUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<MaintenanceSessionCreateWithoutPropertyInput, MaintenanceSessionUncheckedCreateWithoutPropertyInput> | MaintenanceSessionCreateWithoutPropertyInput[] | MaintenanceSessionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutPropertyInput | MaintenanceSessionCreateOrConnectWithoutPropertyInput[]
    upsert?: MaintenanceSessionUpsertWithWhereUniqueWithoutPropertyInput | MaintenanceSessionUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: MaintenanceSessionCreateManyPropertyInputEnvelope
    set?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    disconnect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    delete?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    update?: MaintenanceSessionUpdateWithWhereUniqueWithoutPropertyInput | MaintenanceSessionUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: MaintenanceSessionUpdateManyWithWhereWithoutPropertyInput | MaintenanceSessionUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: MaintenanceSessionScalarWhereInput | MaintenanceSessionScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<TicketCreateWithoutPropertyInput, TicketUncheckedCreateWithoutPropertyInput> | TicketCreateWithoutPropertyInput[] | TicketUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutPropertyInput | TicketCreateOrConnectWithoutPropertyInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutPropertyInput | TicketUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: TicketCreateManyPropertyInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutPropertyInput | TicketUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutPropertyInput | TicketUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type PropertyReviewUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyReviewCreateWithoutPropertyInput, PropertyReviewUncheckedCreateWithoutPropertyInput> | PropertyReviewCreateWithoutPropertyInput[] | PropertyReviewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyReviewCreateOrConnectWithoutPropertyInput | PropertyReviewCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyReviewUpsertWithWhereUniqueWithoutPropertyInput | PropertyReviewUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyReviewCreateManyPropertyInputEnvelope
    set?: PropertyReviewWhereUniqueInput | PropertyReviewWhereUniqueInput[]
    disconnect?: PropertyReviewWhereUniqueInput | PropertyReviewWhereUniqueInput[]
    delete?: PropertyReviewWhereUniqueInput | PropertyReviewWhereUniqueInput[]
    connect?: PropertyReviewWhereUniqueInput | PropertyReviewWhereUniqueInput[]
    update?: PropertyReviewUpdateWithWhereUniqueWithoutPropertyInput | PropertyReviewUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyReviewUpdateManyWithWhereWithoutPropertyInput | PropertyReviewUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyReviewScalarWhereInput | PropertyReviewScalarWhereInput[]
  }

  export type PropertyContractUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyContractCreateWithoutPropertyInput, PropertyContractUncheckedCreateWithoutPropertyInput> | PropertyContractCreateWithoutPropertyInput[] | PropertyContractUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyContractCreateOrConnectWithoutPropertyInput | PropertyContractCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyContractUpsertWithWhereUniqueWithoutPropertyInput | PropertyContractUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyContractCreateManyPropertyInputEnvelope
    set?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
    disconnect?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
    delete?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
    connect?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
    update?: PropertyContractUpdateWithWhereUniqueWithoutPropertyInput | PropertyContractUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyContractUpdateManyWithWhereWithoutPropertyInput | PropertyContractUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyContractScalarWhereInput | PropertyContractScalarWhereInput[]
  }

  export type PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyFeatureCreateWithoutPropertyInput, PropertyFeatureUncheckedCreateWithoutPropertyInput> | PropertyFeatureCreateWithoutPropertyInput[] | PropertyFeatureUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyFeatureCreateOrConnectWithoutPropertyInput | PropertyFeatureCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyFeatureUpsertWithWhereUniqueWithoutPropertyInput | PropertyFeatureUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyFeatureCreateManyPropertyInputEnvelope
    set?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    disconnect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    delete?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    connect?: PropertyFeatureWhereUniqueInput | PropertyFeatureWhereUniqueInput[]
    update?: PropertyFeatureUpdateWithWhereUniqueWithoutPropertyInput | PropertyFeatureUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyFeatureUpdateManyWithWhereWithoutPropertyInput | PropertyFeatureUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyFeatureScalarWhereInput | PropertyFeatureScalarWhereInput[]
  }

  export type PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyPhotoCreateWithoutPropertyInput, PropertyPhotoUncheckedCreateWithoutPropertyInput> | PropertyPhotoCreateWithoutPropertyInput[] | PropertyPhotoUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyPhotoCreateOrConnectWithoutPropertyInput | PropertyPhotoCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyPhotoUpsertWithWhereUniqueWithoutPropertyInput | PropertyPhotoUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyPhotoCreateManyPropertyInputEnvelope
    set?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
    disconnect?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
    delete?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
    connect?: PropertyPhotoWhereUniqueInput | PropertyPhotoWhereUniqueInput[]
    update?: PropertyPhotoUpdateWithWhereUniqueWithoutPropertyInput | PropertyPhotoUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyPhotoUpdateManyWithWhereWithoutPropertyInput | PropertyPhotoUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyPhotoScalarWhereInput | PropertyPhotoScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ReservationCreateWithoutPropertyInput, ReservationUncheckedCreateWithoutPropertyInput> | ReservationCreateWithoutPropertyInput[] | ReservationUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPropertyInput | ReservationCreateOrConnectWithoutPropertyInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutPropertyInput | ReservationUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ReservationCreateManyPropertyInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutPropertyInput | ReservationUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutPropertyInput | ReservationUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<CleaningSessionCreateWithoutPropertyInput, CleaningSessionUncheckedCreateWithoutPropertyInput> | CleaningSessionCreateWithoutPropertyInput[] | CleaningSessionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutPropertyInput | CleaningSessionCreateOrConnectWithoutPropertyInput[]
    upsert?: CleaningSessionUpsertWithWhereUniqueWithoutPropertyInput | CleaningSessionUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: CleaningSessionCreateManyPropertyInputEnvelope
    set?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    disconnect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    delete?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    connect?: CleaningSessionWhereUniqueInput | CleaningSessionWhereUniqueInput[]
    update?: CleaningSessionUpdateWithWhereUniqueWithoutPropertyInput | CleaningSessionUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: CleaningSessionUpdateManyWithWhereWithoutPropertyInput | CleaningSessionUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: CleaningSessionScalarWhereInput | CleaningSessionScalarWhereInput[]
  }

  export type MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<MaintenanceSessionCreateWithoutPropertyInput, MaintenanceSessionUncheckedCreateWithoutPropertyInput> | MaintenanceSessionCreateWithoutPropertyInput[] | MaintenanceSessionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutPropertyInput | MaintenanceSessionCreateOrConnectWithoutPropertyInput[]
    upsert?: MaintenanceSessionUpsertWithWhereUniqueWithoutPropertyInput | MaintenanceSessionUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: MaintenanceSessionCreateManyPropertyInputEnvelope
    set?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    disconnect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    delete?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    connect?: MaintenanceSessionWhereUniqueInput | MaintenanceSessionWhereUniqueInput[]
    update?: MaintenanceSessionUpdateWithWhereUniqueWithoutPropertyInput | MaintenanceSessionUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: MaintenanceSessionUpdateManyWithWhereWithoutPropertyInput | MaintenanceSessionUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: MaintenanceSessionScalarWhereInput | MaintenanceSessionScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<TicketCreateWithoutPropertyInput, TicketUncheckedCreateWithoutPropertyInput> | TicketCreateWithoutPropertyInput[] | TicketUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutPropertyInput | TicketCreateOrConnectWithoutPropertyInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutPropertyInput | TicketUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: TicketCreateManyPropertyInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutPropertyInput | TicketUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutPropertyInput | TicketUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type PropertyReviewUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyReviewCreateWithoutPropertyInput, PropertyReviewUncheckedCreateWithoutPropertyInput> | PropertyReviewCreateWithoutPropertyInput[] | PropertyReviewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyReviewCreateOrConnectWithoutPropertyInput | PropertyReviewCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyReviewUpsertWithWhereUniqueWithoutPropertyInput | PropertyReviewUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyReviewCreateManyPropertyInputEnvelope
    set?: PropertyReviewWhereUniqueInput | PropertyReviewWhereUniqueInput[]
    disconnect?: PropertyReviewWhereUniqueInput | PropertyReviewWhereUniqueInput[]
    delete?: PropertyReviewWhereUniqueInput | PropertyReviewWhereUniqueInput[]
    connect?: PropertyReviewWhereUniqueInput | PropertyReviewWhereUniqueInput[]
    update?: PropertyReviewUpdateWithWhereUniqueWithoutPropertyInput | PropertyReviewUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyReviewUpdateManyWithWhereWithoutPropertyInput | PropertyReviewUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyReviewScalarWhereInput | PropertyReviewScalarWhereInput[]
  }

  export type PropertyContractUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyContractCreateWithoutPropertyInput, PropertyContractUncheckedCreateWithoutPropertyInput> | PropertyContractCreateWithoutPropertyInput[] | PropertyContractUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyContractCreateOrConnectWithoutPropertyInput | PropertyContractCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyContractUpsertWithWhereUniqueWithoutPropertyInput | PropertyContractUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyContractCreateManyPropertyInputEnvelope
    set?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
    disconnect?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
    delete?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
    connect?: PropertyContractWhereUniqueInput | PropertyContractWhereUniqueInput[]
    update?: PropertyContractUpdateWithWhereUniqueWithoutPropertyInput | PropertyContractUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyContractUpdateManyWithWhereWithoutPropertyInput | PropertyContractUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyContractScalarWhereInput | PropertyContractScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<PropertyCreateWithoutFeaturesInput, PropertyUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutFeaturesInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<PropertyCreateWithoutFeaturesInput, PropertyUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutFeaturesInput
    upsert?: PropertyUpsertWithoutFeaturesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutFeaturesInput, PropertyUpdateWithoutFeaturesInput>, PropertyUncheckedUpdateWithoutFeaturesInput>
  }

  export type PropertyCreateNestedOneWithoutPhotosInput = {
    create?: XOR<PropertyCreateWithoutPhotosInput, PropertyUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPhotosInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<PropertyCreateWithoutPhotosInput, PropertyUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPhotosInput
    upsert?: PropertyUpsertWithoutPhotosInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPhotosInput, PropertyUpdateWithoutPhotosInput>, PropertyUncheckedUpdateWithoutPhotosInput>
  }

  export type PropertyCreateNestedOneWithoutReviewsInput = {
    create?: XOR<PropertyCreateWithoutReviewsInput, PropertyUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutReviewsInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<PropertyCreateWithoutReviewsInput, PropertyUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutReviewsInput
    upsert?: PropertyUpsertWithoutReviewsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutReviewsInput, PropertyUpdateWithoutReviewsInput>, PropertyUncheckedUpdateWithoutReviewsInput>
  }

  export type PropertyCreateNestedOneWithoutReservationsInput = {
    create?: XOR<PropertyCreateWithoutReservationsInput, PropertyUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutReservationsInput
    connect?: PropertyWhereUniqueInput
  }

  export type PoleManagerProfileCreateNestedOneWithoutReservationsInput = {
    create?: XOR<PoleManagerProfileCreateWithoutReservationsInput, PoleManagerProfileUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutReservationsInput
    connect?: PoleManagerProfileWhereUniqueInput
  }

  export type EnumReservationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReservationStatus
  }

  export type PropertyUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<PropertyCreateWithoutReservationsInput, PropertyUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutReservationsInput
    upsert?: PropertyUpsertWithoutReservationsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutReservationsInput, PropertyUpdateWithoutReservationsInput>, PropertyUncheckedUpdateWithoutReservationsInput>
  }

  export type PoleManagerProfileUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<PoleManagerProfileCreateWithoutReservationsInput, PoleManagerProfileUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutReservationsInput
    upsert?: PoleManagerProfileUpsertWithoutReservationsInput
    connect?: PoleManagerProfileWhereUniqueInput
    update?: XOR<XOR<PoleManagerProfileUpdateToOneWithWhereWithoutReservationsInput, PoleManagerProfileUpdateWithoutReservationsInput>, PoleManagerProfileUncheckedUpdateWithoutReservationsInput>
  }

  export type PropertyCreateNestedOneWithoutCleaningSessionsInput = {
    create?: XOR<PropertyCreateWithoutCleaningSessionsInput, PropertyUncheckedCreateWithoutCleaningSessionsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutCleaningSessionsInput
    connect?: PropertyWhereUniqueInput
  }

  export type AgentProfileCreateNestedOneWithoutCleaningSessionsInput = {
    create?: XOR<AgentProfileCreateWithoutCleaningSessionsInput, AgentProfileUncheckedCreateWithoutCleaningSessionsInput>
    connectOrCreate?: AgentProfileCreateOrConnectWithoutCleaningSessionsInput
    connect?: AgentProfileWhereUniqueInput
  }

  export type CleaningChecklistCreateNestedManyWithoutCleaningSessionInput = {
    create?: XOR<CleaningChecklistCreateWithoutCleaningSessionInput, CleaningChecklistUncheckedCreateWithoutCleaningSessionInput> | CleaningChecklistCreateWithoutCleaningSessionInput[] | CleaningChecklistUncheckedCreateWithoutCleaningSessionInput[]
    connectOrCreate?: CleaningChecklistCreateOrConnectWithoutCleaningSessionInput | CleaningChecklistCreateOrConnectWithoutCleaningSessionInput[]
    createMany?: CleaningChecklistCreateManyCleaningSessionInputEnvelope
    connect?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
  }

  export type CleaningPhotoCreateNestedManyWithoutCleaningSessionInput = {
    create?: XOR<CleaningPhotoCreateWithoutCleaningSessionInput, CleaningPhotoUncheckedCreateWithoutCleaningSessionInput> | CleaningPhotoCreateWithoutCleaningSessionInput[] | CleaningPhotoUncheckedCreateWithoutCleaningSessionInput[]
    connectOrCreate?: CleaningPhotoCreateOrConnectWithoutCleaningSessionInput | CleaningPhotoCreateOrConnectWithoutCleaningSessionInput[]
    createMany?: CleaningPhotoCreateManyCleaningSessionInputEnvelope
    connect?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
  }

  export type PoleManagerProfileCreateNestedOneWithoutCleaningSessionsInput = {
    create?: XOR<PoleManagerProfileCreateWithoutCleaningSessionsInput, PoleManagerProfileUncheckedCreateWithoutCleaningSessionsInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutCleaningSessionsInput
    connect?: PoleManagerProfileWhereUniqueInput
  }

  export type CleaningChecklistUncheckedCreateNestedManyWithoutCleaningSessionInput = {
    create?: XOR<CleaningChecklistCreateWithoutCleaningSessionInput, CleaningChecklistUncheckedCreateWithoutCleaningSessionInput> | CleaningChecklistCreateWithoutCleaningSessionInput[] | CleaningChecklistUncheckedCreateWithoutCleaningSessionInput[]
    connectOrCreate?: CleaningChecklistCreateOrConnectWithoutCleaningSessionInput | CleaningChecklistCreateOrConnectWithoutCleaningSessionInput[]
    createMany?: CleaningChecklistCreateManyCleaningSessionInputEnvelope
    connect?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
  }

  export type CleaningPhotoUncheckedCreateNestedManyWithoutCleaningSessionInput = {
    create?: XOR<CleaningPhotoCreateWithoutCleaningSessionInput, CleaningPhotoUncheckedCreateWithoutCleaningSessionInput> | CleaningPhotoCreateWithoutCleaningSessionInput[] | CleaningPhotoUncheckedCreateWithoutCleaningSessionInput[]
    connectOrCreate?: CleaningPhotoCreateOrConnectWithoutCleaningSessionInput | CleaningPhotoCreateOrConnectWithoutCleaningSessionInput[]
    createMany?: CleaningPhotoCreateManyCleaningSessionInputEnvelope
    connect?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
  }

  export type EnumSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SessionStatus
  }

  export type PropertyUpdateOneRequiredWithoutCleaningSessionsNestedInput = {
    create?: XOR<PropertyCreateWithoutCleaningSessionsInput, PropertyUncheckedCreateWithoutCleaningSessionsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutCleaningSessionsInput
    upsert?: PropertyUpsertWithoutCleaningSessionsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutCleaningSessionsInput, PropertyUpdateWithoutCleaningSessionsInput>, PropertyUncheckedUpdateWithoutCleaningSessionsInput>
  }

  export type AgentProfileUpdateOneRequiredWithoutCleaningSessionsNestedInput = {
    create?: XOR<AgentProfileCreateWithoutCleaningSessionsInput, AgentProfileUncheckedCreateWithoutCleaningSessionsInput>
    connectOrCreate?: AgentProfileCreateOrConnectWithoutCleaningSessionsInput
    upsert?: AgentProfileUpsertWithoutCleaningSessionsInput
    connect?: AgentProfileWhereUniqueInput
    update?: XOR<XOR<AgentProfileUpdateToOneWithWhereWithoutCleaningSessionsInput, AgentProfileUpdateWithoutCleaningSessionsInput>, AgentProfileUncheckedUpdateWithoutCleaningSessionsInput>
  }

  export type CleaningChecklistUpdateManyWithoutCleaningSessionNestedInput = {
    create?: XOR<CleaningChecklistCreateWithoutCleaningSessionInput, CleaningChecklistUncheckedCreateWithoutCleaningSessionInput> | CleaningChecklistCreateWithoutCleaningSessionInput[] | CleaningChecklistUncheckedCreateWithoutCleaningSessionInput[]
    connectOrCreate?: CleaningChecklistCreateOrConnectWithoutCleaningSessionInput | CleaningChecklistCreateOrConnectWithoutCleaningSessionInput[]
    upsert?: CleaningChecklistUpsertWithWhereUniqueWithoutCleaningSessionInput | CleaningChecklistUpsertWithWhereUniqueWithoutCleaningSessionInput[]
    createMany?: CleaningChecklistCreateManyCleaningSessionInputEnvelope
    set?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
    disconnect?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
    delete?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
    connect?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
    update?: CleaningChecklistUpdateWithWhereUniqueWithoutCleaningSessionInput | CleaningChecklistUpdateWithWhereUniqueWithoutCleaningSessionInput[]
    updateMany?: CleaningChecklistUpdateManyWithWhereWithoutCleaningSessionInput | CleaningChecklistUpdateManyWithWhereWithoutCleaningSessionInput[]
    deleteMany?: CleaningChecklistScalarWhereInput | CleaningChecklistScalarWhereInput[]
  }

  export type CleaningPhotoUpdateManyWithoutCleaningSessionNestedInput = {
    create?: XOR<CleaningPhotoCreateWithoutCleaningSessionInput, CleaningPhotoUncheckedCreateWithoutCleaningSessionInput> | CleaningPhotoCreateWithoutCleaningSessionInput[] | CleaningPhotoUncheckedCreateWithoutCleaningSessionInput[]
    connectOrCreate?: CleaningPhotoCreateOrConnectWithoutCleaningSessionInput | CleaningPhotoCreateOrConnectWithoutCleaningSessionInput[]
    upsert?: CleaningPhotoUpsertWithWhereUniqueWithoutCleaningSessionInput | CleaningPhotoUpsertWithWhereUniqueWithoutCleaningSessionInput[]
    createMany?: CleaningPhotoCreateManyCleaningSessionInputEnvelope
    set?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
    disconnect?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
    delete?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
    connect?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
    update?: CleaningPhotoUpdateWithWhereUniqueWithoutCleaningSessionInput | CleaningPhotoUpdateWithWhereUniqueWithoutCleaningSessionInput[]
    updateMany?: CleaningPhotoUpdateManyWithWhereWithoutCleaningSessionInput | CleaningPhotoUpdateManyWithWhereWithoutCleaningSessionInput[]
    deleteMany?: CleaningPhotoScalarWhereInput | CleaningPhotoScalarWhereInput[]
  }

  export type PoleManagerProfileUpdateOneRequiredWithoutCleaningSessionsNestedInput = {
    create?: XOR<PoleManagerProfileCreateWithoutCleaningSessionsInput, PoleManagerProfileUncheckedCreateWithoutCleaningSessionsInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutCleaningSessionsInput
    upsert?: PoleManagerProfileUpsertWithoutCleaningSessionsInput
    connect?: PoleManagerProfileWhereUniqueInput
    update?: XOR<XOR<PoleManagerProfileUpdateToOneWithWhereWithoutCleaningSessionsInput, PoleManagerProfileUpdateWithoutCleaningSessionsInput>, PoleManagerProfileUncheckedUpdateWithoutCleaningSessionsInput>
  }

  export type CleaningChecklistUncheckedUpdateManyWithoutCleaningSessionNestedInput = {
    create?: XOR<CleaningChecklistCreateWithoutCleaningSessionInput, CleaningChecklistUncheckedCreateWithoutCleaningSessionInput> | CleaningChecklistCreateWithoutCleaningSessionInput[] | CleaningChecklistUncheckedCreateWithoutCleaningSessionInput[]
    connectOrCreate?: CleaningChecklistCreateOrConnectWithoutCleaningSessionInput | CleaningChecklistCreateOrConnectWithoutCleaningSessionInput[]
    upsert?: CleaningChecklistUpsertWithWhereUniqueWithoutCleaningSessionInput | CleaningChecklistUpsertWithWhereUniqueWithoutCleaningSessionInput[]
    createMany?: CleaningChecklistCreateManyCleaningSessionInputEnvelope
    set?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
    disconnect?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
    delete?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
    connect?: CleaningChecklistWhereUniqueInput | CleaningChecklistWhereUniqueInput[]
    update?: CleaningChecklistUpdateWithWhereUniqueWithoutCleaningSessionInput | CleaningChecklistUpdateWithWhereUniqueWithoutCleaningSessionInput[]
    updateMany?: CleaningChecklistUpdateManyWithWhereWithoutCleaningSessionInput | CleaningChecklistUpdateManyWithWhereWithoutCleaningSessionInput[]
    deleteMany?: CleaningChecklistScalarWhereInput | CleaningChecklistScalarWhereInput[]
  }

  export type CleaningPhotoUncheckedUpdateManyWithoutCleaningSessionNestedInput = {
    create?: XOR<CleaningPhotoCreateWithoutCleaningSessionInput, CleaningPhotoUncheckedCreateWithoutCleaningSessionInput> | CleaningPhotoCreateWithoutCleaningSessionInput[] | CleaningPhotoUncheckedCreateWithoutCleaningSessionInput[]
    connectOrCreate?: CleaningPhotoCreateOrConnectWithoutCleaningSessionInput | CleaningPhotoCreateOrConnectWithoutCleaningSessionInput[]
    upsert?: CleaningPhotoUpsertWithWhereUniqueWithoutCleaningSessionInput | CleaningPhotoUpsertWithWhereUniqueWithoutCleaningSessionInput[]
    createMany?: CleaningPhotoCreateManyCleaningSessionInputEnvelope
    set?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
    disconnect?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
    delete?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
    connect?: CleaningPhotoWhereUniqueInput | CleaningPhotoWhereUniqueInput[]
    update?: CleaningPhotoUpdateWithWhereUniqueWithoutCleaningSessionInput | CleaningPhotoUpdateWithWhereUniqueWithoutCleaningSessionInput[]
    updateMany?: CleaningPhotoUpdateManyWithWhereWithoutCleaningSessionInput | CleaningPhotoUpdateManyWithWhereWithoutCleaningSessionInput[]
    deleteMany?: CleaningPhotoScalarWhereInput | CleaningPhotoScalarWhereInput[]
  }

  export type CleaningSessionCreateNestedOneWithoutChecklistInput = {
    create?: XOR<CleaningSessionCreateWithoutChecklistInput, CleaningSessionUncheckedCreateWithoutChecklistInput>
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutChecklistInput
    connect?: CleaningSessionWhereUniqueInput
  }

  export type CleaningSessionUpdateOneRequiredWithoutChecklistNestedInput = {
    create?: XOR<CleaningSessionCreateWithoutChecklistInput, CleaningSessionUncheckedCreateWithoutChecklistInput>
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutChecklistInput
    upsert?: CleaningSessionUpsertWithoutChecklistInput
    connect?: CleaningSessionWhereUniqueInput
    update?: XOR<XOR<CleaningSessionUpdateToOneWithWhereWithoutChecklistInput, CleaningSessionUpdateWithoutChecklistInput>, CleaningSessionUncheckedUpdateWithoutChecklistInput>
  }

  export type CleaningSessionCreateNestedOneWithoutPhotosInput = {
    create?: XOR<CleaningSessionCreateWithoutPhotosInput, CleaningSessionUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutPhotosInput
    connect?: CleaningSessionWhereUniqueInput
  }

  export type CleaningSessionUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<CleaningSessionCreateWithoutPhotosInput, CleaningSessionUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: CleaningSessionCreateOrConnectWithoutPhotosInput
    upsert?: CleaningSessionUpsertWithoutPhotosInput
    connect?: CleaningSessionWhereUniqueInput
    update?: XOR<XOR<CleaningSessionUpdateToOneWithWhereWithoutPhotosInput, CleaningSessionUpdateWithoutPhotosInput>, CleaningSessionUncheckedUpdateWithoutPhotosInput>
  }

  export type PropertyCreateNestedOneWithoutTicketsInput = {
    create?: XOR<PropertyCreateWithoutTicketsInput, PropertyUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutTicketsInput
    connect?: PropertyWhereUniqueInput
  }

  export type AgentProfileCreateNestedOneWithoutTicketsInput = {
    create?: XOR<AgentProfileCreateWithoutTicketsInput, AgentProfileUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: AgentProfileCreateOrConnectWithoutTicketsInput
    connect?: AgentProfileWhereUniqueInput
  }

  export type TicketPhotoCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketPhotoCreateWithoutTicketInput, TicketPhotoUncheckedCreateWithoutTicketInput> | TicketPhotoCreateWithoutTicketInput[] | TicketPhotoUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketPhotoCreateOrConnectWithoutTicketInput | TicketPhotoCreateOrConnectWithoutTicketInput[]
    createMany?: TicketPhotoCreateManyTicketInputEnvelope
    connect?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
  }

  export type PoleManagerProfileCreateNestedOneWithoutTicketsInput = {
    create?: XOR<PoleManagerProfileCreateWithoutTicketsInput, PoleManagerProfileUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutTicketsInput
    connect?: PoleManagerProfileWhereUniqueInput
  }

  export type MaintenanceSessionCreateNestedOneWithoutTicketInput = {
    create?: XOR<MaintenanceSessionCreateWithoutTicketInput, MaintenanceSessionUncheckedCreateWithoutTicketInput>
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutTicketInput
    connect?: MaintenanceSessionWhereUniqueInput
  }

  export type TicketPhotoUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketPhotoCreateWithoutTicketInput, TicketPhotoUncheckedCreateWithoutTicketInput> | TicketPhotoCreateWithoutTicketInput[] | TicketPhotoUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketPhotoCreateOrConnectWithoutTicketInput | TicketPhotoCreateOrConnectWithoutTicketInput[]
    createMany?: TicketPhotoCreateManyTicketInputEnvelope
    connect?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
  }

  export type MaintenanceSessionUncheckedCreateNestedOneWithoutTicketInput = {
    create?: XOR<MaintenanceSessionCreateWithoutTicketInput, MaintenanceSessionUncheckedCreateWithoutTicketInput>
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutTicketInput
    connect?: MaintenanceSessionWhereUniqueInput
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type EnumTicketPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TicketPriority
  }

  export type PropertyUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<PropertyCreateWithoutTicketsInput, PropertyUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutTicketsInput
    upsert?: PropertyUpsertWithoutTicketsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutTicketsInput, PropertyUpdateWithoutTicketsInput>, PropertyUncheckedUpdateWithoutTicketsInput>
  }

  export type AgentProfileUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<AgentProfileCreateWithoutTicketsInput, AgentProfileUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: AgentProfileCreateOrConnectWithoutTicketsInput
    upsert?: AgentProfileUpsertWithoutTicketsInput
    disconnect?: AgentProfileWhereInput | boolean
    delete?: AgentProfileWhereInput | boolean
    connect?: AgentProfileWhereUniqueInput
    update?: XOR<XOR<AgentProfileUpdateToOneWithWhereWithoutTicketsInput, AgentProfileUpdateWithoutTicketsInput>, AgentProfileUncheckedUpdateWithoutTicketsInput>
  }

  export type TicketPhotoUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketPhotoCreateWithoutTicketInput, TicketPhotoUncheckedCreateWithoutTicketInput> | TicketPhotoCreateWithoutTicketInput[] | TicketPhotoUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketPhotoCreateOrConnectWithoutTicketInput | TicketPhotoCreateOrConnectWithoutTicketInput[]
    upsert?: TicketPhotoUpsertWithWhereUniqueWithoutTicketInput | TicketPhotoUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketPhotoCreateManyTicketInputEnvelope
    set?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
    disconnect?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
    delete?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
    connect?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
    update?: TicketPhotoUpdateWithWhereUniqueWithoutTicketInput | TicketPhotoUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketPhotoUpdateManyWithWhereWithoutTicketInput | TicketPhotoUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketPhotoScalarWhereInput | TicketPhotoScalarWhereInput[]
  }

  export type PoleManagerProfileUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<PoleManagerProfileCreateWithoutTicketsInput, PoleManagerProfileUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutTicketsInput
    upsert?: PoleManagerProfileUpsertWithoutTicketsInput
    connect?: PoleManagerProfileWhereUniqueInput
    update?: XOR<XOR<PoleManagerProfileUpdateToOneWithWhereWithoutTicketsInput, PoleManagerProfileUpdateWithoutTicketsInput>, PoleManagerProfileUncheckedUpdateWithoutTicketsInput>
  }

  export type MaintenanceSessionUpdateOneWithoutTicketNestedInput = {
    create?: XOR<MaintenanceSessionCreateWithoutTicketInput, MaintenanceSessionUncheckedCreateWithoutTicketInput>
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutTicketInput
    upsert?: MaintenanceSessionUpsertWithoutTicketInput
    disconnect?: MaintenanceSessionWhereInput | boolean
    delete?: MaintenanceSessionWhereInput | boolean
    connect?: MaintenanceSessionWhereUniqueInput
    update?: XOR<XOR<MaintenanceSessionUpdateToOneWithWhereWithoutTicketInput, MaintenanceSessionUpdateWithoutTicketInput>, MaintenanceSessionUncheckedUpdateWithoutTicketInput>
  }

  export type TicketPhotoUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketPhotoCreateWithoutTicketInput, TicketPhotoUncheckedCreateWithoutTicketInput> | TicketPhotoCreateWithoutTicketInput[] | TicketPhotoUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketPhotoCreateOrConnectWithoutTicketInput | TicketPhotoCreateOrConnectWithoutTicketInput[]
    upsert?: TicketPhotoUpsertWithWhereUniqueWithoutTicketInput | TicketPhotoUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketPhotoCreateManyTicketInputEnvelope
    set?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
    disconnect?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
    delete?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
    connect?: TicketPhotoWhereUniqueInput | TicketPhotoWhereUniqueInput[]
    update?: TicketPhotoUpdateWithWhereUniqueWithoutTicketInput | TicketPhotoUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketPhotoUpdateManyWithWhereWithoutTicketInput | TicketPhotoUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketPhotoScalarWhereInput | TicketPhotoScalarWhereInput[]
  }

  export type MaintenanceSessionUncheckedUpdateOneWithoutTicketNestedInput = {
    create?: XOR<MaintenanceSessionCreateWithoutTicketInput, MaintenanceSessionUncheckedCreateWithoutTicketInput>
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutTicketInput
    upsert?: MaintenanceSessionUpsertWithoutTicketInput
    disconnect?: MaintenanceSessionWhereInput | boolean
    delete?: MaintenanceSessionWhereInput | boolean
    connect?: MaintenanceSessionWhereUniqueInput
    update?: XOR<XOR<MaintenanceSessionUpdateToOneWithWhereWithoutTicketInput, MaintenanceSessionUpdateWithoutTicketInput>, MaintenanceSessionUncheckedUpdateWithoutTicketInput>
  }

  export type TicketCreateNestedOneWithoutPhotosInput = {
    create?: XOR<TicketCreateWithoutPhotosInput, TicketUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: TicketCreateOrConnectWithoutPhotosInput
    connect?: TicketWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<TicketCreateWithoutPhotosInput, TicketUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: TicketCreateOrConnectWithoutPhotosInput
    upsert?: TicketUpsertWithoutPhotosInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutPhotosInput, TicketUpdateWithoutPhotosInput>, TicketUncheckedUpdateWithoutPhotosInput>
  }

  export type TicketCreateNestedOneWithoutMaintenanceSessionInput = {
    create?: XOR<TicketCreateWithoutMaintenanceSessionInput, TicketUncheckedCreateWithoutMaintenanceSessionInput>
    connectOrCreate?: TicketCreateOrConnectWithoutMaintenanceSessionInput
    connect?: TicketWhereUniqueInput
  }

  export type PropertyCreateNestedOneWithoutMaintenanceSessionsInput = {
    create?: XOR<PropertyCreateWithoutMaintenanceSessionsInput, PropertyUncheckedCreateWithoutMaintenanceSessionsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutMaintenanceSessionsInput
    connect?: PropertyWhereUniqueInput
  }

  export type AgentProfileCreateNestedOneWithoutMaintenanceSessionsInput = {
    create?: XOR<AgentProfileCreateWithoutMaintenanceSessionsInput, AgentProfileUncheckedCreateWithoutMaintenanceSessionsInput>
    connectOrCreate?: AgentProfileCreateOrConnectWithoutMaintenanceSessionsInput
    connect?: AgentProfileWhereUniqueInput
  }

  export type MaintenanceMaterialCreateNestedManyWithoutMaintenanceSessionInput = {
    create?: XOR<MaintenanceMaterialCreateWithoutMaintenanceSessionInput, MaintenanceMaterialUncheckedCreateWithoutMaintenanceSessionInput> | MaintenanceMaterialCreateWithoutMaintenanceSessionInput[] | MaintenanceMaterialUncheckedCreateWithoutMaintenanceSessionInput[]
    connectOrCreate?: MaintenanceMaterialCreateOrConnectWithoutMaintenanceSessionInput | MaintenanceMaterialCreateOrConnectWithoutMaintenanceSessionInput[]
    createMany?: MaintenanceMaterialCreateManyMaintenanceSessionInputEnvelope
    connect?: MaintenanceMaterialWhereUniqueInput | MaintenanceMaterialWhereUniqueInput[]
  }

  export type MaintenancePhotoCreateNestedManyWithoutMaintenanceSessionInput = {
    create?: XOR<MaintenancePhotoCreateWithoutMaintenanceSessionInput, MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput> | MaintenancePhotoCreateWithoutMaintenanceSessionInput[] | MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput[]
    connectOrCreate?: MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput | MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput[]
    createMany?: MaintenancePhotoCreateManyMaintenanceSessionInputEnvelope
    connect?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
  }

  export type PoleManagerProfileCreateNestedOneWithoutMaintenanceSessionsInput = {
    create?: XOR<PoleManagerProfileCreateWithoutMaintenanceSessionsInput, PoleManagerProfileUncheckedCreateWithoutMaintenanceSessionsInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutMaintenanceSessionsInput
    connect?: PoleManagerProfileWhereUniqueInput
  }

  export type MaintenanceMaterialUncheckedCreateNestedManyWithoutMaintenanceSessionInput = {
    create?: XOR<MaintenanceMaterialCreateWithoutMaintenanceSessionInput, MaintenanceMaterialUncheckedCreateWithoutMaintenanceSessionInput> | MaintenanceMaterialCreateWithoutMaintenanceSessionInput[] | MaintenanceMaterialUncheckedCreateWithoutMaintenanceSessionInput[]
    connectOrCreate?: MaintenanceMaterialCreateOrConnectWithoutMaintenanceSessionInput | MaintenanceMaterialCreateOrConnectWithoutMaintenanceSessionInput[]
    createMany?: MaintenanceMaterialCreateManyMaintenanceSessionInputEnvelope
    connect?: MaintenanceMaterialWhereUniqueInput | MaintenanceMaterialWhereUniqueInput[]
  }

  export type MaintenancePhotoUncheckedCreateNestedManyWithoutMaintenanceSessionInput = {
    create?: XOR<MaintenancePhotoCreateWithoutMaintenanceSessionInput, MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput> | MaintenancePhotoCreateWithoutMaintenanceSessionInput[] | MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput[]
    connectOrCreate?: MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput | MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput[]
    createMany?: MaintenancePhotoCreateManyMaintenanceSessionInputEnvelope
    connect?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
  }

  export type TicketUpdateOneRequiredWithoutMaintenanceSessionNestedInput = {
    create?: XOR<TicketCreateWithoutMaintenanceSessionInput, TicketUncheckedCreateWithoutMaintenanceSessionInput>
    connectOrCreate?: TicketCreateOrConnectWithoutMaintenanceSessionInput
    upsert?: TicketUpsertWithoutMaintenanceSessionInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutMaintenanceSessionInput, TicketUpdateWithoutMaintenanceSessionInput>, TicketUncheckedUpdateWithoutMaintenanceSessionInput>
  }

  export type PropertyUpdateOneRequiredWithoutMaintenanceSessionsNestedInput = {
    create?: XOR<PropertyCreateWithoutMaintenanceSessionsInput, PropertyUncheckedCreateWithoutMaintenanceSessionsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutMaintenanceSessionsInput
    upsert?: PropertyUpsertWithoutMaintenanceSessionsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutMaintenanceSessionsInput, PropertyUpdateWithoutMaintenanceSessionsInput>, PropertyUncheckedUpdateWithoutMaintenanceSessionsInput>
  }

  export type AgentProfileUpdateOneRequiredWithoutMaintenanceSessionsNestedInput = {
    create?: XOR<AgentProfileCreateWithoutMaintenanceSessionsInput, AgentProfileUncheckedCreateWithoutMaintenanceSessionsInput>
    connectOrCreate?: AgentProfileCreateOrConnectWithoutMaintenanceSessionsInput
    upsert?: AgentProfileUpsertWithoutMaintenanceSessionsInput
    connect?: AgentProfileWhereUniqueInput
    update?: XOR<XOR<AgentProfileUpdateToOneWithWhereWithoutMaintenanceSessionsInput, AgentProfileUpdateWithoutMaintenanceSessionsInput>, AgentProfileUncheckedUpdateWithoutMaintenanceSessionsInput>
  }

  export type MaintenanceMaterialUpdateManyWithoutMaintenanceSessionNestedInput = {
    create?: XOR<MaintenanceMaterialCreateWithoutMaintenanceSessionInput, MaintenanceMaterialUncheckedCreateWithoutMaintenanceSessionInput> | MaintenanceMaterialCreateWithoutMaintenanceSessionInput[] | MaintenanceMaterialUncheckedCreateWithoutMaintenanceSessionInput[]
    connectOrCreate?: MaintenanceMaterialCreateOrConnectWithoutMaintenanceSessionInput | MaintenanceMaterialCreateOrConnectWithoutMaintenanceSessionInput[]
    upsert?: MaintenanceMaterialUpsertWithWhereUniqueWithoutMaintenanceSessionInput | MaintenanceMaterialUpsertWithWhereUniqueWithoutMaintenanceSessionInput[]
    createMany?: MaintenanceMaterialCreateManyMaintenanceSessionInputEnvelope
    set?: MaintenanceMaterialWhereUniqueInput | MaintenanceMaterialWhereUniqueInput[]
    disconnect?: MaintenanceMaterialWhereUniqueInput | MaintenanceMaterialWhereUniqueInput[]
    delete?: MaintenanceMaterialWhereUniqueInput | MaintenanceMaterialWhereUniqueInput[]
    connect?: MaintenanceMaterialWhereUniqueInput | MaintenanceMaterialWhereUniqueInput[]
    update?: MaintenanceMaterialUpdateWithWhereUniqueWithoutMaintenanceSessionInput | MaintenanceMaterialUpdateWithWhereUniqueWithoutMaintenanceSessionInput[]
    updateMany?: MaintenanceMaterialUpdateManyWithWhereWithoutMaintenanceSessionInput | MaintenanceMaterialUpdateManyWithWhereWithoutMaintenanceSessionInput[]
    deleteMany?: MaintenanceMaterialScalarWhereInput | MaintenanceMaterialScalarWhereInput[]
  }

  export type MaintenancePhotoUpdateManyWithoutMaintenanceSessionNestedInput = {
    create?: XOR<MaintenancePhotoCreateWithoutMaintenanceSessionInput, MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput> | MaintenancePhotoCreateWithoutMaintenanceSessionInput[] | MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput[]
    connectOrCreate?: MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput | MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput[]
    upsert?: MaintenancePhotoUpsertWithWhereUniqueWithoutMaintenanceSessionInput | MaintenancePhotoUpsertWithWhereUniqueWithoutMaintenanceSessionInput[]
    createMany?: MaintenancePhotoCreateManyMaintenanceSessionInputEnvelope
    set?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
    disconnect?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
    delete?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
    connect?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
    update?: MaintenancePhotoUpdateWithWhereUniqueWithoutMaintenanceSessionInput | MaintenancePhotoUpdateWithWhereUniqueWithoutMaintenanceSessionInput[]
    updateMany?: MaintenancePhotoUpdateManyWithWhereWithoutMaintenanceSessionInput | MaintenancePhotoUpdateManyWithWhereWithoutMaintenanceSessionInput[]
    deleteMany?: MaintenancePhotoScalarWhereInput | MaintenancePhotoScalarWhereInput[]
  }

  export type PoleManagerProfileUpdateOneRequiredWithoutMaintenanceSessionsNestedInput = {
    create?: XOR<PoleManagerProfileCreateWithoutMaintenanceSessionsInput, PoleManagerProfileUncheckedCreateWithoutMaintenanceSessionsInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutMaintenanceSessionsInput
    upsert?: PoleManagerProfileUpsertWithoutMaintenanceSessionsInput
    connect?: PoleManagerProfileWhereUniqueInput
    update?: XOR<XOR<PoleManagerProfileUpdateToOneWithWhereWithoutMaintenanceSessionsInput, PoleManagerProfileUpdateWithoutMaintenanceSessionsInput>, PoleManagerProfileUncheckedUpdateWithoutMaintenanceSessionsInput>
  }

  export type MaintenanceMaterialUncheckedUpdateManyWithoutMaintenanceSessionNestedInput = {
    create?: XOR<MaintenanceMaterialCreateWithoutMaintenanceSessionInput, MaintenanceMaterialUncheckedCreateWithoutMaintenanceSessionInput> | MaintenanceMaterialCreateWithoutMaintenanceSessionInput[] | MaintenanceMaterialUncheckedCreateWithoutMaintenanceSessionInput[]
    connectOrCreate?: MaintenanceMaterialCreateOrConnectWithoutMaintenanceSessionInput | MaintenanceMaterialCreateOrConnectWithoutMaintenanceSessionInput[]
    upsert?: MaintenanceMaterialUpsertWithWhereUniqueWithoutMaintenanceSessionInput | MaintenanceMaterialUpsertWithWhereUniqueWithoutMaintenanceSessionInput[]
    createMany?: MaintenanceMaterialCreateManyMaintenanceSessionInputEnvelope
    set?: MaintenanceMaterialWhereUniqueInput | MaintenanceMaterialWhereUniqueInput[]
    disconnect?: MaintenanceMaterialWhereUniqueInput | MaintenanceMaterialWhereUniqueInput[]
    delete?: MaintenanceMaterialWhereUniqueInput | MaintenanceMaterialWhereUniqueInput[]
    connect?: MaintenanceMaterialWhereUniqueInput | MaintenanceMaterialWhereUniqueInput[]
    update?: MaintenanceMaterialUpdateWithWhereUniqueWithoutMaintenanceSessionInput | MaintenanceMaterialUpdateWithWhereUniqueWithoutMaintenanceSessionInput[]
    updateMany?: MaintenanceMaterialUpdateManyWithWhereWithoutMaintenanceSessionInput | MaintenanceMaterialUpdateManyWithWhereWithoutMaintenanceSessionInput[]
    deleteMany?: MaintenanceMaterialScalarWhereInput | MaintenanceMaterialScalarWhereInput[]
  }

  export type MaintenancePhotoUncheckedUpdateManyWithoutMaintenanceSessionNestedInput = {
    create?: XOR<MaintenancePhotoCreateWithoutMaintenanceSessionInput, MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput> | MaintenancePhotoCreateWithoutMaintenanceSessionInput[] | MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput[]
    connectOrCreate?: MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput | MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput[]
    upsert?: MaintenancePhotoUpsertWithWhereUniqueWithoutMaintenanceSessionInput | MaintenancePhotoUpsertWithWhereUniqueWithoutMaintenanceSessionInput[]
    createMany?: MaintenancePhotoCreateManyMaintenanceSessionInputEnvelope
    set?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
    disconnect?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
    delete?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
    connect?: MaintenancePhotoWhereUniqueInput | MaintenancePhotoWhereUniqueInput[]
    update?: MaintenancePhotoUpdateWithWhereUniqueWithoutMaintenanceSessionInput | MaintenancePhotoUpdateWithWhereUniqueWithoutMaintenanceSessionInput[]
    updateMany?: MaintenancePhotoUpdateManyWithWhereWithoutMaintenanceSessionInput | MaintenancePhotoUpdateManyWithWhereWithoutMaintenanceSessionInput[]
    deleteMany?: MaintenancePhotoScalarWhereInput | MaintenancePhotoScalarWhereInput[]
  }

  export type MaintenanceSessionCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<MaintenanceSessionCreateWithoutMaterialsInput, MaintenanceSessionUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutMaterialsInput
    connect?: MaintenanceSessionWhereUniqueInput
  }

  export type MaintenanceSessionUpdateOneRequiredWithoutMaterialsNestedInput = {
    create?: XOR<MaintenanceSessionCreateWithoutMaterialsInput, MaintenanceSessionUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutMaterialsInput
    upsert?: MaintenanceSessionUpsertWithoutMaterialsInput
    connect?: MaintenanceSessionWhereUniqueInput
    update?: XOR<XOR<MaintenanceSessionUpdateToOneWithWhereWithoutMaterialsInput, MaintenanceSessionUpdateWithoutMaterialsInput>, MaintenanceSessionUncheckedUpdateWithoutMaterialsInput>
  }

  export type MaintenanceSessionCreateNestedOneWithoutPhotosInput = {
    create?: XOR<MaintenanceSessionCreateWithoutPhotosInput, MaintenanceSessionUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutPhotosInput
    connect?: MaintenanceSessionWhereUniqueInput
  }

  export type MaintenanceSessionUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<MaintenanceSessionCreateWithoutPhotosInput, MaintenanceSessionUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: MaintenanceSessionCreateOrConnectWithoutPhotosInput
    upsert?: MaintenanceSessionUpsertWithoutPhotosInput
    connect?: MaintenanceSessionWhereUniqueInput
    update?: XOR<XOR<MaintenanceSessionUpdateToOneWithWhereWithoutPhotosInput, MaintenanceSessionUpdateWithoutPhotosInput>, MaintenanceSessionUncheckedUpdateWithoutPhotosInput>
  }

  export type LaundryOrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<LaundryOrderItemCreateWithoutProductInput, LaundryOrderItemUncheckedCreateWithoutProductInput> | LaundryOrderItemCreateWithoutProductInput[] | LaundryOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: LaundryOrderItemCreateOrConnectWithoutProductInput | LaundryOrderItemCreateOrConnectWithoutProductInput[]
    createMany?: LaundryOrderItemCreateManyProductInputEnvelope
    connect?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
  }

  export type LaundryOrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<LaundryOrderItemCreateWithoutProductInput, LaundryOrderItemUncheckedCreateWithoutProductInput> | LaundryOrderItemCreateWithoutProductInput[] | LaundryOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: LaundryOrderItemCreateOrConnectWithoutProductInput | LaundryOrderItemCreateOrConnectWithoutProductInput[]
    createMany?: LaundryOrderItemCreateManyProductInputEnvelope
    connect?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
  }

  export type LaundryOrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<LaundryOrderItemCreateWithoutProductInput, LaundryOrderItemUncheckedCreateWithoutProductInput> | LaundryOrderItemCreateWithoutProductInput[] | LaundryOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: LaundryOrderItemCreateOrConnectWithoutProductInput | LaundryOrderItemCreateOrConnectWithoutProductInput[]
    upsert?: LaundryOrderItemUpsertWithWhereUniqueWithoutProductInput | LaundryOrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: LaundryOrderItemCreateManyProductInputEnvelope
    set?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
    disconnect?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
    delete?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
    connect?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
    update?: LaundryOrderItemUpdateWithWhereUniqueWithoutProductInput | LaundryOrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: LaundryOrderItemUpdateManyWithWhereWithoutProductInput | LaundryOrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: LaundryOrderItemScalarWhereInput | LaundryOrderItemScalarWhereInput[]
  }

  export type LaundryOrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<LaundryOrderItemCreateWithoutProductInput, LaundryOrderItemUncheckedCreateWithoutProductInput> | LaundryOrderItemCreateWithoutProductInput[] | LaundryOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: LaundryOrderItemCreateOrConnectWithoutProductInput | LaundryOrderItemCreateOrConnectWithoutProductInput[]
    upsert?: LaundryOrderItemUpsertWithWhereUniqueWithoutProductInput | LaundryOrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: LaundryOrderItemCreateManyProductInputEnvelope
    set?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
    disconnect?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
    delete?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
    connect?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
    update?: LaundryOrderItemUpdateWithWhereUniqueWithoutProductInput | LaundryOrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: LaundryOrderItemUpdateManyWithWhereWithoutProductInput | LaundryOrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: LaundryOrderItemScalarWhereInput | LaundryOrderItemScalarWhereInput[]
  }

  export type PoleManagerProfileCreateNestedOneWithoutLaundryOrdersInput = {
    create?: XOR<PoleManagerProfileCreateWithoutLaundryOrdersInput, PoleManagerProfileUncheckedCreateWithoutLaundryOrdersInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutLaundryOrdersInput
    connect?: PoleManagerProfileWhereUniqueInput
  }

  export type LaundryClientProfileCreateNestedOneWithoutLaundryOrdersInput = {
    create?: XOR<LaundryClientProfileCreateWithoutLaundryOrdersInput, LaundryClientProfileUncheckedCreateWithoutLaundryOrdersInput>
    connectOrCreate?: LaundryClientProfileCreateOrConnectWithoutLaundryOrdersInput
    connect?: LaundryClientProfileWhereUniqueInput
  }

  export type LaundryOrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<LaundryOrderItemCreateWithoutOrderInput, LaundryOrderItemUncheckedCreateWithoutOrderInput> | LaundryOrderItemCreateWithoutOrderInput[] | LaundryOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: LaundryOrderItemCreateOrConnectWithoutOrderInput | LaundryOrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: LaundryOrderItemCreateManyOrderInputEnvelope
    connect?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
  }

  export type DeliveryNoteCreateNestedManyWithoutOrderInput = {
    create?: XOR<DeliveryNoteCreateWithoutOrderInput, DeliveryNoteUncheckedCreateWithoutOrderInput> | DeliveryNoteCreateWithoutOrderInput[] | DeliveryNoteUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryNoteCreateOrConnectWithoutOrderInput | DeliveryNoteCreateOrConnectWithoutOrderInput[]
    createMany?: DeliveryNoteCreateManyOrderInputEnvelope
    connect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
  }

  export type LaundryOrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<LaundryOrderItemCreateWithoutOrderInput, LaundryOrderItemUncheckedCreateWithoutOrderInput> | LaundryOrderItemCreateWithoutOrderInput[] | LaundryOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: LaundryOrderItemCreateOrConnectWithoutOrderInput | LaundryOrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: LaundryOrderItemCreateManyOrderInputEnvelope
    connect?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
  }

  export type DeliveryNoteUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<DeliveryNoteCreateWithoutOrderInput, DeliveryNoteUncheckedCreateWithoutOrderInput> | DeliveryNoteCreateWithoutOrderInput[] | DeliveryNoteUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryNoteCreateOrConnectWithoutOrderInput | DeliveryNoteCreateOrConnectWithoutOrderInput[]
    createMany?: DeliveryNoteCreateManyOrderInputEnvelope
    connect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type PoleManagerProfileUpdateOneRequiredWithoutLaundryOrdersNestedInput = {
    create?: XOR<PoleManagerProfileCreateWithoutLaundryOrdersInput, PoleManagerProfileUncheckedCreateWithoutLaundryOrdersInput>
    connectOrCreate?: PoleManagerProfileCreateOrConnectWithoutLaundryOrdersInput
    upsert?: PoleManagerProfileUpsertWithoutLaundryOrdersInput
    connect?: PoleManagerProfileWhereUniqueInput
    update?: XOR<XOR<PoleManagerProfileUpdateToOneWithWhereWithoutLaundryOrdersInput, PoleManagerProfileUpdateWithoutLaundryOrdersInput>, PoleManagerProfileUncheckedUpdateWithoutLaundryOrdersInput>
  }

  export type LaundryClientProfileUpdateOneRequiredWithoutLaundryOrdersNestedInput = {
    create?: XOR<LaundryClientProfileCreateWithoutLaundryOrdersInput, LaundryClientProfileUncheckedCreateWithoutLaundryOrdersInput>
    connectOrCreate?: LaundryClientProfileCreateOrConnectWithoutLaundryOrdersInput
    upsert?: LaundryClientProfileUpsertWithoutLaundryOrdersInput
    connect?: LaundryClientProfileWhereUniqueInput
    update?: XOR<XOR<LaundryClientProfileUpdateToOneWithWhereWithoutLaundryOrdersInput, LaundryClientProfileUpdateWithoutLaundryOrdersInput>, LaundryClientProfileUncheckedUpdateWithoutLaundryOrdersInput>
  }

  export type LaundryOrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<LaundryOrderItemCreateWithoutOrderInput, LaundryOrderItemUncheckedCreateWithoutOrderInput> | LaundryOrderItemCreateWithoutOrderInput[] | LaundryOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: LaundryOrderItemCreateOrConnectWithoutOrderInput | LaundryOrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: LaundryOrderItemUpsertWithWhereUniqueWithoutOrderInput | LaundryOrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: LaundryOrderItemCreateManyOrderInputEnvelope
    set?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
    disconnect?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
    delete?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
    connect?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
    update?: LaundryOrderItemUpdateWithWhereUniqueWithoutOrderInput | LaundryOrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: LaundryOrderItemUpdateManyWithWhereWithoutOrderInput | LaundryOrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: LaundryOrderItemScalarWhereInput | LaundryOrderItemScalarWhereInput[]
  }

  export type DeliveryNoteUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DeliveryNoteCreateWithoutOrderInput, DeliveryNoteUncheckedCreateWithoutOrderInput> | DeliveryNoteCreateWithoutOrderInput[] | DeliveryNoteUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryNoteCreateOrConnectWithoutOrderInput | DeliveryNoteCreateOrConnectWithoutOrderInput[]
    upsert?: DeliveryNoteUpsertWithWhereUniqueWithoutOrderInput | DeliveryNoteUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DeliveryNoteCreateManyOrderInputEnvelope
    set?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    disconnect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    delete?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    connect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    update?: DeliveryNoteUpdateWithWhereUniqueWithoutOrderInput | DeliveryNoteUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DeliveryNoteUpdateManyWithWhereWithoutOrderInput | DeliveryNoteUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DeliveryNoteScalarWhereInput | DeliveryNoteScalarWhereInput[]
  }

  export type LaundryOrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<LaundryOrderItemCreateWithoutOrderInput, LaundryOrderItemUncheckedCreateWithoutOrderInput> | LaundryOrderItemCreateWithoutOrderInput[] | LaundryOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: LaundryOrderItemCreateOrConnectWithoutOrderInput | LaundryOrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: LaundryOrderItemUpsertWithWhereUniqueWithoutOrderInput | LaundryOrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: LaundryOrderItemCreateManyOrderInputEnvelope
    set?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
    disconnect?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
    delete?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
    connect?: LaundryOrderItemWhereUniqueInput | LaundryOrderItemWhereUniqueInput[]
    update?: LaundryOrderItemUpdateWithWhereUniqueWithoutOrderInput | LaundryOrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: LaundryOrderItemUpdateManyWithWhereWithoutOrderInput | LaundryOrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: LaundryOrderItemScalarWhereInput | LaundryOrderItemScalarWhereInput[]
  }

  export type DeliveryNoteUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DeliveryNoteCreateWithoutOrderInput, DeliveryNoteUncheckedCreateWithoutOrderInput> | DeliveryNoteCreateWithoutOrderInput[] | DeliveryNoteUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryNoteCreateOrConnectWithoutOrderInput | DeliveryNoteCreateOrConnectWithoutOrderInput[]
    upsert?: DeliveryNoteUpsertWithWhereUniqueWithoutOrderInput | DeliveryNoteUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DeliveryNoteCreateManyOrderInputEnvelope
    set?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    disconnect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    delete?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    connect?: DeliveryNoteWhereUniqueInput | DeliveryNoteWhereUniqueInput[]
    update?: DeliveryNoteUpdateWithWhereUniqueWithoutOrderInput | DeliveryNoteUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DeliveryNoteUpdateManyWithWhereWithoutOrderInput | DeliveryNoteUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DeliveryNoteScalarWhereInput | DeliveryNoteScalarWhereInput[]
  }

  export type LaundryOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<LaundryOrderCreateWithoutItemsInput, LaundryOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: LaundryOrderCreateOrConnectWithoutItemsInput
    connect?: LaundryOrderWhereUniqueInput
  }

  export type LaundryProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<LaundryProductCreateWithoutOrderItemsInput, LaundryProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: LaundryProductCreateOrConnectWithoutOrderItemsInput
    connect?: LaundryProductWhereUniqueInput
  }

  export type LaundryOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<LaundryOrderCreateWithoutItemsInput, LaundryOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: LaundryOrderCreateOrConnectWithoutItemsInput
    upsert?: LaundryOrderUpsertWithoutItemsInput
    connect?: LaundryOrderWhereUniqueInput
    update?: XOR<XOR<LaundryOrderUpdateToOneWithWhereWithoutItemsInput, LaundryOrderUpdateWithoutItemsInput>, LaundryOrderUncheckedUpdateWithoutItemsInput>
  }

  export type LaundryProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<LaundryProductCreateWithoutOrderItemsInput, LaundryProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: LaundryProductCreateOrConnectWithoutOrderItemsInput
    upsert?: LaundryProductUpsertWithoutOrderItemsInput
    connect?: LaundryProductWhereUniqueInput
    update?: XOR<XOR<LaundryProductUpdateToOneWithWhereWithoutOrderItemsInput, LaundryProductUpdateWithoutOrderItemsInput>, LaundryProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type LaundryOrderCreateNestedOneWithoutDeliveryNotesInput = {
    create?: XOR<LaundryOrderCreateWithoutDeliveryNotesInput, LaundryOrderUncheckedCreateWithoutDeliveryNotesInput>
    connectOrCreate?: LaundryOrderCreateOrConnectWithoutDeliveryNotesInput
    connect?: LaundryOrderWhereUniqueInput
  }

  export type LaundryOrderUpdateOneRequiredWithoutDeliveryNotesNestedInput = {
    create?: XOR<LaundryOrderCreateWithoutDeliveryNotesInput, LaundryOrderUncheckedCreateWithoutDeliveryNotesInput>
    connectOrCreate?: LaundryOrderCreateOrConnectWithoutDeliveryNotesInput
    upsert?: LaundryOrderUpsertWithoutDeliveryNotesInput
    connect?: LaundryOrderWhereUniqueInput
    update?: XOR<XOR<LaundryOrderUpdateToOneWithWhereWithoutDeliveryNotesInput, LaundryOrderUpdateWithoutDeliveryNotesInput>, LaundryOrderUncheckedUpdateWithoutDeliveryNotesInput>
  }

  export type AgentProfileCreateNestedOneWithoutTaskAssignmentsInput = {
    create?: XOR<AgentProfileCreateWithoutTaskAssignmentsInput, AgentProfileUncheckedCreateWithoutTaskAssignmentsInput>
    connectOrCreate?: AgentProfileCreateOrConnectWithoutTaskAssignmentsInput
    connect?: AgentProfileWhereUniqueInput
  }

  export type AgentProfileUpdateOneRequiredWithoutTaskAssignmentsNestedInput = {
    create?: XOR<AgentProfileCreateWithoutTaskAssignmentsInput, AgentProfileUncheckedCreateWithoutTaskAssignmentsInput>
    connectOrCreate?: AgentProfileCreateOrConnectWithoutTaskAssignmentsInput
    upsert?: AgentProfileUpsertWithoutTaskAssignmentsInput
    connect?: AgentProfileWhereUniqueInput
    update?: XOR<XOR<AgentProfileUpdateToOneWithWhereWithoutTaskAssignmentsInput, AgentProfileUpdateWithoutTaskAssignmentsInput>, AgentProfileUncheckedUpdateWithoutTaskAssignmentsInput>
  }

  export type PropertyCreateNestedOneWithoutContractsInput = {
    create?: XOR<PropertyCreateWithoutContractsInput, PropertyUncheckedCreateWithoutContractsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutContractsInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyOwnerProfileCreateNestedOneWithoutContractsInput = {
    create?: XOR<PropertyOwnerProfileCreateWithoutContractsInput, PropertyOwnerProfileUncheckedCreateWithoutContractsInput>
    connectOrCreate?: PropertyOwnerProfileCreateOrConnectWithoutContractsInput
    connect?: PropertyOwnerProfileWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<PropertyCreateWithoutContractsInput, PropertyUncheckedCreateWithoutContractsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutContractsInput
    upsert?: PropertyUpsertWithoutContractsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutContractsInput, PropertyUpdateWithoutContractsInput>, PropertyUncheckedUpdateWithoutContractsInput>
  }

  export type PropertyOwnerProfileUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<PropertyOwnerProfileCreateWithoutContractsInput, PropertyOwnerProfileUncheckedCreateWithoutContractsInput>
    connectOrCreate?: PropertyOwnerProfileCreateOrConnectWithoutContractsInput
    upsert?: PropertyOwnerProfileUpsertWithoutContractsInput
    connect?: PropertyOwnerProfileWhereUniqueInput
    update?: XOR<XOR<PropertyOwnerProfileUpdateToOneWithWhereWithoutContractsInput, PropertyOwnerProfileUpdateWithoutContractsInput>, PropertyOwnerProfileUncheckedUpdateWithoutContractsInput>
  }

  export type SuperAdminProfileCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SuperAdminProfileCreateWithoutInvoicesInput, SuperAdminProfileUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SuperAdminProfileCreateOrConnectWithoutInvoicesInput
    connect?: SuperAdminProfileWhereUniqueInput
  }

  export type SuperAdminInvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<SuperAdminInvoiceItemCreateWithoutInvoiceInput, SuperAdminInvoiceItemUncheckedCreateWithoutInvoiceInput> | SuperAdminInvoiceItemCreateWithoutInvoiceInput[] | SuperAdminInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: SuperAdminInvoiceItemCreateOrConnectWithoutInvoiceInput | SuperAdminInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: SuperAdminInvoiceItemCreateManyInvoiceInputEnvelope
    connect?: SuperAdminInvoiceItemWhereUniqueInput | SuperAdminInvoiceItemWhereUniqueInput[]
  }

  export type SuperAdminInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<SuperAdminInvoiceItemCreateWithoutInvoiceInput, SuperAdminInvoiceItemUncheckedCreateWithoutInvoiceInput> | SuperAdminInvoiceItemCreateWithoutInvoiceInput[] | SuperAdminInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: SuperAdminInvoiceItemCreateOrConnectWithoutInvoiceInput | SuperAdminInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: SuperAdminInvoiceItemCreateManyInvoiceInputEnvelope
    connect?: SuperAdminInvoiceItemWhereUniqueInput | SuperAdminInvoiceItemWhereUniqueInput[]
  }

  export type SuperAdminProfileUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<SuperAdminProfileCreateWithoutInvoicesInput, SuperAdminProfileUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SuperAdminProfileCreateOrConnectWithoutInvoicesInput
    upsert?: SuperAdminProfileUpsertWithoutInvoicesInput
    connect?: SuperAdminProfileWhereUniqueInput
    update?: XOR<XOR<SuperAdminProfileUpdateToOneWithWhereWithoutInvoicesInput, SuperAdminProfileUpdateWithoutInvoicesInput>, SuperAdminProfileUncheckedUpdateWithoutInvoicesInput>
  }

  export type SuperAdminInvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<SuperAdminInvoiceItemCreateWithoutInvoiceInput, SuperAdminInvoiceItemUncheckedCreateWithoutInvoiceInput> | SuperAdminInvoiceItemCreateWithoutInvoiceInput[] | SuperAdminInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: SuperAdminInvoiceItemCreateOrConnectWithoutInvoiceInput | SuperAdminInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: SuperAdminInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | SuperAdminInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: SuperAdminInvoiceItemCreateManyInvoiceInputEnvelope
    set?: SuperAdminInvoiceItemWhereUniqueInput | SuperAdminInvoiceItemWhereUniqueInput[]
    disconnect?: SuperAdminInvoiceItemWhereUniqueInput | SuperAdminInvoiceItemWhereUniqueInput[]
    delete?: SuperAdminInvoiceItemWhereUniqueInput | SuperAdminInvoiceItemWhereUniqueInput[]
    connect?: SuperAdminInvoiceItemWhereUniqueInput | SuperAdminInvoiceItemWhereUniqueInput[]
    update?: SuperAdminInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | SuperAdminInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: SuperAdminInvoiceItemUpdateManyWithWhereWithoutInvoiceInput | SuperAdminInvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: SuperAdminInvoiceItemScalarWhereInput | SuperAdminInvoiceItemScalarWhereInput[]
  }

  export type SuperAdminInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<SuperAdminInvoiceItemCreateWithoutInvoiceInput, SuperAdminInvoiceItemUncheckedCreateWithoutInvoiceInput> | SuperAdminInvoiceItemCreateWithoutInvoiceInput[] | SuperAdminInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: SuperAdminInvoiceItemCreateOrConnectWithoutInvoiceInput | SuperAdminInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: SuperAdminInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | SuperAdminInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: SuperAdminInvoiceItemCreateManyInvoiceInputEnvelope
    set?: SuperAdminInvoiceItemWhereUniqueInput | SuperAdminInvoiceItemWhereUniqueInput[]
    disconnect?: SuperAdminInvoiceItemWhereUniqueInput | SuperAdminInvoiceItemWhereUniqueInput[]
    delete?: SuperAdminInvoiceItemWhereUniqueInput | SuperAdminInvoiceItemWhereUniqueInput[]
    connect?: SuperAdminInvoiceItemWhereUniqueInput | SuperAdminInvoiceItemWhereUniqueInput[]
    update?: SuperAdminInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | SuperAdminInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: SuperAdminInvoiceItemUpdateManyWithWhereWithoutInvoiceInput | SuperAdminInvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: SuperAdminInvoiceItemScalarWhereInput | SuperAdminInvoiceItemScalarWhereInput[]
  }

  export type SuperAdminInvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<SuperAdminInvoiceCreateWithoutItemsInput, SuperAdminInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SuperAdminInvoiceCreateOrConnectWithoutItemsInput
    connect?: SuperAdminInvoiceWhereUniqueInput
  }

  export type NullableEnumPoleTypeFieldUpdateOperationsInput = {
    set?: $Enums.PoleType | null
  }

  export type SuperAdminInvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SuperAdminInvoiceCreateWithoutItemsInput, SuperAdminInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SuperAdminInvoiceCreateOrConnectWithoutItemsInput
    upsert?: SuperAdminInvoiceUpsertWithoutItemsInput
    connect?: SuperAdminInvoiceWhereUniqueInput
    update?: XOR<XOR<SuperAdminInvoiceUpdateToOneWithWhereWithoutItemsInput, SuperAdminInvoiceUpdateWithoutItemsInput>, SuperAdminInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type LaundryClientProfileCreateNestedOneWithoutLaundryInvoicesInput = {
    create?: XOR<LaundryClientProfileCreateWithoutLaundryInvoicesInput, LaundryClientProfileUncheckedCreateWithoutLaundryInvoicesInput>
    connectOrCreate?: LaundryClientProfileCreateOrConnectWithoutLaundryInvoicesInput
    connect?: LaundryClientProfileWhereUniqueInput
  }

  export type LaundryClientProfileUpdateOneRequiredWithoutLaundryInvoicesNestedInput = {
    create?: XOR<LaundryClientProfileCreateWithoutLaundryInvoicesInput, LaundryClientProfileUncheckedCreateWithoutLaundryInvoicesInput>
    connectOrCreate?: LaundryClientProfileCreateOrConnectWithoutLaundryInvoicesInput
    upsert?: LaundryClientProfileUpsertWithoutLaundryInvoicesInput
    connect?: LaundryClientProfileWhereUniqueInput
    update?: XOR<XOR<LaundryClientProfileUpdateToOneWithWhereWithoutLaundryInvoicesInput, LaundryClientProfileUpdateWithoutLaundryInvoicesInput>, LaundryClientProfileUncheckedUpdateWithoutLaundryInvoicesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumPoleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PoleType | EnumPoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPoleTypeFilter<$PrismaModel> | $Enums.PoleType
  }

  export type NestedEnumPoleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PoleStatus | EnumPoleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PoleStatus[] | ListEnumPoleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoleStatus[] | ListEnumPoleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPoleStatusFilter<$PrismaModel> | $Enums.PoleStatus
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumPoleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoleType | EnumPoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPoleTypeWithAggregatesFilter<$PrismaModel> | $Enums.PoleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoleTypeFilter<$PrismaModel>
    _max?: NestedEnumPoleTypeFilter<$PrismaModel>
  }

  export type NestedEnumPoleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoleStatus | EnumPoleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PoleStatus[] | ListEnumPoleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoleStatus[] | ListEnumPoleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPoleStatusWithAggregatesFilter<$PrismaModel> | $Enums.PoleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoleStatusFilter<$PrismaModel>
    _max?: NestedEnumPoleStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumAgentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentTypeFilter<$PrismaModel> | $Enums.AgentType
  }

  export type NestedEnumAgentAvailabilityFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentAvailability | EnumAgentAvailabilityFieldRefInput<$PrismaModel>
    in?: $Enums.AgentAvailability[] | ListEnumAgentAvailabilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentAvailability[] | ListEnumAgentAvailabilityFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentAvailabilityFilter<$PrismaModel> | $Enums.AgentAvailability
  }

  export type NestedEnumAgentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AgentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentTypeFilter<$PrismaModel>
    _max?: NestedEnumAgentTypeFilter<$PrismaModel>
  }

  export type NestedEnumAgentAvailabilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentAvailability | EnumAgentAvailabilityFieldRefInput<$PrismaModel>
    in?: $Enums.AgentAvailability[] | ListEnumAgentAvailabilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentAvailability[] | ListEnumAgentAvailabilityFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentAvailabilityWithAggregatesFilter<$PrismaModel> | $Enums.AgentAvailability
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentAvailabilityFilter<$PrismaModel>
    _max?: NestedEnumAgentAvailabilityFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumPropertyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusFilter<$PrismaModel> | $Enums.PropertyStatus
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel> | $Enums.PropertyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyStatusFilter<$PrismaModel>
    _max?: NestedEnumPropertyStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumReservationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationStatus | EnumReservationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReservationStatus[] | ListEnumReservationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReservationStatus[] | ListEnumReservationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReservationStatusFilter<$PrismaModel> | $Enums.ReservationStatus
  }

  export type NestedEnumReservationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationStatus | EnumReservationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReservationStatus[] | ListEnumReservationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReservationStatus[] | ListEnumReservationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReservationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReservationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReservationStatusFilter<$PrismaModel>
    _max?: NestedEnumReservationStatusFilter<$PrismaModel>
  }

  export type NestedEnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedEnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPoleTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PoleType | EnumPoleTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPoleTypeNullableFilter<$PrismaModel> | $Enums.PoleType | null
  }

  export type NestedEnumPoleTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoleType | EnumPoleTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PoleType[] | ListEnumPoleTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPoleTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PoleType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPoleTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPoleTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    priority?: string | null
    read?: boolean
    relatedType?: string | null
    relatedId?: string | null
    actionUrl?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    priority?: string | null
    read?: boolean
    relatedType?: string | null
    relatedId?: string | null
    actionUrl?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SuperAdminProfileCreateWithoutUserInput = {
    id?: string
    companyName: string
    businessNumber?: string | null
    vatNumber?: string | null
    billingAddress: string
    billingCity: string
    billingCountry?: string
    billingPostal: string
    subscriptionTier?: string
    subscriptionStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    poleSubscriptions?: PoleSubscriptionCreateNestedManyWithoutSuperAdminInput
    poleManagers?: PoleManagerProfileCreateNestedManyWithoutSuperAdminInput
    invoices?: SuperAdminInvoiceCreateNestedManyWithoutSuperAdminInput
  }

  export type SuperAdminProfileUncheckedCreateWithoutUserInput = {
    id?: string
    companyName: string
    businessNumber?: string | null
    vatNumber?: string | null
    billingAddress: string
    billingCity: string
    billingCountry?: string
    billingPostal: string
    subscriptionTier?: string
    subscriptionStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    poleSubscriptions?: PoleSubscriptionUncheckedCreateNestedManyWithoutSuperAdminInput
    poleManagers?: PoleManagerProfileUncheckedCreateNestedManyWithoutSuperAdminInput
    invoices?: SuperAdminInvoiceUncheckedCreateNestedManyWithoutSuperAdminInput
  }

  export type SuperAdminProfileCreateOrConnectWithoutUserInput = {
    where: SuperAdminProfileWhereUniqueInput
    create: XOR<SuperAdminProfileCreateWithoutUserInput, SuperAdminProfileUncheckedCreateWithoutUserInput>
  }

  export type PoleManagerProfileCreateWithoutUserInput = {
    id?: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdmin: SuperAdminProfileCreateNestedOneWithoutPoleManagersInput
    properties?: PropertyCreateNestedManyWithoutManagerInput
    reservations?: ReservationCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutManagerInput
    tickets?: TicketCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileUncheckedCreateWithoutUserInput = {
    id?: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdminId: string
    properties?: PropertyUncheckedCreateNestedManyWithoutManagerInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutManagerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderUncheckedCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileUncheckedCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileCreateOrConnectWithoutUserInput = {
    where: PoleManagerProfileWhereUniqueInput
    create: XOR<PoleManagerProfileCreateWithoutUserInput, PoleManagerProfileUncheckedCreateWithoutUserInput>
  }

  export type PropertyOwnerProfileCreateWithoutUserInput = {
    id?: string
    company?: string | null
    taxNumber?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    postal?: string | null
    preferredContactMethod?: string | null
    receiveNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutOwnerInput
    contracts?: PropertyContractCreateNestedManyWithoutPropertyOwnerInput
  }

  export type PropertyOwnerProfileUncheckedCreateWithoutUserInput = {
    id?: string
    company?: string | null
    taxNumber?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    postal?: string | null
    preferredContactMethod?: string | null
    receiveNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    contracts?: PropertyContractUncheckedCreateNestedManyWithoutPropertyOwnerInput
  }

  export type PropertyOwnerProfileCreateOrConnectWithoutUserInput = {
    where: PropertyOwnerProfileWhereUniqueInput
    create: XOR<PropertyOwnerProfileCreateWithoutUserInput, PropertyOwnerProfileUncheckedCreateWithoutUserInput>
  }

  export type LaundryClientProfileCreateWithoutUserInput = {
    id?: string
    companyName?: string | null
    contactPerson?: string | null
    defaultPickupAddress?: string | null
    defaultDeliveryAddress: string
    preferredPickupTime?: string | null
    specialInstructions?: string | null
    creditLimit?: number | null
    paymentTerms?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryOrders?: LaundryOrderCreateNestedManyWithoutClientInput
    laundryInvoices?: LaundryInvoiceCreateNestedManyWithoutClientInput
  }

  export type LaundryClientProfileUncheckedCreateWithoutUserInput = {
    id?: string
    companyName?: string | null
    contactPerson?: string | null
    defaultPickupAddress?: string | null
    defaultDeliveryAddress: string
    preferredPickupTime?: string | null
    specialInstructions?: string | null
    creditLimit?: number | null
    paymentTerms?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryOrders?: LaundryOrderUncheckedCreateNestedManyWithoutClientInput
    laundryInvoices?: LaundryInvoiceUncheckedCreateNestedManyWithoutClientInput
  }

  export type LaundryClientProfileCreateOrConnectWithoutUserInput = {
    where: LaundryClientProfileWhereUniqueInput
    create: XOR<LaundryClientProfileCreateWithoutUserInput, LaundryClientProfileUncheckedCreateWithoutUserInput>
  }

  export type AgentProfileCreateWithoutUserInput = {
    id?: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    specialties?: AgentSpecialtyCreateNestedManyWithoutAgentInput
    manager: PoleManagerProfileCreateNestedOneWithoutManagedAgentsInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutAgentInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutAgentInput
    tickets?: TicketCreateNestedManyWithoutAgentInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutAgentInput
  }

  export type AgentProfileUncheckedCreateWithoutUserInput = {
    id?: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    specialties?: AgentSpecialtyUncheckedCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutAgentInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAgentInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentProfileCreateOrConnectWithoutUserInput = {
    where: AgentProfileWhereUniqueInput
    create: XOR<AgentProfileCreateWithoutUserInput, AgentProfileUncheckedCreateWithoutUserInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    priority?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    userId?: StringFilter<"Notification"> | string
    relatedType?: StringNullableFilter<"Notification"> | string | null
    relatedId?: StringNullableFilter<"Notification"> | string | null
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type SuperAdminProfileUpsertWithoutUserInput = {
    update: XOR<SuperAdminProfileUpdateWithoutUserInput, SuperAdminProfileUncheckedUpdateWithoutUserInput>
    create: XOR<SuperAdminProfileCreateWithoutUserInput, SuperAdminProfileUncheckedCreateWithoutUserInput>
    where?: SuperAdminProfileWhereInput
  }

  export type SuperAdminProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: SuperAdminProfileWhereInput
    data: XOR<SuperAdminProfileUpdateWithoutUserInput, SuperAdminProfileUncheckedUpdateWithoutUserInput>
  }

  export type SuperAdminProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    businessNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingCountry?: StringFieldUpdateOperationsInput | string
    billingPostal?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poleSubscriptions?: PoleSubscriptionUpdateManyWithoutSuperAdminNestedInput
    poleManagers?: PoleManagerProfileUpdateManyWithoutSuperAdminNestedInput
    invoices?: SuperAdminInvoiceUpdateManyWithoutSuperAdminNestedInput
  }

  export type SuperAdminProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    businessNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingCountry?: StringFieldUpdateOperationsInput | string
    billingPostal?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poleSubscriptions?: PoleSubscriptionUncheckedUpdateManyWithoutSuperAdminNestedInput
    poleManagers?: PoleManagerProfileUncheckedUpdateManyWithoutSuperAdminNestedInput
    invoices?: SuperAdminInvoiceUncheckedUpdateManyWithoutSuperAdminNestedInput
  }

  export type PoleManagerProfileUpsertWithoutUserInput = {
    update: XOR<PoleManagerProfileUpdateWithoutUserInput, PoleManagerProfileUncheckedUpdateWithoutUserInput>
    create: XOR<PoleManagerProfileCreateWithoutUserInput, PoleManagerProfileUncheckedCreateWithoutUserInput>
    where?: PoleManagerProfileWhereInput
  }

  export type PoleManagerProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: PoleManagerProfileWhereInput
    data: XOR<PoleManagerProfileUpdateWithoutUserInput, PoleManagerProfileUncheckedUpdateWithoutUserInput>
  }

  export type PoleManagerProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdmin?: SuperAdminProfileUpdateOneRequiredWithoutPoleManagersNestedInput
    properties?: PropertyUpdateManyWithoutManagerNestedInput
    reservations?: ReservationUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutManagerNestedInput
    tickets?: TicketUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUpdateManyWithoutManagerNestedInput
  }

  export type PoleManagerProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdminId?: StringFieldUpdateOperationsInput | string
    properties?: PropertyUncheckedUpdateManyWithoutManagerNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutManagerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUncheckedUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type PropertyOwnerProfileUpsertWithoutUserInput = {
    update: XOR<PropertyOwnerProfileUpdateWithoutUserInput, PropertyOwnerProfileUncheckedUpdateWithoutUserInput>
    create: XOR<PropertyOwnerProfileCreateWithoutUserInput, PropertyOwnerProfileUncheckedCreateWithoutUserInput>
    where?: PropertyOwnerProfileWhereInput
  }

  export type PropertyOwnerProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: PropertyOwnerProfileWhereInput
    data: XOR<PropertyOwnerProfileUpdateWithoutUserInput, PropertyOwnerProfileUncheckedUpdateWithoutUserInput>
  }

  export type PropertyOwnerProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiveNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutOwnerNestedInput
    contracts?: PropertyContractUpdateManyWithoutPropertyOwnerNestedInput
  }

  export type PropertyOwnerProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiveNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    contracts?: PropertyContractUncheckedUpdateManyWithoutPropertyOwnerNestedInput
  }

  export type LaundryClientProfileUpsertWithoutUserInput = {
    update: XOR<LaundryClientProfileUpdateWithoutUserInput, LaundryClientProfileUncheckedUpdateWithoutUserInput>
    create: XOR<LaundryClientProfileCreateWithoutUserInput, LaundryClientProfileUncheckedCreateWithoutUserInput>
    where?: LaundryClientProfileWhereInput
  }

  export type LaundryClientProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: LaundryClientProfileWhereInput
    data: XOR<LaundryClientProfileUpdateWithoutUserInput, LaundryClientProfileUncheckedUpdateWithoutUserInput>
  }

  export type LaundryClientProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDeliveryAddress?: StringFieldUpdateOperationsInput | string
    preferredPickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryOrders?: LaundryOrderUpdateManyWithoutClientNestedInput
    laundryInvoices?: LaundryInvoiceUpdateManyWithoutClientNestedInput
  }

  export type LaundryClientProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDeliveryAddress?: StringFieldUpdateOperationsInput | string
    preferredPickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryOrders?: LaundryOrderUncheckedUpdateManyWithoutClientNestedInput
    laundryInvoices?: LaundryInvoiceUncheckedUpdateManyWithoutClientNestedInput
  }

  export type AgentProfileUpsertWithoutUserInput = {
    update: XOR<AgentProfileUpdateWithoutUserInput, AgentProfileUncheckedUpdateWithoutUserInput>
    create: XOR<AgentProfileCreateWithoutUserInput, AgentProfileUncheckedCreateWithoutUserInput>
    where?: AgentProfileWhereInput
  }

  export type AgentProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: AgentProfileWhereInput
    data: XOR<AgentProfileUpdateWithoutUserInput, AgentProfileUncheckedUpdateWithoutUserInput>
  }

  export type AgentProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialties?: AgentSpecialtyUpdateManyWithoutAgentNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutManagedAgentsNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutAgentNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutAgentNestedInput
    tickets?: TicketUpdateManyWithoutAgentNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutAgentNestedInput
  }

  export type AgentProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    specialties?: AgentSpecialtyUncheckedUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAgentNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type UserCreateWithoutSuperAdminProfileInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    poleManagerProfile?: PoleManagerProfileCreateNestedOneWithoutUserInput
    propertyOwnerProfile?: PropertyOwnerProfileCreateNestedOneWithoutUserInput
    laundryClientProfile?: LaundryClientProfileCreateNestedOneWithoutUserInput
    agentProfile?: AgentProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSuperAdminProfileInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    poleManagerProfile?: PoleManagerProfileUncheckedCreateNestedOneWithoutUserInput
    propertyOwnerProfile?: PropertyOwnerProfileUncheckedCreateNestedOneWithoutUserInput
    laundryClientProfile?: LaundryClientProfileUncheckedCreateNestedOneWithoutUserInput
    agentProfile?: AgentProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSuperAdminProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSuperAdminProfileInput, UserUncheckedCreateWithoutSuperAdminProfileInput>
  }

  export type PoleSubscriptionCreateWithoutSuperAdminInput = {
    id?: string
    poleType: $Enums.PoleType
    status?: $Enums.PoleStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    monthlyPrice: number
    lastBillingDate?: Date | string | null
    nextBillingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PoleSubscriptionUncheckedCreateWithoutSuperAdminInput = {
    id?: string
    poleType: $Enums.PoleType
    status?: $Enums.PoleStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    monthlyPrice: number
    lastBillingDate?: Date | string | null
    nextBillingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PoleSubscriptionCreateOrConnectWithoutSuperAdminInput = {
    where: PoleSubscriptionWhereUniqueInput
    create: XOR<PoleSubscriptionCreateWithoutSuperAdminInput, PoleSubscriptionUncheckedCreateWithoutSuperAdminInput>
  }

  export type PoleSubscriptionCreateManySuperAdminInputEnvelope = {
    data: PoleSubscriptionCreateManySuperAdminInput | PoleSubscriptionCreateManySuperAdminInput[]
    skipDuplicates?: boolean
  }

  export type PoleManagerProfileCreateWithoutSuperAdminInput = {
    id?: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPoleManagerProfileInput
    properties?: PropertyCreateNestedManyWithoutManagerInput
    reservations?: ReservationCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutManagerInput
    tickets?: TicketCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileUncheckedCreateWithoutSuperAdminInput = {
    id?: string
    userId: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutManagerInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutManagerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderUncheckedCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileUncheckedCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileCreateOrConnectWithoutSuperAdminInput = {
    where: PoleManagerProfileWhereUniqueInput
    create: XOR<PoleManagerProfileCreateWithoutSuperAdminInput, PoleManagerProfileUncheckedCreateWithoutSuperAdminInput>
  }

  export type PoleManagerProfileCreateManySuperAdminInputEnvelope = {
    data: PoleManagerProfileCreateManySuperAdminInput | PoleManagerProfileCreateManySuperAdminInput[]
    skipDuplicates?: boolean
  }

  export type SuperAdminInvoiceCreateWithoutSuperAdminInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    subtotal: number
    taxRate?: number
    taxAmount: number
    totalAmount: number
    paidAmount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SuperAdminInvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type SuperAdminInvoiceUncheckedCreateWithoutSuperAdminInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    subtotal: number
    taxRate?: number
    taxAmount: number
    totalAmount: number
    paidAmount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SuperAdminInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type SuperAdminInvoiceCreateOrConnectWithoutSuperAdminInput = {
    where: SuperAdminInvoiceWhereUniqueInput
    create: XOR<SuperAdminInvoiceCreateWithoutSuperAdminInput, SuperAdminInvoiceUncheckedCreateWithoutSuperAdminInput>
  }

  export type SuperAdminInvoiceCreateManySuperAdminInputEnvelope = {
    data: SuperAdminInvoiceCreateManySuperAdminInput | SuperAdminInvoiceCreateManySuperAdminInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSuperAdminProfileInput = {
    update: XOR<UserUpdateWithoutSuperAdminProfileInput, UserUncheckedUpdateWithoutSuperAdminProfileInput>
    create: XOR<UserCreateWithoutSuperAdminProfileInput, UserUncheckedCreateWithoutSuperAdminProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSuperAdminProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSuperAdminProfileInput, UserUncheckedUpdateWithoutSuperAdminProfileInput>
  }

  export type UserUpdateWithoutSuperAdminProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    poleManagerProfile?: PoleManagerProfileUpdateOneWithoutUserNestedInput
    propertyOwnerProfile?: PropertyOwnerProfileUpdateOneWithoutUserNestedInput
    laundryClientProfile?: LaundryClientProfileUpdateOneWithoutUserNestedInput
    agentProfile?: AgentProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSuperAdminProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    poleManagerProfile?: PoleManagerProfileUncheckedUpdateOneWithoutUserNestedInput
    propertyOwnerProfile?: PropertyOwnerProfileUncheckedUpdateOneWithoutUserNestedInput
    laundryClientProfile?: LaundryClientProfileUncheckedUpdateOneWithoutUserNestedInput
    agentProfile?: AgentProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PoleSubscriptionUpsertWithWhereUniqueWithoutSuperAdminInput = {
    where: PoleSubscriptionWhereUniqueInput
    update: XOR<PoleSubscriptionUpdateWithoutSuperAdminInput, PoleSubscriptionUncheckedUpdateWithoutSuperAdminInput>
    create: XOR<PoleSubscriptionCreateWithoutSuperAdminInput, PoleSubscriptionUncheckedCreateWithoutSuperAdminInput>
  }

  export type PoleSubscriptionUpdateWithWhereUniqueWithoutSuperAdminInput = {
    where: PoleSubscriptionWhereUniqueInput
    data: XOR<PoleSubscriptionUpdateWithoutSuperAdminInput, PoleSubscriptionUncheckedUpdateWithoutSuperAdminInput>
  }

  export type PoleSubscriptionUpdateManyWithWhereWithoutSuperAdminInput = {
    where: PoleSubscriptionScalarWhereInput
    data: XOR<PoleSubscriptionUpdateManyMutationInput, PoleSubscriptionUncheckedUpdateManyWithoutSuperAdminInput>
  }

  export type PoleSubscriptionScalarWhereInput = {
    AND?: PoleSubscriptionScalarWhereInput | PoleSubscriptionScalarWhereInput[]
    OR?: PoleSubscriptionScalarWhereInput[]
    NOT?: PoleSubscriptionScalarWhereInput | PoleSubscriptionScalarWhereInput[]
    id?: StringFilter<"PoleSubscription"> | string
    poleType?: EnumPoleTypeFilter<"PoleSubscription"> | $Enums.PoleType
    status?: EnumPoleStatusFilter<"PoleSubscription"> | $Enums.PoleStatus
    startDate?: DateTimeNullableFilter<"PoleSubscription"> | Date | string | null
    endDate?: DateTimeNullableFilter<"PoleSubscription"> | Date | string | null
    trialEndDate?: DateTimeNullableFilter<"PoleSubscription"> | Date | string | null
    monthlyPrice?: FloatFilter<"PoleSubscription"> | number
    lastBillingDate?: DateTimeNullableFilter<"PoleSubscription"> | Date | string | null
    nextBillingDate?: DateTimeNullableFilter<"PoleSubscription"> | Date | string | null
    createdAt?: DateTimeFilter<"PoleSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PoleSubscription"> | Date | string
    superAdminId?: StringFilter<"PoleSubscription"> | string
  }

  export type PoleManagerProfileUpsertWithWhereUniqueWithoutSuperAdminInput = {
    where: PoleManagerProfileWhereUniqueInput
    update: XOR<PoleManagerProfileUpdateWithoutSuperAdminInput, PoleManagerProfileUncheckedUpdateWithoutSuperAdminInput>
    create: XOR<PoleManagerProfileCreateWithoutSuperAdminInput, PoleManagerProfileUncheckedCreateWithoutSuperAdminInput>
  }

  export type PoleManagerProfileUpdateWithWhereUniqueWithoutSuperAdminInput = {
    where: PoleManagerProfileWhereUniqueInput
    data: XOR<PoleManagerProfileUpdateWithoutSuperAdminInput, PoleManagerProfileUncheckedUpdateWithoutSuperAdminInput>
  }

  export type PoleManagerProfileUpdateManyWithWhereWithoutSuperAdminInput = {
    where: PoleManagerProfileScalarWhereInput
    data: XOR<PoleManagerProfileUpdateManyMutationInput, PoleManagerProfileUncheckedUpdateManyWithoutSuperAdminInput>
  }

  export type PoleManagerProfileScalarWhereInput = {
    AND?: PoleManagerProfileScalarWhereInput | PoleManagerProfileScalarWhereInput[]
    OR?: PoleManagerProfileScalarWhereInput[]
    NOT?: PoleManagerProfileScalarWhereInput | PoleManagerProfileScalarWhereInput[]
    id?: StringFilter<"PoleManagerProfile"> | string
    userId?: StringFilter<"PoleManagerProfile"> | string
    poleTypes?: EnumPoleTypeNullableListFilter<"PoleManagerProfile">
    canViewAnalytics?: BoolFilter<"PoleManagerProfile"> | boolean
    canManageAgents?: BoolFilter<"PoleManagerProfile"> | boolean
    canManageClients?: BoolFilter<"PoleManagerProfile"> | boolean
    canManageBilling?: BoolFilter<"PoleManagerProfile"> | boolean
    createdAt?: DateTimeFilter<"PoleManagerProfile"> | Date | string
    updatedAt?: DateTimeFilter<"PoleManagerProfile"> | Date | string
    superAdminId?: StringFilter<"PoleManagerProfile"> | string
  }

  export type SuperAdminInvoiceUpsertWithWhereUniqueWithoutSuperAdminInput = {
    where: SuperAdminInvoiceWhereUniqueInput
    update: XOR<SuperAdminInvoiceUpdateWithoutSuperAdminInput, SuperAdminInvoiceUncheckedUpdateWithoutSuperAdminInput>
    create: XOR<SuperAdminInvoiceCreateWithoutSuperAdminInput, SuperAdminInvoiceUncheckedCreateWithoutSuperAdminInput>
  }

  export type SuperAdminInvoiceUpdateWithWhereUniqueWithoutSuperAdminInput = {
    where: SuperAdminInvoiceWhereUniqueInput
    data: XOR<SuperAdminInvoiceUpdateWithoutSuperAdminInput, SuperAdminInvoiceUncheckedUpdateWithoutSuperAdminInput>
  }

  export type SuperAdminInvoiceUpdateManyWithWhereWithoutSuperAdminInput = {
    where: SuperAdminInvoiceScalarWhereInput
    data: XOR<SuperAdminInvoiceUpdateManyMutationInput, SuperAdminInvoiceUncheckedUpdateManyWithoutSuperAdminInput>
  }

  export type SuperAdminInvoiceScalarWhereInput = {
    AND?: SuperAdminInvoiceScalarWhereInput | SuperAdminInvoiceScalarWhereInput[]
    OR?: SuperAdminInvoiceScalarWhereInput[]
    NOT?: SuperAdminInvoiceScalarWhereInput | SuperAdminInvoiceScalarWhereInput[]
    id?: StringFilter<"SuperAdminInvoice"> | string
    invoiceNumber?: StringFilter<"SuperAdminInvoice"> | string
    status?: StringFilter<"SuperAdminInvoice"> | string
    issueDate?: DateTimeFilter<"SuperAdminInvoice"> | Date | string
    dueDate?: DateTimeFilter<"SuperAdminInvoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"SuperAdminInvoice"> | Date | string | null
    subtotal?: FloatFilter<"SuperAdminInvoice"> | number
    taxRate?: FloatFilter<"SuperAdminInvoice"> | number
    taxAmount?: FloatFilter<"SuperAdminInvoice"> | number
    totalAmount?: FloatFilter<"SuperAdminInvoice"> | number
    paidAmount?: FloatFilter<"SuperAdminInvoice"> | number
    superAdminId?: StringFilter<"SuperAdminInvoice"> | string
    notes?: StringNullableFilter<"SuperAdminInvoice"> | string | null
    createdAt?: DateTimeFilter<"SuperAdminInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"SuperAdminInvoice"> | Date | string
  }

  export type SuperAdminProfileCreateWithoutPoleSubscriptionsInput = {
    id?: string
    companyName: string
    businessNumber?: string | null
    vatNumber?: string | null
    billingAddress: string
    billingCity: string
    billingCountry?: string
    billingPostal: string
    subscriptionTier?: string
    subscriptionStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSuperAdminProfileInput
    poleManagers?: PoleManagerProfileCreateNestedManyWithoutSuperAdminInput
    invoices?: SuperAdminInvoiceCreateNestedManyWithoutSuperAdminInput
  }

  export type SuperAdminProfileUncheckedCreateWithoutPoleSubscriptionsInput = {
    id?: string
    userId: string
    companyName: string
    businessNumber?: string | null
    vatNumber?: string | null
    billingAddress: string
    billingCity: string
    billingCountry?: string
    billingPostal: string
    subscriptionTier?: string
    subscriptionStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    poleManagers?: PoleManagerProfileUncheckedCreateNestedManyWithoutSuperAdminInput
    invoices?: SuperAdminInvoiceUncheckedCreateNestedManyWithoutSuperAdminInput
  }

  export type SuperAdminProfileCreateOrConnectWithoutPoleSubscriptionsInput = {
    where: SuperAdminProfileWhereUniqueInput
    create: XOR<SuperAdminProfileCreateWithoutPoleSubscriptionsInput, SuperAdminProfileUncheckedCreateWithoutPoleSubscriptionsInput>
  }

  export type SuperAdminProfileUpsertWithoutPoleSubscriptionsInput = {
    update: XOR<SuperAdminProfileUpdateWithoutPoleSubscriptionsInput, SuperAdminProfileUncheckedUpdateWithoutPoleSubscriptionsInput>
    create: XOR<SuperAdminProfileCreateWithoutPoleSubscriptionsInput, SuperAdminProfileUncheckedCreateWithoutPoleSubscriptionsInput>
    where?: SuperAdminProfileWhereInput
  }

  export type SuperAdminProfileUpdateToOneWithWhereWithoutPoleSubscriptionsInput = {
    where?: SuperAdminProfileWhereInput
    data: XOR<SuperAdminProfileUpdateWithoutPoleSubscriptionsInput, SuperAdminProfileUncheckedUpdateWithoutPoleSubscriptionsInput>
  }

  export type SuperAdminProfileUpdateWithoutPoleSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    businessNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingCountry?: StringFieldUpdateOperationsInput | string
    billingPostal?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSuperAdminProfileNestedInput
    poleManagers?: PoleManagerProfileUpdateManyWithoutSuperAdminNestedInput
    invoices?: SuperAdminInvoiceUpdateManyWithoutSuperAdminNestedInput
  }

  export type SuperAdminProfileUncheckedUpdateWithoutPoleSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    businessNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingCountry?: StringFieldUpdateOperationsInput | string
    billingPostal?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poleManagers?: PoleManagerProfileUncheckedUpdateManyWithoutSuperAdminNestedInput
    invoices?: SuperAdminInvoiceUncheckedUpdateManyWithoutSuperAdminNestedInput
  }

  export type UserCreateWithoutPoleManagerProfileInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    superAdminProfile?: SuperAdminProfileCreateNestedOneWithoutUserInput
    propertyOwnerProfile?: PropertyOwnerProfileCreateNestedOneWithoutUserInput
    laundryClientProfile?: LaundryClientProfileCreateNestedOneWithoutUserInput
    agentProfile?: AgentProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPoleManagerProfileInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    superAdminProfile?: SuperAdminProfileUncheckedCreateNestedOneWithoutUserInput
    propertyOwnerProfile?: PropertyOwnerProfileUncheckedCreateNestedOneWithoutUserInput
    laundryClientProfile?: LaundryClientProfileUncheckedCreateNestedOneWithoutUserInput
    agentProfile?: AgentProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPoleManagerProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPoleManagerProfileInput, UserUncheckedCreateWithoutPoleManagerProfileInput>
  }

  export type SuperAdminProfileCreateWithoutPoleManagersInput = {
    id?: string
    companyName: string
    businessNumber?: string | null
    vatNumber?: string | null
    billingAddress: string
    billingCity: string
    billingCountry?: string
    billingPostal: string
    subscriptionTier?: string
    subscriptionStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSuperAdminProfileInput
    poleSubscriptions?: PoleSubscriptionCreateNestedManyWithoutSuperAdminInput
    invoices?: SuperAdminInvoiceCreateNestedManyWithoutSuperAdminInput
  }

  export type SuperAdminProfileUncheckedCreateWithoutPoleManagersInput = {
    id?: string
    userId: string
    companyName: string
    businessNumber?: string | null
    vatNumber?: string | null
    billingAddress: string
    billingCity: string
    billingCountry?: string
    billingPostal: string
    subscriptionTier?: string
    subscriptionStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    poleSubscriptions?: PoleSubscriptionUncheckedCreateNestedManyWithoutSuperAdminInput
    invoices?: SuperAdminInvoiceUncheckedCreateNestedManyWithoutSuperAdminInput
  }

  export type SuperAdminProfileCreateOrConnectWithoutPoleManagersInput = {
    where: SuperAdminProfileWhereUniqueInput
    create: XOR<SuperAdminProfileCreateWithoutPoleManagersInput, SuperAdminProfileUncheckedCreateWithoutPoleManagersInput>
  }

  export type PropertyCreateWithoutManagerInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoCreateNestedManyWithoutPropertyInput
    owner: PropertyOwnerProfileCreateNestedOneWithoutPropertiesInput
    reservations?: ReservationCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutPropertyInput
    tickets?: TicketCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutManagerInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewUncheckedCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutManagerInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutManagerInput, PropertyUncheckedCreateWithoutManagerInput>
  }

  export type PropertyCreateManyManagerInputEnvelope = {
    data: PropertyCreateManyManagerInput | PropertyCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutManagerInput = {
    id?: string
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    guestCount?: number
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    totalPrice: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    confirmationCode?: string | null
    bookingSource?: string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutManagerInput = {
    id?: string
    propertyId: string
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    guestCount?: number
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    totalPrice: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    confirmationCode?: string | null
    bookingSource?: string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateOrConnectWithoutManagerInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutManagerInput, ReservationUncheckedCreateWithoutManagerInput>
  }

  export type ReservationCreateManyManagerInputEnvelope = {
    data: ReservationCreateManyManagerInput | ReservationCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type CleaningSessionCreateWithoutManagerInput = {
    id?: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    cleaningType: string
    status?: $Enums.SessionStatus
    notes?: string | null
    agentNotes?: string | null
    ownerRating?: number | null
    managerRating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutCleaningSessionsInput
    agent: AgentProfileCreateNestedOneWithoutCleaningSessionsInput
    checklist?: CleaningChecklistCreateNestedManyWithoutCleaningSessionInput
    photos?: CleaningPhotoCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionUncheckedCreateWithoutManagerInput = {
    id?: string
    propertyId: string
    agentId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    cleaningType: string
    status?: $Enums.SessionStatus
    notes?: string | null
    agentNotes?: string | null
    ownerRating?: number | null
    managerRating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checklist?: CleaningChecklistUncheckedCreateNestedManyWithoutCleaningSessionInput
    photos?: CleaningPhotoUncheckedCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionCreateOrConnectWithoutManagerInput = {
    where: CleaningSessionWhereUniqueInput
    create: XOR<CleaningSessionCreateWithoutManagerInput, CleaningSessionUncheckedCreateWithoutManagerInput>
  }

  export type CleaningSessionCreateManyManagerInputEnvelope = {
    data: CleaningSessionCreateManyManagerInput | CleaningSessionCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutManagerInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    reportedBy: string
    reportedAt?: Date | string
    assignedAt?: Date | string | null
    category?: string | null
    issueType?: string | null
    roomLocation?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    estimatedCost?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutTicketsInput
    agent?: AgentProfileCreateNestedOneWithoutTicketsInput
    photos?: TicketPhotoCreateNestedManyWithoutTicketInput
    maintenanceSession?: MaintenanceSessionCreateNestedOneWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutManagerInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    propertyId: string
    reportedBy: string
    reportedAt?: Date | string
    agentId?: string | null
    assignedAt?: Date | string | null
    category?: string | null
    issueType?: string | null
    roomLocation?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    estimatedCost?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: TicketPhotoUncheckedCreateNestedManyWithoutTicketInput
    maintenanceSession?: MaintenanceSessionUncheckedCreateNestedOneWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutManagerInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutManagerInput, TicketUncheckedCreateWithoutManagerInput>
  }

  export type TicketCreateManyManagerInputEnvelope = {
    data: TicketCreateManyManagerInput | TicketCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceSessionCreateWithoutManagerInput = {
    id?: string
    sessionNumber: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutMaintenanceSessionInput
    property: PropertyCreateNestedOneWithoutMaintenanceSessionsInput
    agent: AgentProfileCreateNestedOneWithoutMaintenanceSessionsInput
    materials?: MaintenanceMaterialCreateNestedManyWithoutMaintenanceSessionInput
    photos?: MaintenancePhotoCreateNestedManyWithoutMaintenanceSessionInput
  }

  export type MaintenanceSessionUncheckedCreateWithoutManagerInput = {
    id?: string
    sessionNumber: string
    ticketId: string
    propertyId: string
    agentId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: MaintenanceMaterialUncheckedCreateNestedManyWithoutMaintenanceSessionInput
    photos?: MaintenancePhotoUncheckedCreateNestedManyWithoutMaintenanceSessionInput
  }

  export type MaintenanceSessionCreateOrConnectWithoutManagerInput = {
    where: MaintenanceSessionWhereUniqueInput
    create: XOR<MaintenanceSessionCreateWithoutManagerInput, MaintenanceSessionUncheckedCreateWithoutManagerInput>
  }

  export type MaintenanceSessionCreateManyManagerInputEnvelope = {
    data: MaintenanceSessionCreateManyManagerInput | MaintenanceSessionCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type LaundryOrderCreateWithoutManagerInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    processedDate?: Date | string | null
    readyDate?: Date | string | null
    deliveryDate?: Date | string | null
    pickupAddress?: string | null
    deliveryAddress: string
    instructions?: string | null
    subtotal: number
    taxes?: number | null
    deliveryFee?: number | null
    totalAmount: number
    notes?: string | null
    receivedByClient?: boolean
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: LaundryClientProfileCreateNestedOneWithoutLaundryOrdersInput
    items?: LaundryOrderItemCreateNestedManyWithoutOrderInput
    deliveryNotes?: DeliveryNoteCreateNestedManyWithoutOrderInput
  }

  export type LaundryOrderUncheckedCreateWithoutManagerInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    processedDate?: Date | string | null
    readyDate?: Date | string | null
    deliveryDate?: Date | string | null
    pickupAddress?: string | null
    deliveryAddress: string
    instructions?: string | null
    subtotal: number
    taxes?: number | null
    deliveryFee?: number | null
    totalAmount: number
    notes?: string | null
    receivedByClient?: boolean
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    items?: LaundryOrderItemUncheckedCreateNestedManyWithoutOrderInput
    deliveryNotes?: DeliveryNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LaundryOrderCreateOrConnectWithoutManagerInput = {
    where: LaundryOrderWhereUniqueInput
    create: XOR<LaundryOrderCreateWithoutManagerInput, LaundryOrderUncheckedCreateWithoutManagerInput>
  }

  export type LaundryOrderCreateManyManagerInputEnvelope = {
    data: LaundryOrderCreateManyManagerInput | LaundryOrderCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type AgentProfileCreateWithoutManagerInput = {
    id?: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentProfileInput
    specialties?: AgentSpecialtyCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutAgentInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutAgentInput
    tickets?: TicketCreateNestedManyWithoutAgentInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutAgentInput
  }

  export type AgentProfileUncheckedCreateWithoutManagerInput = {
    id?: string
    userId: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    specialties?: AgentSpecialtyUncheckedCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutAgentInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAgentInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentProfileCreateOrConnectWithoutManagerInput = {
    where: AgentProfileWhereUniqueInput
    create: XOR<AgentProfileCreateWithoutManagerInput, AgentProfileUncheckedCreateWithoutManagerInput>
  }

  export type AgentProfileCreateManyManagerInputEnvelope = {
    data: AgentProfileCreateManyManagerInput | AgentProfileCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPoleManagerProfileInput = {
    update: XOR<UserUpdateWithoutPoleManagerProfileInput, UserUncheckedUpdateWithoutPoleManagerProfileInput>
    create: XOR<UserCreateWithoutPoleManagerProfileInput, UserUncheckedCreateWithoutPoleManagerProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPoleManagerProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPoleManagerProfileInput, UserUncheckedUpdateWithoutPoleManagerProfileInput>
  }

  export type UserUpdateWithoutPoleManagerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    superAdminProfile?: SuperAdminProfileUpdateOneWithoutUserNestedInput
    propertyOwnerProfile?: PropertyOwnerProfileUpdateOneWithoutUserNestedInput
    laundryClientProfile?: LaundryClientProfileUpdateOneWithoutUserNestedInput
    agentProfile?: AgentProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPoleManagerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    superAdminProfile?: SuperAdminProfileUncheckedUpdateOneWithoutUserNestedInput
    propertyOwnerProfile?: PropertyOwnerProfileUncheckedUpdateOneWithoutUserNestedInput
    laundryClientProfile?: LaundryClientProfileUncheckedUpdateOneWithoutUserNestedInput
    agentProfile?: AgentProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SuperAdminProfileUpsertWithoutPoleManagersInput = {
    update: XOR<SuperAdminProfileUpdateWithoutPoleManagersInput, SuperAdminProfileUncheckedUpdateWithoutPoleManagersInput>
    create: XOR<SuperAdminProfileCreateWithoutPoleManagersInput, SuperAdminProfileUncheckedCreateWithoutPoleManagersInput>
    where?: SuperAdminProfileWhereInput
  }

  export type SuperAdminProfileUpdateToOneWithWhereWithoutPoleManagersInput = {
    where?: SuperAdminProfileWhereInput
    data: XOR<SuperAdminProfileUpdateWithoutPoleManagersInput, SuperAdminProfileUncheckedUpdateWithoutPoleManagersInput>
  }

  export type SuperAdminProfileUpdateWithoutPoleManagersInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    businessNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingCountry?: StringFieldUpdateOperationsInput | string
    billingPostal?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSuperAdminProfileNestedInput
    poleSubscriptions?: PoleSubscriptionUpdateManyWithoutSuperAdminNestedInput
    invoices?: SuperAdminInvoiceUpdateManyWithoutSuperAdminNestedInput
  }

  export type SuperAdminProfileUncheckedUpdateWithoutPoleManagersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    businessNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingCountry?: StringFieldUpdateOperationsInput | string
    billingPostal?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poleSubscriptions?: PoleSubscriptionUncheckedUpdateManyWithoutSuperAdminNestedInput
    invoices?: SuperAdminInvoiceUncheckedUpdateManyWithoutSuperAdminNestedInput
  }

  export type PropertyUpsertWithWhereUniqueWithoutManagerInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutManagerInput, PropertyUncheckedUpdateWithoutManagerInput>
    create: XOR<PropertyCreateWithoutManagerInput, PropertyUncheckedCreateWithoutManagerInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutManagerInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutManagerInput, PropertyUncheckedUpdateWithoutManagerInput>
  }

  export type PropertyUpdateManyWithWhereWithoutManagerInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutManagerInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    OR?: PropertyScalarWhereInput[]
    NOT?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    id?: StringFilter<"Property"> | string
    name?: StringFilter<"Property"> | string
    description?: StringFilter<"Property"> | string
    status?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    address?: StringFilter<"Property"> | string
    city?: StringFilter<"Property"> | string
    country?: StringFilter<"Property"> | string
    postalCode?: StringNullableFilter<"Property"> | string | null
    latitude?: FloatNullableFilter<"Property"> | number | null
    longitude?: FloatNullableFilter<"Property"> | number | null
    surface?: FloatNullableFilter<"Property"> | number | null
    numberOfRooms?: IntNullableFilter<"Property"> | number | null
    numberOfBedrooms?: IntNullableFilter<"Property"> | number | null
    numberOfBathrooms?: IntNullableFilter<"Property"> | number | null
    maxGuests?: IntNullableFilter<"Property"> | number | null
    floor?: IntNullableFilter<"Property"> | number | null
    hasElevator?: BoolNullableFilter<"Property"> | boolean | null
    hasParking?: BoolNullableFilter<"Property"> | boolean | null
    hasBalcony?: BoolNullableFilter<"Property"> | boolean | null
    pricePerNight?: FloatNullableFilter<"Property"> | number | null
    cleaningFee?: FloatNullableFilter<"Property"> | number | null
    serviceFee?: FloatNullableFilter<"Property"> | number | null
    securityDeposit?: FloatNullableFilter<"Property"> | number | null
    averageRating?: FloatNullableFilter<"Property"> | number | null
    totalReviews?: IntFilter<"Property"> | number
    checkInTime?: StringNullableFilter<"Property"> | string | null
    checkOutTime?: StringNullableFilter<"Property"> | string | null
    cancellationPolicy?: StringNullableFilter<"Property"> | string | null
    houseRules?: StringNullableFilter<"Property"> | string | null
    accessInstructions?: StringNullableFilter<"Property"> | string | null
    cleaningInstructions?: StringNullableFilter<"Property"> | string | null
    maintenanceNotes?: StringNullableFilter<"Property"> | string | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    ownerId?: StringFilter<"Property"> | string
    managerId?: StringNullableFilter<"Property"> | string | null
  }

  export type ReservationUpsertWithWhereUniqueWithoutManagerInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutManagerInput, ReservationUncheckedUpdateWithoutManagerInput>
    create: XOR<ReservationCreateWithoutManagerInput, ReservationUncheckedCreateWithoutManagerInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutManagerInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutManagerInput, ReservationUncheckedUpdateWithoutManagerInput>
  }

  export type ReservationUpdateManyWithWhereWithoutManagerInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutManagerInput>
  }

  export type ReservationScalarWhereInput = {
    AND?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    OR?: ReservationScalarWhereInput[]
    NOT?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    id?: StringFilter<"Reservation"> | string
    propertyId?: StringFilter<"Reservation"> | string
    guestName?: StringFilter<"Reservation"> | string
    guestEmail?: StringFilter<"Reservation"> | string
    guestPhone?: StringNullableFilter<"Reservation"> | string | null
    guestCount?: IntFilter<"Reservation"> | number
    checkIn?: DateTimeFilter<"Reservation"> | Date | string
    checkOut?: DateTimeFilter<"Reservation"> | Date | string
    nights?: IntFilter<"Reservation"> | number
    basePrice?: FloatFilter<"Reservation"> | number
    cleaningFee?: FloatNullableFilter<"Reservation"> | number | null
    serviceFee?: FloatNullableFilter<"Reservation"> | number | null
    taxes?: FloatNullableFilter<"Reservation"> | number | null
    totalPrice?: FloatFilter<"Reservation"> | number
    status?: EnumReservationStatusFilter<"Reservation"> | $Enums.ReservationStatus
    notes?: StringNullableFilter<"Reservation"> | string | null
    confirmationCode?: StringNullableFilter<"Reservation"> | string | null
    bookingSource?: StringNullableFilter<"Reservation"> | string | null
    checkInTime?: DateTimeNullableFilter<"Reservation"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"Reservation"> | Date | string | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
    managerId?: StringFilter<"Reservation"> | string
  }

  export type CleaningSessionUpsertWithWhereUniqueWithoutManagerInput = {
    where: CleaningSessionWhereUniqueInput
    update: XOR<CleaningSessionUpdateWithoutManagerInput, CleaningSessionUncheckedUpdateWithoutManagerInput>
    create: XOR<CleaningSessionCreateWithoutManagerInput, CleaningSessionUncheckedCreateWithoutManagerInput>
  }

  export type CleaningSessionUpdateWithWhereUniqueWithoutManagerInput = {
    where: CleaningSessionWhereUniqueInput
    data: XOR<CleaningSessionUpdateWithoutManagerInput, CleaningSessionUncheckedUpdateWithoutManagerInput>
  }

  export type CleaningSessionUpdateManyWithWhereWithoutManagerInput = {
    where: CleaningSessionScalarWhereInput
    data: XOR<CleaningSessionUpdateManyMutationInput, CleaningSessionUncheckedUpdateManyWithoutManagerInput>
  }

  export type CleaningSessionScalarWhereInput = {
    AND?: CleaningSessionScalarWhereInput | CleaningSessionScalarWhereInput[]
    OR?: CleaningSessionScalarWhereInput[]
    NOT?: CleaningSessionScalarWhereInput | CleaningSessionScalarWhereInput[]
    id?: StringFilter<"CleaningSession"> | string
    propertyId?: StringFilter<"CleaningSession"> | string
    agentId?: StringFilter<"CleaningSession"> | string
    scheduledDate?: DateTimeFilter<"CleaningSession"> | Date | string
    startTime?: DateTimeNullableFilter<"CleaningSession"> | Date | string | null
    endTime?: DateTimeNullableFilter<"CleaningSession"> | Date | string | null
    duration?: IntNullableFilter<"CleaningSession"> | number | null
    cleaningType?: StringFilter<"CleaningSession"> | string
    status?: EnumSessionStatusFilter<"CleaningSession"> | $Enums.SessionStatus
    notes?: StringNullableFilter<"CleaningSession"> | string | null
    agentNotes?: StringNullableFilter<"CleaningSession"> | string | null
    ownerRating?: FloatNullableFilter<"CleaningSession"> | number | null
    managerRating?: FloatNullableFilter<"CleaningSession"> | number | null
    feedback?: StringNullableFilter<"CleaningSession"> | string | null
    createdAt?: DateTimeFilter<"CleaningSession"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningSession"> | Date | string
    managerId?: StringFilter<"CleaningSession"> | string
  }

  export type TicketUpsertWithWhereUniqueWithoutManagerInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutManagerInput, TicketUncheckedUpdateWithoutManagerInput>
    create: XOR<TicketCreateWithoutManagerInput, TicketUncheckedCreateWithoutManagerInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutManagerInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutManagerInput, TicketUncheckedUpdateWithoutManagerInput>
  }

  export type TicketUpdateManyWithWhereWithoutManagerInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutManagerInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: StringFilter<"Ticket"> | string
    ticketNumber?: StringFilter<"Ticket"> | string
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    propertyId?: StringFilter<"Ticket"> | string
    reportedBy?: StringFilter<"Ticket"> | string
    reportedAt?: DateTimeFilter<"Ticket"> | Date | string
    agentId?: StringNullableFilter<"Ticket"> | string | null
    assignedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    category?: StringNullableFilter<"Ticket"> | string | null
    issueType?: StringNullableFilter<"Ticket"> | string | null
    roomLocation?: StringNullableFilter<"Ticket"> | string | null
    resolution?: StringNullableFilter<"Ticket"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    estimatedCost?: FloatNullableFilter<"Ticket"> | number | null
    estimatedDuration?: IntNullableFilter<"Ticket"> | number | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    managerId?: StringFilter<"Ticket"> | string
  }

  export type MaintenanceSessionUpsertWithWhereUniqueWithoutManagerInput = {
    where: MaintenanceSessionWhereUniqueInput
    update: XOR<MaintenanceSessionUpdateWithoutManagerInput, MaintenanceSessionUncheckedUpdateWithoutManagerInput>
    create: XOR<MaintenanceSessionCreateWithoutManagerInput, MaintenanceSessionUncheckedCreateWithoutManagerInput>
  }

  export type MaintenanceSessionUpdateWithWhereUniqueWithoutManagerInput = {
    where: MaintenanceSessionWhereUniqueInput
    data: XOR<MaintenanceSessionUpdateWithoutManagerInput, MaintenanceSessionUncheckedUpdateWithoutManagerInput>
  }

  export type MaintenanceSessionUpdateManyWithWhereWithoutManagerInput = {
    where: MaintenanceSessionScalarWhereInput
    data: XOR<MaintenanceSessionUpdateManyMutationInput, MaintenanceSessionUncheckedUpdateManyWithoutManagerInput>
  }

  export type MaintenanceSessionScalarWhereInput = {
    AND?: MaintenanceSessionScalarWhereInput | MaintenanceSessionScalarWhereInput[]
    OR?: MaintenanceSessionScalarWhereInput[]
    NOT?: MaintenanceSessionScalarWhereInput | MaintenanceSessionScalarWhereInput[]
    id?: StringFilter<"MaintenanceSession"> | string
    sessionNumber?: StringFilter<"MaintenanceSession"> | string
    ticketId?: StringFilter<"MaintenanceSession"> | string
    propertyId?: StringFilter<"MaintenanceSession"> | string
    agentId?: StringFilter<"MaintenanceSession"> | string
    scheduledDate?: DateTimeFilter<"MaintenanceSession"> | Date | string
    startTime?: DateTimeNullableFilter<"MaintenanceSession"> | Date | string | null
    endTime?: DateTimeNullableFilter<"MaintenanceSession"> | Date | string | null
    estimatedDuration?: IntNullableFilter<"MaintenanceSession"> | number | null
    actualDuration?: IntNullableFilter<"MaintenanceSession"> | number | null
    status?: EnumSessionStatusFilter<"MaintenanceSession"> | $Enums.SessionStatus
    notes?: StringNullableFilter<"MaintenanceSession"> | string | null
    workDescription?: StringNullableFilter<"MaintenanceSession"> | string | null
    agentNotes?: StringNullableFilter<"MaintenanceSession"> | string | null
    laborCost?: FloatNullableFilter<"MaintenanceSession"> | number | null
    materialsCost?: FloatNullableFilter<"MaintenanceSession"> | number | null
    totalCost?: FloatNullableFilter<"MaintenanceSession"> | number | null
    ownerApproval?: BoolNullableFilter<"MaintenanceSession"> | boolean | null
    managerApproval?: BoolNullableFilter<"MaintenanceSession"> | boolean | null
    createdAt?: DateTimeFilter<"MaintenanceSession"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceSession"> | Date | string
    managerId?: StringFilter<"MaintenanceSession"> | string
  }

  export type LaundryOrderUpsertWithWhereUniqueWithoutManagerInput = {
    where: LaundryOrderWhereUniqueInput
    update: XOR<LaundryOrderUpdateWithoutManagerInput, LaundryOrderUncheckedUpdateWithoutManagerInput>
    create: XOR<LaundryOrderCreateWithoutManagerInput, LaundryOrderUncheckedCreateWithoutManagerInput>
  }

  export type LaundryOrderUpdateWithWhereUniqueWithoutManagerInput = {
    where: LaundryOrderWhereUniqueInput
    data: XOR<LaundryOrderUpdateWithoutManagerInput, LaundryOrderUncheckedUpdateWithoutManagerInput>
  }

  export type LaundryOrderUpdateManyWithWhereWithoutManagerInput = {
    where: LaundryOrderScalarWhereInput
    data: XOR<LaundryOrderUpdateManyMutationInput, LaundryOrderUncheckedUpdateManyWithoutManagerInput>
  }

  export type LaundryOrderScalarWhereInput = {
    AND?: LaundryOrderScalarWhereInput | LaundryOrderScalarWhereInput[]
    OR?: LaundryOrderScalarWhereInput[]
    NOT?: LaundryOrderScalarWhereInput | LaundryOrderScalarWhereInput[]
    id?: StringFilter<"LaundryOrder"> | string
    orderNumber?: StringFilter<"LaundryOrder"> | string
    status?: EnumOrderStatusFilter<"LaundryOrder"> | $Enums.OrderStatus
    receivedDate?: DateTimeNullableFilter<"LaundryOrder"> | Date | string | null
    processedDate?: DateTimeNullableFilter<"LaundryOrder"> | Date | string | null
    readyDate?: DateTimeNullableFilter<"LaundryOrder"> | Date | string | null
    deliveryDate?: DateTimeNullableFilter<"LaundryOrder"> | Date | string | null
    pickupAddress?: StringNullableFilter<"LaundryOrder"> | string | null
    deliveryAddress?: StringFilter<"LaundryOrder"> | string
    instructions?: StringNullableFilter<"LaundryOrder"> | string | null
    subtotal?: FloatFilter<"LaundryOrder"> | number
    taxes?: FloatNullableFilter<"LaundryOrder"> | number | null
    deliveryFee?: FloatNullableFilter<"LaundryOrder"> | number | null
    totalAmount?: FloatFilter<"LaundryOrder"> | number
    notes?: StringNullableFilter<"LaundryOrder"> | string | null
    receivedByClient?: BoolFilter<"LaundryOrder"> | boolean
    receivedAt?: DateTimeNullableFilter<"LaundryOrder"> | Date | string | null
    createdAt?: DateTimeFilter<"LaundryOrder"> | Date | string
    updatedAt?: DateTimeFilter<"LaundryOrder"> | Date | string
    managerId?: StringFilter<"LaundryOrder"> | string
    clientId?: StringFilter<"LaundryOrder"> | string
  }

  export type AgentProfileUpsertWithWhereUniqueWithoutManagerInput = {
    where: AgentProfileWhereUniqueInput
    update: XOR<AgentProfileUpdateWithoutManagerInput, AgentProfileUncheckedUpdateWithoutManagerInput>
    create: XOR<AgentProfileCreateWithoutManagerInput, AgentProfileUncheckedCreateWithoutManagerInput>
  }

  export type AgentProfileUpdateWithWhereUniqueWithoutManagerInput = {
    where: AgentProfileWhereUniqueInput
    data: XOR<AgentProfileUpdateWithoutManagerInput, AgentProfileUncheckedUpdateWithoutManagerInput>
  }

  export type AgentProfileUpdateManyWithWhereWithoutManagerInput = {
    where: AgentProfileScalarWhereInput
    data: XOR<AgentProfileUpdateManyMutationInput, AgentProfileUncheckedUpdateManyWithoutManagerInput>
  }

  export type AgentProfileScalarWhereInput = {
    AND?: AgentProfileScalarWhereInput | AgentProfileScalarWhereInput[]
    OR?: AgentProfileScalarWhereInput[]
    NOT?: AgentProfileScalarWhereInput | AgentProfileScalarWhereInput[]
    id?: StringFilter<"AgentProfile"> | string
    userId?: StringFilter<"AgentProfile"> | string
    agentType?: EnumAgentTypeFilter<"AgentProfile"> | $Enums.AgentType
    availability?: EnumAgentAvailabilityFilter<"AgentProfile"> | $Enums.AgentAvailability
    employeeId?: StringNullableFilter<"AgentProfile"> | string | null
    certifications?: StringNullableListFilter<"AgentProfile">
    currentLocation?: JsonNullableFilter<"AgentProfile">
    serviceZones?: StringNullableListFilter<"AgentProfile">
    rating?: FloatNullableFilter<"AgentProfile"> | number | null
    completedTasks?: IntFilter<"AgentProfile"> | number
    averageRating?: FloatNullableFilter<"AgentProfile"> | number | null
    responseTime?: IntNullableFilter<"AgentProfile"> | number | null
    workingHours?: JsonNullableFilter<"AgentProfile">
    availabilityCalendar?: JsonNullableFilter<"AgentProfile">
    hourlyRate?: FloatNullableFilter<"AgentProfile"> | number | null
    isActive?: BoolFilter<"AgentProfile"> | boolean
    hireDate?: DateTimeNullableFilter<"AgentProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"AgentProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AgentProfile"> | Date | string
    managerId?: StringFilter<"AgentProfile"> | string
  }

  export type UserCreateWithoutPropertyOwnerProfileInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    superAdminProfile?: SuperAdminProfileCreateNestedOneWithoutUserInput
    poleManagerProfile?: PoleManagerProfileCreateNestedOneWithoutUserInput
    laundryClientProfile?: LaundryClientProfileCreateNestedOneWithoutUserInput
    agentProfile?: AgentProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPropertyOwnerProfileInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    superAdminProfile?: SuperAdminProfileUncheckedCreateNestedOneWithoutUserInput
    poleManagerProfile?: PoleManagerProfileUncheckedCreateNestedOneWithoutUserInput
    laundryClientProfile?: LaundryClientProfileUncheckedCreateNestedOneWithoutUserInput
    agentProfile?: AgentProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPropertyOwnerProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPropertyOwnerProfileInput, UserUncheckedCreateWithoutPropertyOwnerProfileInput>
  }

  export type PropertyCreateWithoutOwnerInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoCreateNestedManyWithoutPropertyInput
    manager?: PoleManagerProfileCreateNestedOneWithoutPropertiesInput
    reservations?: ReservationCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutPropertyInput
    tickets?: TicketCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewUncheckedCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutOwnerInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput>
  }

  export type PropertyCreateManyOwnerInputEnvelope = {
    data: PropertyCreateManyOwnerInput | PropertyCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type PropertyContractCreateWithoutPropertyOwnerInput = {
    id?: string
    contractNumber: string
    type: string
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    monthlyFee?: number | null
    commissionRate?: number | null
    documentUrl?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutContractsInput
  }

  export type PropertyContractUncheckedCreateWithoutPropertyOwnerInput = {
    id?: string
    contractNumber: string
    type: string
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    propertyId: string
    monthlyFee?: number | null
    commissionRate?: number | null
    documentUrl?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyContractCreateOrConnectWithoutPropertyOwnerInput = {
    where: PropertyContractWhereUniqueInput
    create: XOR<PropertyContractCreateWithoutPropertyOwnerInput, PropertyContractUncheckedCreateWithoutPropertyOwnerInput>
  }

  export type PropertyContractCreateManyPropertyOwnerInputEnvelope = {
    data: PropertyContractCreateManyPropertyOwnerInput | PropertyContractCreateManyPropertyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPropertyOwnerProfileInput = {
    update: XOR<UserUpdateWithoutPropertyOwnerProfileInput, UserUncheckedUpdateWithoutPropertyOwnerProfileInput>
    create: XOR<UserCreateWithoutPropertyOwnerProfileInput, UserUncheckedCreateWithoutPropertyOwnerProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPropertyOwnerProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPropertyOwnerProfileInput, UserUncheckedUpdateWithoutPropertyOwnerProfileInput>
  }

  export type UserUpdateWithoutPropertyOwnerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    superAdminProfile?: SuperAdminProfileUpdateOneWithoutUserNestedInput
    poleManagerProfile?: PoleManagerProfileUpdateOneWithoutUserNestedInput
    laundryClientProfile?: LaundryClientProfileUpdateOneWithoutUserNestedInput
    agentProfile?: AgentProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPropertyOwnerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    superAdminProfile?: SuperAdminProfileUncheckedUpdateOneWithoutUserNestedInput
    poleManagerProfile?: PoleManagerProfileUncheckedUpdateOneWithoutUserNestedInput
    laundryClientProfile?: LaundryClientProfileUncheckedUpdateOneWithoutUserNestedInput
    agentProfile?: AgentProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PropertyUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutOwnerInput, PropertyUncheckedUpdateWithoutOwnerInput>
    create: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutOwnerInput, PropertyUncheckedUpdateWithoutOwnerInput>
  }

  export type PropertyUpdateManyWithWhereWithoutOwnerInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutOwnerInput>
  }

  export type PropertyContractUpsertWithWhereUniqueWithoutPropertyOwnerInput = {
    where: PropertyContractWhereUniqueInput
    update: XOR<PropertyContractUpdateWithoutPropertyOwnerInput, PropertyContractUncheckedUpdateWithoutPropertyOwnerInput>
    create: XOR<PropertyContractCreateWithoutPropertyOwnerInput, PropertyContractUncheckedCreateWithoutPropertyOwnerInput>
  }

  export type PropertyContractUpdateWithWhereUniqueWithoutPropertyOwnerInput = {
    where: PropertyContractWhereUniqueInput
    data: XOR<PropertyContractUpdateWithoutPropertyOwnerInput, PropertyContractUncheckedUpdateWithoutPropertyOwnerInput>
  }

  export type PropertyContractUpdateManyWithWhereWithoutPropertyOwnerInput = {
    where: PropertyContractScalarWhereInput
    data: XOR<PropertyContractUpdateManyMutationInput, PropertyContractUncheckedUpdateManyWithoutPropertyOwnerInput>
  }

  export type PropertyContractScalarWhereInput = {
    AND?: PropertyContractScalarWhereInput | PropertyContractScalarWhereInput[]
    OR?: PropertyContractScalarWhereInput[]
    NOT?: PropertyContractScalarWhereInput | PropertyContractScalarWhereInput[]
    id?: StringFilter<"PropertyContract"> | string
    contractNumber?: StringFilter<"PropertyContract"> | string
    type?: StringFilter<"PropertyContract"> | string
    status?: StringFilter<"PropertyContract"> | string
    startDate?: DateTimeFilter<"PropertyContract"> | Date | string
    endDate?: DateTimeNullableFilter<"PropertyContract"> | Date | string | null
    propertyId?: StringFilter<"PropertyContract"> | string
    propertyOwnerId?: StringFilter<"PropertyContract"> | string
    monthlyFee?: FloatNullableFilter<"PropertyContract"> | number | null
    commissionRate?: FloatNullableFilter<"PropertyContract"> | number | null
    documentUrl?: StringNullableFilter<"PropertyContract"> | string | null
    signedAt?: DateTimeNullableFilter<"PropertyContract"> | Date | string | null
    createdAt?: DateTimeFilter<"PropertyContract"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyContract"> | Date | string
  }

  export type UserCreateWithoutLaundryClientProfileInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    superAdminProfile?: SuperAdminProfileCreateNestedOneWithoutUserInput
    poleManagerProfile?: PoleManagerProfileCreateNestedOneWithoutUserInput
    propertyOwnerProfile?: PropertyOwnerProfileCreateNestedOneWithoutUserInput
    agentProfile?: AgentProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLaundryClientProfileInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    superAdminProfile?: SuperAdminProfileUncheckedCreateNestedOneWithoutUserInput
    poleManagerProfile?: PoleManagerProfileUncheckedCreateNestedOneWithoutUserInput
    propertyOwnerProfile?: PropertyOwnerProfileUncheckedCreateNestedOneWithoutUserInput
    agentProfile?: AgentProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLaundryClientProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLaundryClientProfileInput, UserUncheckedCreateWithoutLaundryClientProfileInput>
  }

  export type LaundryOrderCreateWithoutClientInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    processedDate?: Date | string | null
    readyDate?: Date | string | null
    deliveryDate?: Date | string | null
    pickupAddress?: string | null
    deliveryAddress: string
    instructions?: string | null
    subtotal: number
    taxes?: number | null
    deliveryFee?: number | null
    totalAmount: number
    notes?: string | null
    receivedByClient?: boolean
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager: PoleManagerProfileCreateNestedOneWithoutLaundryOrdersInput
    items?: LaundryOrderItemCreateNestedManyWithoutOrderInput
    deliveryNotes?: DeliveryNoteCreateNestedManyWithoutOrderInput
  }

  export type LaundryOrderUncheckedCreateWithoutClientInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    processedDate?: Date | string | null
    readyDate?: Date | string | null
    deliveryDate?: Date | string | null
    pickupAddress?: string | null
    deliveryAddress: string
    instructions?: string | null
    subtotal: number
    taxes?: number | null
    deliveryFee?: number | null
    totalAmount: number
    notes?: string | null
    receivedByClient?: boolean
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    items?: LaundryOrderItemUncheckedCreateNestedManyWithoutOrderInput
    deliveryNotes?: DeliveryNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LaundryOrderCreateOrConnectWithoutClientInput = {
    where: LaundryOrderWhereUniqueInput
    create: XOR<LaundryOrderCreateWithoutClientInput, LaundryOrderUncheckedCreateWithoutClientInput>
  }

  export type LaundryOrderCreateManyClientInputEnvelope = {
    data: LaundryOrderCreateManyClientInput | LaundryOrderCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type LaundryInvoiceCreateWithoutClientInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    subtotal: number
    taxRate?: number
    taxAmount: number
    totalAmount: number
    paidAmount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryInvoiceUncheckedCreateWithoutClientInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    subtotal: number
    taxRate?: number
    taxAmount: number
    totalAmount: number
    paidAmount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryInvoiceCreateOrConnectWithoutClientInput = {
    where: LaundryInvoiceWhereUniqueInput
    create: XOR<LaundryInvoiceCreateWithoutClientInput, LaundryInvoiceUncheckedCreateWithoutClientInput>
  }

  export type LaundryInvoiceCreateManyClientInputEnvelope = {
    data: LaundryInvoiceCreateManyClientInput | LaundryInvoiceCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLaundryClientProfileInput = {
    update: XOR<UserUpdateWithoutLaundryClientProfileInput, UserUncheckedUpdateWithoutLaundryClientProfileInput>
    create: XOR<UserCreateWithoutLaundryClientProfileInput, UserUncheckedCreateWithoutLaundryClientProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLaundryClientProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLaundryClientProfileInput, UserUncheckedUpdateWithoutLaundryClientProfileInput>
  }

  export type UserUpdateWithoutLaundryClientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    superAdminProfile?: SuperAdminProfileUpdateOneWithoutUserNestedInput
    poleManagerProfile?: PoleManagerProfileUpdateOneWithoutUserNestedInput
    propertyOwnerProfile?: PropertyOwnerProfileUpdateOneWithoutUserNestedInput
    agentProfile?: AgentProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLaundryClientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    superAdminProfile?: SuperAdminProfileUncheckedUpdateOneWithoutUserNestedInput
    poleManagerProfile?: PoleManagerProfileUncheckedUpdateOneWithoutUserNestedInput
    propertyOwnerProfile?: PropertyOwnerProfileUncheckedUpdateOneWithoutUserNestedInput
    agentProfile?: AgentProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type LaundryOrderUpsertWithWhereUniqueWithoutClientInput = {
    where: LaundryOrderWhereUniqueInput
    update: XOR<LaundryOrderUpdateWithoutClientInput, LaundryOrderUncheckedUpdateWithoutClientInput>
    create: XOR<LaundryOrderCreateWithoutClientInput, LaundryOrderUncheckedCreateWithoutClientInput>
  }

  export type LaundryOrderUpdateWithWhereUniqueWithoutClientInput = {
    where: LaundryOrderWhereUniqueInput
    data: XOR<LaundryOrderUpdateWithoutClientInput, LaundryOrderUncheckedUpdateWithoutClientInput>
  }

  export type LaundryOrderUpdateManyWithWhereWithoutClientInput = {
    where: LaundryOrderScalarWhereInput
    data: XOR<LaundryOrderUpdateManyMutationInput, LaundryOrderUncheckedUpdateManyWithoutClientInput>
  }

  export type LaundryInvoiceUpsertWithWhereUniqueWithoutClientInput = {
    where: LaundryInvoiceWhereUniqueInput
    update: XOR<LaundryInvoiceUpdateWithoutClientInput, LaundryInvoiceUncheckedUpdateWithoutClientInput>
    create: XOR<LaundryInvoiceCreateWithoutClientInput, LaundryInvoiceUncheckedCreateWithoutClientInput>
  }

  export type LaundryInvoiceUpdateWithWhereUniqueWithoutClientInput = {
    where: LaundryInvoiceWhereUniqueInput
    data: XOR<LaundryInvoiceUpdateWithoutClientInput, LaundryInvoiceUncheckedUpdateWithoutClientInput>
  }

  export type LaundryInvoiceUpdateManyWithWhereWithoutClientInput = {
    where: LaundryInvoiceScalarWhereInput
    data: XOR<LaundryInvoiceUpdateManyMutationInput, LaundryInvoiceUncheckedUpdateManyWithoutClientInput>
  }

  export type LaundryInvoiceScalarWhereInput = {
    AND?: LaundryInvoiceScalarWhereInput | LaundryInvoiceScalarWhereInput[]
    OR?: LaundryInvoiceScalarWhereInput[]
    NOT?: LaundryInvoiceScalarWhereInput | LaundryInvoiceScalarWhereInput[]
    id?: StringFilter<"LaundryInvoice"> | string
    invoiceNumber?: StringFilter<"LaundryInvoice"> | string
    status?: StringFilter<"LaundryInvoice"> | string
    issueDate?: DateTimeFilter<"LaundryInvoice"> | Date | string
    dueDate?: DateTimeFilter<"LaundryInvoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"LaundryInvoice"> | Date | string | null
    subtotal?: FloatFilter<"LaundryInvoice"> | number
    taxRate?: FloatFilter<"LaundryInvoice"> | number
    taxAmount?: FloatFilter<"LaundryInvoice"> | number
    totalAmount?: FloatFilter<"LaundryInvoice"> | number
    paidAmount?: FloatFilter<"LaundryInvoice"> | number
    clientId?: StringFilter<"LaundryInvoice"> | string
    notes?: StringNullableFilter<"LaundryInvoice"> | string | null
    createdAt?: DateTimeFilter<"LaundryInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"LaundryInvoice"> | Date | string
  }

  export type UserCreateWithoutAgentProfileInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    superAdminProfile?: SuperAdminProfileCreateNestedOneWithoutUserInput
    poleManagerProfile?: PoleManagerProfileCreateNestedOneWithoutUserInput
    propertyOwnerProfile?: PropertyOwnerProfileCreateNestedOneWithoutUserInput
    laundryClientProfile?: LaundryClientProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgentProfileInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    superAdminProfile?: SuperAdminProfileUncheckedCreateNestedOneWithoutUserInput
    poleManagerProfile?: PoleManagerProfileUncheckedCreateNestedOneWithoutUserInput
    propertyOwnerProfile?: PropertyOwnerProfileUncheckedCreateNestedOneWithoutUserInput
    laundryClientProfile?: LaundryClientProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgentProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgentProfileInput, UserUncheckedCreateWithoutAgentProfileInput>
  }

  export type AgentSpecialtyCreateWithoutAgentInput = {
    id?: string
    name: string
    category?: string | null
    level?: string | null
    certified?: boolean
  }

  export type AgentSpecialtyUncheckedCreateWithoutAgentInput = {
    id?: string
    name: string
    category?: string | null
    level?: string | null
    certified?: boolean
  }

  export type AgentSpecialtyCreateOrConnectWithoutAgentInput = {
    where: AgentSpecialtyWhereUniqueInput
    create: XOR<AgentSpecialtyCreateWithoutAgentInput, AgentSpecialtyUncheckedCreateWithoutAgentInput>
  }

  export type AgentSpecialtyCreateManyAgentInputEnvelope = {
    data: AgentSpecialtyCreateManyAgentInput | AgentSpecialtyCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type PoleManagerProfileCreateWithoutManagedAgentsInput = {
    id?: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPoleManagerProfileInput
    superAdmin: SuperAdminProfileCreateNestedOneWithoutPoleManagersInput
    properties?: PropertyCreateNestedManyWithoutManagerInput
    reservations?: ReservationCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutManagerInput
    tickets?: TicketCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileUncheckedCreateWithoutManagedAgentsInput = {
    id?: string
    userId: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdminId: string
    properties?: PropertyUncheckedCreateNestedManyWithoutManagerInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutManagerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderUncheckedCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileCreateOrConnectWithoutManagedAgentsInput = {
    where: PoleManagerProfileWhereUniqueInput
    create: XOR<PoleManagerProfileCreateWithoutManagedAgentsInput, PoleManagerProfileUncheckedCreateWithoutManagedAgentsInput>
  }

  export type CleaningSessionCreateWithoutAgentInput = {
    id?: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    cleaningType: string
    status?: $Enums.SessionStatus
    notes?: string | null
    agentNotes?: string | null
    ownerRating?: number | null
    managerRating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutCleaningSessionsInput
    checklist?: CleaningChecklistCreateNestedManyWithoutCleaningSessionInput
    photos?: CleaningPhotoCreateNestedManyWithoutCleaningSessionInput
    manager: PoleManagerProfileCreateNestedOneWithoutCleaningSessionsInput
  }

  export type CleaningSessionUncheckedCreateWithoutAgentInput = {
    id?: string
    propertyId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    cleaningType: string
    status?: $Enums.SessionStatus
    notes?: string | null
    agentNotes?: string | null
    ownerRating?: number | null
    managerRating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    checklist?: CleaningChecklistUncheckedCreateNestedManyWithoutCleaningSessionInput
    photos?: CleaningPhotoUncheckedCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionCreateOrConnectWithoutAgentInput = {
    where: CleaningSessionWhereUniqueInput
    create: XOR<CleaningSessionCreateWithoutAgentInput, CleaningSessionUncheckedCreateWithoutAgentInput>
  }

  export type CleaningSessionCreateManyAgentInputEnvelope = {
    data: CleaningSessionCreateManyAgentInput | CleaningSessionCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceSessionCreateWithoutAgentInput = {
    id?: string
    sessionNumber: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutMaintenanceSessionInput
    property: PropertyCreateNestedOneWithoutMaintenanceSessionsInput
    materials?: MaintenanceMaterialCreateNestedManyWithoutMaintenanceSessionInput
    photos?: MaintenancePhotoCreateNestedManyWithoutMaintenanceSessionInput
    manager: PoleManagerProfileCreateNestedOneWithoutMaintenanceSessionsInput
  }

  export type MaintenanceSessionUncheckedCreateWithoutAgentInput = {
    id?: string
    sessionNumber: string
    ticketId: string
    propertyId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    materials?: MaintenanceMaterialUncheckedCreateNestedManyWithoutMaintenanceSessionInput
    photos?: MaintenancePhotoUncheckedCreateNestedManyWithoutMaintenanceSessionInput
  }

  export type MaintenanceSessionCreateOrConnectWithoutAgentInput = {
    where: MaintenanceSessionWhereUniqueInput
    create: XOR<MaintenanceSessionCreateWithoutAgentInput, MaintenanceSessionUncheckedCreateWithoutAgentInput>
  }

  export type MaintenanceSessionCreateManyAgentInputEnvelope = {
    data: MaintenanceSessionCreateManyAgentInput | MaintenanceSessionCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutAgentInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    reportedBy: string
    reportedAt?: Date | string
    assignedAt?: Date | string | null
    category?: string | null
    issueType?: string | null
    roomLocation?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    estimatedCost?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutTicketsInput
    photos?: TicketPhotoCreateNestedManyWithoutTicketInput
    manager: PoleManagerProfileCreateNestedOneWithoutTicketsInput
    maintenanceSession?: MaintenanceSessionCreateNestedOneWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutAgentInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    propertyId: string
    reportedBy: string
    reportedAt?: Date | string
    assignedAt?: Date | string | null
    category?: string | null
    issueType?: string | null
    roomLocation?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    estimatedCost?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    photos?: TicketPhotoUncheckedCreateNestedManyWithoutTicketInput
    maintenanceSession?: MaintenanceSessionUncheckedCreateNestedOneWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutAgentInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAgentInput, TicketUncheckedCreateWithoutAgentInput>
  }

  export type TicketCreateManyAgentInputEnvelope = {
    data: TicketCreateManyAgentInput | TicketCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type TaskAssignmentCreateWithoutAgentInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    priority?: string
    status?: string
    assignedAt?: Date | string
    dueDate?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    propertyId?: string | null
    reservationId?: string | null
    cleaningSessionId?: string | null
    maintenanceSessionId?: string | null
    ticketId?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskAssignmentUncheckedCreateWithoutAgentInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    priority?: string
    status?: string
    assignedAt?: Date | string
    dueDate?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    propertyId?: string | null
    reservationId?: string | null
    cleaningSessionId?: string | null
    maintenanceSessionId?: string | null
    ticketId?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskAssignmentCreateOrConnectWithoutAgentInput = {
    where: TaskAssignmentWhereUniqueInput
    create: XOR<TaskAssignmentCreateWithoutAgentInput, TaskAssignmentUncheckedCreateWithoutAgentInput>
  }

  export type TaskAssignmentCreateManyAgentInputEnvelope = {
    data: TaskAssignmentCreateManyAgentInput | TaskAssignmentCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAgentProfileInput = {
    update: XOR<UserUpdateWithoutAgentProfileInput, UserUncheckedUpdateWithoutAgentProfileInput>
    create: XOR<UserCreateWithoutAgentProfileInput, UserUncheckedCreateWithoutAgentProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgentProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgentProfileInput, UserUncheckedUpdateWithoutAgentProfileInput>
  }

  export type UserUpdateWithoutAgentProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    superAdminProfile?: SuperAdminProfileUpdateOneWithoutUserNestedInput
    poleManagerProfile?: PoleManagerProfileUpdateOneWithoutUserNestedInput
    propertyOwnerProfile?: PropertyOwnerProfileUpdateOneWithoutUserNestedInput
    laundryClientProfile?: LaundryClientProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgentProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    superAdminProfile?: SuperAdminProfileUncheckedUpdateOneWithoutUserNestedInput
    poleManagerProfile?: PoleManagerProfileUncheckedUpdateOneWithoutUserNestedInput
    propertyOwnerProfile?: PropertyOwnerProfileUncheckedUpdateOneWithoutUserNestedInput
    laundryClientProfile?: LaundryClientProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AgentSpecialtyUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentSpecialtyWhereUniqueInput
    update: XOR<AgentSpecialtyUpdateWithoutAgentInput, AgentSpecialtyUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentSpecialtyCreateWithoutAgentInput, AgentSpecialtyUncheckedCreateWithoutAgentInput>
  }

  export type AgentSpecialtyUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentSpecialtyWhereUniqueInput
    data: XOR<AgentSpecialtyUpdateWithoutAgentInput, AgentSpecialtyUncheckedUpdateWithoutAgentInput>
  }

  export type AgentSpecialtyUpdateManyWithWhereWithoutAgentInput = {
    where: AgentSpecialtyScalarWhereInput
    data: XOR<AgentSpecialtyUpdateManyMutationInput, AgentSpecialtyUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentSpecialtyScalarWhereInput = {
    AND?: AgentSpecialtyScalarWhereInput | AgentSpecialtyScalarWhereInput[]
    OR?: AgentSpecialtyScalarWhereInput[]
    NOT?: AgentSpecialtyScalarWhereInput | AgentSpecialtyScalarWhereInput[]
    id?: StringFilter<"AgentSpecialty"> | string
    name?: StringFilter<"AgentSpecialty"> | string
    category?: StringNullableFilter<"AgentSpecialty"> | string | null
    level?: StringNullableFilter<"AgentSpecialty"> | string | null
    certified?: BoolFilter<"AgentSpecialty"> | boolean
    agentId?: StringFilter<"AgentSpecialty"> | string
  }

  export type PoleManagerProfileUpsertWithoutManagedAgentsInput = {
    update: XOR<PoleManagerProfileUpdateWithoutManagedAgentsInput, PoleManagerProfileUncheckedUpdateWithoutManagedAgentsInput>
    create: XOR<PoleManagerProfileCreateWithoutManagedAgentsInput, PoleManagerProfileUncheckedCreateWithoutManagedAgentsInput>
    where?: PoleManagerProfileWhereInput
  }

  export type PoleManagerProfileUpdateToOneWithWhereWithoutManagedAgentsInput = {
    where?: PoleManagerProfileWhereInput
    data: XOR<PoleManagerProfileUpdateWithoutManagedAgentsInput, PoleManagerProfileUncheckedUpdateWithoutManagedAgentsInput>
  }

  export type PoleManagerProfileUpdateWithoutManagedAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPoleManagerProfileNestedInput
    superAdmin?: SuperAdminProfileUpdateOneRequiredWithoutPoleManagersNestedInput
    properties?: PropertyUpdateManyWithoutManagerNestedInput
    reservations?: ReservationUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutManagerNestedInput
    tickets?: TicketUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUpdateManyWithoutManagerNestedInput
  }

  export type PoleManagerProfileUncheckedUpdateWithoutManagedAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdminId?: StringFieldUpdateOperationsInput | string
    properties?: PropertyUncheckedUpdateManyWithoutManagerNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutManagerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type CleaningSessionUpsertWithWhereUniqueWithoutAgentInput = {
    where: CleaningSessionWhereUniqueInput
    update: XOR<CleaningSessionUpdateWithoutAgentInput, CleaningSessionUncheckedUpdateWithoutAgentInput>
    create: XOR<CleaningSessionCreateWithoutAgentInput, CleaningSessionUncheckedCreateWithoutAgentInput>
  }

  export type CleaningSessionUpdateWithWhereUniqueWithoutAgentInput = {
    where: CleaningSessionWhereUniqueInput
    data: XOR<CleaningSessionUpdateWithoutAgentInput, CleaningSessionUncheckedUpdateWithoutAgentInput>
  }

  export type CleaningSessionUpdateManyWithWhereWithoutAgentInput = {
    where: CleaningSessionScalarWhereInput
    data: XOR<CleaningSessionUpdateManyMutationInput, CleaningSessionUncheckedUpdateManyWithoutAgentInput>
  }

  export type MaintenanceSessionUpsertWithWhereUniqueWithoutAgentInput = {
    where: MaintenanceSessionWhereUniqueInput
    update: XOR<MaintenanceSessionUpdateWithoutAgentInput, MaintenanceSessionUncheckedUpdateWithoutAgentInput>
    create: XOR<MaintenanceSessionCreateWithoutAgentInput, MaintenanceSessionUncheckedCreateWithoutAgentInput>
  }

  export type MaintenanceSessionUpdateWithWhereUniqueWithoutAgentInput = {
    where: MaintenanceSessionWhereUniqueInput
    data: XOR<MaintenanceSessionUpdateWithoutAgentInput, MaintenanceSessionUncheckedUpdateWithoutAgentInput>
  }

  export type MaintenanceSessionUpdateManyWithWhereWithoutAgentInput = {
    where: MaintenanceSessionScalarWhereInput
    data: XOR<MaintenanceSessionUpdateManyMutationInput, MaintenanceSessionUncheckedUpdateManyWithoutAgentInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutAgentInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutAgentInput, TicketUncheckedUpdateWithoutAgentInput>
    create: XOR<TicketCreateWithoutAgentInput, TicketUncheckedCreateWithoutAgentInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutAgentInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutAgentInput, TicketUncheckedUpdateWithoutAgentInput>
  }

  export type TicketUpdateManyWithWhereWithoutAgentInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutAgentInput>
  }

  export type TaskAssignmentUpsertWithWhereUniqueWithoutAgentInput = {
    where: TaskAssignmentWhereUniqueInput
    update: XOR<TaskAssignmentUpdateWithoutAgentInput, TaskAssignmentUncheckedUpdateWithoutAgentInput>
    create: XOR<TaskAssignmentCreateWithoutAgentInput, TaskAssignmentUncheckedCreateWithoutAgentInput>
  }

  export type TaskAssignmentUpdateWithWhereUniqueWithoutAgentInput = {
    where: TaskAssignmentWhereUniqueInput
    data: XOR<TaskAssignmentUpdateWithoutAgentInput, TaskAssignmentUncheckedUpdateWithoutAgentInput>
  }

  export type TaskAssignmentUpdateManyWithWhereWithoutAgentInput = {
    where: TaskAssignmentScalarWhereInput
    data: XOR<TaskAssignmentUpdateManyMutationInput, TaskAssignmentUncheckedUpdateManyWithoutAgentInput>
  }

  export type TaskAssignmentScalarWhereInput = {
    AND?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
    OR?: TaskAssignmentScalarWhereInput[]
    NOT?: TaskAssignmentScalarWhereInput | TaskAssignmentScalarWhereInput[]
    id?: StringFilter<"TaskAssignment"> | string
    title?: StringFilter<"TaskAssignment"> | string
    description?: StringNullableFilter<"TaskAssignment"> | string | null
    type?: StringFilter<"TaskAssignment"> | string
    priority?: StringFilter<"TaskAssignment"> | string
    status?: StringFilter<"TaskAssignment"> | string
    assignedAt?: DateTimeFilter<"TaskAssignment"> | Date | string
    dueDate?: DateTimeNullableFilter<"TaskAssignment"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"TaskAssignment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TaskAssignment"> | Date | string | null
    agentId?: StringFilter<"TaskAssignment"> | string
    propertyId?: StringNullableFilter<"TaskAssignment"> | string | null
    reservationId?: StringNullableFilter<"TaskAssignment"> | string | null
    cleaningSessionId?: StringNullableFilter<"TaskAssignment"> | string | null
    maintenanceSessionId?: StringNullableFilter<"TaskAssignment"> | string | null
    ticketId?: StringNullableFilter<"TaskAssignment"> | string | null
    estimatedDuration?: IntNullableFilter<"TaskAssignment"> | number | null
    actualDuration?: IntNullableFilter<"TaskAssignment"> | number | null
    notes?: StringNullableFilter<"TaskAssignment"> | string | null
    createdAt?: DateTimeFilter<"TaskAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"TaskAssignment"> | Date | string
  }

  export type AgentProfileCreateWithoutSpecialtiesInput = {
    id?: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentProfileInput
    manager: PoleManagerProfileCreateNestedOneWithoutManagedAgentsInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutAgentInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutAgentInput
    tickets?: TicketCreateNestedManyWithoutAgentInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutAgentInput
  }

  export type AgentProfileUncheckedCreateWithoutSpecialtiesInput = {
    id?: string
    userId: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutAgentInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAgentInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentProfileCreateOrConnectWithoutSpecialtiesInput = {
    where: AgentProfileWhereUniqueInput
    create: XOR<AgentProfileCreateWithoutSpecialtiesInput, AgentProfileUncheckedCreateWithoutSpecialtiesInput>
  }

  export type AgentProfileUpsertWithoutSpecialtiesInput = {
    update: XOR<AgentProfileUpdateWithoutSpecialtiesInput, AgentProfileUncheckedUpdateWithoutSpecialtiesInput>
    create: XOR<AgentProfileCreateWithoutSpecialtiesInput, AgentProfileUncheckedCreateWithoutSpecialtiesInput>
    where?: AgentProfileWhereInput
  }

  export type AgentProfileUpdateToOneWithWhereWithoutSpecialtiesInput = {
    where?: AgentProfileWhereInput
    data: XOR<AgentProfileUpdateWithoutSpecialtiesInput, AgentProfileUncheckedUpdateWithoutSpecialtiesInput>
  }

  export type AgentProfileUpdateWithoutSpecialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentProfileNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutManagedAgentsNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutAgentNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutAgentNestedInput
    tickets?: TicketUpdateManyWithoutAgentNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutAgentNestedInput
  }

  export type AgentProfileUncheckedUpdateWithoutSpecialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAgentNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type PropertyFeatureCreateWithoutPropertyInput = {
    id?: string
    name: string
    icon?: string | null
    category?: string | null
  }

  export type PropertyFeatureUncheckedCreateWithoutPropertyInput = {
    id?: string
    name: string
    icon?: string | null
    category?: string | null
  }

  export type PropertyFeatureCreateOrConnectWithoutPropertyInput = {
    where: PropertyFeatureWhereUniqueInput
    create: XOR<PropertyFeatureCreateWithoutPropertyInput, PropertyFeatureUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyFeatureCreateManyPropertyInputEnvelope = {
    data: PropertyFeatureCreateManyPropertyInput | PropertyFeatureCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyPhotoCreateWithoutPropertyInput = {
    id?: string
    url: string
    caption?: string | null
    isMain?: boolean
    order?: number
    type?: string | null
    createdAt?: Date | string
  }

  export type PropertyPhotoUncheckedCreateWithoutPropertyInput = {
    id?: string
    url: string
    caption?: string | null
    isMain?: boolean
    order?: number
    type?: string | null
    createdAt?: Date | string
  }

  export type PropertyPhotoCreateOrConnectWithoutPropertyInput = {
    where: PropertyPhotoWhereUniqueInput
    create: XOR<PropertyPhotoCreateWithoutPropertyInput, PropertyPhotoUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyPhotoCreateManyPropertyInputEnvelope = {
    data: PropertyPhotoCreateManyPropertyInput | PropertyPhotoCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyOwnerProfileCreateWithoutPropertiesInput = {
    id?: string
    company?: string | null
    taxNumber?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    postal?: string | null
    preferredContactMethod?: string | null
    receiveNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertyOwnerProfileInput
    contracts?: PropertyContractCreateNestedManyWithoutPropertyOwnerInput
  }

  export type PropertyOwnerProfileUncheckedCreateWithoutPropertiesInput = {
    id?: string
    userId: string
    company?: string | null
    taxNumber?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    postal?: string | null
    preferredContactMethod?: string | null
    receiveNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: PropertyContractUncheckedCreateNestedManyWithoutPropertyOwnerInput
  }

  export type PropertyOwnerProfileCreateOrConnectWithoutPropertiesInput = {
    where: PropertyOwnerProfileWhereUniqueInput
    create: XOR<PropertyOwnerProfileCreateWithoutPropertiesInput, PropertyOwnerProfileUncheckedCreateWithoutPropertiesInput>
  }

  export type PoleManagerProfileCreateWithoutPropertiesInput = {
    id?: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPoleManagerProfileInput
    superAdmin: SuperAdminProfileCreateNestedOneWithoutPoleManagersInput
    reservations?: ReservationCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutManagerInput
    tickets?: TicketCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileUncheckedCreateWithoutPropertiesInput = {
    id?: string
    userId: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdminId: string
    reservations?: ReservationUncheckedCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutManagerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderUncheckedCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileUncheckedCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileCreateOrConnectWithoutPropertiesInput = {
    where: PoleManagerProfileWhereUniqueInput
    create: XOR<PoleManagerProfileCreateWithoutPropertiesInput, PoleManagerProfileUncheckedCreateWithoutPropertiesInput>
  }

  export type ReservationCreateWithoutPropertyInput = {
    id?: string
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    guestCount?: number
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    totalPrice: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    confirmationCode?: string | null
    bookingSource?: string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager: PoleManagerProfileCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutPropertyInput = {
    id?: string
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    guestCount?: number
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    totalPrice: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    confirmationCode?: string | null
    bookingSource?: string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
  }

  export type ReservationCreateOrConnectWithoutPropertyInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutPropertyInput, ReservationUncheckedCreateWithoutPropertyInput>
  }

  export type ReservationCreateManyPropertyInputEnvelope = {
    data: ReservationCreateManyPropertyInput | ReservationCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type CleaningSessionCreateWithoutPropertyInput = {
    id?: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    cleaningType: string
    status?: $Enums.SessionStatus
    notes?: string | null
    agentNotes?: string | null
    ownerRating?: number | null
    managerRating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentProfileCreateNestedOneWithoutCleaningSessionsInput
    checklist?: CleaningChecklistCreateNestedManyWithoutCleaningSessionInput
    photos?: CleaningPhotoCreateNestedManyWithoutCleaningSessionInput
    manager: PoleManagerProfileCreateNestedOneWithoutCleaningSessionsInput
  }

  export type CleaningSessionUncheckedCreateWithoutPropertyInput = {
    id?: string
    agentId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    cleaningType: string
    status?: $Enums.SessionStatus
    notes?: string | null
    agentNotes?: string | null
    ownerRating?: number | null
    managerRating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    checklist?: CleaningChecklistUncheckedCreateNestedManyWithoutCleaningSessionInput
    photos?: CleaningPhotoUncheckedCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionCreateOrConnectWithoutPropertyInput = {
    where: CleaningSessionWhereUniqueInput
    create: XOR<CleaningSessionCreateWithoutPropertyInput, CleaningSessionUncheckedCreateWithoutPropertyInput>
  }

  export type CleaningSessionCreateManyPropertyInputEnvelope = {
    data: CleaningSessionCreateManyPropertyInput | CleaningSessionCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceSessionCreateWithoutPropertyInput = {
    id?: string
    sessionNumber: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutMaintenanceSessionInput
    agent: AgentProfileCreateNestedOneWithoutMaintenanceSessionsInput
    materials?: MaintenanceMaterialCreateNestedManyWithoutMaintenanceSessionInput
    photos?: MaintenancePhotoCreateNestedManyWithoutMaintenanceSessionInput
    manager: PoleManagerProfileCreateNestedOneWithoutMaintenanceSessionsInput
  }

  export type MaintenanceSessionUncheckedCreateWithoutPropertyInput = {
    id?: string
    sessionNumber: string
    ticketId: string
    agentId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    materials?: MaintenanceMaterialUncheckedCreateNestedManyWithoutMaintenanceSessionInput
    photos?: MaintenancePhotoUncheckedCreateNestedManyWithoutMaintenanceSessionInput
  }

  export type MaintenanceSessionCreateOrConnectWithoutPropertyInput = {
    where: MaintenanceSessionWhereUniqueInput
    create: XOR<MaintenanceSessionCreateWithoutPropertyInput, MaintenanceSessionUncheckedCreateWithoutPropertyInput>
  }

  export type MaintenanceSessionCreateManyPropertyInputEnvelope = {
    data: MaintenanceSessionCreateManyPropertyInput | MaintenanceSessionCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutPropertyInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    reportedBy: string
    reportedAt?: Date | string
    assignedAt?: Date | string | null
    category?: string | null
    issueType?: string | null
    roomLocation?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    estimatedCost?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentProfileCreateNestedOneWithoutTicketsInput
    photos?: TicketPhotoCreateNestedManyWithoutTicketInput
    manager: PoleManagerProfileCreateNestedOneWithoutTicketsInput
    maintenanceSession?: MaintenanceSessionCreateNestedOneWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutPropertyInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    reportedBy: string
    reportedAt?: Date | string
    agentId?: string | null
    assignedAt?: Date | string | null
    category?: string | null
    issueType?: string | null
    roomLocation?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    estimatedCost?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    photos?: TicketPhotoUncheckedCreateNestedManyWithoutTicketInput
    maintenanceSession?: MaintenanceSessionUncheckedCreateNestedOneWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutPropertyInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutPropertyInput, TicketUncheckedCreateWithoutPropertyInput>
  }

  export type TicketCreateManyPropertyInputEnvelope = {
    data: TicketCreateManyPropertyInput | TicketCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyReviewCreateWithoutPropertyInput = {
    id?: string
    rating: number
    comment?: string | null
    guestName: string
    guestEmail?: string | null
    createdAt?: Date | string
  }

  export type PropertyReviewUncheckedCreateWithoutPropertyInput = {
    id?: string
    rating: number
    comment?: string | null
    guestName: string
    guestEmail?: string | null
    createdAt?: Date | string
  }

  export type PropertyReviewCreateOrConnectWithoutPropertyInput = {
    where: PropertyReviewWhereUniqueInput
    create: XOR<PropertyReviewCreateWithoutPropertyInput, PropertyReviewUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyReviewCreateManyPropertyInputEnvelope = {
    data: PropertyReviewCreateManyPropertyInput | PropertyReviewCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyContractCreateWithoutPropertyInput = {
    id?: string
    contractNumber: string
    type: string
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    monthlyFee?: number | null
    commissionRate?: number | null
    documentUrl?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyOwner: PropertyOwnerProfileCreateNestedOneWithoutContractsInput
  }

  export type PropertyContractUncheckedCreateWithoutPropertyInput = {
    id?: string
    contractNumber: string
    type: string
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    propertyOwnerId: string
    monthlyFee?: number | null
    commissionRate?: number | null
    documentUrl?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyContractCreateOrConnectWithoutPropertyInput = {
    where: PropertyContractWhereUniqueInput
    create: XOR<PropertyContractCreateWithoutPropertyInput, PropertyContractUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyContractCreateManyPropertyInputEnvelope = {
    data: PropertyContractCreateManyPropertyInput | PropertyContractCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyFeatureUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyFeatureWhereUniqueInput
    update: XOR<PropertyFeatureUpdateWithoutPropertyInput, PropertyFeatureUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyFeatureCreateWithoutPropertyInput, PropertyFeatureUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyFeatureUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyFeatureWhereUniqueInput
    data: XOR<PropertyFeatureUpdateWithoutPropertyInput, PropertyFeatureUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyFeatureUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyFeatureScalarWhereInput
    data: XOR<PropertyFeatureUpdateManyMutationInput, PropertyFeatureUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyFeatureScalarWhereInput = {
    AND?: PropertyFeatureScalarWhereInput | PropertyFeatureScalarWhereInput[]
    OR?: PropertyFeatureScalarWhereInput[]
    NOT?: PropertyFeatureScalarWhereInput | PropertyFeatureScalarWhereInput[]
    id?: StringFilter<"PropertyFeature"> | string
    name?: StringFilter<"PropertyFeature"> | string
    icon?: StringNullableFilter<"PropertyFeature"> | string | null
    category?: StringNullableFilter<"PropertyFeature"> | string | null
    propertyId?: StringFilter<"PropertyFeature"> | string
  }

  export type PropertyPhotoUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyPhotoWhereUniqueInput
    update: XOR<PropertyPhotoUpdateWithoutPropertyInput, PropertyPhotoUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyPhotoCreateWithoutPropertyInput, PropertyPhotoUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyPhotoUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyPhotoWhereUniqueInput
    data: XOR<PropertyPhotoUpdateWithoutPropertyInput, PropertyPhotoUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyPhotoUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyPhotoScalarWhereInput
    data: XOR<PropertyPhotoUpdateManyMutationInput, PropertyPhotoUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyPhotoScalarWhereInput = {
    AND?: PropertyPhotoScalarWhereInput | PropertyPhotoScalarWhereInput[]
    OR?: PropertyPhotoScalarWhereInput[]
    NOT?: PropertyPhotoScalarWhereInput | PropertyPhotoScalarWhereInput[]
    id?: StringFilter<"PropertyPhoto"> | string
    url?: StringFilter<"PropertyPhoto"> | string
    caption?: StringNullableFilter<"PropertyPhoto"> | string | null
    isMain?: BoolFilter<"PropertyPhoto"> | boolean
    order?: IntFilter<"PropertyPhoto"> | number
    type?: StringNullableFilter<"PropertyPhoto"> | string | null
    propertyId?: StringFilter<"PropertyPhoto"> | string
    createdAt?: DateTimeFilter<"PropertyPhoto"> | Date | string
  }

  export type PropertyOwnerProfileUpsertWithoutPropertiesInput = {
    update: XOR<PropertyOwnerProfileUpdateWithoutPropertiesInput, PropertyOwnerProfileUncheckedUpdateWithoutPropertiesInput>
    create: XOR<PropertyOwnerProfileCreateWithoutPropertiesInput, PropertyOwnerProfileUncheckedCreateWithoutPropertiesInput>
    where?: PropertyOwnerProfileWhereInput
  }

  export type PropertyOwnerProfileUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: PropertyOwnerProfileWhereInput
    data: XOR<PropertyOwnerProfileUpdateWithoutPropertiesInput, PropertyOwnerProfileUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyOwnerProfileUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiveNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertyOwnerProfileNestedInput
    contracts?: PropertyContractUpdateManyWithoutPropertyOwnerNestedInput
  }

  export type PropertyOwnerProfileUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiveNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: PropertyContractUncheckedUpdateManyWithoutPropertyOwnerNestedInput
  }

  export type PoleManagerProfileUpsertWithoutPropertiesInput = {
    update: XOR<PoleManagerProfileUpdateWithoutPropertiesInput, PoleManagerProfileUncheckedUpdateWithoutPropertiesInput>
    create: XOR<PoleManagerProfileCreateWithoutPropertiesInput, PoleManagerProfileUncheckedCreateWithoutPropertiesInput>
    where?: PoleManagerProfileWhereInput
  }

  export type PoleManagerProfileUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: PoleManagerProfileWhereInput
    data: XOR<PoleManagerProfileUpdateWithoutPropertiesInput, PoleManagerProfileUncheckedUpdateWithoutPropertiesInput>
  }

  export type PoleManagerProfileUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPoleManagerProfileNestedInput
    superAdmin?: SuperAdminProfileUpdateOneRequiredWithoutPoleManagersNestedInput
    reservations?: ReservationUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutManagerNestedInput
    tickets?: TicketUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUpdateManyWithoutManagerNestedInput
  }

  export type PoleManagerProfileUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdminId?: StringFieldUpdateOperationsInput | string
    reservations?: ReservationUncheckedUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutManagerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUncheckedUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ReservationUpsertWithWhereUniqueWithoutPropertyInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutPropertyInput, ReservationUncheckedUpdateWithoutPropertyInput>
    create: XOR<ReservationCreateWithoutPropertyInput, ReservationUncheckedCreateWithoutPropertyInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutPropertyInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutPropertyInput, ReservationUncheckedUpdateWithoutPropertyInput>
  }

  export type ReservationUpdateManyWithWhereWithoutPropertyInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutPropertyInput>
  }

  export type CleaningSessionUpsertWithWhereUniqueWithoutPropertyInput = {
    where: CleaningSessionWhereUniqueInput
    update: XOR<CleaningSessionUpdateWithoutPropertyInput, CleaningSessionUncheckedUpdateWithoutPropertyInput>
    create: XOR<CleaningSessionCreateWithoutPropertyInput, CleaningSessionUncheckedCreateWithoutPropertyInput>
  }

  export type CleaningSessionUpdateWithWhereUniqueWithoutPropertyInput = {
    where: CleaningSessionWhereUniqueInput
    data: XOR<CleaningSessionUpdateWithoutPropertyInput, CleaningSessionUncheckedUpdateWithoutPropertyInput>
  }

  export type CleaningSessionUpdateManyWithWhereWithoutPropertyInput = {
    where: CleaningSessionScalarWhereInput
    data: XOR<CleaningSessionUpdateManyMutationInput, CleaningSessionUncheckedUpdateManyWithoutPropertyInput>
  }

  export type MaintenanceSessionUpsertWithWhereUniqueWithoutPropertyInput = {
    where: MaintenanceSessionWhereUniqueInput
    update: XOR<MaintenanceSessionUpdateWithoutPropertyInput, MaintenanceSessionUncheckedUpdateWithoutPropertyInput>
    create: XOR<MaintenanceSessionCreateWithoutPropertyInput, MaintenanceSessionUncheckedCreateWithoutPropertyInput>
  }

  export type MaintenanceSessionUpdateWithWhereUniqueWithoutPropertyInput = {
    where: MaintenanceSessionWhereUniqueInput
    data: XOR<MaintenanceSessionUpdateWithoutPropertyInput, MaintenanceSessionUncheckedUpdateWithoutPropertyInput>
  }

  export type MaintenanceSessionUpdateManyWithWhereWithoutPropertyInput = {
    where: MaintenanceSessionScalarWhereInput
    data: XOR<MaintenanceSessionUpdateManyMutationInput, MaintenanceSessionUncheckedUpdateManyWithoutPropertyInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutPropertyInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutPropertyInput, TicketUncheckedUpdateWithoutPropertyInput>
    create: XOR<TicketCreateWithoutPropertyInput, TicketUncheckedCreateWithoutPropertyInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutPropertyInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutPropertyInput, TicketUncheckedUpdateWithoutPropertyInput>
  }

  export type TicketUpdateManyWithWhereWithoutPropertyInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyReviewUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyReviewWhereUniqueInput
    update: XOR<PropertyReviewUpdateWithoutPropertyInput, PropertyReviewUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyReviewCreateWithoutPropertyInput, PropertyReviewUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyReviewUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyReviewWhereUniqueInput
    data: XOR<PropertyReviewUpdateWithoutPropertyInput, PropertyReviewUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyReviewUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyReviewScalarWhereInput
    data: XOR<PropertyReviewUpdateManyMutationInput, PropertyReviewUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyReviewScalarWhereInput = {
    AND?: PropertyReviewScalarWhereInput | PropertyReviewScalarWhereInput[]
    OR?: PropertyReviewScalarWhereInput[]
    NOT?: PropertyReviewScalarWhereInput | PropertyReviewScalarWhereInput[]
    id?: StringFilter<"PropertyReview"> | string
    rating?: FloatFilter<"PropertyReview"> | number
    comment?: StringNullableFilter<"PropertyReview"> | string | null
    guestName?: StringFilter<"PropertyReview"> | string
    guestEmail?: StringNullableFilter<"PropertyReview"> | string | null
    propertyId?: StringFilter<"PropertyReview"> | string
    createdAt?: DateTimeFilter<"PropertyReview"> | Date | string
  }

  export type PropertyContractUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyContractWhereUniqueInput
    update: XOR<PropertyContractUpdateWithoutPropertyInput, PropertyContractUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyContractCreateWithoutPropertyInput, PropertyContractUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyContractUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyContractWhereUniqueInput
    data: XOR<PropertyContractUpdateWithoutPropertyInput, PropertyContractUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyContractUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyContractScalarWhereInput
    data: XOR<PropertyContractUpdateManyMutationInput, PropertyContractUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyCreateWithoutFeaturesInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PropertyPhotoCreateNestedManyWithoutPropertyInput
    owner: PropertyOwnerProfileCreateNestedOneWithoutPropertiesInput
    manager?: PoleManagerProfileCreateNestedOneWithoutPropertiesInput
    reservations?: ReservationCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutPropertyInput
    tickets?: TicketCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutFeaturesInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    managerId?: string | null
    photos?: PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewUncheckedCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutFeaturesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutFeaturesInput, PropertyUncheckedCreateWithoutFeaturesInput>
  }

  export type PropertyUpsertWithoutFeaturesInput = {
    update: XOR<PropertyUpdateWithoutFeaturesInput, PropertyUncheckedUpdateWithoutFeaturesInput>
    create: XOR<PropertyCreateWithoutFeaturesInput, PropertyUncheckedCreateWithoutFeaturesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutFeaturesInput, PropertyUncheckedUpdateWithoutFeaturesInput>
  }

  export type PropertyUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PropertyPhotoUpdateManyWithoutPropertyNestedInput
    owner?: PropertyOwnerProfileUpdateOneRequiredWithoutPropertiesNestedInput
    manager?: PoleManagerProfileUpdateOneWithoutPropertiesNestedInput
    reservations?: ReservationUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUncheckedUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutPhotosInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    owner: PropertyOwnerProfileCreateNestedOneWithoutPropertiesInput
    manager?: PoleManagerProfileCreateNestedOneWithoutPropertiesInput
    reservations?: ReservationCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutPropertyInput
    tickets?: TicketCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPhotosInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    managerId?: string | null
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewUncheckedCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPhotosInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPhotosInput, PropertyUncheckedCreateWithoutPhotosInput>
  }

  export type PropertyUpsertWithoutPhotosInput = {
    update: XOR<PropertyUpdateWithoutPhotosInput, PropertyUncheckedUpdateWithoutPhotosInput>
    create: XOR<PropertyCreateWithoutPhotosInput, PropertyUncheckedCreateWithoutPhotosInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPhotosInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPhotosInput, PropertyUncheckedUpdateWithoutPhotosInput>
  }

  export type PropertyUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    owner?: PropertyOwnerProfileUpdateOneRequiredWithoutPropertiesNestedInput
    manager?: PoleManagerProfileUpdateOneWithoutPropertiesNestedInput
    reservations?: ReservationUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUncheckedUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutReviewsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoCreateNestedManyWithoutPropertyInput
    owner: PropertyOwnerProfileCreateNestedOneWithoutPropertiesInput
    manager?: PoleManagerProfileCreateNestedOneWithoutPropertiesInput
    reservations?: ReservationCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutPropertyInput
    tickets?: TicketCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    managerId?: string | null
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutReviewsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutReviewsInput, PropertyUncheckedCreateWithoutReviewsInput>
  }

  export type PropertyUpsertWithoutReviewsInput = {
    update: XOR<PropertyUpdateWithoutReviewsInput, PropertyUncheckedUpdateWithoutReviewsInput>
    create: XOR<PropertyCreateWithoutReviewsInput, PropertyUncheckedCreateWithoutReviewsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutReviewsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutReviewsInput, PropertyUncheckedUpdateWithoutReviewsInput>
  }

  export type PropertyUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUpdateManyWithoutPropertyNestedInput
    owner?: PropertyOwnerProfileUpdateOneRequiredWithoutPropertiesNestedInput
    manager?: PoleManagerProfileUpdateOneWithoutPropertiesNestedInput
    reservations?: ReservationUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutReservationsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoCreateNestedManyWithoutPropertyInput
    owner: PropertyOwnerProfileCreateNestedOneWithoutPropertiesInput
    manager?: PoleManagerProfileCreateNestedOneWithoutPropertiesInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutPropertyInput
    tickets?: TicketCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutReservationsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    managerId?: string | null
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewUncheckedCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutReservationsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutReservationsInput, PropertyUncheckedCreateWithoutReservationsInput>
  }

  export type PoleManagerProfileCreateWithoutReservationsInput = {
    id?: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPoleManagerProfileInput
    superAdmin: SuperAdminProfileCreateNestedOneWithoutPoleManagersInput
    properties?: PropertyCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutManagerInput
    tickets?: TicketCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileUncheckedCreateWithoutReservationsInput = {
    id?: string
    userId: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdminId: string
    properties?: PropertyUncheckedCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutManagerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderUncheckedCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileUncheckedCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileCreateOrConnectWithoutReservationsInput = {
    where: PoleManagerProfileWhereUniqueInput
    create: XOR<PoleManagerProfileCreateWithoutReservationsInput, PoleManagerProfileUncheckedCreateWithoutReservationsInput>
  }

  export type PropertyUpsertWithoutReservationsInput = {
    update: XOR<PropertyUpdateWithoutReservationsInput, PropertyUncheckedUpdateWithoutReservationsInput>
    create: XOR<PropertyCreateWithoutReservationsInput, PropertyUncheckedCreateWithoutReservationsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutReservationsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutReservationsInput, PropertyUncheckedUpdateWithoutReservationsInput>
  }

  export type PropertyUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUpdateManyWithoutPropertyNestedInput
    owner?: PropertyOwnerProfileUpdateOneRequiredWithoutPropertiesNestedInput
    manager?: PoleManagerProfileUpdateOneWithoutPropertiesNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUncheckedUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PoleManagerProfileUpsertWithoutReservationsInput = {
    update: XOR<PoleManagerProfileUpdateWithoutReservationsInput, PoleManagerProfileUncheckedUpdateWithoutReservationsInput>
    create: XOR<PoleManagerProfileCreateWithoutReservationsInput, PoleManagerProfileUncheckedCreateWithoutReservationsInput>
    where?: PoleManagerProfileWhereInput
  }

  export type PoleManagerProfileUpdateToOneWithWhereWithoutReservationsInput = {
    where?: PoleManagerProfileWhereInput
    data: XOR<PoleManagerProfileUpdateWithoutReservationsInput, PoleManagerProfileUncheckedUpdateWithoutReservationsInput>
  }

  export type PoleManagerProfileUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPoleManagerProfileNestedInput
    superAdmin?: SuperAdminProfileUpdateOneRequiredWithoutPoleManagersNestedInput
    properties?: PropertyUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutManagerNestedInput
    tickets?: TicketUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUpdateManyWithoutManagerNestedInput
  }

  export type PoleManagerProfileUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdminId?: StringFieldUpdateOperationsInput | string
    properties?: PropertyUncheckedUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutManagerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUncheckedUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type PropertyCreateWithoutCleaningSessionsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoCreateNestedManyWithoutPropertyInput
    owner: PropertyOwnerProfileCreateNestedOneWithoutPropertiesInput
    manager?: PoleManagerProfileCreateNestedOneWithoutPropertiesInput
    reservations?: ReservationCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutPropertyInput
    tickets?: TicketCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutCleaningSessionsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    managerId?: string | null
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewUncheckedCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutCleaningSessionsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutCleaningSessionsInput, PropertyUncheckedCreateWithoutCleaningSessionsInput>
  }

  export type AgentProfileCreateWithoutCleaningSessionsInput = {
    id?: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentProfileInput
    specialties?: AgentSpecialtyCreateNestedManyWithoutAgentInput
    manager: PoleManagerProfileCreateNestedOneWithoutManagedAgentsInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutAgentInput
    tickets?: TicketCreateNestedManyWithoutAgentInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutAgentInput
  }

  export type AgentProfileUncheckedCreateWithoutCleaningSessionsInput = {
    id?: string
    userId: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    specialties?: AgentSpecialtyUncheckedCreateNestedManyWithoutAgentInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAgentInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentProfileCreateOrConnectWithoutCleaningSessionsInput = {
    where: AgentProfileWhereUniqueInput
    create: XOR<AgentProfileCreateWithoutCleaningSessionsInput, AgentProfileUncheckedCreateWithoutCleaningSessionsInput>
  }

  export type CleaningChecklistCreateWithoutCleaningSessionInput = {
    id?: string
    item: string
    completed?: boolean
    notes?: string | null
    order?: number
  }

  export type CleaningChecklistUncheckedCreateWithoutCleaningSessionInput = {
    id?: string
    item: string
    completed?: boolean
    notes?: string | null
    order?: number
  }

  export type CleaningChecklistCreateOrConnectWithoutCleaningSessionInput = {
    where: CleaningChecklistWhereUniqueInput
    create: XOR<CleaningChecklistCreateWithoutCleaningSessionInput, CleaningChecklistUncheckedCreateWithoutCleaningSessionInput>
  }

  export type CleaningChecklistCreateManyCleaningSessionInputEnvelope = {
    data: CleaningChecklistCreateManyCleaningSessionInput | CleaningChecklistCreateManyCleaningSessionInput[]
    skipDuplicates?: boolean
  }

  export type CleaningPhotoCreateWithoutCleaningSessionInput = {
    id?: string
    url: string
    type?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type CleaningPhotoUncheckedCreateWithoutCleaningSessionInput = {
    id?: string
    url: string
    type?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type CleaningPhotoCreateOrConnectWithoutCleaningSessionInput = {
    where: CleaningPhotoWhereUniqueInput
    create: XOR<CleaningPhotoCreateWithoutCleaningSessionInput, CleaningPhotoUncheckedCreateWithoutCleaningSessionInput>
  }

  export type CleaningPhotoCreateManyCleaningSessionInputEnvelope = {
    data: CleaningPhotoCreateManyCleaningSessionInput | CleaningPhotoCreateManyCleaningSessionInput[]
    skipDuplicates?: boolean
  }

  export type PoleManagerProfileCreateWithoutCleaningSessionsInput = {
    id?: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPoleManagerProfileInput
    superAdmin: SuperAdminProfileCreateNestedOneWithoutPoleManagersInput
    properties?: PropertyCreateNestedManyWithoutManagerInput
    reservations?: ReservationCreateNestedManyWithoutManagerInput
    tickets?: TicketCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileUncheckedCreateWithoutCleaningSessionsInput = {
    id?: string
    userId: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdminId: string
    properties?: PropertyUncheckedCreateNestedManyWithoutManagerInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutManagerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderUncheckedCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileUncheckedCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileCreateOrConnectWithoutCleaningSessionsInput = {
    where: PoleManagerProfileWhereUniqueInput
    create: XOR<PoleManagerProfileCreateWithoutCleaningSessionsInput, PoleManagerProfileUncheckedCreateWithoutCleaningSessionsInput>
  }

  export type PropertyUpsertWithoutCleaningSessionsInput = {
    update: XOR<PropertyUpdateWithoutCleaningSessionsInput, PropertyUncheckedUpdateWithoutCleaningSessionsInput>
    create: XOR<PropertyCreateWithoutCleaningSessionsInput, PropertyUncheckedCreateWithoutCleaningSessionsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutCleaningSessionsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutCleaningSessionsInput, PropertyUncheckedUpdateWithoutCleaningSessionsInput>
  }

  export type PropertyUpdateWithoutCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUpdateManyWithoutPropertyNestedInput
    owner?: PropertyOwnerProfileUpdateOneRequiredWithoutPropertiesNestedInput
    manager?: PoleManagerProfileUpdateOneWithoutPropertiesNestedInput
    reservations?: ReservationUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUncheckedUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type AgentProfileUpsertWithoutCleaningSessionsInput = {
    update: XOR<AgentProfileUpdateWithoutCleaningSessionsInput, AgentProfileUncheckedUpdateWithoutCleaningSessionsInput>
    create: XOR<AgentProfileCreateWithoutCleaningSessionsInput, AgentProfileUncheckedCreateWithoutCleaningSessionsInput>
    where?: AgentProfileWhereInput
  }

  export type AgentProfileUpdateToOneWithWhereWithoutCleaningSessionsInput = {
    where?: AgentProfileWhereInput
    data: XOR<AgentProfileUpdateWithoutCleaningSessionsInput, AgentProfileUncheckedUpdateWithoutCleaningSessionsInput>
  }

  export type AgentProfileUpdateWithoutCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentProfileNestedInput
    specialties?: AgentSpecialtyUpdateManyWithoutAgentNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutManagedAgentsNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutAgentNestedInput
    tickets?: TicketUpdateManyWithoutAgentNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutAgentNestedInput
  }

  export type AgentProfileUncheckedUpdateWithoutCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    specialties?: AgentSpecialtyUncheckedUpdateManyWithoutAgentNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAgentNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type CleaningChecklistUpsertWithWhereUniqueWithoutCleaningSessionInput = {
    where: CleaningChecklistWhereUniqueInput
    update: XOR<CleaningChecklistUpdateWithoutCleaningSessionInput, CleaningChecklistUncheckedUpdateWithoutCleaningSessionInput>
    create: XOR<CleaningChecklistCreateWithoutCleaningSessionInput, CleaningChecklistUncheckedCreateWithoutCleaningSessionInput>
  }

  export type CleaningChecklistUpdateWithWhereUniqueWithoutCleaningSessionInput = {
    where: CleaningChecklistWhereUniqueInput
    data: XOR<CleaningChecklistUpdateWithoutCleaningSessionInput, CleaningChecklistUncheckedUpdateWithoutCleaningSessionInput>
  }

  export type CleaningChecklistUpdateManyWithWhereWithoutCleaningSessionInput = {
    where: CleaningChecklistScalarWhereInput
    data: XOR<CleaningChecklistUpdateManyMutationInput, CleaningChecklistUncheckedUpdateManyWithoutCleaningSessionInput>
  }

  export type CleaningChecklistScalarWhereInput = {
    AND?: CleaningChecklistScalarWhereInput | CleaningChecklistScalarWhereInput[]
    OR?: CleaningChecklistScalarWhereInput[]
    NOT?: CleaningChecklistScalarWhereInput | CleaningChecklistScalarWhereInput[]
    id?: StringFilter<"CleaningChecklist"> | string
    item?: StringFilter<"CleaningChecklist"> | string
    completed?: BoolFilter<"CleaningChecklist"> | boolean
    notes?: StringNullableFilter<"CleaningChecklist"> | string | null
    order?: IntFilter<"CleaningChecklist"> | number
    cleaningSessionId?: StringFilter<"CleaningChecklist"> | string
  }

  export type CleaningPhotoUpsertWithWhereUniqueWithoutCleaningSessionInput = {
    where: CleaningPhotoWhereUniqueInput
    update: XOR<CleaningPhotoUpdateWithoutCleaningSessionInput, CleaningPhotoUncheckedUpdateWithoutCleaningSessionInput>
    create: XOR<CleaningPhotoCreateWithoutCleaningSessionInput, CleaningPhotoUncheckedCreateWithoutCleaningSessionInput>
  }

  export type CleaningPhotoUpdateWithWhereUniqueWithoutCleaningSessionInput = {
    where: CleaningPhotoWhereUniqueInput
    data: XOR<CleaningPhotoUpdateWithoutCleaningSessionInput, CleaningPhotoUncheckedUpdateWithoutCleaningSessionInput>
  }

  export type CleaningPhotoUpdateManyWithWhereWithoutCleaningSessionInput = {
    where: CleaningPhotoScalarWhereInput
    data: XOR<CleaningPhotoUpdateManyMutationInput, CleaningPhotoUncheckedUpdateManyWithoutCleaningSessionInput>
  }

  export type CleaningPhotoScalarWhereInput = {
    AND?: CleaningPhotoScalarWhereInput | CleaningPhotoScalarWhereInput[]
    OR?: CleaningPhotoScalarWhereInput[]
    NOT?: CleaningPhotoScalarWhereInput | CleaningPhotoScalarWhereInput[]
    id?: StringFilter<"CleaningPhoto"> | string
    url?: StringFilter<"CleaningPhoto"> | string
    type?: StringNullableFilter<"CleaningPhoto"> | string | null
    caption?: StringNullableFilter<"CleaningPhoto"> | string | null
    cleaningSessionId?: StringFilter<"CleaningPhoto"> | string
    createdAt?: DateTimeFilter<"CleaningPhoto"> | Date | string
  }

  export type PoleManagerProfileUpsertWithoutCleaningSessionsInput = {
    update: XOR<PoleManagerProfileUpdateWithoutCleaningSessionsInput, PoleManagerProfileUncheckedUpdateWithoutCleaningSessionsInput>
    create: XOR<PoleManagerProfileCreateWithoutCleaningSessionsInput, PoleManagerProfileUncheckedCreateWithoutCleaningSessionsInput>
    where?: PoleManagerProfileWhereInput
  }

  export type PoleManagerProfileUpdateToOneWithWhereWithoutCleaningSessionsInput = {
    where?: PoleManagerProfileWhereInput
    data: XOR<PoleManagerProfileUpdateWithoutCleaningSessionsInput, PoleManagerProfileUncheckedUpdateWithoutCleaningSessionsInput>
  }

  export type PoleManagerProfileUpdateWithoutCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPoleManagerProfileNestedInput
    superAdmin?: SuperAdminProfileUpdateOneRequiredWithoutPoleManagersNestedInput
    properties?: PropertyUpdateManyWithoutManagerNestedInput
    reservations?: ReservationUpdateManyWithoutManagerNestedInput
    tickets?: TicketUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUpdateManyWithoutManagerNestedInput
  }

  export type PoleManagerProfileUncheckedUpdateWithoutCleaningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdminId?: StringFieldUpdateOperationsInput | string
    properties?: PropertyUncheckedUpdateManyWithoutManagerNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutManagerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUncheckedUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type CleaningSessionCreateWithoutChecklistInput = {
    id?: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    cleaningType: string
    status?: $Enums.SessionStatus
    notes?: string | null
    agentNotes?: string | null
    ownerRating?: number | null
    managerRating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutCleaningSessionsInput
    agent: AgentProfileCreateNestedOneWithoutCleaningSessionsInput
    photos?: CleaningPhotoCreateNestedManyWithoutCleaningSessionInput
    manager: PoleManagerProfileCreateNestedOneWithoutCleaningSessionsInput
  }

  export type CleaningSessionUncheckedCreateWithoutChecklistInput = {
    id?: string
    propertyId: string
    agentId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    cleaningType: string
    status?: $Enums.SessionStatus
    notes?: string | null
    agentNotes?: string | null
    ownerRating?: number | null
    managerRating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    photos?: CleaningPhotoUncheckedCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionCreateOrConnectWithoutChecklistInput = {
    where: CleaningSessionWhereUniqueInput
    create: XOR<CleaningSessionCreateWithoutChecklistInput, CleaningSessionUncheckedCreateWithoutChecklistInput>
  }

  export type CleaningSessionUpsertWithoutChecklistInput = {
    update: XOR<CleaningSessionUpdateWithoutChecklistInput, CleaningSessionUncheckedUpdateWithoutChecklistInput>
    create: XOR<CleaningSessionCreateWithoutChecklistInput, CleaningSessionUncheckedCreateWithoutChecklistInput>
    where?: CleaningSessionWhereInput
  }

  export type CleaningSessionUpdateToOneWithWhereWithoutChecklistInput = {
    where?: CleaningSessionWhereInput
    data: XOR<CleaningSessionUpdateWithoutChecklistInput, CleaningSessionUncheckedUpdateWithoutChecklistInput>
  }

  export type CleaningSessionUpdateWithoutChecklistInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cleaningType?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    managerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutCleaningSessionsNestedInput
    agent?: AgentProfileUpdateOneRequiredWithoutCleaningSessionsNestedInput
    photos?: CleaningPhotoUpdateManyWithoutCleaningSessionNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutCleaningSessionsNestedInput
  }

  export type CleaningSessionUncheckedUpdateWithoutChecklistInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cleaningType?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    managerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    photos?: CleaningPhotoUncheckedUpdateManyWithoutCleaningSessionNestedInput
  }

  export type CleaningSessionCreateWithoutPhotosInput = {
    id?: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    cleaningType: string
    status?: $Enums.SessionStatus
    notes?: string | null
    agentNotes?: string | null
    ownerRating?: number | null
    managerRating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutCleaningSessionsInput
    agent: AgentProfileCreateNestedOneWithoutCleaningSessionsInput
    checklist?: CleaningChecklistCreateNestedManyWithoutCleaningSessionInput
    manager: PoleManagerProfileCreateNestedOneWithoutCleaningSessionsInput
  }

  export type CleaningSessionUncheckedCreateWithoutPhotosInput = {
    id?: string
    propertyId: string
    agentId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    cleaningType: string
    status?: $Enums.SessionStatus
    notes?: string | null
    agentNotes?: string | null
    ownerRating?: number | null
    managerRating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    checklist?: CleaningChecklistUncheckedCreateNestedManyWithoutCleaningSessionInput
  }

  export type CleaningSessionCreateOrConnectWithoutPhotosInput = {
    where: CleaningSessionWhereUniqueInput
    create: XOR<CleaningSessionCreateWithoutPhotosInput, CleaningSessionUncheckedCreateWithoutPhotosInput>
  }

  export type CleaningSessionUpsertWithoutPhotosInput = {
    update: XOR<CleaningSessionUpdateWithoutPhotosInput, CleaningSessionUncheckedUpdateWithoutPhotosInput>
    create: XOR<CleaningSessionCreateWithoutPhotosInput, CleaningSessionUncheckedCreateWithoutPhotosInput>
    where?: CleaningSessionWhereInput
  }

  export type CleaningSessionUpdateToOneWithWhereWithoutPhotosInput = {
    where?: CleaningSessionWhereInput
    data: XOR<CleaningSessionUpdateWithoutPhotosInput, CleaningSessionUncheckedUpdateWithoutPhotosInput>
  }

  export type CleaningSessionUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cleaningType?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    managerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutCleaningSessionsNestedInput
    agent?: AgentProfileUpdateOneRequiredWithoutCleaningSessionsNestedInput
    checklist?: CleaningChecklistUpdateManyWithoutCleaningSessionNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutCleaningSessionsNestedInput
  }

  export type CleaningSessionUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cleaningType?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    managerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    checklist?: CleaningChecklistUncheckedUpdateManyWithoutCleaningSessionNestedInput
  }

  export type PropertyCreateWithoutTicketsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoCreateNestedManyWithoutPropertyInput
    owner: PropertyOwnerProfileCreateNestedOneWithoutPropertiesInput
    manager?: PoleManagerProfileCreateNestedOneWithoutPropertiesInput
    reservations?: ReservationCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutTicketsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    managerId?: string | null
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewUncheckedCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutTicketsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutTicketsInput, PropertyUncheckedCreateWithoutTicketsInput>
  }

  export type AgentProfileCreateWithoutTicketsInput = {
    id?: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentProfileInput
    specialties?: AgentSpecialtyCreateNestedManyWithoutAgentInput
    manager: PoleManagerProfileCreateNestedOneWithoutManagedAgentsInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutAgentInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutAgentInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutAgentInput
  }

  export type AgentProfileUncheckedCreateWithoutTicketsInput = {
    id?: string
    userId: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    specialties?: AgentSpecialtyUncheckedCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutAgentInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentProfileCreateOrConnectWithoutTicketsInput = {
    where: AgentProfileWhereUniqueInput
    create: XOR<AgentProfileCreateWithoutTicketsInput, AgentProfileUncheckedCreateWithoutTicketsInput>
  }

  export type TicketPhotoCreateWithoutTicketInput = {
    id?: string
    url: string
    caption?: string | null
    createdAt?: Date | string
  }

  export type TicketPhotoUncheckedCreateWithoutTicketInput = {
    id?: string
    url: string
    caption?: string | null
    createdAt?: Date | string
  }

  export type TicketPhotoCreateOrConnectWithoutTicketInput = {
    where: TicketPhotoWhereUniqueInput
    create: XOR<TicketPhotoCreateWithoutTicketInput, TicketPhotoUncheckedCreateWithoutTicketInput>
  }

  export type TicketPhotoCreateManyTicketInputEnvelope = {
    data: TicketPhotoCreateManyTicketInput | TicketPhotoCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type PoleManagerProfileCreateWithoutTicketsInput = {
    id?: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPoleManagerProfileInput
    superAdmin: SuperAdminProfileCreateNestedOneWithoutPoleManagersInput
    properties?: PropertyCreateNestedManyWithoutManagerInput
    reservations?: ReservationCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileUncheckedCreateWithoutTicketsInput = {
    id?: string
    userId: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdminId: string
    properties?: PropertyUncheckedCreateNestedManyWithoutManagerInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderUncheckedCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileUncheckedCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileCreateOrConnectWithoutTicketsInput = {
    where: PoleManagerProfileWhereUniqueInput
    create: XOR<PoleManagerProfileCreateWithoutTicketsInput, PoleManagerProfileUncheckedCreateWithoutTicketsInput>
  }

  export type MaintenanceSessionCreateWithoutTicketInput = {
    id?: string
    sessionNumber: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutMaintenanceSessionsInput
    agent: AgentProfileCreateNestedOneWithoutMaintenanceSessionsInput
    materials?: MaintenanceMaterialCreateNestedManyWithoutMaintenanceSessionInput
    photos?: MaintenancePhotoCreateNestedManyWithoutMaintenanceSessionInput
    manager: PoleManagerProfileCreateNestedOneWithoutMaintenanceSessionsInput
  }

  export type MaintenanceSessionUncheckedCreateWithoutTicketInput = {
    id?: string
    sessionNumber: string
    propertyId: string
    agentId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    materials?: MaintenanceMaterialUncheckedCreateNestedManyWithoutMaintenanceSessionInput
    photos?: MaintenancePhotoUncheckedCreateNestedManyWithoutMaintenanceSessionInput
  }

  export type MaintenanceSessionCreateOrConnectWithoutTicketInput = {
    where: MaintenanceSessionWhereUniqueInput
    create: XOR<MaintenanceSessionCreateWithoutTicketInput, MaintenanceSessionUncheckedCreateWithoutTicketInput>
  }

  export type PropertyUpsertWithoutTicketsInput = {
    update: XOR<PropertyUpdateWithoutTicketsInput, PropertyUncheckedUpdateWithoutTicketsInput>
    create: XOR<PropertyCreateWithoutTicketsInput, PropertyUncheckedCreateWithoutTicketsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutTicketsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutTicketsInput, PropertyUncheckedUpdateWithoutTicketsInput>
  }

  export type PropertyUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUpdateManyWithoutPropertyNestedInput
    owner?: PropertyOwnerProfileUpdateOneRequiredWithoutPropertiesNestedInput
    manager?: PoleManagerProfileUpdateOneWithoutPropertiesNestedInput
    reservations?: ReservationUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUncheckedUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type AgentProfileUpsertWithoutTicketsInput = {
    update: XOR<AgentProfileUpdateWithoutTicketsInput, AgentProfileUncheckedUpdateWithoutTicketsInput>
    create: XOR<AgentProfileCreateWithoutTicketsInput, AgentProfileUncheckedCreateWithoutTicketsInput>
    where?: AgentProfileWhereInput
  }

  export type AgentProfileUpdateToOneWithWhereWithoutTicketsInput = {
    where?: AgentProfileWhereInput
    data: XOR<AgentProfileUpdateWithoutTicketsInput, AgentProfileUncheckedUpdateWithoutTicketsInput>
  }

  export type AgentProfileUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentProfileNestedInput
    specialties?: AgentSpecialtyUpdateManyWithoutAgentNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutManagedAgentsNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutAgentNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutAgentNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutAgentNestedInput
  }

  export type AgentProfileUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    specialties?: AgentSpecialtyUncheckedUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type TicketPhotoUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketPhotoWhereUniqueInput
    update: XOR<TicketPhotoUpdateWithoutTicketInput, TicketPhotoUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketPhotoCreateWithoutTicketInput, TicketPhotoUncheckedCreateWithoutTicketInput>
  }

  export type TicketPhotoUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketPhotoWhereUniqueInput
    data: XOR<TicketPhotoUpdateWithoutTicketInput, TicketPhotoUncheckedUpdateWithoutTicketInput>
  }

  export type TicketPhotoUpdateManyWithWhereWithoutTicketInput = {
    where: TicketPhotoScalarWhereInput
    data: XOR<TicketPhotoUpdateManyMutationInput, TicketPhotoUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketPhotoScalarWhereInput = {
    AND?: TicketPhotoScalarWhereInput | TicketPhotoScalarWhereInput[]
    OR?: TicketPhotoScalarWhereInput[]
    NOT?: TicketPhotoScalarWhereInput | TicketPhotoScalarWhereInput[]
    id?: StringFilter<"TicketPhoto"> | string
    url?: StringFilter<"TicketPhoto"> | string
    caption?: StringNullableFilter<"TicketPhoto"> | string | null
    ticketId?: StringFilter<"TicketPhoto"> | string
    createdAt?: DateTimeFilter<"TicketPhoto"> | Date | string
  }

  export type PoleManagerProfileUpsertWithoutTicketsInput = {
    update: XOR<PoleManagerProfileUpdateWithoutTicketsInput, PoleManagerProfileUncheckedUpdateWithoutTicketsInput>
    create: XOR<PoleManagerProfileCreateWithoutTicketsInput, PoleManagerProfileUncheckedCreateWithoutTicketsInput>
    where?: PoleManagerProfileWhereInput
  }

  export type PoleManagerProfileUpdateToOneWithWhereWithoutTicketsInput = {
    where?: PoleManagerProfileWhereInput
    data: XOR<PoleManagerProfileUpdateWithoutTicketsInput, PoleManagerProfileUncheckedUpdateWithoutTicketsInput>
  }

  export type PoleManagerProfileUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPoleManagerProfileNestedInput
    superAdmin?: SuperAdminProfileUpdateOneRequiredWithoutPoleManagersNestedInput
    properties?: PropertyUpdateManyWithoutManagerNestedInput
    reservations?: ReservationUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUpdateManyWithoutManagerNestedInput
  }

  export type PoleManagerProfileUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdminId?: StringFieldUpdateOperationsInput | string
    properties?: PropertyUncheckedUpdateManyWithoutManagerNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUncheckedUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type MaintenanceSessionUpsertWithoutTicketInput = {
    update: XOR<MaintenanceSessionUpdateWithoutTicketInput, MaintenanceSessionUncheckedUpdateWithoutTicketInput>
    create: XOR<MaintenanceSessionCreateWithoutTicketInput, MaintenanceSessionUncheckedCreateWithoutTicketInput>
    where?: MaintenanceSessionWhereInput
  }

  export type MaintenanceSessionUpdateToOneWithWhereWithoutTicketInput = {
    where?: MaintenanceSessionWhereInput
    data: XOR<MaintenanceSessionUpdateWithoutTicketInput, MaintenanceSessionUncheckedUpdateWithoutTicketInput>
  }

  export type MaintenanceSessionUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    agent?: AgentProfileUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    materials?: MaintenanceMaterialUpdateManyWithoutMaintenanceSessionNestedInput
    photos?: MaintenancePhotoUpdateManyWithoutMaintenanceSessionNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    materials?: MaintenanceMaterialUncheckedUpdateManyWithoutMaintenanceSessionNestedInput
    photos?: MaintenancePhotoUncheckedUpdateManyWithoutMaintenanceSessionNestedInput
  }

  export type TicketCreateWithoutPhotosInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    reportedBy: string
    reportedAt?: Date | string
    assignedAt?: Date | string | null
    category?: string | null
    issueType?: string | null
    roomLocation?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    estimatedCost?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutTicketsInput
    agent?: AgentProfileCreateNestedOneWithoutTicketsInput
    manager: PoleManagerProfileCreateNestedOneWithoutTicketsInput
    maintenanceSession?: MaintenanceSessionCreateNestedOneWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutPhotosInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    propertyId: string
    reportedBy: string
    reportedAt?: Date | string
    agentId?: string | null
    assignedAt?: Date | string | null
    category?: string | null
    issueType?: string | null
    roomLocation?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    estimatedCost?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    maintenanceSession?: MaintenanceSessionUncheckedCreateNestedOneWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutPhotosInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutPhotosInput, TicketUncheckedCreateWithoutPhotosInput>
  }

  export type TicketUpsertWithoutPhotosInput = {
    update: XOR<TicketUpdateWithoutPhotosInput, TicketUncheckedUpdateWithoutPhotosInput>
    create: XOR<TicketCreateWithoutPhotosInput, TicketUncheckedCreateWithoutPhotosInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutPhotosInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutPhotosInput, TicketUncheckedUpdateWithoutPhotosInput>
  }

  export type TicketUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    roomLocation?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutTicketsNestedInput
    agent?: AgentProfileUpdateOneWithoutTicketsNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutTicketsNestedInput
    maintenanceSession?: MaintenanceSessionUpdateOneWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    propertyId?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    roomLocation?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    maintenanceSession?: MaintenanceSessionUncheckedUpdateOneWithoutTicketNestedInput
  }

  export type TicketCreateWithoutMaintenanceSessionInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    reportedBy: string
    reportedAt?: Date | string
    assignedAt?: Date | string | null
    category?: string | null
    issueType?: string | null
    roomLocation?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    estimatedCost?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutTicketsInput
    agent?: AgentProfileCreateNestedOneWithoutTicketsInput
    photos?: TicketPhotoCreateNestedManyWithoutTicketInput
    manager: PoleManagerProfileCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutMaintenanceSessionInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    propertyId: string
    reportedBy: string
    reportedAt?: Date | string
    agentId?: string | null
    assignedAt?: Date | string | null
    category?: string | null
    issueType?: string | null
    roomLocation?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    estimatedCost?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    photos?: TicketPhotoUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutMaintenanceSessionInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutMaintenanceSessionInput, TicketUncheckedCreateWithoutMaintenanceSessionInput>
  }

  export type PropertyCreateWithoutMaintenanceSessionsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoCreateNestedManyWithoutPropertyInput
    owner: PropertyOwnerProfileCreateNestedOneWithoutPropertiesInput
    manager?: PoleManagerProfileCreateNestedOneWithoutPropertiesInput
    reservations?: ReservationCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutPropertyInput
    tickets?: TicketCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutMaintenanceSessionsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    managerId?: string | null
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewUncheckedCreateNestedManyWithoutPropertyInput
    contracts?: PropertyContractUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutMaintenanceSessionsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutMaintenanceSessionsInput, PropertyUncheckedCreateWithoutMaintenanceSessionsInput>
  }

  export type AgentProfileCreateWithoutMaintenanceSessionsInput = {
    id?: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentProfileInput
    specialties?: AgentSpecialtyCreateNestedManyWithoutAgentInput
    manager: PoleManagerProfileCreateNestedOneWithoutManagedAgentsInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutAgentInput
    tickets?: TicketCreateNestedManyWithoutAgentInput
    taskAssignments?: TaskAssignmentCreateNestedManyWithoutAgentInput
  }

  export type AgentProfileUncheckedCreateWithoutMaintenanceSessionsInput = {
    id?: string
    userId: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    specialties?: AgentSpecialtyUncheckedCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutAgentInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAgentInput
    taskAssignments?: TaskAssignmentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentProfileCreateOrConnectWithoutMaintenanceSessionsInput = {
    where: AgentProfileWhereUniqueInput
    create: XOR<AgentProfileCreateWithoutMaintenanceSessionsInput, AgentProfileUncheckedCreateWithoutMaintenanceSessionsInput>
  }

  export type MaintenanceMaterialCreateWithoutMaintenanceSessionInput = {
    id?: string
    name: string
    quantity: number
    unit: string
    unitPrice: number
    totalPrice: number
    supplier?: string | null
  }

  export type MaintenanceMaterialUncheckedCreateWithoutMaintenanceSessionInput = {
    id?: string
    name: string
    quantity: number
    unit: string
    unitPrice: number
    totalPrice: number
    supplier?: string | null
  }

  export type MaintenanceMaterialCreateOrConnectWithoutMaintenanceSessionInput = {
    where: MaintenanceMaterialWhereUniqueInput
    create: XOR<MaintenanceMaterialCreateWithoutMaintenanceSessionInput, MaintenanceMaterialUncheckedCreateWithoutMaintenanceSessionInput>
  }

  export type MaintenanceMaterialCreateManyMaintenanceSessionInputEnvelope = {
    data: MaintenanceMaterialCreateManyMaintenanceSessionInput | MaintenanceMaterialCreateManyMaintenanceSessionInput[]
    skipDuplicates?: boolean
  }

  export type MaintenancePhotoCreateWithoutMaintenanceSessionInput = {
    id?: string
    url: string
    type?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput = {
    id?: string
    url: string
    type?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type MaintenancePhotoCreateOrConnectWithoutMaintenanceSessionInput = {
    where: MaintenancePhotoWhereUniqueInput
    create: XOR<MaintenancePhotoCreateWithoutMaintenanceSessionInput, MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput>
  }

  export type MaintenancePhotoCreateManyMaintenanceSessionInputEnvelope = {
    data: MaintenancePhotoCreateManyMaintenanceSessionInput | MaintenancePhotoCreateManyMaintenanceSessionInput[]
    skipDuplicates?: boolean
  }

  export type PoleManagerProfileCreateWithoutMaintenanceSessionsInput = {
    id?: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPoleManagerProfileInput
    superAdmin: SuperAdminProfileCreateNestedOneWithoutPoleManagersInput
    properties?: PropertyCreateNestedManyWithoutManagerInput
    reservations?: ReservationCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutManagerInput
    tickets?: TicketCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileUncheckedCreateWithoutMaintenanceSessionsInput = {
    id?: string
    userId: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdminId: string
    properties?: PropertyUncheckedCreateNestedManyWithoutManagerInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutManagerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutManagerInput
    laundryOrders?: LaundryOrderUncheckedCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileUncheckedCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileCreateOrConnectWithoutMaintenanceSessionsInput = {
    where: PoleManagerProfileWhereUniqueInput
    create: XOR<PoleManagerProfileCreateWithoutMaintenanceSessionsInput, PoleManagerProfileUncheckedCreateWithoutMaintenanceSessionsInput>
  }

  export type TicketUpsertWithoutMaintenanceSessionInput = {
    update: XOR<TicketUpdateWithoutMaintenanceSessionInput, TicketUncheckedUpdateWithoutMaintenanceSessionInput>
    create: XOR<TicketCreateWithoutMaintenanceSessionInput, TicketUncheckedCreateWithoutMaintenanceSessionInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutMaintenanceSessionInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutMaintenanceSessionInput, TicketUncheckedUpdateWithoutMaintenanceSessionInput>
  }

  export type TicketUpdateWithoutMaintenanceSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    roomLocation?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutTicketsNestedInput
    agent?: AgentProfileUpdateOneWithoutTicketsNestedInput
    photos?: TicketPhotoUpdateManyWithoutTicketNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutMaintenanceSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    propertyId?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    roomLocation?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    photos?: TicketPhotoUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type PropertyUpsertWithoutMaintenanceSessionsInput = {
    update: XOR<PropertyUpdateWithoutMaintenanceSessionsInput, PropertyUncheckedUpdateWithoutMaintenanceSessionsInput>
    create: XOR<PropertyCreateWithoutMaintenanceSessionsInput, PropertyUncheckedCreateWithoutMaintenanceSessionsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutMaintenanceSessionsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutMaintenanceSessionsInput, PropertyUncheckedUpdateWithoutMaintenanceSessionsInput>
  }

  export type PropertyUpdateWithoutMaintenanceSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUpdateManyWithoutPropertyNestedInput
    owner?: PropertyOwnerProfileUpdateOneRequiredWithoutPropertiesNestedInput
    manager?: PoleManagerProfileUpdateOneWithoutPropertiesNestedInput
    reservations?: ReservationUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutMaintenanceSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUncheckedUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type AgentProfileUpsertWithoutMaintenanceSessionsInput = {
    update: XOR<AgentProfileUpdateWithoutMaintenanceSessionsInput, AgentProfileUncheckedUpdateWithoutMaintenanceSessionsInput>
    create: XOR<AgentProfileCreateWithoutMaintenanceSessionsInput, AgentProfileUncheckedCreateWithoutMaintenanceSessionsInput>
    where?: AgentProfileWhereInput
  }

  export type AgentProfileUpdateToOneWithWhereWithoutMaintenanceSessionsInput = {
    where?: AgentProfileWhereInput
    data: XOR<AgentProfileUpdateWithoutMaintenanceSessionsInput, AgentProfileUncheckedUpdateWithoutMaintenanceSessionsInput>
  }

  export type AgentProfileUpdateWithoutMaintenanceSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentProfileNestedInput
    specialties?: AgentSpecialtyUpdateManyWithoutAgentNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutManagedAgentsNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutAgentNestedInput
    tickets?: TicketUpdateManyWithoutAgentNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutAgentNestedInput
  }

  export type AgentProfileUncheckedUpdateWithoutMaintenanceSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    specialties?: AgentSpecialtyUncheckedUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAgentNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type MaintenanceMaterialUpsertWithWhereUniqueWithoutMaintenanceSessionInput = {
    where: MaintenanceMaterialWhereUniqueInput
    update: XOR<MaintenanceMaterialUpdateWithoutMaintenanceSessionInput, MaintenanceMaterialUncheckedUpdateWithoutMaintenanceSessionInput>
    create: XOR<MaintenanceMaterialCreateWithoutMaintenanceSessionInput, MaintenanceMaterialUncheckedCreateWithoutMaintenanceSessionInput>
  }

  export type MaintenanceMaterialUpdateWithWhereUniqueWithoutMaintenanceSessionInput = {
    where: MaintenanceMaterialWhereUniqueInput
    data: XOR<MaintenanceMaterialUpdateWithoutMaintenanceSessionInput, MaintenanceMaterialUncheckedUpdateWithoutMaintenanceSessionInput>
  }

  export type MaintenanceMaterialUpdateManyWithWhereWithoutMaintenanceSessionInput = {
    where: MaintenanceMaterialScalarWhereInput
    data: XOR<MaintenanceMaterialUpdateManyMutationInput, MaintenanceMaterialUncheckedUpdateManyWithoutMaintenanceSessionInput>
  }

  export type MaintenanceMaterialScalarWhereInput = {
    AND?: MaintenanceMaterialScalarWhereInput | MaintenanceMaterialScalarWhereInput[]
    OR?: MaintenanceMaterialScalarWhereInput[]
    NOT?: MaintenanceMaterialScalarWhereInput | MaintenanceMaterialScalarWhereInput[]
    id?: StringFilter<"MaintenanceMaterial"> | string
    name?: StringFilter<"MaintenanceMaterial"> | string
    quantity?: FloatFilter<"MaintenanceMaterial"> | number
    unit?: StringFilter<"MaintenanceMaterial"> | string
    unitPrice?: FloatFilter<"MaintenanceMaterial"> | number
    totalPrice?: FloatFilter<"MaintenanceMaterial"> | number
    supplier?: StringNullableFilter<"MaintenanceMaterial"> | string | null
    maintenanceSessionId?: StringFilter<"MaintenanceMaterial"> | string
  }

  export type MaintenancePhotoUpsertWithWhereUniqueWithoutMaintenanceSessionInput = {
    where: MaintenancePhotoWhereUniqueInput
    update: XOR<MaintenancePhotoUpdateWithoutMaintenanceSessionInput, MaintenancePhotoUncheckedUpdateWithoutMaintenanceSessionInput>
    create: XOR<MaintenancePhotoCreateWithoutMaintenanceSessionInput, MaintenancePhotoUncheckedCreateWithoutMaintenanceSessionInput>
  }

  export type MaintenancePhotoUpdateWithWhereUniqueWithoutMaintenanceSessionInput = {
    where: MaintenancePhotoWhereUniqueInput
    data: XOR<MaintenancePhotoUpdateWithoutMaintenanceSessionInput, MaintenancePhotoUncheckedUpdateWithoutMaintenanceSessionInput>
  }

  export type MaintenancePhotoUpdateManyWithWhereWithoutMaintenanceSessionInput = {
    where: MaintenancePhotoScalarWhereInput
    data: XOR<MaintenancePhotoUpdateManyMutationInput, MaintenancePhotoUncheckedUpdateManyWithoutMaintenanceSessionInput>
  }

  export type MaintenancePhotoScalarWhereInput = {
    AND?: MaintenancePhotoScalarWhereInput | MaintenancePhotoScalarWhereInput[]
    OR?: MaintenancePhotoScalarWhereInput[]
    NOT?: MaintenancePhotoScalarWhereInput | MaintenancePhotoScalarWhereInput[]
    id?: StringFilter<"MaintenancePhoto"> | string
    url?: StringFilter<"MaintenancePhoto"> | string
    type?: StringNullableFilter<"MaintenancePhoto"> | string | null
    caption?: StringNullableFilter<"MaintenancePhoto"> | string | null
    maintenanceSessionId?: StringFilter<"MaintenancePhoto"> | string
    createdAt?: DateTimeFilter<"MaintenancePhoto"> | Date | string
  }

  export type PoleManagerProfileUpsertWithoutMaintenanceSessionsInput = {
    update: XOR<PoleManagerProfileUpdateWithoutMaintenanceSessionsInput, PoleManagerProfileUncheckedUpdateWithoutMaintenanceSessionsInput>
    create: XOR<PoleManagerProfileCreateWithoutMaintenanceSessionsInput, PoleManagerProfileUncheckedCreateWithoutMaintenanceSessionsInput>
    where?: PoleManagerProfileWhereInput
  }

  export type PoleManagerProfileUpdateToOneWithWhereWithoutMaintenanceSessionsInput = {
    where?: PoleManagerProfileWhereInput
    data: XOR<PoleManagerProfileUpdateWithoutMaintenanceSessionsInput, PoleManagerProfileUncheckedUpdateWithoutMaintenanceSessionsInput>
  }

  export type PoleManagerProfileUpdateWithoutMaintenanceSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPoleManagerProfileNestedInput
    superAdmin?: SuperAdminProfileUpdateOneRequiredWithoutPoleManagersNestedInput
    properties?: PropertyUpdateManyWithoutManagerNestedInput
    reservations?: ReservationUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutManagerNestedInput
    tickets?: TicketUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUpdateManyWithoutManagerNestedInput
  }

  export type PoleManagerProfileUncheckedUpdateWithoutMaintenanceSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdminId?: StringFieldUpdateOperationsInput | string
    properties?: PropertyUncheckedUpdateManyWithoutManagerNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutManagerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUncheckedUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type MaintenanceSessionCreateWithoutMaterialsInput = {
    id?: string
    sessionNumber: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutMaintenanceSessionInput
    property: PropertyCreateNestedOneWithoutMaintenanceSessionsInput
    agent: AgentProfileCreateNestedOneWithoutMaintenanceSessionsInput
    photos?: MaintenancePhotoCreateNestedManyWithoutMaintenanceSessionInput
    manager: PoleManagerProfileCreateNestedOneWithoutMaintenanceSessionsInput
  }

  export type MaintenanceSessionUncheckedCreateWithoutMaterialsInput = {
    id?: string
    sessionNumber: string
    ticketId: string
    propertyId: string
    agentId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    photos?: MaintenancePhotoUncheckedCreateNestedManyWithoutMaintenanceSessionInput
  }

  export type MaintenanceSessionCreateOrConnectWithoutMaterialsInput = {
    where: MaintenanceSessionWhereUniqueInput
    create: XOR<MaintenanceSessionCreateWithoutMaterialsInput, MaintenanceSessionUncheckedCreateWithoutMaterialsInput>
  }

  export type MaintenanceSessionUpsertWithoutMaterialsInput = {
    update: XOR<MaintenanceSessionUpdateWithoutMaterialsInput, MaintenanceSessionUncheckedUpdateWithoutMaterialsInput>
    create: XOR<MaintenanceSessionCreateWithoutMaterialsInput, MaintenanceSessionUncheckedCreateWithoutMaterialsInput>
    where?: MaintenanceSessionWhereInput
  }

  export type MaintenanceSessionUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: MaintenanceSessionWhereInput
    data: XOR<MaintenanceSessionUpdateWithoutMaterialsInput, MaintenanceSessionUncheckedUpdateWithoutMaterialsInput>
  }

  export type MaintenanceSessionUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutMaintenanceSessionNestedInput
    property?: PropertyUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    agent?: AgentProfileUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    photos?: MaintenancePhotoUpdateManyWithoutMaintenanceSessionNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    photos?: MaintenancePhotoUncheckedUpdateManyWithoutMaintenanceSessionNestedInput
  }

  export type MaintenanceSessionCreateWithoutPhotosInput = {
    id?: string
    sessionNumber: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutMaintenanceSessionInput
    property: PropertyCreateNestedOneWithoutMaintenanceSessionsInput
    agent: AgentProfileCreateNestedOneWithoutMaintenanceSessionsInput
    materials?: MaintenanceMaterialCreateNestedManyWithoutMaintenanceSessionInput
    manager: PoleManagerProfileCreateNestedOneWithoutMaintenanceSessionsInput
  }

  export type MaintenanceSessionUncheckedCreateWithoutPhotosInput = {
    id?: string
    sessionNumber: string
    ticketId: string
    propertyId: string
    agentId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    materials?: MaintenanceMaterialUncheckedCreateNestedManyWithoutMaintenanceSessionInput
  }

  export type MaintenanceSessionCreateOrConnectWithoutPhotosInput = {
    where: MaintenanceSessionWhereUniqueInput
    create: XOR<MaintenanceSessionCreateWithoutPhotosInput, MaintenanceSessionUncheckedCreateWithoutPhotosInput>
  }

  export type MaintenanceSessionUpsertWithoutPhotosInput = {
    update: XOR<MaintenanceSessionUpdateWithoutPhotosInput, MaintenanceSessionUncheckedUpdateWithoutPhotosInput>
    create: XOR<MaintenanceSessionCreateWithoutPhotosInput, MaintenanceSessionUncheckedCreateWithoutPhotosInput>
    where?: MaintenanceSessionWhereInput
  }

  export type MaintenanceSessionUpdateToOneWithWhereWithoutPhotosInput = {
    where?: MaintenanceSessionWhereInput
    data: XOR<MaintenanceSessionUpdateWithoutPhotosInput, MaintenanceSessionUncheckedUpdateWithoutPhotosInput>
  }

  export type MaintenanceSessionUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutMaintenanceSessionNestedInput
    property?: PropertyUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    agent?: AgentProfileUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    materials?: MaintenanceMaterialUpdateManyWithoutMaintenanceSessionNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    materials?: MaintenanceMaterialUncheckedUpdateManyWithoutMaintenanceSessionNestedInput
  }

  export type LaundryOrderItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    unitPrice: number
    subtotal: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: LaundryOrderCreateNestedOneWithoutItemsInput
  }

  export type LaundryOrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    quantity: number
    unitPrice: number
    subtotal: number
    notes?: string | null
    orderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryOrderItemCreateOrConnectWithoutProductInput = {
    where: LaundryOrderItemWhereUniqueInput
    create: XOR<LaundryOrderItemCreateWithoutProductInput, LaundryOrderItemUncheckedCreateWithoutProductInput>
  }

  export type LaundryOrderItemCreateManyProductInputEnvelope = {
    data: LaundryOrderItemCreateManyProductInput | LaundryOrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type LaundryOrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: LaundryOrderItemWhereUniqueInput
    update: XOR<LaundryOrderItemUpdateWithoutProductInput, LaundryOrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<LaundryOrderItemCreateWithoutProductInput, LaundryOrderItemUncheckedCreateWithoutProductInput>
  }

  export type LaundryOrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: LaundryOrderItemWhereUniqueInput
    data: XOR<LaundryOrderItemUpdateWithoutProductInput, LaundryOrderItemUncheckedUpdateWithoutProductInput>
  }

  export type LaundryOrderItemUpdateManyWithWhereWithoutProductInput = {
    where: LaundryOrderItemScalarWhereInput
    data: XOR<LaundryOrderItemUpdateManyMutationInput, LaundryOrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type LaundryOrderItemScalarWhereInput = {
    AND?: LaundryOrderItemScalarWhereInput | LaundryOrderItemScalarWhereInput[]
    OR?: LaundryOrderItemScalarWhereInput[]
    NOT?: LaundryOrderItemScalarWhereInput | LaundryOrderItemScalarWhereInput[]
    id?: StringFilter<"LaundryOrderItem"> | string
    quantity?: IntFilter<"LaundryOrderItem"> | number
    unitPrice?: FloatFilter<"LaundryOrderItem"> | number
    subtotal?: FloatFilter<"LaundryOrderItem"> | number
    notes?: StringNullableFilter<"LaundryOrderItem"> | string | null
    orderId?: StringFilter<"LaundryOrderItem"> | string
    productId?: StringFilter<"LaundryOrderItem"> | string
    createdAt?: DateTimeFilter<"LaundryOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"LaundryOrderItem"> | Date | string
  }

  export type PoleManagerProfileCreateWithoutLaundryOrdersInput = {
    id?: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPoleManagerProfileInput
    superAdmin: SuperAdminProfileCreateNestedOneWithoutPoleManagersInput
    properties?: PropertyCreateNestedManyWithoutManagerInput
    reservations?: ReservationCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutManagerInput
    tickets?: TicketCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileUncheckedCreateWithoutLaundryOrdersInput = {
    id?: string
    userId: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdminId: string
    properties?: PropertyUncheckedCreateNestedManyWithoutManagerInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutManagerInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutManagerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutManagerInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutManagerInput
    managedAgents?: AgentProfileUncheckedCreateNestedManyWithoutManagerInput
  }

  export type PoleManagerProfileCreateOrConnectWithoutLaundryOrdersInput = {
    where: PoleManagerProfileWhereUniqueInput
    create: XOR<PoleManagerProfileCreateWithoutLaundryOrdersInput, PoleManagerProfileUncheckedCreateWithoutLaundryOrdersInput>
  }

  export type LaundryClientProfileCreateWithoutLaundryOrdersInput = {
    id?: string
    companyName?: string | null
    contactPerson?: string | null
    defaultPickupAddress?: string | null
    defaultDeliveryAddress: string
    preferredPickupTime?: string | null
    specialInstructions?: string | null
    creditLimit?: number | null
    paymentTerms?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLaundryClientProfileInput
    laundryInvoices?: LaundryInvoiceCreateNestedManyWithoutClientInput
  }

  export type LaundryClientProfileUncheckedCreateWithoutLaundryOrdersInput = {
    id?: string
    userId: string
    companyName?: string | null
    contactPerson?: string | null
    defaultPickupAddress?: string | null
    defaultDeliveryAddress: string
    preferredPickupTime?: string | null
    specialInstructions?: string | null
    creditLimit?: number | null
    paymentTerms?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryInvoices?: LaundryInvoiceUncheckedCreateNestedManyWithoutClientInput
  }

  export type LaundryClientProfileCreateOrConnectWithoutLaundryOrdersInput = {
    where: LaundryClientProfileWhereUniqueInput
    create: XOR<LaundryClientProfileCreateWithoutLaundryOrdersInput, LaundryClientProfileUncheckedCreateWithoutLaundryOrdersInput>
  }

  export type LaundryOrderItemCreateWithoutOrderInput = {
    id?: string
    quantity: number
    unitPrice: number
    subtotal: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: LaundryProductCreateNestedOneWithoutOrderItemsInput
  }

  export type LaundryOrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    quantity: number
    unitPrice: number
    subtotal: number
    notes?: string | null
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryOrderItemCreateOrConnectWithoutOrderInput = {
    where: LaundryOrderItemWhereUniqueInput
    create: XOR<LaundryOrderItemCreateWithoutOrderInput, LaundryOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type LaundryOrderItemCreateManyOrderInputEnvelope = {
    data: LaundryOrderItemCreateManyOrderInput | LaundryOrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryNoteCreateWithoutOrderInput = {
    id?: string
    number: string
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryNoteUncheckedCreateWithoutOrderInput = {
    id?: string
    number: string
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryNoteCreateOrConnectWithoutOrderInput = {
    where: DeliveryNoteWhereUniqueInput
    create: XOR<DeliveryNoteCreateWithoutOrderInput, DeliveryNoteUncheckedCreateWithoutOrderInput>
  }

  export type DeliveryNoteCreateManyOrderInputEnvelope = {
    data: DeliveryNoteCreateManyOrderInput | DeliveryNoteCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PoleManagerProfileUpsertWithoutLaundryOrdersInput = {
    update: XOR<PoleManagerProfileUpdateWithoutLaundryOrdersInput, PoleManagerProfileUncheckedUpdateWithoutLaundryOrdersInput>
    create: XOR<PoleManagerProfileCreateWithoutLaundryOrdersInput, PoleManagerProfileUncheckedCreateWithoutLaundryOrdersInput>
    where?: PoleManagerProfileWhereInput
  }

  export type PoleManagerProfileUpdateToOneWithWhereWithoutLaundryOrdersInput = {
    where?: PoleManagerProfileWhereInput
    data: XOR<PoleManagerProfileUpdateWithoutLaundryOrdersInput, PoleManagerProfileUncheckedUpdateWithoutLaundryOrdersInput>
  }

  export type PoleManagerProfileUpdateWithoutLaundryOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPoleManagerProfileNestedInput
    superAdmin?: SuperAdminProfileUpdateOneRequiredWithoutPoleManagersNestedInput
    properties?: PropertyUpdateManyWithoutManagerNestedInput
    reservations?: ReservationUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutManagerNestedInput
    tickets?: TicketUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUpdateManyWithoutManagerNestedInput
  }

  export type PoleManagerProfileUncheckedUpdateWithoutLaundryOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdminId?: StringFieldUpdateOperationsInput | string
    properties?: PropertyUncheckedUpdateManyWithoutManagerNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutManagerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type LaundryClientProfileUpsertWithoutLaundryOrdersInput = {
    update: XOR<LaundryClientProfileUpdateWithoutLaundryOrdersInput, LaundryClientProfileUncheckedUpdateWithoutLaundryOrdersInput>
    create: XOR<LaundryClientProfileCreateWithoutLaundryOrdersInput, LaundryClientProfileUncheckedCreateWithoutLaundryOrdersInput>
    where?: LaundryClientProfileWhereInput
  }

  export type LaundryClientProfileUpdateToOneWithWhereWithoutLaundryOrdersInput = {
    where?: LaundryClientProfileWhereInput
    data: XOR<LaundryClientProfileUpdateWithoutLaundryOrdersInput, LaundryClientProfileUncheckedUpdateWithoutLaundryOrdersInput>
  }

  export type LaundryClientProfileUpdateWithoutLaundryOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDeliveryAddress?: StringFieldUpdateOperationsInput | string
    preferredPickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLaundryClientProfileNestedInput
    laundryInvoices?: LaundryInvoiceUpdateManyWithoutClientNestedInput
  }

  export type LaundryClientProfileUncheckedUpdateWithoutLaundryOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDeliveryAddress?: StringFieldUpdateOperationsInput | string
    preferredPickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryInvoices?: LaundryInvoiceUncheckedUpdateManyWithoutClientNestedInput
  }

  export type LaundryOrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: LaundryOrderItemWhereUniqueInput
    update: XOR<LaundryOrderItemUpdateWithoutOrderInput, LaundryOrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<LaundryOrderItemCreateWithoutOrderInput, LaundryOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type LaundryOrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: LaundryOrderItemWhereUniqueInput
    data: XOR<LaundryOrderItemUpdateWithoutOrderInput, LaundryOrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type LaundryOrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: LaundryOrderItemScalarWhereInput
    data: XOR<LaundryOrderItemUpdateManyMutationInput, LaundryOrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type DeliveryNoteUpsertWithWhereUniqueWithoutOrderInput = {
    where: DeliveryNoteWhereUniqueInput
    update: XOR<DeliveryNoteUpdateWithoutOrderInput, DeliveryNoteUncheckedUpdateWithoutOrderInput>
    create: XOR<DeliveryNoteCreateWithoutOrderInput, DeliveryNoteUncheckedCreateWithoutOrderInput>
  }

  export type DeliveryNoteUpdateWithWhereUniqueWithoutOrderInput = {
    where: DeliveryNoteWhereUniqueInput
    data: XOR<DeliveryNoteUpdateWithoutOrderInput, DeliveryNoteUncheckedUpdateWithoutOrderInput>
  }

  export type DeliveryNoteUpdateManyWithWhereWithoutOrderInput = {
    where: DeliveryNoteScalarWhereInput
    data: XOR<DeliveryNoteUpdateManyMutationInput, DeliveryNoteUncheckedUpdateManyWithoutOrderInput>
  }

  export type DeliveryNoteScalarWhereInput = {
    AND?: DeliveryNoteScalarWhereInput | DeliveryNoteScalarWhereInput[]
    OR?: DeliveryNoteScalarWhereInput[]
    NOT?: DeliveryNoteScalarWhereInput | DeliveryNoteScalarWhereInput[]
    id?: StringFilter<"DeliveryNote"> | string
    number?: StringFilter<"DeliveryNote"> | string
    date?: DateTimeFilter<"DeliveryNote"> | Date | string
    notes?: StringNullableFilter<"DeliveryNote"> | string | null
    orderId?: StringFilter<"DeliveryNote"> | string
    createdAt?: DateTimeFilter<"DeliveryNote"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryNote"> | Date | string
  }

  export type LaundryOrderCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    processedDate?: Date | string | null
    readyDate?: Date | string | null
    deliveryDate?: Date | string | null
    pickupAddress?: string | null
    deliveryAddress: string
    instructions?: string | null
    subtotal: number
    taxes?: number | null
    deliveryFee?: number | null
    totalAmount: number
    notes?: string | null
    receivedByClient?: boolean
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager: PoleManagerProfileCreateNestedOneWithoutLaundryOrdersInput
    client: LaundryClientProfileCreateNestedOneWithoutLaundryOrdersInput
    deliveryNotes?: DeliveryNoteCreateNestedManyWithoutOrderInput
  }

  export type LaundryOrderUncheckedCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    processedDate?: Date | string | null
    readyDate?: Date | string | null
    deliveryDate?: Date | string | null
    pickupAddress?: string | null
    deliveryAddress: string
    instructions?: string | null
    subtotal: number
    taxes?: number | null
    deliveryFee?: number | null
    totalAmount: number
    notes?: string | null
    receivedByClient?: boolean
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    clientId: string
    deliveryNotes?: DeliveryNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LaundryOrderCreateOrConnectWithoutItemsInput = {
    where: LaundryOrderWhereUniqueInput
    create: XOR<LaundryOrderCreateWithoutItemsInput, LaundryOrderUncheckedCreateWithoutItemsInput>
  }

  export type LaundryProductCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    description: string
    price: number
    stock?: number
    category?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    description: string
    price: number
    stock?: number
    category?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryProductCreateOrConnectWithoutOrderItemsInput = {
    where: LaundryProductWhereUniqueInput
    create: XOR<LaundryProductCreateWithoutOrderItemsInput, LaundryProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type LaundryOrderUpsertWithoutItemsInput = {
    update: XOR<LaundryOrderUpdateWithoutItemsInput, LaundryOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<LaundryOrderCreateWithoutItemsInput, LaundryOrderUncheckedCreateWithoutItemsInput>
    where?: LaundryOrderWhereInput
  }

  export type LaundryOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: LaundryOrderWhereInput
    data: XOR<LaundryOrderUpdateWithoutItemsInput, LaundryOrderUncheckedUpdateWithoutItemsInput>
  }

  export type LaundryOrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByClient?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: PoleManagerProfileUpdateOneRequiredWithoutLaundryOrdersNestedInput
    client?: LaundryClientProfileUpdateOneRequiredWithoutLaundryOrdersNestedInput
    deliveryNotes?: DeliveryNoteUpdateManyWithoutOrderNestedInput
  }

  export type LaundryOrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByClient?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    deliveryNotes?: DeliveryNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LaundryProductUpsertWithoutOrderItemsInput = {
    update: XOR<LaundryProductUpdateWithoutOrderItemsInput, LaundryProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<LaundryProductCreateWithoutOrderItemsInput, LaundryProductUncheckedCreateWithoutOrderItemsInput>
    where?: LaundryProductWhereInput
  }

  export type LaundryProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: LaundryProductWhereInput
    data: XOR<LaundryProductUpdateWithoutOrderItemsInput, LaundryProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type LaundryProductUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryOrderCreateWithoutDeliveryNotesInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    processedDate?: Date | string | null
    readyDate?: Date | string | null
    deliveryDate?: Date | string | null
    pickupAddress?: string | null
    deliveryAddress: string
    instructions?: string | null
    subtotal: number
    taxes?: number | null
    deliveryFee?: number | null
    totalAmount: number
    notes?: string | null
    receivedByClient?: boolean
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager: PoleManagerProfileCreateNestedOneWithoutLaundryOrdersInput
    client: LaundryClientProfileCreateNestedOneWithoutLaundryOrdersInput
    items?: LaundryOrderItemCreateNestedManyWithoutOrderInput
  }

  export type LaundryOrderUncheckedCreateWithoutDeliveryNotesInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    processedDate?: Date | string | null
    readyDate?: Date | string | null
    deliveryDate?: Date | string | null
    pickupAddress?: string | null
    deliveryAddress: string
    instructions?: string | null
    subtotal: number
    taxes?: number | null
    deliveryFee?: number | null
    totalAmount: number
    notes?: string | null
    receivedByClient?: boolean
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    clientId: string
    items?: LaundryOrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LaundryOrderCreateOrConnectWithoutDeliveryNotesInput = {
    where: LaundryOrderWhereUniqueInput
    create: XOR<LaundryOrderCreateWithoutDeliveryNotesInput, LaundryOrderUncheckedCreateWithoutDeliveryNotesInput>
  }

  export type LaundryOrderUpsertWithoutDeliveryNotesInput = {
    update: XOR<LaundryOrderUpdateWithoutDeliveryNotesInput, LaundryOrderUncheckedUpdateWithoutDeliveryNotesInput>
    create: XOR<LaundryOrderCreateWithoutDeliveryNotesInput, LaundryOrderUncheckedCreateWithoutDeliveryNotesInput>
    where?: LaundryOrderWhereInput
  }

  export type LaundryOrderUpdateToOneWithWhereWithoutDeliveryNotesInput = {
    where?: LaundryOrderWhereInput
    data: XOR<LaundryOrderUpdateWithoutDeliveryNotesInput, LaundryOrderUncheckedUpdateWithoutDeliveryNotesInput>
  }

  export type LaundryOrderUpdateWithoutDeliveryNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByClient?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: PoleManagerProfileUpdateOneRequiredWithoutLaundryOrdersNestedInput
    client?: LaundryClientProfileUpdateOneRequiredWithoutLaundryOrdersNestedInput
    items?: LaundryOrderItemUpdateManyWithoutOrderNestedInput
  }

  export type LaundryOrderUncheckedUpdateWithoutDeliveryNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByClient?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    items?: LaundryOrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type AgentProfileCreateWithoutTaskAssignmentsInput = {
    id?: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentProfileInput
    specialties?: AgentSpecialtyCreateNestedManyWithoutAgentInput
    manager: PoleManagerProfileCreateNestedOneWithoutManagedAgentsInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutAgentInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutAgentInput
    tickets?: TicketCreateNestedManyWithoutAgentInput
  }

  export type AgentProfileUncheckedCreateWithoutTaskAssignmentsInput = {
    id?: string
    userId: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
    specialties?: AgentSpecialtyUncheckedCreateNestedManyWithoutAgentInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutAgentInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutAgentInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentProfileCreateOrConnectWithoutTaskAssignmentsInput = {
    where: AgentProfileWhereUniqueInput
    create: XOR<AgentProfileCreateWithoutTaskAssignmentsInput, AgentProfileUncheckedCreateWithoutTaskAssignmentsInput>
  }

  export type AgentProfileUpsertWithoutTaskAssignmentsInput = {
    update: XOR<AgentProfileUpdateWithoutTaskAssignmentsInput, AgentProfileUncheckedUpdateWithoutTaskAssignmentsInput>
    create: XOR<AgentProfileCreateWithoutTaskAssignmentsInput, AgentProfileUncheckedCreateWithoutTaskAssignmentsInput>
    where?: AgentProfileWhereInput
  }

  export type AgentProfileUpdateToOneWithWhereWithoutTaskAssignmentsInput = {
    where?: AgentProfileWhereInput
    data: XOR<AgentProfileUpdateWithoutTaskAssignmentsInput, AgentProfileUncheckedUpdateWithoutTaskAssignmentsInput>
  }

  export type AgentProfileUpdateWithoutTaskAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentProfileNestedInput
    specialties?: AgentSpecialtyUpdateManyWithoutAgentNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutManagedAgentsNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutAgentNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutAgentNestedInput
    tickets?: TicketUpdateManyWithoutAgentNestedInput
  }

  export type AgentProfileUncheckedUpdateWithoutTaskAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    specialties?: AgentSpecialtyUncheckedUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type PropertyCreateWithoutContractsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: PropertyFeatureCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoCreateNestedManyWithoutPropertyInput
    owner: PropertyOwnerProfileCreateNestedOneWithoutPropertiesInput
    manager?: PoleManagerProfileCreateNestedOneWithoutPropertiesInput
    reservations?: ReservationCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionCreateNestedManyWithoutPropertyInput
    tickets?: TicketCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutContractsInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    managerId?: string | null
    features?: PropertyFeatureUncheckedCreateNestedManyWithoutPropertyInput
    photos?: PropertyPhotoUncheckedCreateNestedManyWithoutPropertyInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSessions?: CleaningSessionUncheckedCreateNestedManyWithoutPropertyInput
    maintenanceSessions?: MaintenanceSessionUncheckedCreateNestedManyWithoutPropertyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: PropertyReviewUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutContractsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutContractsInput, PropertyUncheckedCreateWithoutContractsInput>
  }

  export type PropertyOwnerProfileCreateWithoutContractsInput = {
    id?: string
    company?: string | null
    taxNumber?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    postal?: string | null
    preferredContactMethod?: string | null
    receiveNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertyOwnerProfileInput
    properties?: PropertyCreateNestedManyWithoutOwnerInput
  }

  export type PropertyOwnerProfileUncheckedCreateWithoutContractsInput = {
    id?: string
    userId: string
    company?: string | null
    taxNumber?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    postal?: string | null
    preferredContactMethod?: string | null
    receiveNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type PropertyOwnerProfileCreateOrConnectWithoutContractsInput = {
    where: PropertyOwnerProfileWhereUniqueInput
    create: XOR<PropertyOwnerProfileCreateWithoutContractsInput, PropertyOwnerProfileUncheckedCreateWithoutContractsInput>
  }

  export type PropertyUpsertWithoutContractsInput = {
    update: XOR<PropertyUpdateWithoutContractsInput, PropertyUncheckedUpdateWithoutContractsInput>
    create: XOR<PropertyCreateWithoutContractsInput, PropertyUncheckedCreateWithoutContractsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutContractsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutContractsInput, PropertyUncheckedUpdateWithoutContractsInput>
  }

  export type PropertyUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUpdateManyWithoutPropertyNestedInput
    owner?: PropertyOwnerProfileUpdateOneRequiredWithoutPropertiesNestedInput
    manager?: PoleManagerProfileUpdateOneWithoutPropertiesNestedInput
    reservations?: ReservationUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyOwnerProfileUpsertWithoutContractsInput = {
    update: XOR<PropertyOwnerProfileUpdateWithoutContractsInput, PropertyOwnerProfileUncheckedUpdateWithoutContractsInput>
    create: XOR<PropertyOwnerProfileCreateWithoutContractsInput, PropertyOwnerProfileUncheckedCreateWithoutContractsInput>
    where?: PropertyOwnerProfileWhereInput
  }

  export type PropertyOwnerProfileUpdateToOneWithWhereWithoutContractsInput = {
    where?: PropertyOwnerProfileWhereInput
    data: XOR<PropertyOwnerProfileUpdateWithoutContractsInput, PropertyOwnerProfileUncheckedUpdateWithoutContractsInput>
  }

  export type PropertyOwnerProfileUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiveNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertyOwnerProfileNestedInput
    properties?: PropertyUpdateManyWithoutOwnerNestedInput
  }

  export type PropertyOwnerProfileUncheckedUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiveNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type SuperAdminProfileCreateWithoutInvoicesInput = {
    id?: string
    companyName: string
    businessNumber?: string | null
    vatNumber?: string | null
    billingAddress: string
    billingCity: string
    billingCountry?: string
    billingPostal: string
    subscriptionTier?: string
    subscriptionStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSuperAdminProfileInput
    poleSubscriptions?: PoleSubscriptionCreateNestedManyWithoutSuperAdminInput
    poleManagers?: PoleManagerProfileCreateNestedManyWithoutSuperAdminInput
  }

  export type SuperAdminProfileUncheckedCreateWithoutInvoicesInput = {
    id?: string
    userId: string
    companyName: string
    businessNumber?: string | null
    vatNumber?: string | null
    billingAddress: string
    billingCity: string
    billingCountry?: string
    billingPostal: string
    subscriptionTier?: string
    subscriptionStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    poleSubscriptions?: PoleSubscriptionUncheckedCreateNestedManyWithoutSuperAdminInput
    poleManagers?: PoleManagerProfileUncheckedCreateNestedManyWithoutSuperAdminInput
  }

  export type SuperAdminProfileCreateOrConnectWithoutInvoicesInput = {
    where: SuperAdminProfileWhereUniqueInput
    create: XOR<SuperAdminProfileCreateWithoutInvoicesInput, SuperAdminProfileUncheckedCreateWithoutInvoicesInput>
  }

  export type SuperAdminInvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: number
    totalPrice: number
    poleType?: $Enums.PoleType | null
  }

  export type SuperAdminInvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: number
    totalPrice: number
    poleType?: $Enums.PoleType | null
  }

  export type SuperAdminInvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: SuperAdminInvoiceItemWhereUniqueInput
    create: XOR<SuperAdminInvoiceItemCreateWithoutInvoiceInput, SuperAdminInvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type SuperAdminInvoiceItemCreateManyInvoiceInputEnvelope = {
    data: SuperAdminInvoiceItemCreateManyInvoiceInput | SuperAdminInvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type SuperAdminProfileUpsertWithoutInvoicesInput = {
    update: XOR<SuperAdminProfileUpdateWithoutInvoicesInput, SuperAdminProfileUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SuperAdminProfileCreateWithoutInvoicesInput, SuperAdminProfileUncheckedCreateWithoutInvoicesInput>
    where?: SuperAdminProfileWhereInput
  }

  export type SuperAdminProfileUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SuperAdminProfileWhereInput
    data: XOR<SuperAdminProfileUpdateWithoutInvoicesInput, SuperAdminProfileUncheckedUpdateWithoutInvoicesInput>
  }

  export type SuperAdminProfileUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    businessNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingCountry?: StringFieldUpdateOperationsInput | string
    billingPostal?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSuperAdminProfileNestedInput
    poleSubscriptions?: PoleSubscriptionUpdateManyWithoutSuperAdminNestedInput
    poleManagers?: PoleManagerProfileUpdateManyWithoutSuperAdminNestedInput
  }

  export type SuperAdminProfileUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    businessNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: StringFieldUpdateOperationsInput | string
    billingCity?: StringFieldUpdateOperationsInput | string
    billingCountry?: StringFieldUpdateOperationsInput | string
    billingPostal?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poleSubscriptions?: PoleSubscriptionUncheckedUpdateManyWithoutSuperAdminNestedInput
    poleManagers?: PoleManagerProfileUncheckedUpdateManyWithoutSuperAdminNestedInput
  }

  export type SuperAdminInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: SuperAdminInvoiceItemWhereUniqueInput
    update: XOR<SuperAdminInvoiceItemUpdateWithoutInvoiceInput, SuperAdminInvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<SuperAdminInvoiceItemCreateWithoutInvoiceInput, SuperAdminInvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type SuperAdminInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: SuperAdminInvoiceItemWhereUniqueInput
    data: XOR<SuperAdminInvoiceItemUpdateWithoutInvoiceInput, SuperAdminInvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type SuperAdminInvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: SuperAdminInvoiceItemScalarWhereInput
    data: XOR<SuperAdminInvoiceItemUpdateManyMutationInput, SuperAdminInvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type SuperAdminInvoiceItemScalarWhereInput = {
    AND?: SuperAdminInvoiceItemScalarWhereInput | SuperAdminInvoiceItemScalarWhereInput[]
    OR?: SuperAdminInvoiceItemScalarWhereInput[]
    NOT?: SuperAdminInvoiceItemScalarWhereInput | SuperAdminInvoiceItemScalarWhereInput[]
    id?: StringFilter<"SuperAdminInvoiceItem"> | string
    description?: StringFilter<"SuperAdminInvoiceItem"> | string
    quantity?: FloatFilter<"SuperAdminInvoiceItem"> | number
    unitPrice?: FloatFilter<"SuperAdminInvoiceItem"> | number
    totalPrice?: FloatFilter<"SuperAdminInvoiceItem"> | number
    poleType?: EnumPoleTypeNullableFilter<"SuperAdminInvoiceItem"> | $Enums.PoleType | null
    invoiceId?: StringFilter<"SuperAdminInvoiceItem"> | string
  }

  export type SuperAdminInvoiceCreateWithoutItemsInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    subtotal: number
    taxRate?: number
    taxAmount: number
    totalAmount: number
    paidAmount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdmin: SuperAdminProfileCreateNestedOneWithoutInvoicesInput
  }

  export type SuperAdminInvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    subtotal: number
    taxRate?: number
    taxAmount: number
    totalAmount: number
    paidAmount?: number
    superAdminId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuperAdminInvoiceCreateOrConnectWithoutItemsInput = {
    where: SuperAdminInvoiceWhereUniqueInput
    create: XOR<SuperAdminInvoiceCreateWithoutItemsInput, SuperAdminInvoiceUncheckedCreateWithoutItemsInput>
  }

  export type SuperAdminInvoiceUpsertWithoutItemsInput = {
    update: XOR<SuperAdminInvoiceUpdateWithoutItemsInput, SuperAdminInvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<SuperAdminInvoiceCreateWithoutItemsInput, SuperAdminInvoiceUncheckedCreateWithoutItemsInput>
    where?: SuperAdminInvoiceWhereInput
  }

  export type SuperAdminInvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: SuperAdminInvoiceWhereInput
    data: XOR<SuperAdminInvoiceUpdateWithoutItemsInput, SuperAdminInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type SuperAdminInvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdmin?: SuperAdminProfileUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type SuperAdminInvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    superAdminId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryClientProfileCreateWithoutLaundryInvoicesInput = {
    id?: string
    companyName?: string | null
    contactPerson?: string | null
    defaultPickupAddress?: string | null
    defaultDeliveryAddress: string
    preferredPickupTime?: string | null
    specialInstructions?: string | null
    creditLimit?: number | null
    paymentTerms?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLaundryClientProfileInput
    laundryOrders?: LaundryOrderCreateNestedManyWithoutClientInput
  }

  export type LaundryClientProfileUncheckedCreateWithoutLaundryInvoicesInput = {
    id?: string
    userId: string
    companyName?: string | null
    contactPerson?: string | null
    defaultPickupAddress?: string | null
    defaultDeliveryAddress: string
    preferredPickupTime?: string | null
    specialInstructions?: string | null
    creditLimit?: number | null
    paymentTerms?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryOrders?: LaundryOrderUncheckedCreateNestedManyWithoutClientInput
  }

  export type LaundryClientProfileCreateOrConnectWithoutLaundryInvoicesInput = {
    where: LaundryClientProfileWhereUniqueInput
    create: XOR<LaundryClientProfileCreateWithoutLaundryInvoicesInput, LaundryClientProfileUncheckedCreateWithoutLaundryInvoicesInput>
  }

  export type LaundryClientProfileUpsertWithoutLaundryInvoicesInput = {
    update: XOR<LaundryClientProfileUpdateWithoutLaundryInvoicesInput, LaundryClientProfileUncheckedUpdateWithoutLaundryInvoicesInput>
    create: XOR<LaundryClientProfileCreateWithoutLaundryInvoicesInput, LaundryClientProfileUncheckedCreateWithoutLaundryInvoicesInput>
    where?: LaundryClientProfileWhereInput
  }

  export type LaundryClientProfileUpdateToOneWithWhereWithoutLaundryInvoicesInput = {
    where?: LaundryClientProfileWhereInput
    data: XOR<LaundryClientProfileUpdateWithoutLaundryInvoicesInput, LaundryClientProfileUncheckedUpdateWithoutLaundryInvoicesInput>
  }

  export type LaundryClientProfileUpdateWithoutLaundryInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDeliveryAddress?: StringFieldUpdateOperationsInput | string
    preferredPickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLaundryClientProfileNestedInput
    laundryOrders?: LaundryOrderUpdateManyWithoutClientNestedInput
  }

  export type LaundryClientProfileUncheckedUpdateWithoutLaundryInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDeliveryAddress?: StringFieldUpdateOperationsInput | string
    preferredPickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryOrders?: LaundryOrderUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    superAdminProfile?: SuperAdminProfileCreateNestedOneWithoutUserInput
    poleManagerProfile?: PoleManagerProfileCreateNestedOneWithoutUserInput
    propertyOwnerProfile?: PropertyOwnerProfileCreateNestedOneWithoutUserInput
    laundryClientProfile?: LaundryClientProfileCreateNestedOneWithoutUserInput
    agentProfile?: AgentProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    superAdminProfile?: SuperAdminProfileUncheckedCreateNestedOneWithoutUserInput
    poleManagerProfile?: PoleManagerProfileUncheckedCreateNestedOneWithoutUserInput
    propertyOwnerProfile?: PropertyOwnerProfileUncheckedCreateNestedOneWithoutUserInput
    laundryClientProfile?: LaundryClientProfileUncheckedCreateNestedOneWithoutUserInput
    agentProfile?: AgentProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    superAdminProfile?: SuperAdminProfileUpdateOneWithoutUserNestedInput
    poleManagerProfile?: PoleManagerProfileUpdateOneWithoutUserNestedInput
    propertyOwnerProfile?: PropertyOwnerProfileUpdateOneWithoutUserNestedInput
    laundryClientProfile?: LaundryClientProfileUpdateOneWithoutUserNestedInput
    agentProfile?: AgentProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    superAdminProfile?: SuperAdminProfileUncheckedUpdateOneWithoutUserNestedInput
    poleManagerProfile?: PoleManagerProfileUncheckedUpdateOneWithoutUserNestedInput
    propertyOwnerProfile?: PropertyOwnerProfileUncheckedUpdateOneWithoutUserNestedInput
    laundryClientProfile?: LaundryClientProfileUncheckedUpdateOneWithoutUserNestedInput
    agentProfile?: AgentProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    superAdminProfile?: SuperAdminProfileCreateNestedOneWithoutUserInput
    poleManagerProfile?: PoleManagerProfileCreateNestedOneWithoutUserInput
    propertyOwnerProfile?: PropertyOwnerProfileCreateNestedOneWithoutUserInput
    laundryClientProfile?: LaundryClientProfileCreateNestedOneWithoutUserInput
    agentProfile?: AgentProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    superAdminProfile?: SuperAdminProfileUncheckedCreateNestedOneWithoutUserInput
    poleManagerProfile?: PoleManagerProfileUncheckedCreateNestedOneWithoutUserInput
    propertyOwnerProfile?: PropertyOwnerProfileUncheckedCreateNestedOneWithoutUserInput
    laundryClientProfile?: LaundryClientProfileUncheckedCreateNestedOneWithoutUserInput
    agentProfile?: AgentProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    superAdminProfile?: SuperAdminProfileUpdateOneWithoutUserNestedInput
    poleManagerProfile?: PoleManagerProfileUpdateOneWithoutUserNestedInput
    propertyOwnerProfile?: PropertyOwnerProfileUpdateOneWithoutUserNestedInput
    laundryClientProfile?: LaundryClientProfileUpdateOneWithoutUserNestedInput
    agentProfile?: AgentProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    superAdminProfile?: SuperAdminProfileUncheckedUpdateOneWithoutUserNestedInput
    poleManagerProfile?: PoleManagerProfileUncheckedUpdateOneWithoutUserNestedInput
    propertyOwnerProfile?: PropertyOwnerProfileUncheckedUpdateOneWithoutUserNestedInput
    laundryClientProfile?: LaundryClientProfileUncheckedUpdateOneWithoutUserNestedInput
    agentProfile?: AgentProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    superAdminProfile?: SuperAdminProfileCreateNestedOneWithoutUserInput
    poleManagerProfile?: PoleManagerProfileCreateNestedOneWithoutUserInput
    propertyOwnerProfile?: PropertyOwnerProfileCreateNestedOneWithoutUserInput
    laundryClientProfile?: LaundryClientProfileCreateNestedOneWithoutUserInput
    agentProfile?: AgentProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    password?: string | null
    name: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: string | null
    timezone?: string | null
    emailVerified?: boolean
    phoneVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    superAdminProfile?: SuperAdminProfileUncheckedCreateNestedOneWithoutUserInput
    poleManagerProfile?: PoleManagerProfileUncheckedCreateNestedOneWithoutUserInput
    propertyOwnerProfile?: PropertyOwnerProfileUncheckedCreateNestedOneWithoutUserInput
    laundryClientProfile?: LaundryClientProfileUncheckedCreateNestedOneWithoutUserInput
    agentProfile?: AgentProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    superAdminProfile?: SuperAdminProfileUpdateOneWithoutUserNestedInput
    poleManagerProfile?: PoleManagerProfileUpdateOneWithoutUserNestedInput
    propertyOwnerProfile?: PropertyOwnerProfileUpdateOneWithoutUserNestedInput
    laundryClientProfile?: LaundryClientProfileUpdateOneWithoutUserNestedInput
    agentProfile?: AgentProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    superAdminProfile?: SuperAdminProfileUncheckedUpdateOneWithoutUserNestedInput
    poleManagerProfile?: PoleManagerProfileUncheckedUpdateOneWithoutUserNestedInput
    propertyOwnerProfile?: PropertyOwnerProfileUncheckedUpdateOneWithoutUserNestedInput
    laundryClientProfile?: LaundryClientProfileUncheckedUpdateOneWithoutUserNestedInput
    agentProfile?: AgentProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SessionCreateManyUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    priority?: string | null
    read?: boolean
    relatedType?: string | null
    relatedId?: string | null
    actionUrl?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PoleSubscriptionCreateManySuperAdminInput = {
    id?: string
    poleType: $Enums.PoleType
    status?: $Enums.PoleStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    trialEndDate?: Date | string | null
    monthlyPrice: number
    lastBillingDate?: Date | string | null
    nextBillingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PoleManagerProfileCreateManySuperAdminInput = {
    id?: string
    userId: string
    poleTypes?: PoleManagerProfileCreatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: boolean
    canManageAgents?: boolean
    canManageClients?: boolean
    canManageBilling?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuperAdminInvoiceCreateManySuperAdminInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    subtotal: number
    taxRate?: number
    taxAmount: number
    totalAmount: number
    paidAmount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PoleSubscriptionUpdateWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleType?: EnumPoleTypeFieldUpdateOperationsInput | $Enums.PoleType
    status?: EnumPoleStatusFieldUpdateOperationsInput | $Enums.PoleStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyPrice?: FloatFieldUpdateOperationsInput | number
    lastBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PoleSubscriptionUncheckedUpdateWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleType?: EnumPoleTypeFieldUpdateOperationsInput | $Enums.PoleType
    status?: EnumPoleStatusFieldUpdateOperationsInput | $Enums.PoleStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyPrice?: FloatFieldUpdateOperationsInput | number
    lastBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PoleSubscriptionUncheckedUpdateManyWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleType?: EnumPoleTypeFieldUpdateOperationsInput | $Enums.PoleType
    status?: EnumPoleStatusFieldUpdateOperationsInput | $Enums.PoleStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyPrice?: FloatFieldUpdateOperationsInput | number
    lastBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PoleManagerProfileUpdateWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPoleManagerProfileNestedInput
    properties?: PropertyUpdateManyWithoutManagerNestedInput
    reservations?: ReservationUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutManagerNestedInput
    tickets?: TicketUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUpdateManyWithoutManagerNestedInput
  }

  export type PoleManagerProfileUncheckedUpdateWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutManagerNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutManagerNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutManagerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutManagerNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutManagerNestedInput
    laundryOrders?: LaundryOrderUncheckedUpdateManyWithoutManagerNestedInput
    managedAgents?: AgentProfileUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type PoleManagerProfileUncheckedUpdateManyWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poleTypes?: PoleManagerProfileUpdatepoleTypesInput | $Enums.PoleType[]
    canViewAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canManageAgents?: BoolFieldUpdateOperationsInput | boolean
    canManageClients?: BoolFieldUpdateOperationsInput | boolean
    canManageBilling?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuperAdminInvoiceUpdateWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SuperAdminInvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type SuperAdminInvoiceUncheckedUpdateWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SuperAdminInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type SuperAdminInvoiceUncheckedUpdateManyWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateManyManagerInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
  }

  export type ReservationCreateManyManagerInput = {
    id?: string
    propertyId: string
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    guestCount?: number
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    totalPrice: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    confirmationCode?: string | null
    bookingSource?: string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningSessionCreateManyManagerInput = {
    id?: string
    propertyId: string
    agentId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    cleaningType: string
    status?: $Enums.SessionStatus
    notes?: string | null
    agentNotes?: string | null
    ownerRating?: number | null
    managerRating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyManagerInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    propertyId: string
    reportedBy: string
    reportedAt?: Date | string
    agentId?: string | null
    assignedAt?: Date | string | null
    category?: string | null
    issueType?: string | null
    roomLocation?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    estimatedCost?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceSessionCreateManyManagerInput = {
    id?: string
    sessionNumber: string
    ticketId: string
    propertyId: string
    agentId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryOrderCreateManyManagerInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    processedDate?: Date | string | null
    readyDate?: Date | string | null
    deliveryDate?: Date | string | null
    pickupAddress?: string | null
    deliveryAddress: string
    instructions?: string | null
    subtotal: number
    taxes?: number | null
    deliveryFee?: number | null
    totalAmount: number
    notes?: string | null
    receivedByClient?: boolean
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
  }

  export type AgentProfileCreateManyManagerInput = {
    id?: string
    userId: string
    agentType: $Enums.AgentType
    availability?: $Enums.AgentAvailability
    employeeId?: string | null
    certifications?: AgentProfileCreatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileCreateserviceZonesInput | string[]
    rating?: number | null
    completedTasks?: number
    averageRating?: number | null
    responseTime?: number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: number | null
    isActive?: boolean
    hireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUpdateManyWithoutPropertyNestedInput
    owner?: PropertyOwnerProfileUpdateOneRequiredWithoutPropertiesNestedInput
    reservations?: ReservationUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUncheckedUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
  }

  export type ReservationUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingSource?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingSource?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingSource?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningSessionUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cleaningType?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    managerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutCleaningSessionsNestedInput
    agent?: AgentProfileUpdateOneRequiredWithoutCleaningSessionsNestedInput
    checklist?: CleaningChecklistUpdateManyWithoutCleaningSessionNestedInput
    photos?: CleaningPhotoUpdateManyWithoutCleaningSessionNestedInput
  }

  export type CleaningSessionUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cleaningType?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    managerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklist?: CleaningChecklistUncheckedUpdateManyWithoutCleaningSessionNestedInput
    photos?: CleaningPhotoUncheckedUpdateManyWithoutCleaningSessionNestedInput
  }

  export type CleaningSessionUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cleaningType?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    managerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    roomLocation?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutTicketsNestedInput
    agent?: AgentProfileUpdateOneWithoutTicketsNestedInput
    photos?: TicketPhotoUpdateManyWithoutTicketNestedInput
    maintenanceSession?: MaintenanceSessionUpdateOneWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    propertyId?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    roomLocation?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: TicketPhotoUncheckedUpdateManyWithoutTicketNestedInput
    maintenanceSession?: MaintenanceSessionUncheckedUpdateOneWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    propertyId?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    roomLocation?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceSessionUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutMaintenanceSessionNestedInput
    property?: PropertyUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    agent?: AgentProfileUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    materials?: MaintenanceMaterialUpdateManyWithoutMaintenanceSessionNestedInput
    photos?: MaintenancePhotoUpdateManyWithoutMaintenanceSessionNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: MaintenanceMaterialUncheckedUpdateManyWithoutMaintenanceSessionNestedInput
    photos?: MaintenancePhotoUncheckedUpdateManyWithoutMaintenanceSessionNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryOrderUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByClient?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: LaundryClientProfileUpdateOneRequiredWithoutLaundryOrdersNestedInput
    items?: LaundryOrderItemUpdateManyWithoutOrderNestedInput
    deliveryNotes?: DeliveryNoteUpdateManyWithoutOrderNestedInput
  }

  export type LaundryOrderUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByClient?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    items?: LaundryOrderItemUncheckedUpdateManyWithoutOrderNestedInput
    deliveryNotes?: DeliveryNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LaundryOrderUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByClient?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type AgentProfileUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentProfileNestedInput
    specialties?: AgentSpecialtyUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutAgentNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutAgentNestedInput
    tickets?: TicketUpdateManyWithoutAgentNestedInput
    taskAssignments?: TaskAssignmentUpdateManyWithoutAgentNestedInput
  }

  export type AgentProfileUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialties?: AgentSpecialtyUncheckedUpdateManyWithoutAgentNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutAgentNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAgentNestedInput
    taskAssignments?: TaskAssignmentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentProfileUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentType?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    availability?: EnumAgentAvailabilityFieldUpdateOperationsInput | $Enums.AgentAvailability
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: AgentProfileUpdatecertificationsInput | string[]
    currentLocation?: NullableJsonNullValueInput | InputJsonValue
    serviceZones?: AgentProfileUpdateserviceZonesInput | string[]
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    completedTasks?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    workingHours?: NullableJsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateManyOwnerInput = {
    id?: string
    name: string
    description: string
    status?: $Enums.PropertyStatus
    address: string
    city: string
    country?: string
    postalCode?: string | null
    latitude?: number | null
    longitude?: number | null
    surface?: number | null
    numberOfRooms?: number | null
    numberOfBedrooms?: number | null
    numberOfBathrooms?: number | null
    maxGuests?: number | null
    floor?: number | null
    hasElevator?: boolean | null
    hasParking?: boolean | null
    hasBalcony?: boolean | null
    pricePerNight?: number | null
    cleaningFee?: number | null
    serviceFee?: number | null
    securityDeposit?: number | null
    averageRating?: number | null
    totalReviews?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: string | null
    houseRules?: string | null
    accessInstructions?: string | null
    cleaningInstructions?: string | null
    maintenanceNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
  }

  export type PropertyContractCreateManyPropertyOwnerInput = {
    id?: string
    contractNumber: string
    type: string
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    propertyId: string
    monthlyFee?: number | null
    commissionRate?: number | null
    documentUrl?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: PropertyFeatureUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUpdateManyWithoutPropertyNestedInput
    manager?: PoleManagerProfileUpdateOneWithoutPropertiesNestedInput
    reservations?: ReservationUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    features?: PropertyFeatureUncheckedUpdateManyWithoutPropertyNestedInput
    photos?: PropertyPhotoUncheckedUpdateManyWithoutPropertyNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSessions?: CleaningSessionUncheckedUpdateManyWithoutPropertyNestedInput
    maintenanceSessions?: MaintenanceSessionUncheckedUpdateManyWithoutPropertyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: PropertyReviewUncheckedUpdateManyWithoutPropertyNestedInput
    contracts?: PropertyContractUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    numberOfRooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfBathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    hasElevator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasParking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasBalcony?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pricePerNight?: NullableFloatFieldUpdateOperationsInput | number | null
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    securityDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    accessInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyContractUpdateWithoutPropertyOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutContractsNestedInput
  }

  export type PropertyContractUncheckedUpdateWithoutPropertyOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyContractUncheckedUpdateManyWithoutPropertyOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryOrderCreateManyClientInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    receivedDate?: Date | string | null
    processedDate?: Date | string | null
    readyDate?: Date | string | null
    deliveryDate?: Date | string | null
    pickupAddress?: string | null
    deliveryAddress: string
    instructions?: string | null
    subtotal: number
    taxes?: number | null
    deliveryFee?: number | null
    totalAmount: number
    notes?: string | null
    receivedByClient?: boolean
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
  }

  export type LaundryInvoiceCreateManyClientInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    subtotal: number
    taxRate?: number
    taxAmount: number
    totalAmount: number
    paidAmount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryOrderUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByClient?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: PoleManagerProfileUpdateOneRequiredWithoutLaundryOrdersNestedInput
    items?: LaundryOrderItemUpdateManyWithoutOrderNestedInput
    deliveryNotes?: DeliveryNoteUpdateManyWithoutOrderNestedInput
  }

  export type LaundryOrderUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByClient?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    items?: LaundryOrderItemUncheckedUpdateManyWithoutOrderNestedInput
    deliveryNotes?: DeliveryNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LaundryOrderUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    deliveryFee?: NullableFloatFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByClient?: BoolFieldUpdateOperationsInput | boolean
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
  }

  export type LaundryInvoiceUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryInvoiceUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryInvoiceUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentSpecialtyCreateManyAgentInput = {
    id?: string
    name: string
    category?: string | null
    level?: string | null
    certified?: boolean
  }

  export type CleaningSessionCreateManyAgentInput = {
    id?: string
    propertyId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    cleaningType: string
    status?: $Enums.SessionStatus
    notes?: string | null
    agentNotes?: string | null
    ownerRating?: number | null
    managerRating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
  }

  export type MaintenanceSessionCreateManyAgentInput = {
    id?: string
    sessionNumber: string
    ticketId: string
    propertyId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
  }

  export type TicketCreateManyAgentInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    propertyId: string
    reportedBy: string
    reportedAt?: Date | string
    assignedAt?: Date | string | null
    category?: string | null
    issueType?: string | null
    roomLocation?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    estimatedCost?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
  }

  export type TaskAssignmentCreateManyAgentInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    priority?: string
    status?: string
    assignedAt?: Date | string
    dueDate?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    propertyId?: string | null
    reservationId?: string | null
    cleaningSessionId?: string | null
    maintenanceSessionId?: string | null
    ticketId?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentSpecialtyUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    certified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AgentSpecialtyUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    certified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AgentSpecialtyUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    certified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CleaningSessionUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cleaningType?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    managerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutCleaningSessionsNestedInput
    checklist?: CleaningChecklistUpdateManyWithoutCleaningSessionNestedInput
    photos?: CleaningPhotoUpdateManyWithoutCleaningSessionNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutCleaningSessionsNestedInput
  }

  export type CleaningSessionUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cleaningType?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    managerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    checklist?: CleaningChecklistUncheckedUpdateManyWithoutCleaningSessionNestedInput
    photos?: CleaningPhotoUncheckedUpdateManyWithoutCleaningSessionNestedInput
  }

  export type CleaningSessionUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cleaningType?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    managerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceSessionUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutMaintenanceSessionNestedInput
    property?: PropertyUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    materials?: MaintenanceMaterialUpdateManyWithoutMaintenanceSessionNestedInput
    photos?: MaintenancePhotoUpdateManyWithoutMaintenanceSessionNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    materials?: MaintenanceMaterialUncheckedUpdateManyWithoutMaintenanceSessionNestedInput
    photos?: MaintenancePhotoUncheckedUpdateManyWithoutMaintenanceSessionNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    roomLocation?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutTicketsNestedInput
    photos?: TicketPhotoUpdateManyWithoutTicketNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutTicketsNestedInput
    maintenanceSession?: MaintenanceSessionUpdateOneWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    propertyId?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    roomLocation?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    photos?: TicketPhotoUncheckedUpdateManyWithoutTicketNestedInput
    maintenanceSession?: MaintenanceSessionUncheckedUpdateOneWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    propertyId?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    roomLocation?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAssignmentUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssignmentUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    cleaningSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyFeatureCreateManyPropertyInput = {
    id?: string
    name: string
    icon?: string | null
    category?: string | null
  }

  export type PropertyPhotoCreateManyPropertyInput = {
    id?: string
    url: string
    caption?: string | null
    isMain?: boolean
    order?: number
    type?: string | null
    createdAt?: Date | string
  }

  export type ReservationCreateManyPropertyInput = {
    id?: string
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    guestCount?: number
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    totalPrice: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    confirmationCode?: string | null
    bookingSource?: string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
  }

  export type CleaningSessionCreateManyPropertyInput = {
    id?: string
    agentId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    cleaningType: string
    status?: $Enums.SessionStatus
    notes?: string | null
    agentNotes?: string | null
    ownerRating?: number | null
    managerRating?: number | null
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
  }

  export type MaintenanceSessionCreateManyPropertyInput = {
    id?: string
    sessionNumber: string
    ticketId: string
    agentId: string
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    status?: $Enums.SessionStatus
    notes?: string | null
    workDescription?: string | null
    agentNotes?: string | null
    laborCost?: number | null
    materialsCost?: number | null
    totalCost?: number | null
    ownerApproval?: boolean | null
    managerApproval?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
  }

  export type TicketCreateManyPropertyInput = {
    id?: string
    ticketNumber: string
    title: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    reportedBy: string
    reportedAt?: Date | string
    agentId?: string | null
    assignedAt?: Date | string | null
    category?: string | null
    issueType?: string | null
    roomLocation?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    estimatedCost?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId: string
  }

  export type PropertyReviewCreateManyPropertyInput = {
    id?: string
    rating: number
    comment?: string | null
    guestName: string
    guestEmail?: string | null
    createdAt?: Date | string
  }

  export type PropertyContractCreateManyPropertyInput = {
    id?: string
    contractNumber: string
    type: string
    status?: string
    startDate: Date | string
    endDate?: Date | string | null
    propertyOwnerId: string
    monthlyFee?: number | null
    commissionRate?: number | null
    documentUrl?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyFeatureUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyFeatureUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyFeatureUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyPhotoUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPhotoUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPhotoUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    isMain?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingSource?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: PoleManagerProfileUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingSource?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
  }

  export type ReservationUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestCount?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationCode?: NullableStringFieldUpdateOperationsInput | string | null
    bookingSource?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
  }

  export type CleaningSessionUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cleaningType?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    managerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentProfileUpdateOneRequiredWithoutCleaningSessionsNestedInput
    checklist?: CleaningChecklistUpdateManyWithoutCleaningSessionNestedInput
    photos?: CleaningPhotoUpdateManyWithoutCleaningSessionNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutCleaningSessionsNestedInput
  }

  export type CleaningSessionUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cleaningType?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    managerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    checklist?: CleaningChecklistUncheckedUpdateManyWithoutCleaningSessionNestedInput
    photos?: CleaningPhotoUncheckedUpdateManyWithoutCleaningSessionNestedInput
  }

  export type CleaningSessionUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cleaningType?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    managerRating?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceSessionUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutMaintenanceSessionNestedInput
    agent?: AgentProfileUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
    materials?: MaintenanceMaterialUpdateManyWithoutMaintenanceSessionNestedInput
    photos?: MaintenancePhotoUpdateManyWithoutMaintenanceSessionNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutMaintenanceSessionsNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    materials?: MaintenanceMaterialUncheckedUpdateManyWithoutMaintenanceSessionNestedInput
    photos?: MaintenancePhotoUncheckedUpdateManyWithoutMaintenanceSessionNestedInput
  }

  export type MaintenanceSessionUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    agentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    laborCost?: NullableFloatFieldUpdateOperationsInput | number | null
    materialsCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    ownerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    managerApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    roomLocation?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentProfileUpdateOneWithoutTicketsNestedInput
    photos?: TicketPhotoUpdateManyWithoutTicketNestedInput
    manager?: PoleManagerProfileUpdateOneRequiredWithoutTicketsNestedInput
    maintenanceSession?: MaintenanceSessionUpdateOneWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    roomLocation?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    photos?: TicketPhotoUncheckedUpdateManyWithoutTicketNestedInput
    maintenanceSession?: MaintenanceSessionUncheckedUpdateOneWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    roomLocation?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyReviewUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyReviewUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyReviewUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyContractUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyOwner?: PropertyOwnerProfileUpdateOneRequiredWithoutContractsNestedInput
  }

  export type PropertyContractUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyOwnerId?: StringFieldUpdateOperationsInput | string
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyContractUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyOwnerId?: StringFieldUpdateOperationsInput | string
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningChecklistCreateManyCleaningSessionInput = {
    id?: string
    item: string
    completed?: boolean
    notes?: string | null
    order?: number
  }

  export type CleaningPhotoCreateManyCleaningSessionInput = {
    id?: string
    url: string
    type?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type CleaningChecklistUpdateWithoutCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type CleaningChecklistUncheckedUpdateWithoutCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type CleaningChecklistUncheckedUpdateManyWithoutCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type CleaningPhotoUpdateWithoutCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningPhotoUncheckedUpdateWithoutCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningPhotoUncheckedUpdateManyWithoutCleaningSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketPhotoCreateManyTicketInput = {
    id?: string
    url: string
    caption?: string | null
    createdAt?: Date | string
  }

  export type TicketPhotoUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketPhotoUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketPhotoUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceMaterialCreateManyMaintenanceSessionInput = {
    id?: string
    name: string
    quantity: number
    unit: string
    unitPrice: number
    totalPrice: number
    supplier?: string | null
  }

  export type MaintenancePhotoCreateManyMaintenanceSessionInput = {
    id?: string
    url: string
    type?: string | null
    caption?: string | null
    createdAt?: Date | string
  }

  export type MaintenanceMaterialUpdateWithoutMaintenanceSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceMaterialUncheckedUpdateWithoutMaintenanceSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceMaterialUncheckedUpdateManyWithoutMaintenanceSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenancePhotoUpdateWithoutMaintenanceSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenancePhotoUncheckedUpdateWithoutMaintenanceSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenancePhotoUncheckedUpdateManyWithoutMaintenanceSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryOrderItemCreateManyProductInput = {
    id?: string
    quantity: number
    unitPrice: number
    subtotal: number
    notes?: string | null
    orderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryOrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: LaundryOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type LaundryOrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryOrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryOrderItemCreateManyOrderInput = {
    id?: string
    quantity: number
    unitPrice: number
    subtotal: number
    notes?: string | null
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryNoteCreateManyOrderInput = {
    id?: string
    number: string
    date: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryOrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: LaundryProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type LaundryOrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryOrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryNoteUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryNoteUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryNoteUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuperAdminInvoiceItemCreateManyInvoiceInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: number
    totalPrice: number
    poleType?: $Enums.PoleType | null
  }

  export type SuperAdminInvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    poleType?: NullableEnumPoleTypeFieldUpdateOperationsInput | $Enums.PoleType | null
  }

  export type SuperAdminInvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    poleType?: NullableEnumPoleTypeFieldUpdateOperationsInput | $Enums.PoleType | null
  }

  export type SuperAdminInvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    poleType?: NullableEnumPoleTypeFieldUpdateOperationsInput | $Enums.PoleType | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}